.FL CAP
.AP
.LC
.HL 1 INTRODUCTION
	<KLEPTO IS A DAMAGE ASSESMENT PROGRAM FOR <TOPS10 FILE STRUCTURES.
^THE INSPECTION INCLUDES TESTS FOR NUMEROUS TYPES OF ERRORS, BUT THE
EMPHASIS IS ON <SAT BLOCK ERRORS. <KLEPTO WILL AUTOMATICALLY
CORRECT ALL ERRORS IN THE <SAT BLOCKS.
	<KLEPTO IS DESIGNED TO BE A REPLACEMENT FOR <DSKRAT AND <RIPOFF.
^IT IS SIGNIFICANTLY FASTER THAN ITS PREDESSORS.
.HL 1 HOW TO RUN KLEPTO
^TYPE:
.B 1
.LIT
.AS dskx STR
.AS dsky LPT
.R KLEPTO
.EL
.B 1
^WHERE "DSKX" IS THE NAME OF THE FILE STRUCTURE
TO BE PROCESSED,
AND "DSKY" IS THE NAME OF THE STRUCTURE TO
PLACE THE LOG FILE ON.
^THE NAME OF THE LOG FILE WILL BE DSKX.<LOG.
^NOTE THAT IF LOGICAL NAME "<LPT" IS NOT ASSIGNED, THEN THE LOG FILE
WILL GO TO <TTY:.
^NOTE THAT A SPOOLED <LPT IS NOT LEGAL (OR ANY OTHER SPOOLED DEVICE).
.HL 1 TYPES OF CORRUPTION
	^WHEN <KLEPTO DISCOVERS A DISCREPANCY IN THE <SAT BLOCK,
IT WILL CATEGORIZE IT INTO ONE OF THREE TYPES: LOST CLUSTERS,
FREE CLUSTERS, AND MULTIPLY USED CLUSTERS.
.HL 2 LOST CLUSTERS
	^A LOST CLUSTER IS WHERE THE <SAT BLOCK SAYS THAT
THE CLUSTER IS IN USE, BUT THERE IS NO FILE ANYWHERE ON THE
STRUCTURE WHICH HAS A POINTER TO THIS CLUSTER (I.E. THE <SAT
BIT IS ONE BUT SHOULD BE ZERO).
	^OF THE THREE TYPES, A LOST CLUSTER IS BY FAR THE LEAST
SEVERE.
^UNDER NORMAL DAY TO DAY OPERATIONS IT IS EXPECTED THAT ALL THE
FILE STRUCTURES ON YOUR SYSTEM WILL SLOWLY ACCUMULATE LOST CLUSTERS.
^THIS IS TO BE CONSIDERED PERFECTLY NORMAL.
^YOU SHOULD NOT BE ALARMED
EVEN IF A STRUCTURE HAS A LARGE
NUMBER OF LOST CLUSTERS.
	^CONSIDER THE FOLLOWING SCENARIO: ^THE FILE <X.DAT IS 5000 BLOCKS.
^A USER ATTEMPTS TO COPY <X.DAT TO <Y.DAT. ^THE FIRST 3000 BLOCKS HAVE BEEN
COPIED WHEN THE SYSTEM ACCIDENTALLY CRASHES.
^AT THE TIME OF THE CRASH, THE FILE <Y.DAT HAD NOT
YET BEEN CLOSED. ^THUS THERE IS NO ENTRY IN THE <UFD.
^THE 3000 BLOCKS WHICH HAD ALREADY BEEN ALLOCATED TO <Y.DAT WILL
BECOME LOST.
	^THIS SCENARIO IS TYPICAL OF HOW LOST CLUSTERS ARE CREATED.
^THEY ARE CREATED WHEN THE SYSTEM CRASHES DURING THE CREATION
OF A FILE. ^EACH CRASH WILL PROBABLY CREATE AT LEAST ONE LOST CLUSTER.
^SOME CRASHES WILL CREATE MORE.
.HL 2 FREE CLUSTERS
	^A FREE CLUSTER IS THE EXACT OPPOSITE OF A LOST CLUSTER.
^A FREE CLUSTER IS WHERE THE <SAT BLOCK SAYS THAT THE CLUSTER IS NOT IN
USE, BUT THERE IS, IN FACT, A FILE WHICH USES THE CLUSTER
(I.E. THE <SAT BIT IS ZERO BUT SHOULD BE ONE).
	^THE EXISTENCE OF A FREE CLUSTER IS NOT BE TAKEN LIGHTLY.
^A FREE CLUSTER IS A RATHER SEVERE ERROR. ^THE FILE WHICH CONTAINS
THIS CLUSTER IS QUITE LIKELY TO BE CORRUPT.
^ALTHOUGH <KLEPTO WILL REPAIR THE <SAT BLOCK, IT CANNOT REPAIR THE
FILE ITSELF. ^TO INSURE THE INTEGRITY OF YOUR DATA, WE SUGGEST THAT
YOU RESTORE THE FILE FROM A <BACKUP TAPE. <KLEPTO WILL TELL YOU
WHICH FILE(S) CONTAIN FREE CLUSTERS.
.HL 2 MULTIPLY USED CLUSTERS
	^AS THE NAME IMPLIES, A "MULTIPLY USED CLUSTER" IS ONE
THAT IS POINTED TO BY SEVERAL FILES. ^THIS IS TO BE CONSIDERED
A SERIOUS ERROR.
	^NOTE THAT A GIVEN CLUSTER CAN EASILY SWITCH FROM THE
STATE OF BEING FREE TO THE STATE OF BEING MULTIPLY USED (AND
VIS A VIS).
^IF THE MONITOR ALLOCATES A FREE CLUSTER TO SOME FILE, THEN
THE CLUSTER BECOMES MULTIPLY USED. ^IF ONE OF THE TWO FILES IS THEN
DELETED, THE CLUSTER BECOMES FREE AGAIN.
	^DURING THE INTERVAL THAT THE CLUSTER IS MULTIPLY USED,
IT'S QUITE EASY FOR ONE OR BOTH OF THE FILES TO HAVE ITS
DATA CORRUPTED. ^DATA FROM THE FIRST FILE CAN OVERWRITE DATA
FROM THE SECOND FILE. ^LIKEWISE, DATA FROM THE SECOND FILE
CAN OVERWRITE DATA FROM THE FIRST FILE.
^IT'S QUITE POSSIBLE THAT A GIVEN CLUSTER CONTAINS A MIXTURE OF
DATA FROM BOTH FILES.
	^TO BE ON THE SAFE SIDE, YOU SHOULD ASSUME THAT BOTH
FILES ARE CORRUPT. ^BOTH FILES SHOULD BE RESTORED FROM
<BACKUP TAPES. ^BEFORE RESTORING THE FILES, HOWEVER, YOU MUST
DELETE THE CORRUPTED VERSIONS USING THE </S SWITCH TO <DELFIL.
^FAILURE TO DO THIS WILL RESULT IN A <BAZ STOPCODE.
.HL 1 CHECKSUMMING
	^THERE IS A CHECKSUM ASSOCIATED WHICH EACH RETRIEVAL POINTER
IN EACH FILE ON THE STRUCTURE. ^THE PURPOSE OF THIS CHECKSUM IS
TO DETECT THE CONDITION OUTLINED ABOVE (WHEN DATA FROM ONE FILE
OVERWRITES THE DATA FROM ANOTHER FILE). <KLEPTO WILL TEST EACH
OF THESE CHECKSUMS AND TYPE OUT A WARNING MESSAGE IF THERE ARE
ANY DISCREPANCIES.
	^BE AWARE, HOWEVER, THAT THE CHECKSUM ONLY INCLUDES THE FIRST
WORD OF THE FIRST BLOCK OF THE FIRST CLUSTER IN A RETRIEVAL POINTER.
^IT IS THEREFORE QUITE POSSIBLE FOR THE FILE TO BE CORRUPT EVEN IF
THERE IS NO CHECKSUM ERROR. ^FOR SAFETY SAKE, YOU SHOULD ASSUME THAT
ANY FILE WITH A FREE OR MULTIPLY USED CLUSTER IS CORRUPT.
.HL 1 BAD BLOCKS
	^WHEN READING OR WRITING A FILE, IF THE MONITOR ENCOUNTERS
AN UNRECOVERABLE DISK ERROR, IT WILL STORE THE BLOCK NUMBER IN
THE <DDB (LOCATION <DEVELB).
^LATER, WHEN THE FILE IS CLOSED,
<DEVELB IS COPIED TO THE <RIB (LOCATION <RIBELB), AND
ALSO TO THE <BAT BLOCK.
^MUCH LATER, WHEN THE FILE IS DELETED,
THE MONITOR IS CAREFUL TO INSPECT LOCATION <RIBELB AND NOT RETURN
THAT CLUSTER TO THE FREE POOL. ^THUS THE BAD SPOT WILL NOT
BE REALLOCATED TO ANOTHER FILE.
	^NOTE THAT AT THIS POINT IN TIME THE CLUSTER IS
TECHNICALLY "LOST". <KLEPTO WILL NOT, HOWEVER, INCLUDE THIS CLUSTER
IN ITS LOST LIST.
<KLEPTO WILL NOT INCLUDE ANY CLUSTER WHICH IS LISTED IN THE <BAT BLOCK.
	^NOTE THAT THE CLUSTER WILL CONTINUE TO BE "TECHNICALLY LOST"
UNTIL THE NEXT TIME THE STRUCTURE IS REFRESHED. ^THE CLUSTER WILL THEN
BE INSERTED INTO <BADBLK.SYS.
.HL 2 BAD FREE BLOCKS
	^IF <KLEPTO ENCOUNTERS A CLUSTER WHICH IS LISTED
IN <BAT BUT FOR WHICH THE <SAT BIT IS ZERO (I.E. THE CLUSTER IS
NOT CONTAINED IN <BADBLK.SYS), THEN <KLEPTO WILL LIST THE CLUSTER
AS BEING "FREE".
^IF THESE ARE THE ONLY FREE BLOCKS, <KLEPTO WILL PRINT THE MESSAGE
"^ALL FREE BLOCKS ARE BAD". ^PASS TWO WILL BE OMITTED.
	^THE EXISTENCE OF A BAD FREE BLOCK IS NOT A SERIOUS ERROR.
^DO NOT BE ALARMED. ^IT MEANS SIMPLY THAT <RIBELB OVERFLOWED.
^THERE'S ONLY ROOM IN THE <RIB TO LIST ONE BAD SPOT.
^IF A FILE HAS TWO BAD SPOTS, THEN ONE WILL HAVE TO BE DROPPED.
^BOTH ARE LISTED IN THE <BAT BLOCK, BUT ONLY ONE IS RECORDED IN
THE <RIB. ^WHEN THE FILE IS DELETED, THE BAD SPOT WHICH IS
NOT RECORDED IN <RIBELB WILL BECOME A BAD FREE CLUSTER.
<KLEPTO WILL LIGHT THE COORESPONDING <SAT BIT, WHICH IS WHAT THE
MONITOR WOULD HAVE DONE IF THERE HAD BEEN MORE ROOM IN THE <RIB.
.HL 1 WHEN TO RUN KLEPTO
	^THE PRIMARY REASON FOR RUNNING <KLEPTO IS TO RECOVER
LOST BLOCKS.
^THE NUMBER OF LOST BLOCKS YOU CAN EXPECT TO RECOVER
IS ROUGHLY PROPORTIONATE TO THE NUMBER OF CRASHES YOU'VE EXPERIENCED.
^DURING PERIODS OF FREQUENT CRASHES YOU SHOULD RUN <KLEPTO OFTEN.
^DURING PERIODS OF HIGH STABILITY IT WILL NOT BE NECESSARY TO RUN
<KLEPTO AT ALL.
	^THERE IS NO PRECISE METHOD FOR ANTICIPATING WHAT THE
NUMBER OF LOST BLOCKS WILL BE. ^CONTRARY TO COMMON BELIEF, <DSKLST
AND <DIRECT/ALLOCATE/SUM
ARE NOT GOOD INDICATORS OF ACTUAL FILE USAGE. ^THEY DO NOT INCLUDE
THE FILES WHICH ARE CURRENTLY OPEN. ^MOREOVER, THEY TAKE SUBSTANTIALLY
LONGER TO RUN THAN <KLEPTO ITSELF.
.HL 1 DISMOUNT
	^TO PREVENT ANYBODY FROM ALTERING ANY FILE, <KLEPTO WILL
DISMOUNT THE STRUCTURE DURING PROCESSING (SINGLE ACCESS IS NOT GOOD ENOUGH).
^ALL <I/O WILL BE PERFORMED AS SUPER <I/O.
	^WHEN PROCESSING IS COMPLETE, <KLEPTO WILL AUTOMATICALLY RE-MOUNT THE
STRUCTURE.
^IF THE STRUCTURE WAS INITIALLY IN THE SYSTEM SEARCH LIST,
THEN <KLEPTO WILL RE-INSERT IT.
^IF NEED BE, <KLEPTO WILL ALSO RE-INSERT THE STRUCTURE INTO THE
ACTIVE SWAPPING LIST AND THE SYSTEM DUMP LIST. <KLEPTO WILL MAKE
NO ATTEMPT, HOWEVER, TO RESTORE ANYBODY'S JOB SEARCH LIST.
.HL 1 ALGORITHM
	^IN AN INTERNAL DATA BASE, <KLEPTO MAINTAINS A LINKED LIST OF
NODES. ^THERE'S ONE NODE FOR EACH BLOCK ON THE DISK THAT <KLEPTO INTENDS
TO READ. ^THE LIST IS SORTED IN ASCENDING ORDER BY BLOCK NUMBER.
^THERE ARE THREE TYPES OF NODES: <RIB'<S, DIRECTORY DATA BLOCKS,
AND CHECKSUM BLOCKS.
	^TO PREVENT HEAD TRASHING, <KLEPTO PROCESSES THE LIST IN
ORDER BY CYLINDER. <I.E. <KLEPTO WILL PROCESS ALL THE NODES ON A GIVEN
CYLINDER BEFORE MOVING THE HEADS TO A NEW CYLINDER. ^WITHIN A GIVEN
CYLINDER, THE NODES ARE NOT NECESSARILY PROCESSED IN ORDER.
^THE ROTATIONAL POSITION OF THE DISK WILL DETERMINE WHICH BLOCK
CAN BE PULLED INTO CORE IN THE LEAST AMOUNT OF TIME.
	^NOT ALL TRANSFERS ARE ONE BLOCK LONG. ^IF <KLEPTO NEEDS
TO READ SEVERAL CONSECUTIVE BLOCKS, IT WILL DO SO IN A SINGLE
TRANSFER. <E.G. ^THE ENTIRE DATA PORTION OF A <UFD IS USUALLY READ
IN A SINGLE TRANSFER. ^THE <RIB OF A FILE AND THE CHECKSUM BLOCK
ARE NORMALLY READ IN A SINGLE TRANSFER.
	^ALL TRANSFERS ARE PERFORMED IN NON-BLOCKING MODE.
<KLEPTO DOES THE PROCESSING FOR ONE BLOCK WHILE
THE TRANSFER IS IN PROGRESS FOR ANOTHER BLOCK.
	^UPON READING A CHECKSUM BLOCK, <KLEPTO MERELY COMPUTES
THE FOLDED CHECKSUM AND COMPARES THIS WITH THE ANTICIPATED VALUE.
^UPON READING A DIRECTORY BLOCK, <KLEPTO INSERTS A NEW
NODE IN THE LIST FOR EACH ENTRY IN THE DIRECTORY.
^UPON READING A <RIB, THE ACTION TAKEN BY <KLEPTO VARIES GREATLY DEPENDING
ON WHETHER OR NOT THE FILE IS A DIRECTORY. ^FOR A NON-DIRECTORY <RIB,
<KLEPTO INSERTS A NEW NODE IN THE LIST FOR EACH RETRIEVAL POINTER
(I.E. EACH CHECKSUM BLOCK). ^FOR A DIRECTORY <RIB,
<KLEPTO INSERTS A NEW NODE IN THE LIST FOR EACH DATA BLOCK IN THE
DIRECTORY.
	^THE ALGORITHMS USED BY <KLEPTO ARE RATHER CORE INTENSIVE.
^FOR A COMPLEX STRUCTURE, <KLEPTO WILL NEED TO STORE A LARGE NUMBER OF
NODES. ^BUT THERE ARE FEW STRUCTURES THAT WILL REQUIRE MORE THAN 200^P.
^UNDER NO CIRUMSTANCE, HOWEVER, WILL <KLEPTO ALLOW ITSELF TO GO
VIRTUAL. ^IF CORE GETS TIGHT, <KLEPTO WILL ALTER ITS SCHEDULING ALGORITHM
TO INSURE THAT SOME CORE IS RETURNED.
.HL 1 PASS TWO
	^IF THE STRUCTURE HAS ANY FREE CLUSTERS OR MULTIPLY USED CLUSTERS,
THEN <KLEPTO WILL PERFORM A SECOND A PASS. ^THE PURPOSE OF THIS PASS
IS SOLEY TO PRINT DIAGNOSTIC MESSAGES. <KLEPTO WILL LIST EACH FILE
THAT REFERENCES THE CLUSTER. <KLEPTO CANNOT DO THIS ON THE FIRST PASS
AS IT DOES NOT YET KNOW WHICH CLUSTERS ARE MULTIPLY USED AND/OR FREE.
	^NOTE THAT CHECKSUMS ARE NOT COMPUTED ON PASS TWO.
.HL 1 ALL STRUCTURES
	^TO PROCESS ALL THE STRUCTURES ON THE SYSTEM, TYPE:
.B 1
.LIT
.AS ALL STR
.AS dsky LPT
.R KLEPTO
.EL
.B 1
^WHERE DSKY IS THE NAME OF THE STRUCTURE
TO PLACE THE LOG FILES ON. <KLEPTO WILL CREATE A SEPERATE LOG FILE FOR
EACH STRUCTURE IT PROCESSES
(E.G. THE LOG FILE FOR STRUCTURE <DSKX WILL BE <DSKY:DSKX.LST).
	^NOTE THAT <KLEPTO CANNOT PLACE <DSKY.LST DIRECTLY ON <DSKY: AS
<DSKY IS NOT MOUNTED AT THE TIME. <KLEPTO WILL CREATE A <TMP FILE ON SOME
OTHER STRUCTURE. ^WHEN THE PROCESSING OF <DSKY IS COMPLETED, <KLEPTO
WILL COPY THE LOG FILE TO ITS PROPER PLACE.
.HL 1 MULTIPLE KLEPTOS
	^WHEN PROCESSING ALL THE STRUCTURES ON THE SYSTEM, IT OFTEN
HELPS IF YOU RUN MULTIPLE COPIES <KLEPTO. ^IF YOU RUN TWO COPIES, FOR
EXAMPLE, THE JOB WILL GET DONE IN ROUGHLY HALF THE TIME. ^DON'T RUN TOO
MANY COPIES, HOWEVER, AS THIS CAN DO MORE HARM THAN GOOD. ^THE OPTIMUM NUMBER
VARIES FROM SYSTEM TO SYSTEM. ^WE SUGGEST THAT YOU TRY A FEW EXPERIMENTS
AND SEE WHAT WORKS BEST ON YOUR OWN CONFIGURATION. ^AS A STARTING POINT, WE
SUGGEST YOU TRY <CPUN+1 (ONE PLUS THE NUMBER OF <CPU'<S).
	^NOTE THAT THE VARIOUS COPIES OF <KLEPTO COMMUNICATE WITH EACH OTHER
VIA A SHARED <HISEG. ^BY MUTUAL CONSENT, THEY AGREE WHICH COPY WILL PROCESS
WHICH STRUCTURE AND IN WHAT ORDER. ^THE SCHEDULING ALGORITHM IS VERY COMPLEX
AND CONSIDERS MANY FACTORS. ^THE PRIME GOAL IS, IF POSSIBLE, TO GIVE EACH
COPY OF <KLEPTO A DEDICATED DISK CHANNEL.
.HL 1 CPU SPECIFICATION
	^DO NOT USE THE "<SET <CPU" COMMAND WHEN RUNNING <KLEPTO.
^ALTHOUGH THERE ARE A FEW CASES WHERE THE COMMAND WOULD HELP,
THEY ARE NOT AT ALL OBVIOUS. ^IN FACT, THEY ARE EXTREMELY COUNTER
INTUITIVE.
	<KLEPTO KNOWS EXACTLY WHAT THESE CASES ARE AND WILL
SET THE <CPU SPECIFICATION IF NECESSARY. ^DON'T INTERFERE BY USING
THE <SET COMMAND.
.HL 1 HPQ
	^DON'T USE THE "<SET <HPQ" COMMAND WHEN RUNNING
<KLEPTO. <KLEPTO WON'T RUN SUBSTANTIALLY FASTER AS A RESULT.
^MOREOVER, THE "<SET <HPQ" COMMAND WILL HAVE AN ADVERSE AFFECT
ON THE OTHER JOBS THAT MIGHT BE RUNNING.
.HL 1 OCTAL VERSUS DECIMAL
	^SOME OF THE NUMBERS <KLEPTO TYPES ARE OCTAL AND SOME ARE
DECIMAL. ^THE RULE IS AS FOLLOWS: ^COUNTERS ARE ALWAYS DECIMAL,
AND EVERYTHING ELSE IS OCTAL.
^THUS BLOCK NUMBERS AND CLUSTER ADDRESSES ARE ALWAYS OCTAL.
^BUT THE COUNT OF LOST CLUSTERS, FOR EXAMPLE, IS DECIMAL.
.HL 1 7.01A VERSUS 7.02
	<KLEPTO WAS DESIGNED TO RUN UNDER VERSION 7.02 OF
THE MONITOR. ^IT WILL, HOWEVER, RUN UNDER <7.01A BUT IT WILL DO SO
AT SLIGHTLY REDUCED SPEED.
.HL 1 KNOWN BUGS AND DEFICIENCIES.
	^THERE ARE NO KNOWN BUGS IN <KLEPTO ITSELF.
<KLEPTO DOES, HOWEVER, EXERCIZE A BUG IN VERSION
4(1150) OF <QUASAR.
	^WHEN <KLEPTO DISMOUNTS A FILE STRUCTURE, <QUASAR
CORRECTLY NOTICES THIS FACT. ^WHEN <KLEPTO RE-MOUNTS THE
STRUCTURE, HOWEVER, <QUASAR IS OBLIVIOUS.
^THE RESULT IS THAT <GALAXY REFUSES TO TOUCH ANY STRUCTURE
THAT HAS BEEN PROCESSED BY <KLEPTO. <GALAXY INSISTS THAT
THE STRUCTURE DOES NOT EXIST.
<PCO 10-702-62 WILL CORRECT THIS PROBLEM. ^IT IS, HOWEVER,
A DIFFICULT <PCO TO INSTALL. ^AS A WORKAROUND,
YOU CAN DISMOUNT THE STRUCTURE WITH <OMOUNT
AND ISSUE A RECOGNIZE COMMAND TO <OPR.
