






                                IDENTIFICATION
                                --------------

        PRODUCT CODE:           AH-T102C-DD

        DIAGNOSTIC CODE:        DFRPN

        PRODUCT NAME:           DFRPNC0 RP07 BASIC DEVICE DIAGNOSTIC

        VERSION:                0.3

        DATE RELEASED:          APRIL 1984

        MAINTAINED BY:          36-BIT DIAGNOSTIC ENGINEERING

        AUTHOR:                 MARSHALL SMITH

                        COPYRIGHT (C) 1982, 1984

                DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

        THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR  USE  ONLY  ON  A
        SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH THE INCLUSION
        OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE,  OR  ANY  OTHER
        COPIES  THEREOF, MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE
        TO ANY OTHER PERSON EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO
        AGREES  TO  THESE  LICENSE TERMS.  TITLE TO AND OWNERSHIP OF THE
        SOFTWARE  SHALL  AT   ALL  TIMES  REMAIN  IN  DIGITAL  EQUIPMENT
        CORPORATION.

        THE INFORMATION IN THIS DOCUMENT IS SUBJECT  TO  CHANGE  WITHOUT
        NOTICE  AND  SHOULD  NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
        EQUIPMENT CORPORATION.

        DIGITAL EQUIPMENT CORPORATION ASSUMES NO  RESPONSIBILITY FOR THE
        USE  OR  RELIABILITY  OF  ITS SOFTWARE IN EQUIPMENT WHICH IS NOT
        SUPPLIED BY DIGITAL EQUIPMENT CORPORATION.

                                                                            Page ii


                             Program Documentation for
                 RP07 Basic Functional Diagnostic Program (DFRPN)


                                                                  Page
                                                                  ----
                                                                Page 1


1.0  Program Abstract

    1.1  Scope of this documentation

    This is the documentation for the RP07 Basic Diagnostic  which  is
    named  DFRPN.   To clarify the descriptions of user interfaces and
    error  reporting,  this  document  makes  references  to  examples
    contained in appendix-A



    1.2  General program description

    DFRPN functions  as  the  the  basic  diagnostic  for  single  and
    multi-drive  confidence  testing, and assures that no solid faults
    exist for RP07's attached to  RH20  Massbus  controllers  on  KL10
    family  of  computers.  DFRPN will run in EXEC and USER mode under
    both TOPS10  and  TOPS20  and  unless  specifically  stated,  will
    provide  identical  functionality in both EXEC and USER mode.  The
    program is designed with adequate functionality and safeguards  to
    allow  its  operation  on  the fixed media RP07 disk drive in both
    exec and user mode without loss of customer data that  may  be  on
    the  media.   DFRPN  along with the standard diagnostic subroutine
    package and monitor will load and execute in 64k of memory for (1)
    drive, and will expand 1K for each additional drive configured.



    1.3  Pre-requisite software

    DFRPN  assumes  no  solid  faults  exist  in  the  CPU/Memory/RH20
    hardware for it to operate predictably.  The following diagnostics
    must be run prior to DFRPN:

     o  CPU and Memory diagnostics (all)
     o  RH20 fault isolation diagnostic (DFRHB)




    1.4  Program size

    In the majority of  system  configurations  DFRPN  will  load  and
    execute  in  less  than  64k of memory.  Approximately 16k of that
    memory is  dedicated  to  standard  diagnostic  software  (Subrtn,
    Diamon,Klddt)  so  the actual diagnostic segment will be less than
    48k.  The program may exceed 64k on systems containing many drives
    as it will require approximately 1k additional core for each drive
    that the user  selects  for  testing.   The  additional  space  is
    required  for storage of data buffers and status tables particular
    to each drive.  The program is optimum  in  the  respect  that  it
    dynamically expands only as required by the system configuration.
                                                                Page 2


    1.5  Program run time

    Program runtime varies according to the test  or  script  that  is
    chosen, the iteration count (if in manual mode), and the number of
    drives  being  tested.   The  reference  to   script   apples   to
    prepackaged  test  strings  (i.e., TSTA, DIAA, DATAA or DUAL).  In
    default mode, all tests but  TST1,  TST30,  microdiagnostic  DIA46
    (tachometer  calibration utility), and the scripts mentioned above
    are run, the average run time in  default  mode  is  less  than  3
    minutes  per drive in exec, and 9 minutes per drive user mode with
    a very light system load.



    1.6  User mode capability

    DFRPN will run in user mode (timesharing) under  TOPS10(7.01)  and
    TOPS20(4.0).   Both  of  these monitors must contain RP20 support.
    Without RP20 support the DIAG JSYS/UUO has insufficient capability
    to  support  this  software.   User  mode  capability  under older
    versions  of  the  monitor  is  not  supported.   The  user   mode
    diagnostic  capability  of  this  program is accomplished entirely
    through the use of the DIAG JSYS/UUO (program performs its own I/O
    in   a   real   time  privileged  environment).   There  are  some
    restrictions imposed upon the diagnostic in  user  mode  that  are
    listed in the appropriate section.



    1.7  Fault detection and isolation

    The purpose of  DFRPN  is  to  preform  the  following  functional
    testing;

     o  Insure that the RP07 responds only when it should.

     o  That the  control  bus  section  of  the  Massbus  is  working
        properly, and that the drive registers respond correctly.

     o  That the internal  ISS  microdiagnostics  run  and  report  no
        errors.

     o  That the data path section of the Massbus  performs  correctly
        and  that  we  may read and write the microdiagnostic cylinder
        (631.).

     o  That Dual Port arbitration logic functions correctly,  (manual
        mode MAN> in EXEC only).

     o  Report errors encountered in testing and callout  the  suspect
        module  or modules, as well as supply pertinent information to
        the failure.
                                                                Page 3


     o  Upon successful completion of DFRPN the Reliability diagnostic
        DFRPM should run free of solid faults.




    1.8  General user interface philosophy

    All OUTPUT messages are clear and concise.   Decimal  numbers  are
    always  followed  by a point.  Numbers without the point are octal
    with the exception of the dumping of RP07 maintenance register and
    error log (TST30).  Error codes which are 2 digit hexadecimal, are
    in hexadecimal  to  be  consistent  with  RP07  documentation  and
    manuals.   Many of the numbers output will be dumped in both octal
    and and decimal as it is often desirable in  disk  diagnostics  to
    work in both bases when analyzing error printouts.

    The notation for outputting in both  octal  and  decimal  is,  the
    octal   value   first   followed  by  the  decimal  equivalent  in
    parenthesis (e.g., 144(100.).

    All INPUT is preceded with a prompt.

    All input is checked for legality and incorrect responses will  be
    followed  by  a  reprompt  and  in  some cases an additional error
    message.

    All numerical input may be in either  octal  or  decimal  where  a
    period following the number indicates decimal.

    Any point in the program allowing multiple input options  supports
    a help message to further explain the options.

    The program requests only 3 types of input, numerical, yes or  no,
    and sixbit.

    When an error is detected on a yes or no input, the user is merely
    reprompted.

    When an error is detected on sixbit input the prompt is re-issued.
    The  dispatchers, (Default (DEF), Manual (MAN), Variable (VAR) and
    Mode) also issue the message "- INVALID RESPONSE -", then the user
    is  reprompted.   The  user can then query the program for further
    information by asking for help.

    The design goal was to make  the  user  interface  so  simple  and
    complete   that   the   user  can  run  the  program  without  any
    pre-requisite reading.  The program will "LEAD".
                                                                Page 4


    1.9  Compatibility goals

    1.9.1  CPU family

    DFRPN is compatible with all DECsystem 10/20 systems,  having  the
    RH20 as the system Massbus controller.



    1.9.2  Standard diagnostic support software

    DFRPN is compatible with all of the standard  diagnostic  loaders,
    monitors, subroutines.



    1.9.3  Operating systems

    DFRPN  is  fully  supported  in  user  mode  under  the  following
    monitors:

     o  TOPS10 release 7.01 (with RP20 support) or newer
     o  TOPS20 release 4.0 (with RP20 support) or newer

    The program will not be supported on older versions of the monitor
    since  it  requires the enhancements to the DIAG JSYS/UUO which do
    not exist in earlier monitors.

    The program determines if it is running under TOPS20 (rel-4),  and
    if  this  is  the  case  a flag is set, This flag is tested by the
    microdiagnostic dispatcher and if set, disallows  running  of  any
    microdiagnostic  that  exceeds the guaranteed 5.0 seconds that the
    monitor allows with out causing  a  keepalive  cease.   There  are
    three microdiagnostics that exceed this TOPS20 (rel 4) time limit.
    They are:

                DIA-39          DIA19           DIA1A

    Under all other supported monitors these microdiagnostics will  be
    run if selected, and in all cases they will be run in exec mode.



    1.10  CPU/Memory failures

    Most CPU and Memory faults are FATAL errors to the program and  it
    will not be able to continue.  The program may survive some memory
    parity errors.  If the parity error is in the program data buffer,
    the  program  will be allowed to continue.  If the error is in the
    program area itself, the error is considered FATAL.
                                                                Page 5


    1.11  Power fail/restart

    Not Supported



    1.12  Disk drive failure

    The program will  run  on  any  RH20/Disk  Drive  selected  during
    configuration  regardless  of  the  type, this is to allow for the
    possibility of a drive responding to other than the correct  drive
    type  or  logical number.  Of course the user could select a drive
    of the incorrect type or a nonexistent drive, and the  information
    and  errors  reported  would be without meaning.  This feature has
    been supplied  for  the  diagnosing  of  Massbus  and  drive  type
    register  problems.   All errors reported will include the suspect
    module or modules by their circuit symbol (i.e., A1A10).



    1.13  Restrictions

    Under TOPS20 a user must have at least MAINTENANCE  privileges  to
    run  the  program.   WHEEL's  and  OPERATORS  also have sufficient
    privileges to run the program in user mode.



    1.14  User mode transfer sizes

    In user mode, all transfers are restricted to being  multiples  of
    full sectors of data since zero fill cannot be programmed with the
    DIAG JSYS/UUO.  This restriction is of little consequence  in  the
    basic  functional because we are restricted to the microdiagnostic
    cylinder and is mentioned only to make the point that the  program
    will enforce the restriction automatically.



    1.15  User mode timing tests

    There are no user mode timing test made, however under  EXEC  mode
    the Dual Port test do preform timing test for port arbitration.



    1.16  User mode priority interrupts

    The diagnostic is not allowed to use the priority interrupt system
    in  user  mode.   The program will pole the hardware registers for
    interrupt conditions.
                                                                Page 6


    1.17  Non-Goals

    Diagnostic Engineering does not support or respond to problems  in
    the  8080  or  2901  microcode,  this  type  of  problem should be
    addressed by Disk Engineering.



    1.18  Support of the ISS CE cylinder for RP07

    Cylinder 631.  is the innermost cylinder on the drive and is  used
    by  the  drive  microdiagnostics.  This program uses this cylinder
    (631.) for all of the data path testing.  In the  event  that  the
    format  is  not  in  18  bit  mode, the program has the ability to
    reformat it in 18 bit mode.  Formating this cylinder is not a user
    option  and  the  decision  is  made during the data path testing.
    Data path test DATA8 is realy a utility to format  this  cylinder,
    this is done to insure that the cylinder is left in good condition
    at the completion of default testing.  This cylinder was  selected
    for use by this program to insure that the FE cylinders (629.  and
    630.) are not altered and the Formatter/Exerciser DFRPM  will  run
    without the user having to reformat them if the format was correct
    prior to running the Basic Diagnostic (DFRPN).



2.0  Hardware Requirements

    2.1  CPU family

    DFRPN  will  run  on  any  KL10  processor  with  a  RH20  Massbus
    controller.



    2.2  Memory

    DFRPN requires at least 64K of memory of any type to run  in  EXEC
    mode.

    Memory may be configured in any manner (i.e., internal,  external,
    interleaved  in  any  manner).  The key point is that the programs
    performance will not be effected by memory and cache options other
    than an overall program run time.

    In  user  mode  more  memory  is  required  due  to  the   monitor
    requirements,  there  must  be at least 64K of memory available to
    the user.
                                                                Page 7


    2.3  Load device

    DFRPN will load from any standard load device.  Program loading is
    is  a  function  of  the  standard diagnostic loaders and monitors
    (i.e., Diamon, D20mon, Magmon, Kldcp etc.).



    2.4  User interface to the program

    User interface to the program is through dialogue at the terminal.
    In  exec  mode, the console switches on the KL (left side switches
    are 11/40 front end console switches) will be used  directly.   In
    user mode, software sense switches are used as standard procedure.
    All  operator/program  dialogue  is  done  through  the   standard
    diagnostic subroutine package.  Sense switch options are described
    in section-3.



    2.5  Operating systems

    DFRPN runs  in  user  mode  under  monitors  supporting  the  DIAG
    JSYS/UUO.   This  monitor  feature  is  supported in the following
    monitors:

         o  TOPS10 (7.01) (With RP20 support) or newer.
         o  TOPS20 (4.0) (With RP20 support) or newer.

    The program is not be supported on older versions of  the  monitor
    since  it  requires the enhancements to the DIAG JSYS/UUO which do
    not exist in earlier monitors.



3.0  Functional Description

    This section provides a description of the functionality  that  is
    provided   by   DFRPN   at   various   program  levels  (start-up,
    configuration, test level, etc).



    3.1  Philosophical overview

    The functionality provided in this diagnostic was determined after
    examining  the  needs  for  the  RP07  and  a  close  look  at the
    functionality provided by existing basic disk diagnostics.

    This software is similiar in functionality  to  DFRPH  and  DFRPK.
    The  RP04/06  Basic  diagnostics.   This program has improved test
    dispatching and user interface dialogue.
                                                                Page 8


     o  DFRPN provides nearly identical functionality in exec mode and
        under  both  TOPS10  and  TOPS20  by  using  the DIAG JSYS/UUO
        features.  Briefly put, DFRPN does all of its own I/O in  real
        time  using DIAG features and is not restricted to limitations
        particular to either of the operating systems.  There is  only
        1  I/O  interface module for EXEC, TOPS10, TOPS20 and from the
        point of view of the user, functionality of the  program  will
        be   nearly   identical  in  all  three  cases.   DFRPN  fully
        implements loop on error so scope looping and trouble shooting
        is possible in any test.

     o  DFRPN provides the ability to reconfigure the program  at  any
        time.   This  is  done by entering manual or variable mode and
        selecting 'CONFIG' as if it were a test.




    3.2  Console sense switch options

    The only switches used by the program are a subset of the standard
    (left hand) sense switch options and are listed here.

    400000  If set: abort program at end of this pass
    200000  Not used
    100000  Not used

    040000  Inhibit all but FORCED printouts
    020000  Output to LPT in exec mode, DFRPN.PNT in user mode
    010000  Ring bell on error (bell is force printed)

    004000  If set: loop upon first occurrence of error
    002000  Halt on error (switch is ignored in user mode)
    001000  If set: print all repetitions of errors in a scope loop
            If reset: print only on first occurrence of error in loop

    000400  Not used
    000200  If set: use abbreviated printouts where possible
    000100  If set: inhibit operation of KL paging hardware

    000040  Not used
    000020  If set (at startup): inhibit operation of cache
    000010  Not used

    000004  Not used
    000002  Not used
    000001  Not used

    There are no right hand switch options in this program.  All other
    program options are selected through dialogue at the terminal.
                                                                Page 9


    3.3  Program start and restart philosophy

    DFRPN provides an alternate starting address that  allows  you  to
    get  gracefully  back  into  the  program  following  hardware  or
    software malfunctions or in  many  cases  after  a  power  down/up
    sequence if the program is in core memory.



    3.4  Initial program start up

    The inital starting address is at 30000.  Starting the program  at
    30000  (the  normal  address)  causes the program to be completely
    reset along with the reinitialization of the diagnostic subroutine
    package.   This  step  actually  needs  to be done only once after
    initial program load.  Starting at 30000 is  identical  to  typing
    the  STD  command  to KLDCP and results in maximum dialogue at the
    terminal.



    3.5  Optional restart address

    The optional starting  address  at  30004  gives  you  ability  to
    restart,  reconfigure  if  desired.  In addition, dialogue is very
    brief if you choose to keep the same configuration.  If you choose
    not  to  reconfigure, you will have to enter only minimum dialogue
    to get the program running again.



    3.6  Control-C capability (Ctrl-C)

    The program supports the CTRL-C and CONTINUE commands in user mode
    only, for both TOPS10 and TOPS20.  The CTRL-C intercept is honored
    by the program at the completion of its next I/O  operation.   The
    program  honors  the CTRL-C by cleanly terminating the program and
    returning to monitor level.  If a CONTINUE command is issued  from
    monitor level, the program will resume execution as if it were not
    interrupted.



    3.7  Configuration of program and subsystem

    This section outlines the operations of configuring the program to
    the  system  at run time.  There is a whole section of the program
    dedicated to configuration.  Several functional steps are executed
    in configuring the program:

     o  The program goes out and poles the system  in  an  attempt  to
        determine which Massbus controllers and drives are attached to
        the system (this step is also performed in user mode).
                                                               Page 10


     o  The program then reports the configuration  on  the  terminal.
        By now the program has built tables that identify the hardware
        configuration.

     o  The program then allows the user to select the controllers  to
        be used during the diagnostic.

     o  The program will then allow the user to run down the  list  of
        selected  controllers and pick the drives to be tested on each
        controller.

     o  If the user responds with "A" (all) only RP07 disk drives will
        be selected.

     o  The program then goes to each of the selected drives and  does
        a status check of the hardware, and reports some properties of
        the device.  When the dialogue is complete, the programs  data
        base and options will be complete.




    3.8  Finding RH20's and Drives

    In user mode the program reads the CONI status for each of  the  8
    RH's  and if NON-0, assumes the controller exists.  The responding
    device is also tested to see if bit 0 is set.  In  this  case  the
    device is not believed to be an RH20 and therefore not selected.

    In exec mode the program looks for any of the 8  possible  RH20's.
    The existence of a particular RH20 is tested for by first clearing
    it and then setting its PIA bits and checking for proper response.
    The  program  will  allow  an  RH20  to  be  used if the following
    conditions are met:

     o  The PIA bits can be set to 7 and cleared with an RHCLR.

     o  No RH20 error conditions exist following the RHCLR.

     o  Bit 0 is not set.


    There are several criteria that must be met  for  the  program  to
    recognize  the  existence  of  a  drive  on  any  of  the  Massbus
    controllers.  Drives are  only  looked  for  on  controllers  that
    passed  the  controller  criteria  mentioned in the previous step.
    The following criteria is then used for finding RP07 drives:

     o  The drive must handshake properly when the drive type register
        is read.

     o  The drive type must match that of an RP07.  At this point  the
        user  could  select  a  drive  other  than  an  RP07,  causing
        erroneous error reporting.
                                                               Page 11


    The program is capable of detecting and reporting  the  fact  that
    there  are  RP04,  RP06  and  RP20's  on the system but that's the
    extent of the support.  The program will allow you attempt to test
    them even though they will not respond correctly and report errors
    that are not consistent.  The responsibility of  proper  selection
    of  drives  rests  on the user, this allows testing of drives that
    are failing in the area that indicates drive type, logical number,
    ect.



    3.9  Reconfiguration capability

    The entire configuration package is constructed so it looks like a
    test  within  DFRPN.   This provides the capability to reconfigure
    from the manual 'MAN>', or variable 'VAR>'  mode  and  change  the
    configuration   and/or   modify  your  run  time  options  without
    re-initializing the program.



    3.10  Handling of user data on the media


    1.  This program preforms all write operations to the  maintenance
        area.  Reading and positioning will be allowed anywhere on the
        media.




    3.11  Modes of program operation

    There are 3 major operational modes of test control in DFRPN.  The
    modes  of  operation  are  called default (DEF), manual (MAN) and,
    variable (VAR).  The manual (MAN) and variable  (VAR)  mode  allow
    the  user  to  select  the  test to be performed.  In default mode
    (DEF) mode the tests and  iteration  count  are  supplied  by  the
    program.  The prompts for manual and variable mode are:

     o  WHAT TEST (OR HELP) ?  MAN> (implies manual mode)

     o  WHAT TEST (OR HELP) ?  VAR> (implies variable mode)




    3.11.1  Default mode DEF>

    In default (DEF) mode the test sequencing and parameter choice are
    entirely under control of the program.  The only user options are:

     o  'PRINT LOW PROBAILITY OF FAILURE - Y OR  N  <CR>',  this  will
        only  be  asked  once  after program startup and will be asked
        form the first mode entered.
                                                               Page 12


     o  'SINGLE OR MULTIPLE PASSES (S OR M)?  ', this  will  be  asked
        each time the default mode is entered.

    The program merely executes a predetermined set of tests  on  each
    of  the  drives  that  have  been selected for test.  The operator
    intervention test TST1, dump of the 8080 error log TST30, and Dual
    port  test  are  not  run  in  default mode.  Also microdiagnostic
    DIA46, the tachometer calibration utility and TD631, a utility for
    reading  and  writing  TD's  on  cylinder  631 are not run.  After
    completion of all default testing the program will return  to  the
    prompt  'WHAT  MODE (MAN,DEF,VAR OR HELP)?  ' this is also true if
    the default mode is aborted by the user by typing an altmode.



    3.11.2  Manual mode MAN>

    Manual mode provides the user a greater degree  of  test  control.
    If  entering  manual  mode  (MAN)  from  program startup the first
    prompt asks 'DO YOU WISH TO PRINT LOW PROBILITY MODULE CALLOUTS (y
    or  n)  ?',  if this question has been previously answered it will
    not be asked again.  Then the prompt is 'DEFAULT  ITERATION  COUNT
    IS  1,  DO YOU WISH TO CHANGE IT (y or n) ?', this allows the user
    to select how many times each test is to be run before  moving  to
    the  next drive or test, then the prompt is 'What test (or help) ?
    MAN>', which allows the user to select the test to  be  run.   The
    user  selects  from  the  list  of  all  possible  tests  that are
    implemented.  There are four prepackaged  test  scripts  available
    under  (MAN)  mode, They are strings of the test groups, TSTA runs
    all  the  control  bus  tests  in  sequence,  DIAA  runs  all  the
    microdiagnostics  tests  in  sequence, DATAA runs all the data bus
    tests in a sequence and DUAL runs all the  dual  port  test  in  a
    sequence,  (dual  port  testing  is  restricted to EXEC mode only,
    because it requires reconfiguring the Massbus).



    3.11.3  Variable mode VAR>

    The variable (VAR) mode of operation allows  the  user  to  select
    tests  from  prompt  level  just  as  he  does in manual mode.  In
    variable mode however, the test  will  loop  indefinitely  on  the
    first  drive  selected  and  the  first  test  run,  in the case a
    pre-packaged script was selected (TSTA, DIAA, or DATAA), DUAL port
    testing  does  not  run in variable mode VAR>.  This mode is realy
    meant for long term scope looping.  Because of this it is best  to
    select  one  only drive if running in variable VAR> mode, and then
    run the test which will loop until interrupted  with  an  altmode.
    The altmode will cause return to variable mode VAR>.
                                                               Page 13


    3.12  Test dispatching

    The program has 3 test dispatchers, one for default mode, one  for
    manual  and  variable mode and the dual port test dispatcher.  The
    dual port tests must be run in  EXEC  mode  and  in  sequence  for
    timing  tests  on  port  arbitration  and time-outs with automatic
    release of the port.

    The dual port dispatcher is not available to the user directly but
    is  called from manual mode dispatcher MAN> to preform the testing
    of dual port functions, this will run in EXEC mode only.

    The dispatcher used in manual  and  variable  modes  provides  the
    additional  dialogue,  control,  and parsing that is required when
    the user is picking and choosing the tests.

    The function  of  the  dispatcher  (regardless  of  which)  is  to
    properly  get  you  from  command  level to one of the implemented
    tests.   The  dispatcher  merely  scans  a  series  of  tables  to
    determine things like legality of test name, starting address, and
    iteration  counts.   The  dispatcher  knows  nothing   about   the
    particulars   of   the  test.   By  separating  the  functions  of
    dispatching and testing it is very easy to add, delete, or  modify
    tests  without changing the control structure of the program.  The
    handling of all test dependent operations  is  done  at  the  test
    level.

    The  microdiagnostics  are  always  run  from  a   microdiagnostic
    dispatcher.   This  dispatcher  is  actually  called  by the afore
    mentioned dispatchers, after the test has been determined to be  a
    microdiagnostic.   In  user  mode  this dispatcher assures that at
    least 12 seconds (by the wall clock) has expired since the  finish
    of   the   last   microdiagnostic   prior  to  starting  the  next
    microdiagnostic.  The purpose of this  timer  is  to  insure  that
    other  users  of  the  resources  used  in testing will be allowed
    access to the drives on this RH20.



    3.13  General test philosophy


     o  Provide a level of test control that allows the program to  go
        out and test the drives with a minimum of user dialogue.  This
        is the default mode DEF>.

     o  Provide a level of test  control  which  allows  the  user  to
        selectively  choose  a  test  from  the programs repertoire of
        tests and utilities.  This is the manual mode MAN>.

     o  Provide another level of manual test control that  allows  the
        user  to  loop  indefinitely on a test.  This is a loop of the
        complete test and will be  shortened  if  the  loop  on  error
        switch is set and an error occures.  This is the variable mode
        VAR>.
                                                               Page 14


     o  Report errors that are detected  during  the  running  of  the
        basic  diagnostic, and read the drive error log containing the
        last twenty (20) errors that the drive has seen and  corrected
        through retries or other means.

     o  To isolate failures to the field replaceable unit (FRU).




    3.14  Test specification and terminology

    This is an  introduction  to  some  of  the  terminology  used  to
    describe  tests  both  in  this  specification  and  in the actual
    program (through dialogue at the terminal).  Each test has a  name
    of  up  to  6 characters in length.  These names are recognized by
    the program as being valid tests.



    3.15  Test flow (cycling through devices)


     o  In default mode, a drive is chosen and then the  test  is  run
        until  the  iteration  count  is  exhausted.   At  present the
        default iteration count is set at one.  Then the next drive is
        chosen  and  the  test  is  then  run  on that drive until the
        iteration count is exhausted.  This continues until  the  test
        has  been performed the correct number of iterations on all of
        the selected drives.  The test then  returns  control  to  the
        dispatcher  who  will  determine  what  to  do  next  (usually
        dispatch to next test).  While in default mode, any parameters
        required  by  the  test will be supplied by the program (i.e.,
        sect, surface for formatting).

     o  In manual mode, you supply the iteration count when you  first
        enter  the  mode,  it will remain the same for all tests.  You
        may change the iteration count by running the  iteration  test
        (ITRSET),  which  allows  you  to change the count, if you run
        "ITRSET" and your response is no, the iteration count will  be
        set  to 1.  If you exit manual mode and enter default mode the
        iteration count will be set to 1.   And  upon  reenter  manual
        mode  you  will  be  asked if you wish to change the iteration
        count.

        The test dispatcher gets you to a particular test, a drive  is
        chosen  and  then  the  test  is  run  on that drive until the
        iteration count is exhausted.  The next drive  is  chosen  and
        the  process  continues until the test has been run the proper
        number of iterations on all  the  drives  selected  for  test.
        After  running  on  all  the selected drives, the test returns
        control to the manual mode test dispatcher which asks the user
        again to select another test.
                                                               Page 15


     o  Variable mode is some what different.  Built into  the  design
        of  the program is the assumption that we need a variable mode
        in order to recreate some failing condition that  we  observed
        on  a  particular  drive  so  that  it may be investigated and
        repaired.  The first effect of this assumption  is  that  when
        you enter a test, you do not want to get out when an iteration
        count is exhausted.  Unless specifically stated  in  the  test
        description,  tests entered in variable mode never return back
        to the dispatcher until the user types an altmode (escape)  to
        the program, this will return the user to the mode prompt.

        The second consideration in variable mode is determining which
        drive  to use, keeping in mind the fact that once it starts it
        never stops.  When running in variable mode DFRPN  choses  the
        first  drive of those selected for test and runs the test only
        on that drive.   The  cleanest  way  to  use  the  program  in
        variable  mode  is to first run CONFIG choosing only the drive
        you wish to test and  then  proceed.   The  variable  mode  is
        provided  mainly  for  the  purpose of scoping a drive that is
        suspect of malfunction and for some reason the diagnostic  has
        not  provided  all  the  information the user feels is needed,
        therefore the assumption that you are fixing one  drive  at  a
        time and are using some form of test equipment which would not
        lend to moving from drive to drive trying to keep up with  the
        dispatcher.




    3.16  Starting the test

    All tests are started automatically when arrived at from the  test
    dispatcher.   All  tests  are  self initializing and no particular
    test order is mandatory.



    3.17  Stopping the test

    Tests can be stopped in several ways:

     o  In default mode the test dispatcher sits  in  a  loop  cycling
        through  a  list  of  tests  that  are  pre-determined  by the
        diagnostic.  The user can get back into control by  typing  an
        altmode   (escape)  to  the  program.   The  altmode  will  be
        recognized immediately if no printing is taking place  and  at
        the  end  of the current error report if the program is in the
        middle of an error report.   The  test  in  progress  will  be
        allowed to finish then command will return to the prompt 'WHAT
        TEST (OR HELP) ?  MAN>'.  There is an exception if the altmode
        is  type  during a microdiagnostic a delay up to eighteen (18)
        seconds is possible, in user mode and six (6) seconds in  exec
        mode, (see Section 3, Test Dispatching).
                                                               Page 16


     o  In manual mode, control will come back to the user when either
        the  iteration count is exhausted or he types an altmode.  The
        altmode will be  recognized  immediately  if  no  printing  is
        taking place and at the end of the current error report if the
        program is in the middle of an error report, the current  test
        will be completed but the iterations remaining will be ignored
        and command will  return  to  mode  selection.   There  is  an
        exception  if  the  altmode is type during a microdiagnostic a
        delay up to eighteen (18) seconds is possible,  in  user  mode
        and  six  (6)  seconds  in  exec  mode,(see  Section  3,  Test
        Dispatching).

     o  If the tests are being run in variable mode, the only way  for
        the user to get back into control is to type the altmode.  The
        altmode will be  recognized  immediately  if  no  printing  is
        taking place and at the end of the current error report if the
        program is in the middle of an  error  report.   There  is  an
        exception  if  the  altmode is type during a microdiagnostic a
        delay up to eighteen (18) seconds is possible,  in  user  mode
        and  six  (6)  seconds  in  exec  mode,  (see  Section 3, Test
        Dispatching).  As in MAN mode the current  pass  of  the  test
        will  be  completed  and  the  iteration  count  (in this case
        infinite) will be ignored and command will be returned to  the
        prompt 'WHAT TEST (OR HELP) ?  VAR>'.




    3.18  Obtaining run time status (S) in user mode.

    The (S) function has been implemented as a method  of  determining
    if  the  program is still running or stuck in a loop of some sort.
    Typing the character (S) while the program is running will  return
    the  following  information as a way to insure that the program is
    actively running.

     o  Program run time (HH:MM:SS)
     o  Name of current test
     o  RH and DRIVE under test
     o  The request count is the number of times the  ".reqa"  routine
        has  been  called  since  startup, this will constantly change
        indicating that the program is running, not stuck in a loop.


    This request (.reqa) counter is 36 bits and can  overflow  if  the
    program  is run for a long enough period.  This function is merely
    to show that activity is going on.  The value is of  no  practical
    use, and only indicates activity.

    The program services the (S) in a synchronous manner so there  may
    be  a  1  or 2 second delay before response takes place.  Like the
    altmode response, you may have  to  wait  for  the  current  error
    printout  to  complete  before the (S) is honored.  There may be a
    delay of up to 6 seconds  due  to  the  microdiagnostic  execution
    time, and possible further delays due to monitor load.
                                                               Page 17


    Due to some minor differences in the  way  the  various  operating
    systems  and  diagnostic  support  programs  operate,  it  may  be
    necessary to type S<CR>  in  some  configurations  to  obtain  the
    runtime status.



    3.19  Obtaining run time status (S) in exec mode.

    The ctrlS (S)  function  has  been  implemented  as  a  method  of
    determining  if the program is still running or stuck in a loop of
    some sort.  Typing the ctrlS (S) while the program is running will
    return  the  same information as in user mode except the time will
    be the total time the program has been running in  hours,  minutes
    and  seconds.   Also in exec mode typing S ctrl T (ST) will return
    the run time status.  There may be a delay  of  up  to  6  seconds
    because of the microdiagnostic execution time.



    3.20  Restarting the test

    There is no way to jump back into the middle of a test once it has
    been aborted with an altmode.

    Typing an altmode in default mode has the  same  basic  effect  as
    reaching the end of a pass.

    In manual or variable mode you merely need  to  execute  the  test
    once more.



    3.21  Scope looping

    DFRPN supports the ability to loop on error in all  modes  if  the
    appropriate  sense  switch  is  set and an error occurs.  The loop
    uses only the controller/drive pair that was in effect at the time
    the  error  occurred.   Once  a  scope  loop  is entered it can be
    interrupted by either clearing the loop on error switch or  typing
    an  altmode to the program.  Note that the altmode abort takes you
    all the way back to dispatch level  while  the  resetting  of  the
    switch allows you to proceed from wherever you were looping.

    When running in variable mode the loop on  error  switch  has  the
    effect  of  tightening  the scope loop to the first failure in the
    test.  The other effect of the loop on error switch in  this  mode
    is a subtle effect on the printing.  With the loop on error switch
    set, only the first occurrence of an error  is  printed  which  is
    standard procedure with this switch.
                                                               Page 18


    3.22  Error printouts

    Error printouts closely resemble the error printouts provided with
    existing disk diagnostics.  There are 4 basic parts:

     o  The header of each message contains cosmetic information  such
        as  test  name,  type of interrupt condition, program run time
        etc.

     o  RH20 CONI status and registers are dumped (as appropriate)

     o  DRIVE registers are dumped (as appropriate)

     o  All additional information will be printed  pertinent  to  the
        test running.

     o  Module callout by circuit symbol (i.e., A1A10).

    In all of the error printouts, the registers and  status  data  is
    dumped  as a combination of ascii, sixbit, hex, and numerical data
    by default.  The TXTINH sense switch (If set) will  force  all  of
    the  status to be dumped in raw octal as it appears in the various
    hardware registers.



    3.23  Maintenance areas on the media

    The maintenance area of any disk (pack  or  fixed  media)  is  the
    innermost  cylinder.   This is the innermost cylinder of the media
    that is accessible without having to set any  diagnostic  bits  or
    issue special commands to gain access.

    In addition, the RP07 has 3  maintenance  cylinders  that  can  be
    accessed  by  setting  the  diagnostic mode bit.  The first two of
    these cylinders will be used by the reliability diagnostic and the
    third  cylinder  631  will  be used by this diagnostic, this is to
    insure  that  the  format  is  not   lost,   this   is   the   ISS
    microdiagnostic  cylinder,  it will be formatted by this test upon
    completion of data bus testing, but  there  is  a  possibility  of
    losing  the skip words, this will not have a marked affect on this
    diagnostic, the ISS microdiagnostics, or  cause  any  other  known
    problems.



    3.23.1  Write track descriptor (write TD)

    Only the inner most cylinder will be formatted by this diagnostic,
    DATA8   will  automatically  reformat  using  any  available  skip
    information.  This will not require any user control, and  is  run
    in default or manual mode.
                                                               Page 19


    4.0  Program retry of commands

    There will be no retry commands in this program.



    5.0  Test and Utility descriptions

    This section describes the functions, parameters, restrictions  of
    each  test  contained in the diagnostic.  The descriptions in this
    section cover all  of  those  operations  that  may  be  input  in
    response  to  the  'WHAT  TEST (OR HELP) ?  MAN> (or VAR>)' prompt
    even though some of the operations  are  not  device  tests.   The
    default  test sequence is listed with it's default parameters, and
    the four  (4)  prepackaged  sequences  for  running  control  bus,
    microdiagnostic,  data  path,  and  dual  port  test sequences are
    covered in this section.



    6.0  Test-1 Basic drive select test


                             Description

    This test verifies that  no  other  device  on  the  massbus  will
    respond  to  the  device  select code of the drive under test.  In
    this test all devices on the massbus are powered up but the  drive
    under  test.   The  test  will read the drive type register of the
    drive under test, that is, it will read  the  register  using  the
    device  select code for the drive under test.  No response to this
    read should occur.  If the test is unsuccessful,  the  drive  type
    and  serial  number  registers  of  the  responding device will be
    printed in order to aid in the isolation of the fault.

                              Additional

    In this particular test, the drive being tested is not the  faulty
    device.   If  the  offending  device  can't be identified from the
    information provided in the error printout, it may be necessary to
    power  down  the  other  devices on this massbus one at a time and
    rerun the test  until  the  offending  device  is  isolated.   The
    problem involves device selection, that is, a device responded and
    there wasn't supposed to be any response.  At this point,  several
    things could be wrong.  Some possible reasons for failure are:

         o  The controller may  not  be  sending  the  correct  device
            select code.
         o  The wrong drive is  being  selected  because  of  a  cable
            problem,  faulty  device select receivers in the drive, or
            failing device select circuits in the drive.
         o  The logic that looks for a match between the device select
            code and the device select switches is malfunctioning.
                                                               Page 20


         o  A remote possibility is that there are two devices on this
            massbus with the same device select switch setting.
         o  If the drive under  test  has  been  'disabled'  with  the
            disable switch, the switch itself could be bad.


    This test only verifies that another device does  not  respond  to
    the  device select code of the drive under test.  We will not know
    if the drive under test responds to any other device  select  code
    until we have successfully run test 13.



    7.0  Test-2 Demand transfer test


                             Description

    This test verifies the correct operation  of  the  demand/transfer
    handshake  of  the  control  bus.   The  drive being tested is now
    powered up.  The test reads the drive type register of  the  drive
    under  test  looking  only  for  proper  operation  of  demand and
    transfer over the massbus.  Improper operation would result  in  a
    control  bus  timeout.  Data and parity errors are ignored at this
    point.

                              Additional

    A failure in this test is indicated  by  a  control  bus  timeout.
    Some possible reasons for failure are:

         o  Demand is not getting to the  drive  because  of  a  cable
            problem or faulty demand receiver in the drive.
         o  The drive  is  not  being  selected  because  of  a  cable
            problem,  faulty  device select receivers in the drive, or
            failing device select circuits.
         o  A non-existent register is being  selected  because  of  a
            cable  problem,  faulty  register  select receivers in the
            drive, or failing register select circuits.
         o  Faulty disable switch or on-line switch in the drive.
         o  The handshake logic in the  drive  is  malfunctioning  and
            transfer is not being generated in the drive.
         o  Transfer is not getting back over the massbus because of a
            faulty  transfer  transmitter  in  the  drive  or  a cable
            problem.
         o  The power monitor signal at the input to  the  transmitter
            carrying   transfer   is   incorrect   and  disabling  the
            transmitter.  This could involve checking power  supplies,
            etc.

                                                               Page 21


    8.0  Test-3 Transceiver enable test


                          Test  Description

    This test is a preliminary check of the control  bus  read  cycle.
    This  test  reads the drive type register looking for a legal RP07
    device type.  It is the first time we are  trying  to  read  known
    data  from  the  drive.  This test is a partial guarantee that the
    transceivers are enabled during a control bus read cycle and  that
    the   CTOD  line  (controller  to  drive),  which  determines  the
    direction of the transfer, is  not  stuck  at  one  (indicating  a
    control  bus write) during the control bus read cycle.  Successful
    operation indicates that we can select a register  and  perform  a
    control bus read cycle.

                              Additional

    If this test fails some possible reasons are:

         o  A register select problem due to cables,  faulty  register
            select  receivers in the drive, or failing register select
            circuits.
         o  An invalid drive type detected due faulty or disabled data
            transmitters.
         o  The CTOD line is stuck at one meaning  we  are  trying  to
            write a register rather than read a register.




    9.0  Test-4 DA reg loaded with ones and zeroes


                             Description

    This test verifies  that  the  desired  address  register  can  be
    written with ones and zeroes.  The test sequence is:

         o  Issue a master clear.
         o  Write ones to desired address register.
         o  Read desired address register and verify that all bits are
            ones (ignore parity errors).
         o  Write zeroes to desired address register.
         o  Read desired address register and verify that all bits are
            zeroes ignore parity errors).


                              Additional

    If this test fails some reasons are:

         o  A register select problem might be causing  us  to  access
            the wrong register.
                                                               Page 22


         o  Stuck bits in the DA register or faulty data transmitters.
         o  The CTOD line is stuck at zero meaning we  are  trying  to
            read a register rather than write a register.




    10.0  Test-5 For cross-coupled bits with DA reg


                             Description

    This test checks for cross-coupled bits on the control  bus  using
    the  desired  address  register.   The test uses the data in table
    CBDAT for test patterns.  It starts with all ones and  all  zeroes
    (as in test 4), then floating ones, and then floating zeroes.

                        The test sequence is:

         o  Select a data pattern to be written.
         o  Write desired address register with selected pattern.
         o  Read desired address  register  and  verify  that  it  got
            written with the selected pattern.
         o  Increment to next pattern and test if  we  are  done  with
            patterns.   If not done, go to step 1.  If done, go select
            next drive.

            Additional

            None.




    11.0  Test-6 Parity network can generate a 1 or 0


                             Description

    This test verifies that  the  parity  network  in  the  drive  can
    generate  odd  parity, i.e.,, it checks that the parity bit is not
    stuck at zero or one.  The test sequence is:

         o  Write desired address register with zeroes.
         o  Read desired address register and verify that  the  parity
            generated was odd, i.e.,, the parity bit was a one.
         o  Write desired address register with a one.
         o  Read desired address register and verify that  the  parity
            generated was odd, i.e.,, the parity bit was zero.


                              Additional

    If this test fails, the parity network in the  drive  is  probably
    broken.
                                                               Page 23


    12.0  Test-7 Check faulty parity error detection


                             Description

    This test verifies that the parity error detection in the drive is
    functioning  correctly.   The  test  is almost the same as test 5,
    except that here we add a test to see if  the  parity  error  flag
    gets set after each pattern.  The test sequence is:

         o  Select a pattern to be written.
         o  Write desired address register with selected pattern.
         o  Read error register 1 and verify that the parity error bit
            did not set.
         o  Increment to the next pattern and test if we are done.  If
            not done, go to step 1.  If done, go select next drive.


                              Additional

    This test partially checks the parity chips and assumes that  test
    5  has  been  run  successfully, i.e.,, we assume that the desired
    address register is getting written properly.  @@



    13.0  Test-8 Register select test 1


                             Description

    This test is a check that writable registers can be  selected  and
    written.   The  writable  registers used are the control register,
    desired address register, offset register,  and  desired  cylinder
    register.  The test sequence is:

         o  Select a register to be written.
         o  Write the register with a data pattern  of  70  (arbitrary
            choice).
         o  Read  the  register  and  verify  that  it   got   written
            correctly.
         o  If all writable registers have been  selected,  go  select
            next drive.


                              Additional

    This test separates register select problems between read-only and
    read/write registers.
                                                               Page 24


    14.0  Test-9 Register select test 2


                             Description

    This test verifies that each writable register on the massbus  has
    a  unique address.  That is, we will try to verify that a write to
    one register does not cause some other register to be written  due
    to  a  register selection problem.  The writable registers are the
    control, desired address, offset, and desired cylinder  registers.
    These  registers  will be referred to as 'X' registers and will be
    written with a data pattern  of  70.   All  the  other  registers,
    including  the  writable registers not currently selected, will be
    referred to as 'Y' registers and will be written with a data field
    of 0.  The following algorithm is used:

        1.  Select a writable register and call it reg-X.
        2.  Check if all the writable registers  have  been  selected.
            If  they  have, we start the test over if another drive is
            available, or the test is  done  if  another  drive  isn't
            available.   If  they haven't all been selected go to step
            3.
        3.  Select another register and call it reg-Y.
        4.  Check that reg-Y is not greater than 37.   If  it  is,  we
            have checked reg-X against all values of reg-Y and go back
            to step 1 and select a new reg-X.  If it isn't, we  go  to
            step 5.
        5.  Check that reg-Y does not equal reg-X.  If it does, we  go
            back  to step 3 and select a new reg-Y.  If it doesn't, we
            go to step 6.
        6.  Write reg-X with a data field of 70.
        7.  Write reg-Y with a data field of 0.
        8.  Read reg-X and check that the data field is still 70.   If
            it  is,  go  back to step 3 and select a new reg-Y.  If it
            isn't, we will loop on error if the loop on  error  switch
            is  set or go back to step 3 and select a new reg-Y if the
            loop on error switch isn't set.


    The loop is completed when all writable registers in all available
    drives have been tested.

                              Additional

    This test by default guarantees that no two readable registers are
    mixed up because of a register select problem.



    15.0  Test-10 Test maintenance register selection


                             Description

    This test verifies that we can select  the  maintenance  register.
                                                               Page 25


    The test writes a data pattern of 70 into the maintenance register
    and reads it back and verifies it.

                              Additional

    This is the first time the maintenance register is used.



    16.0  Test-11 Test maint reg with data patterns


                             Description

    This test verifies that the maintenance register doesn't have  any
    stuck  data  bits.   The test uses the data from table CBDAT.  The
    test sequence is:

         o  Select a pattern to be written.
         o  Write maintenance register with selected pattern.
         o  Read maintenance  register  and  verify  that  pattern  is
            correct.
         o  Increment the byte pointer and test if we  have  used  all
            data patterns.

            Additional

            None.




    17.0  Test-12 Test massbus init and drv clr cmd


                             Description

    This test checks that massbus init (RHCLR) and drive clear work by
    checking  the  state  of  the  diagnostic mode bit (bit-15) of the
    maintenance register after each operation.  The test sequence is:

         o  Write a one to the DMD bit in maintenance register.
         o  Issue an RHCLR.
         o  Read maintenance register and  verify  that  the  DMD  bit
            cleared.  If it did not clear, set RHCLRF (RHCLR failed).
         o  Write a one to the DMD bit in maintenance register again.
         o  Issue a drive clear command to the control register.
         o  Read maintenance register and  verify  that  the  DMD  bit
            cleared  with  the  drive  clear  command.   If it did not
            clear, and RHCLRF is set, then both RHCLR and drive  clear
            failed.   If  it  did  not not clear, and RHCLRF is clear,
            then only the drive clear failed.  If it  did  clear,  and
            RHCLRF  is  set,  then  only  the RHCLR failed.  If it did
            clear, and RHCLRF is clear,  then  both  RHCLR  and  drive
            clear worked and there is no error.
                                                               Page 26


                              Additional

    We know from test 11 that the DMD bit in the maintenance  register
    is  not stuck at zero or one.  Therefore, if we set the bit and it
    clears with the drive clear command,  we  know  that  the  command
    decoder and go bit are at least partially functioning the way they
    should.



    18.0  Test-13 Test for multi-drive response


                             Description

    This test is effectively the complement  of  test  1.   This  test
    insures  that the drive being tested does not respond to any other
    drive's device select code but its own.  The test sequence is:

        1.  Write control register of drive under  test  with  a  data
            pattern of 70.  Call this drive-X.
        2.  Select some other drive (whether present or not), and call
            this drive-Y.
        3.  Write control register of drive-Y with zeroes.
        4.  Read control register of drive-X and verify  that  it  has
            not been modified (still 70).
        5.  If step 4 fails, report error and loop if loop on error is
            set.   If  step  4 doesn't fail repeat all steps letting Y
            range from 0 to 7 but not equal to X.


                              Additional

    If this test fails, it means the drive being tested is  responding
    to  some  other  drive's  device  select  code  and the same items
    outlined in test 1 should be checked.



    19.0  Test-14 Test parity error detection


                             Description

    This test verifies the correct operation of the parity error  flag
    (PAR)  and  illegal function flag (ILF) when an illegal command is
    issued to the drive and the drive  detects  a  parity  error.   We
    accomplish  this  by issuing the command with bad parity.  In this
    case the drive should only set the parity  error  flag,  since  it
    isn't  possible  for  the drive to tell if the command was a legal
    command or not (because of the parity error).  The test first uses
    an  illegal  command  with  an odd number of bits (fc=25) and then
    uses an illegal command with an even number of bits (fc=27) to  be
    sure that the test works for both cases.  The test sequence is:
                                                               Page 27


        1.  Read error register 1 and check to see if both PAR and ILF
            clear.  If they are, go to step 3, if not, go to step 2.
        2.  Issue an RHCLR and read error register 1 again.   If  both
            PAR  and ILF are clear go, to step 3.  If either one isn't
            clear, set the error flag and loop if enabled.
        3.  Initialize first time flag.
        4.  If this is  the  first  time  through,  issue  an  illegal
            function  with an odd number of bits (fc=25) and force bad
            parity.  If it is not the first  time  through,  issue  an
            illegal  function  with an even number of bits (fc=27) and
            force bad parity.
        5.  Read error register 1 and determine state of PAR and ILF.

                o If both are clear, set error flag and loop on  steps
                4
                   and 5.  If both aren't clear, go to step b.
                o If both are set, set error flag and loop on steps  4
                and
                   5.  If both aren't set, go to step c.
                o If only ILF is set, set error flag and loop on steps
                4
                   and 5.  If ILF is not set and we got this  far,  it
                   means  that only PAR was set, which is correct, and
                   we go to step 6.

        6.  Issue an RHCLR.
        7.  Read error register 1 and verify that PAR is clear.  If it
            isn't,  set  error flag and loop on steps 4 through 7.  If
            it is, go to step 8.
        8.  If this is first time through, set first time flag  to  -1
            and  go  to  step 4.  If this is not first through, we are
            done.


                              Additional

    We are not specifically testing the ILF bit in this  test,  i.e.,,
    we don't check it for all illegal commands.  However, we are using
    a double fault condition (illegal  function  and  bad  parity)  in
    order to isolate the problem to the 2901.  If both PAR and ILF are
    set or cleared, there is a good chance the 2901 is broken.



    20.0  Test-15 Check drv for correct parity to RH20


                             Description

    This test verifies that the drive sends correct parity to the RH20
    controller.   The  desired address register is used again with the
    patterns in table CBDAT, but this time we enable  checking  for  a
    control bus parity error.  The test sequence is:

                                                               Page 28


         o  Select a pattern to be written.
         o  Write desired address with pattern.
         o  Read desired address  register  with  control  bus  parity
            checking enabled.
         o  Increment byte pointer and test if we are  done  with  all
            patterns.


                              Additional

    After  this  test  the  parity  network  and  detection  logic  is
    completely tested.



    21.0  Test-16 Verify that ERR is not stuck at one


                             Description

    This test verifies that composite error (ERR) is not stuck at one.
    The test sequence is:

         o  Issue a drive clear command to control register.
         o  Read status register and verify that ERR is clear.

            Additional

            None.




    22.0  Test-17 Verify that ERR will set and clear


                             Description

    This test verifies that composite error (ERR) will set and  clear.
    The test sequence is:

         o  Cause composite error by writing desired address  register
            with bad parity.
         o  Read error register 1 and verify that parity  error  (PAR)
            is set.
         o  Read status register and verify that ERR is set.
         o  Issue a drive clear command.
         o  Read error register 1 and verify that PAR is clear.   read
            status register and verify that ERR is clear.


                              Additional

    The parity circuits were completely tested in tests 14 and 15.
                                                               Page 29


    23.0  Test-18 Verify that ATA is not stuck at one


                             Description

    This test verifies that attention active (ATA)  is  not  stuck  at
    one.  The test sequence is:

         o  Issue a drive clear command to control register.
         o  Read status register and verify that ATA is clear.

            Additional

            None.




    24.0  Test-19 Verify that ATA will set and clear


                             Description

    This test verifies that attention active (ATA) will set and clear.
    The test sequence is:

        1.  Cause composite error by writing desired address  register
            with bad parity.
        2.  Read status register and verify that ATA and ERR are set.
        3.  Issue a drive clear command.
        4.  Read status register and  verify  that  ATA  and  ERR  are
            clear.
        5.  Repeat steps 1 and 2.
        6.  Issue an RHCLR.
        7.  Repeat step 4.


                              Additional

    The parity circuits were completely tested in tests 14 and 15.



    25.0  Test-20 First check of ATA position decode


                             Description

    This test verifies that the  attention  summary  register  can  be
    cleared by issuing a massbus init.  The test sequence is:

         o  Issue an RHCLR.
         o  Read attention summary register  and  verify  that  it  is
            cleared.
                                                               Page 30


                              Additional

    If the test fails the attention summary register will  be  printed
    and  the  status  registers  of  all drives on the massbus will be
    printed (if TXTINH isn't set).  if it is some other drive that  is
    causing  the problem, you may have to power down the drives one at
    a time to isolate which drive is causing the problem.



    26.0  Test-21 Correct position decode of ATA


                             Description

    This test is a check of the  correct  operation  of  the  position
    decode of the attention summary register.  The sequence is:

         o  Issue an RHCLR.
         o  Cause composite error by writing desired address  register
            with bad parity.
         o  Read status register and verify that ATA and ERR are  set.
            (this worked in test 17).
         o  Read  attention  summary  register  and   verify   correct
            position for this drive.
         o  Write attention summary register with the correct bit  for
            this drive.
         o  Read status register and verify that ATA is clear and  ERR
            is set.
         o  Read attention summary register  and  verify  that  it  is
            cleared.

            Additional

            None.




    27.0  Test-22 Unique position decode of ATTN

                           summary register

                             Description

    This test verifies that  the  position  decode  of  the  attention
    summary register is unique.  The idea is to cause an attention and
    then write all bits of the attention summary register  except  the
    bit  for  the  drive  asserting attention.  If position decoder is
    working properly, check ATA in the drive under test will still  be
    set.  The following sequence is used:

        1.  Issue an RHCLR.
                                                               Page 31


        2.  Cause composite  error  by  writing  the  desired  address
            register with bad parity.
        3.  Read status register and verify that ATA and ERR are set.
        4.  Read attention summary register and verify  that  position
            is correct for drive being tested.
        5.  Write attention summary register with bits for all  drives
            not under test.
        6.  Read status register and verify that ATA and ERR are still
            set.
        7.  Read attention summary register and verify  that  position
            is correct for drive being tested.

                              Additional

            Steps 3 and 4 worked in test 21.




    28.0  Test-23 Massbus ATTN line is not stuck at 1


                             Description

    This test will verify that the massbus ATTN line is not  stuck  at
    one.  The test sequence is:

         o  Issue an RHCLR.
         o  Read attention summary  register  and  save  for  possible
            error report.
         o  Read RH controller status register and verify that massbus
            ATTN is not asserted.


                              Additional

    If this test fails the contents of the  status  registers  of  all
    drives  on  this  massbus will be printed (if TXTINH isn't set) in
    order to see which drive is asserting ATTN.  If you can't  see  an
    obvious problem you may have to     power down each drive one at a
    time to isolate the faulty drive.



    29.0  Test-24 Massbus ATTN can be set and cleared


                             Description

    This test verifies that the massbus ATTN line can be asserted  and
    non-asserted.  The test sequence is:

         o  Issue an RHCLR.
                                                               Page 32


         o  Cause ATTN by writing the desired  address  register  with
            bad parity.
         o  Read attention summary  register  and  save  for  possible
            error report.
         o  Read RH controller status register and verify that ATTN is
            asserted.
         o  Issue a drive clear command.
         o  Read attention summary  register  and  save  for  possible
            error report.
         o  Read RH controller status register and verify that ATTN is
            non-asserted.

            Additional

            None.




    30.0  Test-25 Basic test of readin preset command


                             Description

    This test is a basic test of the command decoder and uses a readin
    preset  command  to  check  the  response  of the drive.  The test
    sequence is:

         o  Issue an RHCLR.
         o  Issue readin preset command.
         o  Read status  register  and  verify  that  composite  error
            didn't set.


                              Additional

    We could also get an "ILF"  or  other  strange  failure.   we  are
    assuming that the command decoder is broken.



    31.0  Test-26 Readin preset command test


                             Description

    This test  verifies  the  correct  response  to  a  readin  preset
    command.  The test sequence is:

         o  Issue an RHCLR.
         o  Load desired address register with a 7 (arbitrary value).
         o  Load desired cylinder register with a 7 (arbitrary value).
         o  Write a one to the "FMT" bit (12) in the offset register.
                                                               Page 33


         o  Issue a readin preset command.
         o  Read desired  address  register  and  verify  that  it  is
            cleared.
         o  Read offset register and verify that it is cleared.
         o  Read desired cylinder  register  and  verify  that  it  is
            cleared.

            Additional

            None.




    32.0  Test-27 Verify correct response to CMD issued

                             with ERR set

                             Description

    This test verifies that when a command is issued  while  composite
    error  is  set,  that  the  drive  rejects  the command.  The test
    sequence is:

         o  Issue an RHCLR.
         o  Cause composite error by writing desired address  register
            with all ones and bad parity.
         o  Write 377 to  attention  summary  register  to  clear  all
            ATA's.
         o  Issue a readin preset command.
         o  Read drive status register and verify that ATA is set.
         o  Read desired  address  register  and  verify  that  it  is
            unchanged (all ones).

            Additional

            None.




    33.0  Test-28 Verify correct response to CMD issued

                             with ATA set

                             Description

    This test verifies that when a command is issued  while  attention
    active  (ATA)  is  set  and  no errors are left outstanding in the
    drive (ERR is clear), that the drive  accepts  the  command.   The
    drive  should  reset ata and execute the command.  To verify this,
    we will set the FMT bit in the offset register (just so  there  is
    something  there),  then issue an offset command, and then issue a
    readin preset command.  The offset command is a NO-OP in the  RP07
    (it  is  there  to  provide  compatibility  with older drives) and
                                                               Page 34


    should set ATA upon completion .  The readin preset command should
    clear the offset register (already verified in test 26) and should
    not set ATA upon completion.  Therefore, we have the sequence of a
    command  completing and setting ATA and another command completing
    and not setting ATA.  The test sequence is:

         o  Issue an RHCLR.
         o  Set the format bit in the offset register.
         o  Issue an offset command to the control register.
         o  Read status register and verify that ATA set and no  error
            occurred.
         o  Issue a readin preset command.
         o  Read status register and verify that ATA is clear  and  no
            error occurred.
         o  Read offset register and verify that it is clear.




    34.0  Test-29 Verify error register 2


                             Description

    This test is run in preparation for  running  the  microdiagnostic
    routines   resident   in  the  RP07.   It  will  verify  that  all
    combinations of error codes are recognizable.  This test  utilizes
    the communication wrapback feature.



    35.0  Test-30 routine to read RP07 error log


                             Description

    This routine will read and  print  the  error  log  that  is  kept
    updated  by  the RP07 microcontroller.  The procedure is to select
    the RDRAM routine (DIA17) which is loaded into the  high  byte  of
    the  maintenance register.  The hex address of the location in the
    error log is loaded into the low byte of the maintenance register.

                              Additional

    The information contained in the ERROR LOG is as follows:


         o  Number of times drive detected 'SEEK TOO LONG ERRORS'.

         o  Number of times drive detected 'SEEK OVERSHOOT ERRORS'.

         o  Number  of  times  drive  detected  'SOFT  SEEK  OVERSHOOT
            ERRORS'.
                                                               Page 35


         o  Number of times drive detected 'SEEK INCOMPLETE ERRORS'.

         o  Number of times drive detected 'INDEX  ERRORS',  presently
            inactive.

         o  Number of times drive detected 'PLO UNSAFE ERRORS'.

         o  The latest error code detected,  also  entered  in  unique
            error code list with count.

         o  The oldest unique error code, in a list of up to ten  (10)
            .

         o  The number of  times  in  decimal  that  the  above  error
            occured.

         o  Up to nine (9) more unique error codes and there number of
            occurences.

         o  The release level of the 8080 microcode.

         o  The release level of the 2901 microcode.



                                   NOTE

        All of the counters are printed in decimal, they count  up
        to  255 and if additional errors occur they will remain at
        255.  The counters do not recycle.  There is only room for
        ten   (10)   unique  error  codes  and  their  count.,  If
        additional  unique  error  codes  occur,  the  top   entry
        (oldest),  and  count  will be lost.  The nine error codes
        below it in the list will be moved up the list with  their
        counts  and the newest unique error code will be placed on
        the bottom of the list with it's count.

        When an error code is detected the  list  is  scanned,  if
        already in the list, only the counter will be incremented.

        The end result is the list will contain  up  to  ten  (10)
        unique  error  codes  and  their counts.  If more than ten
        (10)   unique   error   codes    have    occurred    since
        initialization, the list will contain the latest ten (10).
        Therefore it is possible to lose some unique  error  codes
        encountered,  due  to  list over flow.  But if these error
        codes are occurring frequently, they will most  likely  be
        on the list again as new unique error code entrys.


                                                               Page 36


    36.0  TSTA Prepackaged control bus test script


                             Description

    This is a package of tests for the  control  bus  portion  of  the
    massbus.   It runs TST2 through TST29 in sequence, this is similar
    to default mode with respect to the test dispatching, and  is  for
    isolating  problems in the control bus portion of the massbus.  It
    runs under manual mode MAN> and reduces test time if  the  problem
    is  known to be in this section of the massbus.  TST1 the operator
    intervention tests and TST30 are not run.
                                                               Page 37


    37.0  Microdiagnostics chart by sequence

    THIS LIST OF TESTS WAS GENERATED FROM uCODE LISTING DATED 05/27/80


    SEQ.        ROUT    DESCRIPTION             TEST            NOTE
    NUM.        NUM.                            NAME
    ===============================================================     
    1   | 24    | PROM CHECK            | ROMTST        |
    2   | 26    | INTERRUPT CHECK       | INTTST        |
    3   | 27    | CPU UNSAFE            | CPUSTS        |
    4   | 28    | TIMER TEST            | TIMTST        |
    5   | 29    | BUS CHECK             | BUSTST        |
    6   | 2A    | ANALOG C              | AATST         |
    7   | 2B    | A/D                   | ADTST         |
    8   | 2C    | A/D-D/A               | DATST         |
    9   | 2D    | OSCILLATOR            | OSCTST        |
    10  | 2E    | DIFFERENCE COUNTER    | DCTST         |
    11  | 2F    | LINEAR MODE           | SRTST         |
    12  | 30    | CYLINDER DETECTOR     | CDTST         |
    13  | 31    | POISTION CHANNEL      | PCTST         |
    14  | 32    | SERVO AMPLIFIER       | SEATST        |
    15  | 33    | CURVE GENERATOR       | CGTST         |
    16  | 34    | COMM/MAINT REGISTER   | CISTS         |
    17  | 23    | CROM PARITY (DCL)     | CRPTST        | 1
    18  | 35    | CROM CHECKSUM         | CRMCK         | 1
    19  | 36    | DCL1                  | DCL1TS        | 1
    20  | 37    | DCL2                  | DCL2TS        | 1
    21  | 38    | I/O WRAP              | ICTST         | 1
    22  | 39    | FULL CHECK ON J12     | INTFT         | 1
    23  | 3A    | SERDES WRAP           | SRDTS         | 1
    24  | 3B    | R/W BASIC             | RWSTS         | 1
    25  | 18    | PLO UNSAFE            | UNSTST        |
    26  | 19    | EMA CURRENT REPORTING | PDRTST        |
    27  | 14    | TACHOMETER DIAGNOSTIC | TACTST        |
    28  | 1A    | SECT/L.A. REG/UNSAFE  | INSC          | 1
    29  | 1B    | R/W SAFTY EXT         | RWSFX         | 1
    30  | 1C    | SERDES                | SDEXL         | 1
    31  | 1D    | DATA ENCODE/DECODE    | DECLX         |
    32  | 1E    | READ TRACK DESCRIPTOR | CERTD         | 2
    33  | 1F    | WRITE NULL            | WRTNL         | 2
    34  | 20    | WRITE/READ            | WRRTN         | 2
    35  | 21    | READ DATA             | RDDTA         | 2
    36  | 22    | AM TEST               | WAMCK         | 2
    --  | 46    | TACH. CAL. UTILITY    | TCALA         |

    NOTES:  1. ONE PARAMETER IS USED IN FE MODE:
           RUN OPTION (00 - DF) = DELAY TIME
                             FE = STOP ON ERROR
                             FF = SINGLE CYCLE

        2. TWO PARAMETERS ARE USED IN THE FE MODE
           (a) HEADER # (00 - 31) AND RIPPLE BIT 5
           (b) RUN OPTION (00 - DF) = DELAY TIME
                                 FE = STOP ON ERROR
                                                               Page 38


                                 FF = SINGLE CYCLE





    38.0  DIA-24        PROM check routine


    This routine checks all the PROM's on the CPU card  (A1A7)  board.
    There  are  7  PROM"s  that  are checked by this test, if any PROM
    besides the first one fails, the likely problem is with  the  PROM
    itself  (a  less  likely possibility is the IC that decodes select
    for that PROM).  If the first PROM fails the cause of the  failure
    are  likely  to be, the PROM itself, faulty address or data lines,
    or a bad chip select decoder.   The  PROM  test  operates  in  the
    following way:

     o  The sum (mod 255) of all the locations in the PROM  should  be
        zero.   When  the  PROM is burned in the last location of each
        PROM is the 2's complement of the sum (mod  255)  of  all  the
        previous data in the PROM.
     o  The next to last location in the PROM should be all ones.
     o  The second to last (one prior to next to last) should  be  all
        zeros.
     o  The error codes for this test are 10 through 12 and 14 through
        17, they are as follows:

         o  10 -- Error in CPU PROM 0, 0 - 2K address area.
         o  11 -- Error in CPU PROM 1, 2 - 4K address area.
         o  12 -- Error in CPU PROM 1, 4 - 6K address area.
         o  14 -- Error in CPU PROM 2, 6 - 8K address area.
         o  15 -- Error in CPU PROM 3, 8 - 10K address area.
         o  16 -- Error in CPU PROM 4, 10 - 12K address area.
         o  17 -- Error in CPU PROM 5, 12 - 14K address area.


    Note:  Error code 13 is used in a RAM test DIA0001 and not here.



    39.0  DIA-26        Interrupt test


    This routine checks the  interrupt  structure  on  the  drive  CPU
    (A1A07)  board.   The  interrupt service address for all interrupt
    levels except the one being tested are set to  an  error  handler.
    The  service  address  for  the  one  tested  is set to the normal
    return.  An interrupt is then sent out to the level being  tested.
    If  an  interrupt  to the wrong level or no interrupt occures then
    the error return is taken.  Otherwise, the next level  is  checked
    and the loop repeated until all interrupt levels have been tested.
    The only error code for this test is 3E and follows:

                                                               Page 39


         o  3E -- Interrupt test failed.




    40.0  DIA-27        CPU unsafe circuit test routine


    This routine checks the functioning of the  8080  unsafe  circuit.
    The test is in two parts, it first checks to see that no interrupt
    is received from the  circuit  within  4  microseconds  after  the
    circuit  has been refreshed, then checks to see if an interrupt is
    received within the next 4 microseconds.  The error codes for this
    test are 3C and 3D and follow:

         o  3C -- No interrupt received.
         o  3D -- Interrupt was too soon.




    41.0  DIA-28        Timer 1,2, 3 of 8080 CPU, test                                  _


    This routine tests the 8253 timer and it's  associated  circuitry.
    It  checks  each  timer  in the chip by loading a timeout and then
    jumping to a software timing  loop  until  interrupted.   It  then
    checks the amount of time it took to get the interrupt against the
    software timeout and gives an error if they don't compare.  If the
    test  fails,  the problem could be the 8253 chip itself, the clock
    interrupts, the latches associated with the timer or the interrupt
    structure.   The  error  codes for this test are 18, 19 and 1A and
    follow:

         o  18 -- Timer 1 circuitry failed.
         o  19 -- Timer 2 circuitry failed.
         o  1A -- Timer 3 circuitry failed.




    42.0  DIA-29        Bus check routine


    This routine verifies that the data  bus  is  working.   The  test
    first  sends  out  all  0's  to  two  different registers that are
    capable of being both written and read, then reads back  what  was
    sent  out,  if it doesn't compare on either of the registers, then
    the test fails, the test is repeated using all 1's.  If  the  test
    fails, some possible causes of the error are:

     o  A bus driver getting on the bus when not enabled.
     o  Shorted input on a bus receiver.
                                                               Page 40


     o  Bus driver on the CPU card not working.
     o  Bus receiver on the CPU card not working.
     o  I/O read or write pulse not working.
     o  Short or open backplane wiring.
     o  This is a test of a bus and any of the following boards  could
        be hanging the bus, (A1A4 through A1A16 and A1A20).  The error
        code for this test is 1F and follows:


         o  1F -- 8080 external bus test, this bus is across the
               backplane and any of  the  above  14  boards  could  be
               hanging the bus.




    43.0  DIA-2A        Analog "C" RAM test


    This routine checks the Analog "A" RAM to insure proper  operation
    of  the  Analog  "A" board.  This check tests all bits of each RAM
    location by using a test pattern that is rotated through  the  RAM
    memory  in  such a fashion that all possible four bit patterns are
    exercised for both the high and low order four bit groups of  each
    RAM  location.   At  the same time faulty or shorted address lines
    are tested for.  An error  in  this  test  will  indicate  that  a
    problem  exists  with either the RAM, data lines or address lines.
    The error code for this test is 60 and follows:

         o  60 -- RAM failure to compare after a write then read
               sequence.




    44.0  DIA-2B        Analog/Digital test routine


    This routine checks the limits of conversion of the A/D converter.
    It  also performes the zeroing of the A/D converter.  This is done
    by inputing +15 Volts into the A/D and then checking the output to
    see  if it returns a value of 7F Hex.  Then an input of - 15 Volts
    is inputed and the resulting value is checked to ensure that it is
    80 Hex.  The offset is then checked by inputing 0 Volts to the A/D
    and then checking to be sure that the value is +/- 0.75 Volts.  An
    error  in  this section will indicate a error in the A/D converter
    on the Analog "C" card or in the multiplexor  on  the  Analog  "C"
    card.  The error codes for this test are 70 through 73 and follow:

         o  70 -- Failure to saturate to 7F (hex) with +15 Volts
               reference channel.
         o  71 -- Failure to saturate to 80 (hex) with -15 Volts
               reference channel.
                                                               Page 41


         o  72 -- A/D failure to calibrate (A/D calibration offset
               too positive).
         o  73 -- A/D failure to calibrate (A/D calibration offset
               too negative).


    NOTE:  If this test fails it may cause other tests to also fail.



    45.0  DIA-2C        A/D and D/A wrapback circuitry test.


    This routine makes a basic check on the A/D and the  D/A  converts
    on  A1A04  board,  this  is  done by setting the D/A to a specific
    value and then wraping the channel around to  the  A/D,  and  then
    checking  if  the  proper  voltage  was  produced.  All MUX's data
    selectors are involved in this test in such a way that  all  basic
    parts  of  the  A/D  and D/A system are involved in some way.  The
    error codes for this test are 28 and 29 and follow:

         o  28 -- D/A - A/D test (positive offset).
         o  29 -- D/A - A/D (curve D/A reference) circuitry.




    46.0  DIA-2D        Analog "A" diff posi offset and cal


    This  test  will  automatically  zero  the  differential  position
    offset.  This series of tests requires the proper operation of the
    test oscillator.  The differential position offset is  checked  to
    see  if  it  is  within specified limits, and referenced to the on
    track signal.  The AGC is checked  to  ensure  that  the  AGC  has
    sufficient  gain.   This  is  accomplished by setting a normal AGC
    value and then changing the AGC value by Epsilon, the change  that
    results  in  the  AGC  data  is  checked to make sure it is within
    specified limits.  The even and  odd  off  track  signals  of  the
    differential  position  is  checked  to  ensure  that differential
    position signal will supply sufficient amplitude to  allow  proper
    operation.  Any error in these routines will indicate a problem in
    the Analog "A" circuits.  The error codes for this  test  are  61,
    62, and 64 through 66 and follow:

         o  61 -- Difference position offset failure to calibrate.
         o  62 -- AGC response to a positive change in gain.
         o  64 -- Insufficient negative amplitude of difference
               position.
         o  65 -- Insufficient positive amplitude of difference
               position.
         o  66 -- Difference position offset was too large,
               (test oscillator was on track).

                                                               Page 42


    NOTE:  This test makes use of the A/D and D/A on  the  Analog  "C"
    card.



    47.0  DIA-2E        Difference counter test


    This routine tests the difference counter  for  all  possible  bit
    combinations  by  rotating a test pattern through it.  The counter
    is then read back and checked for missing or added bits.  An error
    in  this  part will indicate that the counter register or the data
    bus is bad.  The difference counter  clock  is  also  checked  for
    proper  operation.   This  is accomplished by repetitively setting
    and resetting the difference counter clock enable  line  and  then
    checking  the  counter  clock  to  verify that the clock is indeed
    clocking the counter properly.  The difference  greater  than  255
    bit  is also checked by this routine.  This is done by setting the
    difference counter to values greater than 255, first 256 then  512
    and  checking the greater than 255 bit to be sure that it has been
    set.  An error in this section will indicate that  the  difference
    greater  than  255 decoders are not operating properly.  The error
    codes for this test are 74 through 7B and follow:

         o  74 -- Low difference counter test.
         o  75 -- Difference greater than 255 set, (difference
               = 0080 hex) test.  Here  we  loaded  128  decimal  into
               difference  counter, difference greater than 255 should
               not have set.
         o  76 -- Difference greater than 255 failed to set,
               (difference = 0100  hex)  test.   Here  we  loaded  256
               decimal into difference counter, now bit should set.
         o  77 -- High difference counter failed on a read back,
               (difference = 0100 hex).   After  the  256  decimal  is
               loaded into the difference counter to check the greater
               than 255 bit, the counter  is  read  to  insure  proper
               operation.
         o  78 -- Difference greater than 255 failed to set,
               (difference =  200  hex)  test.   Here  we  loaded  512
               decimal into difference counter, again the greater than
               255 bit should set.
         o  79 -- High difference counter failed on a read back,
               (difference = 0200 hex).   After  the  512  decimal  is
               loaded into the difference counter to check the greater
               than 255 bit, the counter  is  read  to  insure  proper
               operation.
         o  7A -- Low difference counter clock test.  The enable is
               toggled on and off, and counter is checked  for  proper
               operation.
         o  7B -- High difference counter clock test.  The enable is
               toggled on and off, and counter is checked  for  proper
               operation.

                                                               Page 43


    48.0  DIA-2F        Linear mode test - Status reg


    This routine checks the linear  mode  status.   This  is  done  by
    clearing  linear  mode and then checking to see if the linear mode
    is low.  Then linear mode is  set  and  the  linear  mode  set  is
    verified.  The error codes are 7C and 7D and follow:

         o  7C -- Linear mode reset test, reset linear mode then check
               that it is low.
         o  7D -- Linear mode set test, set linear mode then check
               that is set.




    49.0  DIA-30        Cylinder detector test


    This routine checks the fine and coarse cylinders detectors.  This
    is done by simulating a on track signal and then testing both fine
    and coarse cylinder detectors to ensure that they are  set.   Then
    the position signal is set to it's maximum positive value and then
    to it's maximum negative value.  Then  fine  and  course  cylinder
    detectors  are  checked  to  verify  that they are low.  The error
    codes for this test are 6C through 6F and follow:

         o  6C -- Fine cylinder detector bit, a logical AND is
               preformed with register 32 and a mask  of  01,  testing
               the  fine cylinder detect bit.  The (test oscillator on
               track).
         o  6D -- Coarse cylinder detector bit, a logical AND is
               preformed with register 32 and a mask  of  02,  testing
               the  coarse  cylinder detect bit.  The (test oscillator
               on track).
         o  6E -- Fine or coarse cylinder set, the differential
               position is set to = +6 Volts then both coarse and fine
               cylinder  detect  bits  are  tested by a logical AND of
               register 32 with a mask of 03.  With  (test  oscillator
               on track) and (+ odd defeat is true).
         o  6F -- Fine or coarse cylinder set, the differential
               position is set to = -6 Volts then both coarse and fine
               cylinder  detect  bits  are  tested by a logical AND of
               register 32 with a mask of 03.  With  (test  oscillator
               on track) and (+ even defeat is true).




    50.0  DIA-31        Position and differential position

                        channel test, (EMA disabled)

    The position and differential position channel are  tested.   This
    is  done  by  simulating  on  track  signals  as well as off track
                                                               Page 44


    signals and then testing the resulting responses via the  position
    and  differential position channels.  Proper operation is verified
    by testing the resulting output and comparing  it  to  a  expected
    value.   The  error  codes  for  this  test  are 2A through 2F and
    follow:

         o  2A -- Filtered differential position channel more negative
               than  -4.5  Volts,(C4  hex),  (-test   oscillator   PLO
               unsafe-1 and +even defeat set).
         o  2B -- Position channel is more positive than + 4.5
               Volts, (3C HEX), (-test oscillator PLO  unsafe  -1  and
               +even defeat set).
         o  2C -- Filtered difference position channel is more
               positive than +0.5 Volt, (07  hex),  (-test  oscillator
               PLO unsafe-1 set).
         o  2D -- Filtered difference position channel is more
               negative  that  minus  0.5  Volt,  (F9   hex),   (-test
               oscillator PLO unsafe-1 set).
         o  2E -- Position channel is more positive than +0.5 Volts,
               (07 hex.  (-test oscillator PLO unsafe-1 set).
         o  2F -- Position channel is more negative than minus 0.5
               Volts, (F9 hex), (-test oscillator PLO unsafe-1 set).




    51.0  DIA-32        Servo Error Amplifier (EMA Disabled)


    This routine verifies that the servo  error  amplifier  offset  is
    within  the  specified  0.5  Volt window.  This is accomplished by
    simulating an on-track signal and then  testing  the  servo  error
    test  point  to verify that the offset is within limits.  An error
    code for this test are 48 and 49 and follow:
     o  48 -- Servo Error Offset Greater than 0.05 Volts
     o  49 -- Servo Error Offset More Negative than minus 0.5 Volts




    52.0  DIA-33        Curve generator test (EMA disabled)


    Tests the curve generator to be sure that references are operating
    properly.   This  routine  checks  the curve for proper operation.
    This is done by  loading  the  difference  counter  with  specific
    values.   Then  testing  the  curve  generator  TP  and  the curve
    generator D/A to ensure that the curve generator is producing  the
    proper  values.   The  curve is checked at three points, the upper
    limit, lower limit and at the center of  it's  range.   The  error
    codes for this test are 57 through 5F and follow:

         o  57 -- Testing curve A/D converter output, difference
               counter =  0,  (0  hex),  failure  if  output  is  more
               positive than +300 Mvolts (05 hex).
                                                               Page 45


         o  58 -- Testing curve generator output, difference counter
               = 0, (0 hex), failure if output is more  negative  than
               minus 300 Mvolts (FC hex).
         o  59 -- Testing curve generator output, difference counter
               = 10 (0A hex), failure if output is more negative  than
               minus 2.2 Volts (E4 hex).
         o  5A -- Testing curve generator output, difference counter
               = 10, (0A hex), failure if output is  less  than  minus
               1.2 Volts (F1 hex).
         o  5B -- Testing curve A/D converter output, difference
               counter = 10 (0A hex), failure if more than +1 Volt (0D
               hex).
         o  5C -- Testing curve A/D converter output, difference
               counter = 10 (0A hex), failure if less  than  plus  500
               Mvolts (07 hex).
         o  5D -- Testing curve A/D converter output, difference
               counter = 127 (7F hex), failure if more than plus  9.75
               Volts (7D hex).
         o  5E -- Testing curve generator output, difference counter
               = 127 (7F hex), failure if less than minus 7 Volts  (A4
               hex).
         o  5F -- Testing servo error output, difference counter
               = 127 (7F hex), failure if less than minus 5 Volts  (BE
               hex).




    53.0  DIA-34        Comm and Maint register test


    This routine checks the functioning of the CIS board  A1A08.   The
    communications  register  is  checked by sending one bit high at a
    time to the "S" bus and then wrapping it back through the "Y" bus.
    The  2901 "Y" bus and the "S" bus are tri-stated during this test.
    The errors codes for this test are 7E and 7F and follow:

         o  7E Communications register self wrap test, this test is
               internal to the A1A8 board but A1A9, A1A10,  A1A12  and
               A1A14 may load the "Y" and/or "S" bus.
         o  7F Maintenance register, this test is internal to the
               A1A8 board but A1A11, A1A12 or A1A13 may load  the  "T"
               bus.




    54.0  DIA-23        DCL CROM parity test.


    This test checks for parity errors in the CROM of  the  DCL  A1A09
    and  A1A10.   All  locations  from  0000  to  0DFF will be checked
    excluding 01F7 through  01FF,  these  are  reserved  for  checksum
    storage.  The error code for this test is 8F and follows.
                                                               Page 46


         o  8F -- DCL CROM parity error




    55.0  DIA-35        CROM checksum on DCL1 and DCL2 test


    This routine will verify the CROM checksum  by  generating  a  sum
    based  on  the data read from the CROM's and compare this sum with
    pre-stored sums in CROM  0.   The  test  for  CROM   0  itself  is
    different in that it only checks itself to be zero.  The following
    locations in CROM 0, are used for storage of checksums.

            ADDRESS     CONTENTS                ADDRESS CONTENTS

            1FF Revision Level          1FB     CROM #3 Checksum
            1FE CROM #0 Adjustment      1FA     CROM #4 Checksum
            1FD CROM #1 Checksum        1F9     CROM #5 Checksum
            1FC CROM #2 Checksum        1F8     CROM #6 Checksum

    The error codes for this test are 30 through 36 and follow:

         o  30 -- Testing first 512 words (0000 to 01FF hex) of CROM
               for proper checksum.
         o  31 -- Testing second 512 words (0200 to 03FF hex) of CROM
               for proper checksum.
         o  32 -- Testing third 512 words (0400 to 05FF hex) of CROM
               for proper checksum.
         o  33 -- Testing fourth 512 words (0600 to 07FF hex) of CROM
               for proper checksum.
         o  34 -- Testing fifth 512 words (0800 to 09FF hex) of CROM
               for proper checksum.
         o  35 -- Testing sixth 512 words (0A00 to 0BFF hex) of CROM
               for proper checksum.
         o  36 -- Testing seventh 512 words (0C00 to 0DFF hex) of CROM
               for proper checksum.




    56.0  DIA-36        DCL1 check routine


    External bus, Pattern exchange  (8080  to  DCL  and  return,  DCL1
    unsafe,  diagnostic  timeout,  diagnostic  timeout, and diagnostic
    response or handshaking (from DCL) tests.   The  error  codes  for
    this test are 69, 81 through 86 and D0 and follow.

         o  69 -- CROM parity bit test.
         o  81 -- Communications register wrap test and external bus
               test.
         o  82 -- Handshaking failure, wrong code received from DCL.
                                                               Page 47


         o  83 -- Pattern exchange, from 8080 to DCL and back, testing
               pattern transmission and reception circuitry.
         o  84 -- DCL1 unsafe test.
         o  85 -- DCL2 timeout test.
         o  86 -- DCL2 diagnostic response test.
         o  D0 -- DCL2 "OP" register test.




    57.0  DIA-37        DCL2 check routine


    This routine checks the functioning of the DCL2 board (A1A10).  It
    tests the operation register, external branch in force mode, state
    branch register, sync register, "S" clock control function, vector
    interrupt,  interrupt  at  vector  address  00  and  1F, wrap test
    byte/word register, byte/word counter  and  DCL  status  register.
    The error codes for this test are 85, 86, D0 through D6 and D8 and
    follow:

         o  85 -- DCL2 handshaking timeout test.
         o  86 -- DCL2 diagnostic reply from DCL1 (high byte)
               incorrectly returned.
         o  D0 -- DCL2 "OP" register test, external branch failed in
               force  mode  or  "OP"  register  failed  in  bit   test
               capability.
         o  D1 -- DCL2 status register test.
         o  D2 -- Sync register and it's branch test failed in
               diagnostic  clear  mode  and  it's  associated   branch
               conditions, the branch conditions are:

                DCL2BR    INDEX     AM DETECT     EXE IN
                RWGOOD    DEVCK     ECCOK         ENDBR

         o  D3 -- DCL2 Interrupt in force mode-1 at vector 00 failed.
         o  D4 -- DCL2 byte count and word count register, compare
         o  D5 -- DCL2 status register failed.
         o  D6 -- DCL2 "S clock" control test failed.
         o  D8 -- External register failed on DCL2 board, there are
               two read/write DCL registers on  the  DCL2  board,  the
               "OP"  and "BC" registers, either one failed in the wrap
               check with DCL1.




    58.0  DIA-38        Interface control check routine


    This routine checks the functioning of the interface control board
    A1A12.  The following DCL external registers are wrap checked, ECC
    pattern and position registers A1A14,  error  register  1  and  3,
    desired  address and cylinder registers, current cylinder register
    and offset register.  The error code  for  this  test  is  DA  and
                                                               Page 48


    follows:

         o  DA -- Communication register wrap test via external
               registers.  There are eight DCL read/write registers on
               the  I/O  control  board,  the  test sequence is RPEC2,
               RPEC1, RPER3, RPDA, RPCC, RPDC, RPOF  and  RPER1.   Any
               one can cause this failure.




    59.0  DIA-39        Interface control test


                    General

    This test will check out the A1A12 board.  It can be called by the
    CE when in CE local mode or from the system through the diagnostic
    mode.  This routine starts on  Prom  2.   The  routine  takes  one
    parameter  when running from the local mode and it is described as
    follows:

        00      =       Execute partial test.
        01-FD   =       Execute the full test with the delay timer 
                        defined by the parameter.
        FE      =       Execute the fill test and stop if an error
                        is detected.
        FF      =       Execute the full test in single cycle mode.

    Full and partial as referred to above describe how the  test  will
    exercise  the  parity  checker on the TBUSC interface lines.  When
    full is invoked, the entire range of  patterns  will  be  used  to
    verify  proper  operation  of  the parity checker which will cause
    test  1 to take about 25  seconds  to  complete.   If  partial  is
    selected,  only  one  pattern will be used to check out the parity
    checker.  This capability is provided to allow the user  to  scope
    failures  in  other  parts  of  the  test  with  a  better (higher
    repetition rate) environment.   When  in  the  online  mode,  full
    testing is forced.

     o  Test 1 Parity/Maintenance register test.  This test will check
        out  the  TBUS  parity checker and the maintenance register on
        the TBUS.  High and low  pair  contains  the  pattern  of  the
        parity  checking  starting  with  all 0's and insertion of 1's
        each time, so it  is  16  times  to  loop  through  the  whole
        pattern.  Error codes 90, 91 and 92 are posted by this test.

     o  Test 2 RPDS test.  This test will check out the DS register by
        loading  it  through the 2901 and then reading it back through
        the maintenance register.  The patterns that are  checked  are
        0's,  then  an  alternating  pattern  of  1's  and  0's.   The
        alternating pattern is not a true test as some  bits  are  not
        throughly tested due to their effect in the hardware.

                                                               Page 49


     o  Test 3 ER2/CTLF register check.   This  test  is  designed  to
        check  out  the  ER2  register and the gating controls for the
        error presentation.  Also the CTLF register on A1A08 board  is
        checked out here.  This test supply the error codes 94, 95, 96
        and 97 as planned errors.

     o  Test 4 File test.  This test will check out all  registers  in
        the  file.  The inhibit function of error signal for registers
        ER1, ER3, EC1 and EC2 is also verifyed by this test.  On entry
        this  test  expects  error  to be set and high/low to be zero.
        Error codes 98 and 99 provided  as  primary  errors  for  this
        section.

     o  Test 5 Massbus write.  This test is for massbus write  of  OF,
        DC and DA registers.  This test starts using the massbus write
        capability.  It  checks  out  writting  into  OF,  DA  and  DC
        registers,  then reading them back and also testing the errors
        on A1A12, and the valid bits for the registers.   Error  codes
        9A, 9B, 9C and 9D are used as primary errors for this test.

     o  Test 6 Command register test.  This test checks out some parts
        of the command register and the NOP1 and NOP2 commands.

     o  Test 7 Preset command  test.   This  test  issues  the  preset
        command  and checks out the invaliditity and validation of the
        DA, DC and OF register

     o  Test 8 Invalid  command  test.   This  test  will  issue  some
        invalid  commands  with good and bad parity to check out of GO
        and RMR.

     o  Test 9 Illegal register test.  This test  checks  out  illegal
        register  detection  logic  for  reads  and  writes,  and that
        registers  do  not  get  modified  when  illegal  address   is
        detected.

     o  Test 10 Special attention and inhibit test.  This test  checks
        out  special  attention  and  the  inhibit write function when
        error is asserted.

     o  Test 11 Diagnostic command and drive clear  test.   This  test
        checks  out  the functions of the diagnostic command interrupt
        and drive clear on the A1A07, A1A08  and  A1A12  boards.   The
        routine will supply one error code B9.

     o  Test 12 DMD bit test.  This test checks out the DMD bit on the
        A1A08 board.  It uses the error code of BA.


    The error codes for this test are 90 through 9F, A0 through AF, B0
    through BA, BE and BF and follow:

         o  90 -- Floating "T BUSC" checks, maintenance register and
               accumulator circuits.  With the "T BUSC" floating  (all
               high).   The  accumulator checks for any pulled down or
                                                               Page 50


               low bits.
         o  91 -- "T BUSC" patery generator circuit and the CPA line
               for either partial (only one pattern) or  all  patterns
               with normal CPA line and CPA set to zero.
         o  92 -- Testing the maintenance register read function,
               this is done by writing  different  patterns  into  the
               maintenance register and reading them through the D BUS
               and the 8080 and making a comparison.
         o  93 -- RPDS register test, testing the "DS" register by
               loading different patterns through the 2901 and reading
               it  back  through "T BUSC", maintenance register, D BUS
               and the 8080.  This data path has been  checked  by  an
               earlier tests.
         o  94 -- Testing output control of the RPER2 register with
               8080 SETER signal not set.  The ER2 register which  has
               it's  low byte on A1A8 and high byte on A1A12 is tested
               by not setting 8080 SETER the output  of  the  register
               ER2 is in the high impedance state.  This verifies that
               the control functions properly on both A1A8 and A1A12.
         o  95 -- Testing output control of the RPER2 register with
               8080 SETER signal active.  The ER2 register  which  has
               it's  low  byte  on  A1A8 and high byte on A1A12 by not
               setting the signal 8080 SETER the ER2 register is read.
               This verifies that the output is zero with zero input.
         o  96 -- Testing RPER2 register, low byte.  This test is
               performed with 256 different patterns, ER2 low byte  is
               on A1A8.
         o  97 -- Testing RPER2 register, high byte.  This test is
               performed with 256 different patterns, ER2 high byte is
               on A1A12.
         o  98 -- Testing register file.  All eight registers RPER1,
               RPDA, RPOF, RPLDC, RPCC, RPER3, RPEC1 and RPEC2 in  the
               register  file  are  tested  by  loading  16  different
               patterns  and  reading  them  through  the  maintenance
               register  and  the 8080 accumulator, then comparing the
               results.
         o  99 -- Testing inhibit function of the register file.
               When the "-ERR" signal  is  active  the  register  file
               cannot be read.
         o  9A -- Massbus write and read of the "DA" register.
               Sixteen different patterns are written  into  the  "DA"
               register  through  the  maintenance  register, and read
               back into the maintenance register and compared.
         o  9B -- Massbus write and read of the "DC" register.
               Sixteen different patterns are written  into  the  "DC"
               register through the maintenance register and read back
               into the maintenance register and compared.
         o  9C -- Massbus write and read of the "OF" register.
               Sixteen different patterns are written  into  the  "OF"
               register through the maintenance register and read back
               into the maintenance register and compared.
         o  9D -- Testing the "DA", "DC" and "OF" register.  Massbus
               write of "DA",  "DC"  and  "OF"  registers.   Incorrect
               status has been reported from the A1A12 board.
                                                               Page 51


         o  9E -- Testing massbus write of "CS1" register.  Command
               register test is done by setting one command bit  at  a
               time  and  doing  a  massbus  write into "CS1" register
               through the maintenance register and then reading  back
               through the maintenance register.
         o  9F -- Testing command register preset command.  When
               preset  is  set   the   invalid   signals   "-RPOFINV",
               "-RPDCINV" and "-RPDAINV" should be true (low).
         o  A0 -- Inhibiting the "DA" register with preset command.
               This command should inhibit any output  from  the  "DA"
               register when it is read.
         o  A1 -- Inhibiting the "DC" register with preset command.
               This command should inhibit any output  from  the  "DC"
               register when it is read.
         o  A2 -- Inhibiting the "OF" register with preset command.
               This command should inhibit any output  from  the  "OF"
               register when it is read.
         o  A3 -- Preset command test, validation of the "DA", "DC"
               and "OF" registers with a massbus write command.   With
               the  preset  command  set,  a  massbus write into these
               registers should validate  them.   The  validate  flags
               should be set.
         o  A4 -- Preset command test test, validation of the "DA",
               "DC" and "OF" registers  with  a  2901  write  command.
               With  the  preset command set, a command to the 2901 to
               write these registers should validate them.
         o  A5 -- Invalid command test, write parity error.  Testing
               that a parity error will set when  an  invalid  command
               with bad parity is sent to the "CS1" register.
         o  A6 -- Invalid command, device check and A1A12 unsafe.
               Test that device check and  A1A12  unsafe  set  when  a
               invalid command with bad parity is issued.
         o  A7 -- Invalid command, massbus write to "CS1".  Testing
               to see if "GO" bit will set when an invalid command  is
               issued to the "CS1" register.  The "GO" bit should set.
         o  A8 -- Massbus write command with "GO" bit set.  The "RMR"
               bit should be set when attempting to write "CS1" with a
               NOP  command, and the "GO" bit is set.  If "RMR" should
               set.
         o  A9 -- Massbus write "CS1" command with "RMR" bit set.
               Device check and unsafe should set when  attempting  to
               write "CS1" with a NOP command while "RMR" is set.
         o  AA -- Massbus write of the "CS" register with "GO" bit
               set.  If "GO" bit is set  it  should  inhibit  writting
               into the "CS" register.
         o  AB -- Massbus write of the "OF" register with "GO" bit
               set.  If "GO" bit is set  it  should  inhibit  writting
               into the "OF" register.
         o  AC -- "GO" reset test.  Testing to see if the 2901 command
               to reset the "GO" signal functions correctly.
         o  AD -- Illegal register test, register 11.  Testing to see
               if "ILR" bit will set when attempting a massbus read of
               an illegal register 11.  If "ILR" should be set.
                                                               Page 52


         o  AE -- Illegal register test, changes in maintenance
               register.  Checking if the contents of the  maintenance
               register  are  modified  when  an  illegal  register is
               addressed, no modification should occur.
         o  AF -- Illegal register test, device check and A1A12
               unsafe.  Checking that device check  and  A1A12  unsafe
               bits are active when an illegal register is addressed.
         o  B0 -- Illegal register test, register 12.  Checking to see
               if the contents of the maintenance register are changed
               when  an  illegal  register  command "MBR12" is issued.
               Maintenance register should not be modified.
         o  B1 -- Illegal register test, register 13.  Checking to see
               if the contents of the maintenance register are changed
               when  an  illegal  register  command "MBR13" is issued.
               Maintenance register should not be modified.
         o  B2 -- Illegal register test, write command.  Testing
               that "ILR" bit sets when attempting to write an illegal
               register.
         o  B3 -- Massbus write to an illegal register, test for
               "CS1" modification.  Attempting to write to an  illegal
               register  with  a  massbus  write command, and checking
               "CS1" for any modification, none should occur.
         o  B4 -- Illegal register write command, test for "ILR"
               bit.  "ILR" must set when a massbus write to an illegal
               register is attempted.
         o  B5 -- Illegal register write command, validation of the
               "OF"  register.   The  "OF"  register  should  not  get
               validated by an illegal register write command.
         o  B6 -- Testing for "ATTN" bit with the massbus write
               command  and  "ERR"  set.   Checking  to  see  if   the
               attention  bit  gets  set when attempting to write into
               the "ER1" register with the massbus write command while
               the "ERR" bit is set.
         o  B7 -- Inhibiting the massbus write command with error
               set.  Any massbus  command  to  write  into  the  "ER1"
               register  with  "ERR"  set  should  not write into that
               register.
         o  B8 -- Inhibiting the massbus write commands of the read
               only registers, "CC",  "ER3",  "EC1"  and  "EC2"  while
               "ERR"  is  set.   Verifying that massbus write commands
               into the "CC", "ER3", "EC1" and  "EC2"  registers  will
               not change their contents if "ERR" is set.
         o  B9 -- Testing the diagnostic command interrupt and
               drive clear.  These functions are on A1A07,  A1A08  and
               A1A12.   The  A1A07  and  A1A08 boards have been tested
               earlier.
         o  BA -- "DMD" bit check.Testing the "DMD" bit of status
               register on A1A08, this signal is also on A1A12.
         o  BE -- Testing error logic of A1A12 board.  Testing three
               error signals, "TCBUSPARER",  "+ILR"  AND  "+RMR",  all
               three  should be inactive.  "TCBUSPARER" is (T and/or C
               bus parity error).
         o  BF -- Command register test, "GO" and "ATTENTION" bits
               reset.   Testing  the  command  register  with  a   NOP
               command,  the  "ATTENTION" and "GO" bits should not set
                                                               Page 53


               under this condition.




    60.0  DIA-3A        Serdes wrap check routine


    This routine checks the functioning of the SERDES board  A1A14  It
    is   entered  at  SRDCK  from  initialization  routine  or  system
    diagnostic and at SRDTS from CE monitor.  The error code for  this
    test is E2 and follows:

         o  E2 -- External register wrap test via DCL1, testing wrap
               circuitry.




    61.0  DIA-3B        Read/Write safty wrap check


    This routine checks the functioning of the read/write safty  board
    A1A16.   It  is  entered  at  RWSCK  from initialization or system
    diagnostic and at RWSTS from CE monitor.  The error code for  this
    test is F0 and follows:

         o  F0 -- External register wrap via the read/write safty
               board.  Testing read/write safty circuitry A1A16.




    62.0  DIA-18        Phase lock osc, unsafe


    This routine tests the unsafe  circuitry  and  the  index  timing.
    This unsafe check is accomplished by simulating a unsafe condition
    and then testing to be sure that the unsafe has  occurred.   Index
    timing  is tested before measuring the time interval between index
    pulses and then testing to see if the time interval is  within  3%
    of  the specified limit.  If an error results then the pack is not
    up to speed or a fault exists with the PLO  unsafe  or  the  index
    timing  circuits.  The error codes for this test are 67 and 68 and
    follow:

         o  67 -- PLO unsafe-1 test failure.  Testing the unsafe-1
               circuitry.
         o  68 -- PLO unsafe-2 test failure.  Testing the unsafe-2
               circuitry.

                                                               Page 54


    63.0  DIA-19        EMA current, Pulser/Driver test


    The Pulser/Driver PROM is tested for no  active  outputs,  forward
    outputs and reverse outputs.  Then the Pulser/Driver is tested for
    maximum reverse drive, offset current, calibration circuits, pulse
    and  drive  current  forward and reverse and error detection while
    driving to the forward and reverse stops.   The  error  codes  for
    this  test  are  4B through 4F, 54, 56, 63 and 8B through 8D, they
    follow:

         o  4B -- Analog "B" test.  Testing the Pulser/Driver
               PROM and associated circuitry for no active outputs.
         o  4C -- Analog "B" test.  Testing the Pulser/Driver
               PROM and associated circuitry  for  pulse  forward  and
               drive  forward outputs.  Does not respond to difference
               counter bit 256 in forward.
         o  4D -- Analog "B" test.  Testing the Pulser/Driver
               PROM and associated circuitry  for  pulse  reverse  and
               drive  reverse outputs.  Does not respond to difference
               counter bit 256 in in reverse.
         o  4E -- EMA current sample.  Testing the (maximum
               reverse drive) circuitry.  Insufficient EMA current.
         o  4F -- EMA current sample.  Testing the (maximum
               forward drive) circuitry.  Insufficient EMA current.
         o  54 -- EMA current offset calibration.  Testing
               the offset calibration circuitry, error is negative.
         o  56 -- EMA current offset calibration.  Testing
               the offset calibration circuitry, error is positive.
         o  63 -- Test pulse forward and drive forward.  Fails if
               Pulser/Driver does not respond in forward mode.
         o  8B -- Testing servo error reverse mode.  Servo error
               not greater than 4.0 Volts in reverse mode, by  driving
               carriage to rear stop.
         o  8C -- Test pulse reverse and drive reverse.  Fails if
               Pulser/Driver does not respond in reverse mode.
         o  8D -- Testing servo error forward mode.  Servo error not
               less  than  4.0  Volts  in  forward  mode,  by  driving
               carriage to forward stop.




    64.0  DIA-14        Tachometer diagnostic testing


    The tachometer circuits are tested for output between zero and 250
    Mvolts  low  and high bandwidth, output greater than 10 Volts with
    high slew rate and bandwidth and output between 4.5 and 6.5  Volts
    high  slew  rate  and  low bandwidth.  Also tachometer integration
    positive forward and reverse  are  tested.   The  following  error
    codes will be reported, C0 through C6 as follows:

                                                               Page 55


         o  C0 -- Tachometer on track test, low bandwidth.  Testing
               the tachometer output to be between zero and 250 Mvolts
               with low bandwidth while on track.
         o  C1 -- Tachometer on track test, high bandwidth.  Testing
               the tachometer output to be between zero and 250 Mvolts
               with high bandwidth while on track.
         o  C2 -- Tachometer integration test, positive and forward.
               Testing tachometer while  test  oscillator  is  set  to
               maximum positive value and EMA current offset is set to
               maximum positive value in forward direction.
         o  C3 -- Tachometer integration test, positive and reverse.
               Testing tachometer while  test  oscillator  is  set  to
               maximum positive value and EMA current offset is set to
               maximum positive value in reverse direction.
         o  C4 -- Tachometer integration test, negative and forward.
               Testing tachometer while  test  oscillator  is  set  to
               maximum negative value and EMA current offset is set to
               maximum negative value in forward direction.
         o  C5 -- Tachometer differentiator test, high bandwidth.
               Testing tachometer differentiator output to be  greater
               than  positive 10 Volts during high slew simulation and
               high bandwidth.
         o  C6 -- Tachometer differentiator test, low bandwidth.
               Testing tachometer differentiator output to be  between
               positive  4.5  and  positive 6.5 Volts during high slew
               simulation and low bandwidth.




    65.0  DIA-1A        Index/Sector timing check


     o  Test 1 Sector between index pulse test.  This routine is  used
        to check the number of sectors between two index pulses.  This
        must be performed while the pack is spinning.   There  are  67
        sectors/index,  a  number  chosen  to  test  this  part of the
        hardware only.

         o  Algorithm of the routine:
         o  Set up the timer constants in the 8253 by using subroutine
            "SMARP".
         o  Detect when index first occurs.
         o  Read look ahead register, which  contains  sector  number,
            and check if it is zero.
         o  Pause 240 uSec and read look ahead register to check  that
            sector number has been incremented by 1.
         o  Repeat (4) until next index occurs and look ahead register
            should be 67.
         o  Check if the second  index  would  reset  the  look  ahead
            register.
         o  To assure the operation, perform (3),  (4),  (5)  sequence
            again.

                                                               Page 56


     o  Test 2 Control paths, status and  control  registers,  part  1
        This  routine is used to check the hardware possibly tested on
        A1A08 board.  Excluding the index/sector  test,  communication
        register  and  maintenance register test.  It basically checks
        the control paths, status  registers,  control  registers  and
        ect.

     o  Test 3 Control paths, status and control registers, part 2

         o  This is a continuation of test 2.


    The error codes are reported by these tests, 89, 8A  and  8E,  and
    follow:

         o  89 -- Lookahead register test, on A1A08.
         o  8A -- Control signal test.  Testing control paths, status
               registers  control  registers,  and  their   associated
               circuitry.
         o  8E Device check bit test, on A1A08.




    66.0  DIA-1B        Read/Write safty extended diag


    This test is designed to position the heads over  the  guard  band
    and call the extended read/write safty diagnostic in the DCL code.
    Only one parameter is taken, that for the delay Timer/SOE/  Single
    cycle.   The  error  codes for this test are E9, F1 through F5 and
    follow:

         o  E9 -- Index recognition, tests that 2901 sees index.
         o  F1 -- Read/write unsafe-1 circuitry A1A16 test.
         o  F2 -- Read/write unsafe-2 circuitry A1A16 test.
         o  F3 -- Read/write unsafe-3 circuitry A1A16 test.
         o  F4 -- Write current voltage unsafe test A1A16 test.
         o  F5 -- Unsafe, all three unsafe conditions are tested,
               while drive tries to do a read or write.




    67.0  DIA-1C        Serdes extended test diagnostic


    This test is designed to execute the extended serdes check in  the
    DCL  code.  Only one parameter is used when running from the local
    mode, that is the Delay/SOE/Single  cycle  parameter.   The  error
    codes for this test are D6, DC through DF, E0, E1, E3, E4, and E9,
    the D6 error code  entry  point  is  realy  D6-1  and  is  on  the
    following page of the Pathfinder.  The error code explanations are
    as follows:
                                                               Page 57


         o  D6 -- DCL2 "S" clock control test, (pathfinder D6-1).
               Testing "S" clock control on A1A10.
         o  DC -- Serdes bit ring counter test, A1A14.
         o  DD -- Force end pulse and pattern select test of
               the Serdes board A1A14.
         o  DE -- Serdes (read) latch "B" and "LIFO" test of
               the A1A14 board, (LIFO is last in first out stack).
         o  DF -- Serdes "LIFO" data compare test of the A1A14
               board, (LIFO means last in first out stack).
         o  E0 -- Serdes "ECC" circuits test of the A1A14 board,
               part 1.
         o  E1 -- Serdes "ECC" circuits test of the A1A14 board,
               part 2.
         o  E3 -- Write "FIFO" without "T BUS", test of the Serdes
               board A1A14, (FIFO is first in first out stack).
         o  E4 -- Write "FIFO" with "T BUS", test of the Serdes
               board A1A14, (FIFO is first in first out stack).
         o  E9 -- 2901 index recognition, testing that 2901 sees
               index.




    68.0  DIA-1D        Data encode/decode test diagnostic


    This routine will invoke the  DCL  data  Encode/Decode  diagnostic
    only  one parameter is requested when running from the local mode,
    that for the Delay/SOE/Single cycle.  The  error  codes  for  this
    test are E6 and E7, and follow:

         o  E6 -- Read/write flag and sync complete test.  Testing
               the read/write flag on A1A15.
         o  E7 -- Encoder/decoder functional circuitry test of A1A15.




    69.0  DIA-1E        CE read track descriptor diagnostic


    This routine will recal, then seek to the CE cylinder and read the
    track  descriptor  at  the selected head.  Two parameters are used
    when running in the local mode as follows:

     o  The desired head  number  (0-29  decimal)and  the  ripple  bit
        (bit-5).
     o  2.   Run  option  (0-FD=delay  time,  FE=stop  on  error,  and
        FF=single cycle).


    The error codes for this test are F6 through F9,  also  the  error
    codes FE and FF may be arrived at from the Pathfinder, error codes
    follow.
                                                               Page 58


         o  F6 -- Functional read/write test part 1.  Testing the
               read/write circuits under  functional  conditions,  the
               read track descriptor test has failed on all heads.
         o  F7 -- Write null test, after testing the read/write
               circuits under functional conditions, a sync  character
               was detected where should not have be one.
         o  F8 -- Write data test.  Testing the write circuits under
               functional conditions.  Drive  timing  error  or  write
               sync uncompleted failure.
         o  F9 -- Read data test.  Testing the read circuits under
               functional conditions.  Drive timing  error  or  RWGOOD
               undetected failure.
         o  FE -- Functional read/write test part 2.  Testing under
               functional condition read track descriptor failed,  but
               not for all heads.
         o  FF -- Functional read/write test part 3.  Testing
               read/write circuits  under  functional  conditions  and
               write/read test failed.




    70.0  DIA-1F        Write null test


    This routine will recal, then seek to the CE cylinder and read  TD
    then  write  a null record, then read it back.  Two parameters are
    used when running in the local mode as follows:

     o  The desired head number (0-29  decimal)  and  the  ripple  bit
        (bit-5).
     o  Run option (0-FD = delay time, FE = stop  on  error,  and  FF=
        single cycle).

    The error code for this test is F7 and follows:


         o  F7 -- Write null test, after testing the read/write
               circuits under functional conditions, a sync  character
               was detected where should not have be one.




    71.0  DIA-20        CE write/read routine


    This routine will recal, then seek to the CE  cylinder  and  write
    data,  then  read  back  the  data.   Two parameters are used when
    running in the local mode as follows:

         o  The desired head number (0-29 decimal) and the ripple  bit
            (bit-5).
                                                               Page 59


         o  Run option (0-FD = delay, FE = stop on  error,  and  FF  =
            single cycle).


    There are no error codes for this test, it is an exercise.



    72.0  DIA-21        Read data routine


    This routine will recal, then seek to the  CE  cylinder  and  read
    data.   Two  parameters are used when running in the local mode as
    follows:

         o  The desired head number (0-29 decimal) and the ripple  bit
            (bit-5).
         o  Run option (0-FD = delay, FE = stop on  error,  and  FF  =
            single cycle).


    There are no error codes for this test, it is an exerciser.



    73.0  DIA-22        AM (address mark) test


    This routine will recal, then seek to the CE cylinder and  perform
    the  address  mark write/read test.  The error code reported is E8
    and follows:

         o  E8 -- Address mark detect test.  Testing the address mark
               detect circuitry on A1A15.




    74.0  DIA-46        Tachometer calibration routine


    This routine calibrates the tachometer in both the  high  and  low
    slew   rate   conditions  of  the  demodulator.   Thus  there  are
    essentially

    two complete iterations of the basic process.  Each calibration is
    done in the following manner:

    A value if fed into the difference counter to  make  the  carriage
    move  at  a constant velocity (4.21 inches per second for low slew
    rate, and 11.13 inches per second for high slew rate).  The actual
    velocity  is  then measured by counting the time it takes to do 30
    track  cross-  ings.   If  the  actual  velocity  is  not   within
    acceptable  bounds  then  the  AGC reference value is increased or
    decreased and the loop is repeated again.  This process  continues
                                                               Page 60


    until the actual velocity is within acceptable bounds.  (4.3 IPS =
    DIFF =3;  11.1 IPS = DIFF =10).  Set up  timeout  on  timer  3  to
    guard  against  getting  hung-up  in  the  calibration  routine if
    something fails.  If the timer completes it's timeout a return  to
    the  calling  routine  will  be  made  with  the  carry  bit  set,
    indicating that the calibration has failed.  There  are  no  error
    codes, this is a utility not a test.



    75.0  DIAA Prepackage script of remote microdiagnostics


                             Description

    This is a prepackaged script of all the  remote  microdiagnostics.
    It  allows testing of the ISS portion of the drive without running
    the tests for the control bus and data bus portion of the massbus.
    This  is  similar  to  default  mode  with  respect  to  the  test
    dispatching, and is for isolating problems in ISS portion  of  the
    drive.   It  runs  under  manual mode MAN> and reduces the time to
    isolate a problem, if the problem  is  known  to  be  in  the  ISS
    portion  of  the  drive.  DIA46 is a remote tachometer calibration
    utility and is not run.



    76.0  Data-1 Testing a seek with DMD set and reset


                             Description

    This is the first of the data path tests, it is testing  that  the
    IAE  and  DMD  bit work correctly, a recal is performed and then a
    seek to cyl 629., with DMD reset.  This is to check that a  normal
    seek  can  be performed.  Then recal and seek to cylinder 631 with
    DMD reset, this should cause  composite  error  ERR,  and  illegal
    address error IAE to be set.  Finally a recal and seek to cylinder
    631 with DMD set  is  performed,  this  should  produce  no  error
    conditions.

                              Additional

    A snap shot of all regigters is taken after each seek command.  In
    the event of an error the following registers are dumped:

        CONI    DATA            RH20    SBAR
        RH20    STCR            RH20    PBAR
        RH20    PTCR            RH20    INTERRUPT VECTOR REGISTER
        RP07    DRCR            RP07    DRSR
        RP07    DRER1           RP07    DRER1
        RP07    DRER2
                                                               Page 61


    77.0  Data-2 Testing data bus bits <02:17>


                             Description

    This test reads the track descriptor on cylinder (631.) surface 0,
    and checks for the correct information.  The drive reads the track
    descriptor as six (6) sixteen bit words, assembles them  as  three
    (3)  thirtysix  bit words and sends them to the RH20.  they appear
    as follows:
        RH20 WORD ONE   =   TD WORD 1 ,,TD WORD 2
                  TWO   =   TD WORD 3 ,,TD WORD 4
                  THREE =   TH WORD 5 ,,TD WORD 6

    TD word one contains the TD and H0 moved flags in bits 02 and  03,
    the  cylinder number in bits 06:17.  This should be 1167 octal, TD
    word two contains track number in bits  20:27  and  ones  in  bits
    28:35.   This should be 000377 for track 0.  Words 3 through 6 and
    checked for null words or skip  words,  although  bits  00:01  and
    18:19 and supplyed by the drive as zeros.  If any are ones it will
    indicate they are stuck on a one during a read.

                              Additional

                                None.



    78.0  Data-3 Read TD and Write it restore it


                             Description

    This test uses the TD that is declared free of TD and H0 skips and
    had null words in TD words 3 through 6.  The TD words should be as
    follows:
        Word 0ne 000,011,001,001,110,111 or 031167 octal.

        Word two 00X,XXX,XXX,X11,111,111 or surf#377 octal, where
        the X's = surface  number and can be from 0 to 37 octal.

        Word three through six should be the same.
        Word three 001,100,000,000,000,000 or 140000 octal.
        This is a null word or no defect skip.


                              Additional

                                None.
                                                               Page 62


    79.0  Data-4 Float ones and zeros in TD word 6


                             Description

    Data bus bits <02:17> are tested here, a one is floated through TD
    word 6, after each TD write the TD is read back and verified.  The
    same procedure is repeated using a floating zero,  then  patterns,
    after completing the pattern testing the TD is restored.



    80.0  Data-5 Format command, cylinder 631.


                             Description

    This test formats a track on cylinder 631.  and verify it.  The TD
    and  headers  are  built  in  BUF1A  and  the  format  command  is
    performed, the drive supplies all ones for the  data  field.   The
    data  field  is  verifyed  for sector zero.  It may have errors in
    bits 00 and 01.  They have not been checked prior  to  this  test.
    If  they  are stuck on a zero we will find that here.  If they are
    stuck on a one we will fail in the next test "DATA6".   This  test
    must  be here because at this point we do not know what format the
    drive is in.  It will be in 16 bit, if just received  or  HDA  was
    just replaced, or maybe no format at all after a hardware failure.



    81.0  Data-6 Pattern testing, bits 00 through 17


                             description
    In this test we are pattern testing, cylinder 631.   A  previously
    formatted  track  is used to write and verify data patterns.  This
    will test all bits  of  the  data  bus  portion  of  the  massbus.
    Floating ones and zeros are written and verified.  Then worst case
    magnetic media patterns are written and verified, bits <00:17> are
    tested and stuck ones or zeros are reported.



    82.0  Data-7 Position and house keeping commands


                             description


    This test performs all positioning and housekeeping commands  that
    have  not  been  previously tested.  although the microdiagnostics
    have tested all commands, this is the first  time  many  of  these
    commands have been issued from the massbus.
                                                               Page 63


    This test insures that all functions work correctly.  All commands
    are  issued  and  tested  for error free performance.  Reading and
    positioning is done  any  where,  but  writing  in  restricted  to
    cylinder  631.   Upon  successful  completion of this test and all
    prior tests, the drive is ready for reliability testing (DFRPM).

                              Additional

    This test also performs all illegal commands and checks  that  the
    ILF bit has been set.  Both noop commands are executed and checked
    for proper results.



    83.0  Data-8 Formatting all tracks cylinder 631.


                             description


    This test formats all tracks of cylinder 631.  This is  to  insure
    that the microdiagnostic cylinder is not degraded over a period of
    trouble shooting.  In all cases any track displacement information
    is  saved  and restored, this is more of a built in utility than a
    test.



    84.0  DATAA Prepackaged script of all Data tests


                             description


    This is a prepackaged script of all data path  tests.   It  allows
    testing  of  the  data path portion of the massbus without running
    control bus or microdiagnostics.  This is similar to default  mode
    with  respect  to the test dispatching.  It runs under manual mode
    MAN> and reduces the time to isolate a problem, if the problem  is
    known  to  be  in  the  data  path  portion of the massbus.  DATA1
    through DATA8 are run.



    85.0  Dual1 Verify programmable mode


                             Description

    Read  and  verify  that  both   ports   status   registers   yield
    programmable  bit.   This  test  also  fails if reading the status
    register happens to capture the port.  It should not do so.

            Additional
                                                               Page 64


            None.



    86.0  Dual2 Operation of capture/release port-A


                             Description

    The test is designed to do the following:

         o  Get into neutral
         o  Seize port-a with read of control register verify  with  a
            read of port-B status
         o  Wait approx.  1/2 sec.   and  verify  (by  reading  port-B
            status)  that  drive  has  not  yet  dropped  into neutral
            because of a one shot fault.
         o  Wait approx.  1 sec.  more and verify that the  drive  has
            gone  into  neutral  (the  one  shot did time out) causing
            automatic release.

            Additional

            None.




    87.0  Dual3 operation of capture/release port-B


                             Description

    This test is designed to do the following:

         o  Go into neutral
         o  Seize port-B with read of control register verify  with  a
            read of port-A status
         o  Wait approx.  1.5 second and verify  that  the  drive  has
            gone  into  neutral  (the  one  shot did time out) causing
            automatic release.

            Additional

            None.




    88.0  Dual4 Verify ability to hold port-A


                             Description

                                                               Page 65


        1.  Repeatedly capture port-A for some period of time  greater
            than  1.5  second  and verify that the port stays captured
            for the entire time.  The following sequence is used:
        2.  Go into neutral.
        3.  Capture port-A by reading the control register.
        4.  Read port-B  status  and  verify  that  drive  has  port-A
            captured.
        5.  Repeat steps 2 and 3 for a period of time longer than  the
            one shot time (approx 2 second) .


                              Additional

    This test is essentially testing the ability of the one shot to be
    re-triggered by the port-A capture.



    89.0  Dual5 Verify ability to hold port-B


                             Description

        1.  Repeatedly capture port-B for some period of time  greater
            than  1.5  seconds and verify that the port stays captured
            for the entire period of time.  The following sequence  is
            used:
        2.  Go into neutral.
        3.  Capture port-B by reading the control register.
        4.  Read  port-A  status  and  verify  that  port-B  has  been
            captured.
        5.  Repeat steps 2 and 3 for a period of time longer than  the
            one slot time (approx 2 seconds.).


                              Additional

    This test is essentially testing the ability of the one slot to be
    re-triggered by the port-B capture.



    90.0  Dual6 Reading reg-00 causes port-A capture


                             Description

         o  Go into neutral.
         o  Read each of the mass  bus  registers  (excluding  control
            reg)  and after each read, verify that port-A has not been
            captured by checking status on port-B.


                              Additional
                                                               Page 66


    This test is necessary because there is special  control  register
    select decoding done on the board for dual port operation.



    91.0  Dual7 Reading reg-00 causes port-B capture


                             Description

         o  Go into neutral.
         o  Read each of the mass  bus  registers  (excluding  control
            reg)  and after each read, verify that port-B has not been
            captured by checking the status on port-A.


                              Additional

    This test is necessary because there is  special  register  select
    decoding done on the board for dual port operation.



    92.0  Dual8 Write other ATA's doesn't capture port


                             Description

    Write ATA registers for all drives but  the  one  under  test  and
    verify no port has been captured.

                              Additional

    This is necessary because of special ATA decode logic on the  dual
    port board.



    93.0  Dual9 Capture port-A by writing control reg


                             Description

    Writing any register will capture a port if drive is  in  neutral,
    the selection of the control register is arbitrary.

         o  Get into neutral.
         o  Write control register on port-A.
         o  Read  status  from  port-B  and  verify  that  port-A  was
            captured.

            Additional

            None.
                                                               Page 67


    94.0  Dual10 Capture port-B writing its cont reg


                             Description

    Writing any register will capture the port if drive is in neutral,
    the selection of the control register is arbitrary.

         o  Get into neutral.
         o  Write the control register on port-B.
         o  

            Read  status  from  port-A  and  verify  that  port-B  was
            captured.

            Additional

            None.




    95.0  Dual11 Release from port-A doesn't set ATA


                             Description

    With no request on port-B, a release from port-A  should  not  set
    the ATA flop on port-B.

         o  Get into neutral with ATA's for both ports clear.
         o  Read control register for port-A to capture.
         o  Wait until we flip back into neutral.
         o  Verify that ATA has not been set for port-B.

            Additional

            None.




    96.0  Dual12 Release from port-B doesn't set ATA


    .center;Description

    With no request on port-A, a release from port-B  should  not  set
    the ATA flop on port-A.

         o  Get into neutral with ATA's for both ports clear.
         o  Read control register for port-B to capture.
         o  Wait until we flip back into neutral.
                                                               Page 68


         o  Verify that ATA has not been set for port-A.

            Additional

            None.




    97.0  Dual13 Release command, from port-A


                             Description

    Verify that we can release from port-A with a release command  and
    that issuing the release command does not cause composite error.

         o  Go into neutral.
         o  Read control register on port-A to capture it.
         o  Issue a release command.
         o  Read status register on port-B  and  verify  that  release
            worked correctly and did not cause composite error.

            Additional

            None.




    98.0  Dual14 Release command, from port-B


                             Description

    Verify that we can release from port-B with a release command  and
    that issuing the release command does not cause composite error.

         o  Go into neutral.
         o  Read control register from port-B to capture the port.
         o  Issue a release command.
         o  Read status register on port-B  and  verify  that  release
            command  worked  correctly  and  did  not  cause composite
            error.

            Additional

            None.

                                                               Page 69


    99.0  Dual15 1st part, request hold logic


                             Description

        1.  Go into neutral and reset all ATA's
        2.  Capture port-B by reading port-B control reg.
        3.  Request port-A by writing port-A control reg.
        4.  Read port-A status and verify that  it  is  not  captured,
            port-B should be in possession for 1 sec.
        5.  Wait for greater than a second to give  auto-release  from
            port-B a chance to happen.
        6.  Read status from port-A and  verify  that  "ATA"  has  set
            (because of the request from step-3).

            Additional

            None.




    100.0  Dual16 2nd test to verify request hold logic


                    Description

        1.  Go into neutral and reset all ATA's.
        2.  Capture port-A by reading port-A control reg.
        3.  Request port-B by writing port-B control reg.
        4.  Read port-B status and verify that  it  is  not  captured,
            port-A should be in possession for 1 sec.
        5.  Wait for greater than a second to give  auto-release  from
            port-A a chance to happen.
        6.  Read status from port-B and  verify  that  "ATA"  has  set
            (because of the request from step-3).


                    Additional

                    None.



    101.0  Dual17 Check "auto unlock" from port-B


                             Description

    Verify that we don't hang on a port if it  is  requested  but  not
    used.

         o  Clear all ATA's and go into neutral.
                                                               Page 70


         o  Capture port-A by reading the control register.
         o  Request port-B by reading its control register.
         o  Wait approx 3 sec, Drive should time out on  port-A,  flip
            to  port-B  because  of the request, timeout on port-B and
            flip back to neutral.
         o  Read status and verify that we are not hung on one of  the
            ports.

            Additional

            None.




    102.0  Dual18 Check "auto unlock" from port-A


                             Description

    Verify that we don't hang on a port if it  is  requested  but  not
    used.

         o  Clear all ATA's and go into neutral.
         o  Capture port-B by reading the control register.
         o  Request port-A by reading its control register.
         o  Approx wait 3 sec.  Drive should time out on  port-B  flip
            to  port-A  because  of the request, timeout on port-A and
            flip back to neutral.
         o  Read status and verify that we are not hung on one of  the
            ports.

            Additional

            None.




 103.0  Dual19 Verify RHCLR won't reset ATA in neutral


                             Description

         o  Cause Ata on port-A, (recal).
         o  Cause Ata on port-B, (recal).
         o  Issue RHCLR.
         o  Read status from both ports and verify  that  neither  ATA
            bit has been reset.

            Additional

            None.

                                                               Page 71


    104.0  DUAL Prepackaged script of all dual port tests


                             Description

    Dual port tests can not be selected one at a  time.   Due  to  the
    nature  of dual port arbitration timing testing, all tests must be
    run in sequence.  For this reason dual port test are dispatched by
    their  own  dispatcher.   In dual port testing the massbus must be
    reconfigured with a special  test  cable  'DEC  number  70-10507'.
    This  cable  swaps the differential pair for DS0, drive select bit
    0.  This makes port A and B appear to have unique logical numbers.
    After  completion of dual port testing, the massbus must be cabled
    correctly for system use.  Then  it  should  be  tested  again  to
    insure  that  cable  problems  have  not been inserted.  Dual port
    testing is done in EXEC mode only and only under the  manual  mode
    MAN> dispatcher.



    105.0  Major Internal Utilities

    105.0.1  TD631 - Read and Modify TD's cylinder 631.


                             Description

    This utility reads the specified TD  on  cylinder  631,  the  user
    specifies  the  surface.   All skips are reported, and the user is
    allowed to modify (remove and or add) skips).  This will allow the
    user to obtain a copy of defect skips on cylinder 631., and in the
    event of lost skip information, they may be rewritten  using  this
    utility.



106.0  Glossary

    DFRPK - The basic functional  diagnostic  for  RP06  on  DECsystem
        10/20.

    DFRPM - The formatter/exerciser for RP06/RP07 on DECsystem 10/20.

    DFRPN - The basic functional  diagnostic  for  RP07  on  DECsystem
        10/20.

    DIAG JSYS - Special diagnostic interface  to  the  TOPS20  monitor
        used for producing diagnostics that run while timesharing.

    DIAG UUO - Special diagnostic interface to the TOPS10 monitor used
        for introducing diagnostics that run while timesharing.

    FRU - Field replaceable unit.

    EXEC MODE - Program running on a stand-alone system.
                                                               Page 72


    USER MODE - Program runs on a timesharing system while the  system
        continues to timeshare.

    REMOTE DIAGNOSIS - The ability to diagnose or  exercise  a  device
        from a location other than the site of the timesharing system.

    TD - Abbreviation for Track Descriptor  Records  recorded  on  the
        front of each track of the RP07.

    ECC - Abbreviation for Error Correction Code.

    HUNG DEVICE - Program watchdog timer has timed out  while  waiting
        for  a  command  to  a  drive to complete.  Nominally set to 4
        seconds.












                              APPENDIX A

                                                                  Page
                                                                  ----
                                                              Page A-1


The following are examples of the diagnostic user interface and  error
reporting.
                          *** EXAMPLE 1 ***



A.1  Starting DFRPN and selecting a drive.

@D20MON.EXE.4 

* D20MON [DDQDH] - DECSYSTEM20 DIAGNOSTIC MONITOR - VER 0.3 *

D20MON CMD - DFRPN.A10
DFRPN.A10   VER 77.77   17-NOV-81

DFRPN RH20/RP07 BASIC DRIVE DIAGNOSTIC VERSION (UNRELEASED)
** FIELD TEST VERSION      EDIT # 4 OF 16 NOV 81 **

VERSION 77.77, SV=0.15, TOPS-20, KL10, CPU#=2102

TTY SWITCH CONTROL ? - 0,S, Y OR N <CR> - N

SWITCHES = 000000 000000 

MEMORY MAP =
FROM     TO         SIZE/K
00000000 00141777       49
PROGRAM USING  67(55.)K  155(109.)PAGES
PROGRAM USING  74(60.)K  170(120.)PAGES
PROGRAM USING  75(61.)K  172(122.)PAGES

THIS PROGRAM READS AND POSITIONS ANYWHERE ON THE MEDIA BUT WRITES "ONLY" TO
THE MAINTENANCE CYLINDER AND WILL NOT DAMAGE ANY USER DATA ON THIS MEDIA 

THE FOLLOWING RH'S AND DRIVES ARE DETECTED

RH'S    DRIVES
540     2 (RP06),3 (RP04),4 (RP04),5 (RP06),6 (RP06),7 (RP06)
544     0 (RP06),1 (RP06),2 (RP06)
550     3 (RP06),4 (RP06),5 (RP06)
554 
560 
564 
570     1 (RP07)

SELECT RH'S (540,544,550,554,560,564,570,574,A=ALL ARE LEGAL)
RH'S = 570

SELECT DRIVES (0-7, A=ALL, N=NONE) ON RH-570 = 1

XXXX-XXXX-XXXX
CONFIGURING -  DRIVE-1 RH-570 
PROGRAM USING  77(63.)K  175(125.)PAGES
DRIVE TYPE=020042 RP07 SINGLE PORTED  SER. NO.=0104.
DRSR    REG-01  570-1: DRAES TRA PARBIT MOL DPR DRY VV 
                                                              Page A-2



XXXX-XXXX-XXXX

WHAT MODE (MAN,DEF,VAR OR HELP)? DEF

PRINT LOW PROBABILITY OF FAILURE -  Y OR N <CR> - Y
SINGLE OR MULTIPLE PASSES (S OR M)? S

ERROR: TEST-TST2
SCOPE PC = 031665   START ADR OF TEST = 031655 
DATA SWITCHES = 000000 000000 

 DRIVE-1 RH-570 DRDT    REG-06  570: 060601 020022 

READING DRIVE REGISTER 06, BITS 20-35 SHOULD CONTAIN DRIVE TYPE,
20042=SINGLE PORT, 24042=DUAL PORT RP07


DEMAND-TRANSFER HANDSHAKE FAILURE. A CONTROL BUS TIMEOUT OCCURRED WHEN
READING THE DRIVE TYPE REGISTER (TRA = BIT 10 OF DATAI IS NOT SET).

MASSBUS CABLES, CONNECTORS OR TERMINATORS
DEVICE SELECT LINES OR CIRCUITS DS<2:0>
REGISTER SELECT LINES OR CIRCUITS RS<4:0>
FAULTY DISABLE OR ON-LINE SWITCH
DRIVE MODULE A1A11 - MASSBUS INTERFACE, PORT B
DRIVE MODULE A1A13 - MASSBUS INTERFACE, PORT A
DRIVE MODULE A1A08 - COMMAND INDEX AND SECTOR
---------------------------------------

                                                              Page A-3


                          *** EXAMPLE 2 ***



A.2  Reporting of a incorrect pattern after writing a register.

ERROR: TEST-TST5
SCOPE PC = 032111   START ADR OF TEST = 032062 
DATA SWITCHES = 000000 000000 

 DRIVE-1 RH-570 DRDA    REG-05  570: 050601 200030 

CORRECT PATTERN (IN BITS 20-35) IS:   000000 

CAN'T FLOAT PATTERNS THROUGH DESIRED ADDRESS REGISTER.

MASSBUS CABLES, CONNECTORS OR TERMINATORS
DRIVE MODULE A1A11 - MASSBUS INTERFACE, PORT B
DRIVE MODULE A1A13 - MASSBUS INTERFACE, PORT A
DRIVE MODULE A1A12 - INTERFACE CONTROL,  COMMON TO BOTH PORTS
DRIVE MODULE A1A08 - COMMAND INDEX AND SECTOR
---------------------------------------

                                                              Page A-4


                          *** EXAMPLE 3 ***



A.3  Testing the communications wrapback feature.

ERROR: TEST-TST29
SCOPE PC = 034750   START ADR OF TEST = 034710 
DATA SWITCHES = 000000 000000 

THE MAINTENANCE REGISTER WAS WRITTEN WITH

DRMR    REG-03  570-1: DRAES TRA DMD  ROUTINE(HEX)=7E 

THE VALUE READ FROM ERROR REGISTER 2 WAS A9

DRER2   REG-14  570-1: DRAES TRA PARBIT 

THE EXPECTED ERROR CODE(HEX) WAS A1


DRIVE MODULE A1A08 - COMMAND INDEX AND SECTOR
DRIVE MODULE A1A11 - MASSBUS INTERFACE, PORT B
DRIVE MODULE A1A12 - INTERFACE CONTROL,  COMMON TO BOTH PORTS
DRIVE MODULE A1A13 - MASSBUS INTERFACE, PORT A

IF THIS APPEARS AS A HUNG BIT, THE PROBLEM MAY BE ANY ONE OF THE
MODULES CALLED OUT, THEY SHARE THE "TBUSC", IF DUAL PORTED SUGGEST
TESTING FROM THE OTHER PORT
---------------------------------------

                                                              Page A-5


                          *** EXAMPLE 4 ***



A.4  Reporting error code, remote microdiagnostic.

ERROR: TEST-DIA24
SCOPE PC = 035433   START ADR OF TEST = 035323 
DATA SWITCHES = 000000 000000 

DRMR    REG-03  570-1: DRAES TRA DMD  ROUTINE(HEX)=24 
DRER2   REG-14  570-1: DRAES TRA  ERROR CODE(HEX)=10 

ERROR WHILE RUNNING MICRODIAGNOSTIC ROUTINE DIA24
ON  DRIVE-1 RH-570 .

DRIVE MODULE A1A07 - SERVO CONTROL
---------------------------------------

                                                              Page A-6


                          *** EXAMPLE 5 ***



A.5  This is the help file for the manual and variable mode.

WHAT TEST (OR HELP) ? MAN>HELP


CONFIG - ALLOWS YOU TO SELECT ANOTHER CONTROLLER AND/OR DRIVE
DDT - EXIT TO DDT
DESC - WILL ASK FOR TEST NAME AND PRINT A BRIEF DESCRIPTION OF THE TEST
DESCA - PRINTS A BRIEF DESCRIPTION OF ALL TESTS
EXIT - EXIT TO DIAMON
HELP OR H - PRINTS THIS MESSAGE
ITRSET - ALLOWS MODIFICATION OF ITERATION COUNT (MANUAL MODE ONLY)
LIST - PRINTS A LIST OF TEST NAMES
LOWPM - ALLOWS RESELECTING PRINT OUT OF LOW PROBABILITY MODULES
MODE - ALLOWS YOU TO RESELECT MODE (MAN,VAR OR DEF)
PGMSIZ - PRINTS CURRENT MEMORY USAGE (USER MODE ONLY)
RUNTME - PRINTS  PROGRAM RUN TIME
RUNZRO - RESETS PROGRAM RUN TIME TO ZERO
TYPE - ALTMODE TO CAUSE PROGRAM TO FINISH THE TEST OR SUBTEST IT IS
        EXECUTING AND RETURN TO THE PROMPT.
TYPE - S<CR> USER MODE, PRINTS PROGRAM STATUS, (DRIVE, TEST, AND NUMBER
        OF TESTS EXECUTED. (THIS WILL SHOW RELITIVE PROGRESS ONLY)
TYPE - (CTRL)S IN EXEC MODE, PROVIDES SAME INFO AS S<CR> IN USER MODE,
        S(CTRL)T WILL ALSO PROVIDE PROGRAM STATUS INFORMATION IN EXEC MODE

ANY OTHER INPUT WILL BE INTERPRETED AS A TEST NAME.
IN MANUAL MODE THE TEST WILL BE RUN (X) ITERATIONS ON EACH SELECTED DRIVE.
IN VARIABLE MODE THE TEST WILL BE RUN CONTINUOUSLY ON THE FIRST DRIVE
SELECTED UNTIL INTERRUPTED BY USER.
---------------------------------------

                                                              Page A-7


                          *** EXAMPLE 6 ***



A.6  This is the help for the mode dispatcher.

WHAT MODE (MAN,DEF,VAR OR HELP)? HELP


DEF - SELECTS DEFAULT MODE - DIAGNOSTIC WILL USE DEFAULT TESTS,
       BUT YOU MAY SPECIFY SINGLE (S) OR MULTIPLE (M) PASSES
MAN - SELECTS MANUAL MODE - YOU SPECIFY THE TEST TO BE RUN AND ITERATIONS
VAR - SELECTS VARIABLE MODE - YOU SPECIFY THE TEST TO BE RUN CONTINUOUSLY
DDT - EXIT TO DDT
EXIT - EXIT TO DIAMON
HELP OR H - PRINTS THIS MESSAGE
TYPE - ALTMODE TO CAUSE PROGRAM TO FINISH THE TEST OR SUBTEST IT IS
        EXECUTING AND RETURN TO THE PROMPT.
TYPE - S<CR> USER MODE, PRINTS PROGRAM STATUS, (DRIVE, TEST, AND NUMBER
        OF TESTS EXECUTED. (THIS WILL SHOW RELITIVE PROGRESS ONLY)
TYPE - (CTRL)S IN EXEC MODE, PROVIDES SAME INFO AS S<CR> IN USER MODE,
        S(CTRL)T WILL ALSO PROVIDE PROGRAM STATUS INFORMATION IN EXEC MODE

THE TEST LISTS AND DISCRIPTIONS ARE AVAILABLE IN MANUAL OR VARIABLE MODE

---------------------------------------

                                                              Page A-8


                          *** EXAMPLE 7 ***



A.7  Test descriptions from the (MAN) or (VAR) mode.

WHAT TEST (OR HELP) ? MAN>DESCA

TST1  - BASIC DRIVE SELECT TEST, WITH USER INTERVENTION
TST2  - DEMAND-TRANSFER TEST
TST3  - TRANSCEIVER ENABLE TEST
TST4  - TEST THAT DA REGISTER CAN BE LOADED WITH ONES AND ZEROES
TST5  - TEST FOR CROSS-COUPLED BITS WITH DA REGISTER
TST6  - TEST THAT PARITY NETWORK CAN GENERATE A ONE AND ZERO
TST7  - CHECK FAULTY PARITY ERROR DETECTION
TST8  - REGISTER SELECT TEST 1
TST9  - REGISTER SELECT TEST 2
TST10 - TEST MAINTENANCE REGISTER SELECTION
TST11 - TEST MAINTENANCE REGISTER WITH DATA PATTERNS
TST12 - TEST MASSBUS INIT AND DRIVE CLEAR COMMAND
TST13 - TEST FOR POSSIBILITY OF MULTI-DRIVE RESPONSE
TST14 - TEST PARITY ERROR DETECTION
TST15 - CHECK THAT DRIVE SENDS CORRECT PARITY TO THE RH20
TST16 - VERIFY THAT ERR IS NOT STUCK AT ONE
TST17 - VERIFY THAT ERR WILL SET AND CLEAR
TST18 - VERIFY THAT ATA IS NOT STUCK AT ONE
TST19 - VERIFY THAT ATA WILL SET AND CLEAR
TST20 - PRELIMINARY CHECK OF ATA POSITION DECODE
TST21 - CHECK FOR CORRECT POSITION DECODE OF ATA
TST22 - VERIFY UNIQUE POSITION DECODE OF ATTENTION SUMMARY REGISTER
TST23 - VERIFY THAT MASSBUS ATTN LINE IS NOT STUCK AT ONE
TST24 - VERIFY THAT MASSBUS ATTN CAN BE SET AND CLEARED
TST25 - BASIC TEST OF READIN PRESET COMMAND
TST26 - FUNCTIONAL TEST OF READIN PRESET COMMAND
TST27 - VERIFY CORRECT RESPONSE TO CMD ISSUED WITH ERR SET
TST28 - VERIFY CORRECT RESPONSE TO CMD ISSUED WITH ATA SET
TST29 - VERIFY ERROR REGISTER 2
TST30 - ROUTINE TO READ RP07 ERROR LOG
TSTA  - ALL CONTROL BUS TESTS EXCEPT TST1 AND TST30
DIA24 - PROM CHECK
DIA26 - INTERRUPT TEST
DIA27 - CPU UNSAFE TEST
DIA28 - TIMER TEST
DIA29 - BUS TEST
DIA2A - ANALOG C TEST
DIA2B - A/D TEST
DIA2C - A/D-D/A TEST
DIA2D - OSCILLATOR TEST
DIA2E - DIFFERENCE COUNTER TEST
DIA2F - LINEAR MODE TEST
DIA30 - CYLINDER DETECTOR TEST
DIA31 - POSITION CHANNEL TEST
DIA32 - SERVO AMP TEST
DIA33 - CURVE GENERATOR
DIA34 - COMM./MAINT. REGISTER TEST
                                                              Page A-9


DIA23 - CROM PARITY CHECK (DCL)
DIA35 - CROM CHECKSUM TEST
DIA36 - DCL1 TEST (2901)
DIA37 - DCL2 TEST (2901)
DIA38 - I/O WRAP TEST (2901)
DAI39 - FULL CHECK ON A1A12 (8080)
DIA3A - SERDES WRAP TEST (2901)
DIA3B - READ/WRITE BASIC TEST (2901)
DIA18 - PLO UNSAFE TEST
DIA19 - EMA DRIVER CURRENT TEST
DIA14 - TACHOMETER DIAGNOSTIC
DIA1A - INDEX/SECTOR/UNSAFE TEST
DIA1B - READ/WRITE SAFETY EXTENDED TEST (2901)
DIA1C - SERDES EXTENDED TEST (2901)
DIA1D - DATA ENCODE/DECODE TEST (2901)
DIA1E - READ TRACK DESCRIPTOR UTILITY (2901)
DIA1F - WRITE NULL UTILITY (2901)
DIA20 - WRITE/READ UTILITY (2901)
DIA21 - READ DATA UTILITY (2901)
DAI22 - ADDRESS MARK TEST UTILITY (2901)
DIA46 - TACHOMETER CALIBRATION UTILITY
DIA10 - SEEK-SEEK EXERCISER (8080) (NO REMOTE)
DIA11 - INCREMENTAL SEEK EXERCISER (8080) (NO REMOTE)
DIA12 - RANDOM SEEK EXERCISER (8080) (NO REMOTE)
DIA13 - RECAL-RECAL EXERCISER (8080) (NO REMOTE)
DIA15 - LAMP TEST EXERCISER (NO REMOTE)
DIA16 - CE CONTROL PANEL TEST EXERCISER (NO REMOTE)
DIA17 - RAM READ UTILITY (READS ERROR LOG) (8080), CALLED BY
        TST30, RUN TST30 TO READ DRIVE ERROR LOG AND uCODE VERSIONS.
DIA25 - REGISTER CHECK (NO REMOTE)
DIA3C - DCL UTILITY FOR CONTROL SIGNAL (NO REMOTE)
DIA3D - 8080 UTILITY FOR CONTROL SIGNAL (NO REMOTE)
DIA3E - PACK SPIN UP UTILITY (NO REMOTE)
DIA3F - PACK SPIN DOWN UTILITY (NO REMOTE)
DIA40 - DUMMY, NOT USED (NO REMOTE)
DIA41 - DUMMY, NOT USED (NO REMOTE)
DIA42 - DUMMY, NOT USED (NO REMOTE)
DIA43 - DUMMY, NOT USED (NO REMOTE)
DIA44 - DUMMY, NOT USED (NO REMOTE)
DIA45 - DUMMY, NOT USED (NO REMOTE)
DIA47 - TSTALL, RUNS ALL LOCAL MICRODIAGNOSTICS (NO REMOTE)
DIAA  - ALL MICRODIAGNOSTICS RUN IN A STRING, (DIA46 NOT RUN)
DATA1 - SEEK TO CYL 629 AND 631 TESTING DMD AND IAE
DATA2 - READ TRACK DESCRIPTOR ON CYLINDER 631
DATA3 - WRITE TRACK DESCRIPTOR CYL 631
DATA4 - PATTERNS IN TD WRD 3-6, TESTS BITS 02-17
DATA5 - FORMAT A FULL TRACK ON CYL 631
DATA6 - PATTERNS IN A SECTOR CYL 631, TESTS BITS 00-17
DATA7 - TEST ALL THE HOUSEKEEPING AND POSITIONING COMMANDS
DATA8 - FORMAT ALL OF CYL 631, UTILITY TO LEAVE IN GOOD COND.
DATAA - ALL DATA PATH TESTS RUN IN A STRING
DUAL  - ALL DUAL PORT TESTS, TIMING REQUIRES RUNNING IN A STRING
TD631 - UTILITY TO MANUALLY READ AND MODIFY TD'S, CYLINDER 631

---------------------------------------
                                                             Page A-10


                          *** EXAMPLE 8 ***



A.8  DATA8 reporting defect skips on cylinder 631.

WHAT TEST (OR HELP) ? MAN>DATA8
DO YOU WANT DEFECT SKIP WORDS PRINTED Y OR N <CR> - Y

DRIVE   CYL     SURF    DEFECT
NO.     NO.     NO.     WORDS
0104.   631.    0.      1599.  TD-MOVED

WHAT TEST (OR HELP) ? MAN>

---------------------------------------

                                                             Page A-11


                          *** EXAMPLE 9 ***



A.9  This is an example of the utility TD631.

WHAT TEST (OR HELP) ? MAN>TD631
DO YOU WISH HELP -  Y OR N <CR> - Y

THIS IS A UTILITY TO MANUALLY WRITE TRACK DESCRIPTORS FOR CYLINDER 631,
FIRST IT ASKS FOR SURFACE NUMBER, CORRECT RESPONSE IS 0-37 OCT (0.-31. DEC).

NEXT THE TD IS READ AND REPORTED TO YOU, YOUR ASKED IF YOU WISH TO MODIFY IT.
IF YES, YOU WILL BE ASKED ABOUT SKIP INFORMATION.
IF NO, YOU WILL BE ASKED IF YOU ARE DONE.

IF YES, YOU WILL EXIT THE UTILITY.
IF NO, YOU WILL ASK FOR THE NEXT SURFACE NUMBER.

A PERMANENT RECORD OF ALL SKIP INFORMATION ON CYLINDER 631 IS USEFUL
TO RESTORE IT, IF A HARDWARE FAILURE SHOULD DESTROY IT.

WHAT SURFACE (0 - 37 OCT OR 0 - 31 DEC) - 0

DATA CURRENTLY IN THIS TD:
CYL = 1167(631.)   SURF = 0(0.)
THERE ARE NO DEFECT DISPLACEMENTS
DO YOU WISH TO MODIFY ? Y OR N <CR> - Y
WANT TD-MOVED ? Y OR N <CR> - Y
WANT H0-MOVED ? Y OR N <CR> - N

DO YOU WISH TO ADD ANOTHER DEFECT ? Y OR N <CR> - Y
ENTER DISTANCE (16 BIT WDS) FROM INDEX 
THESE VALUES ARE ALLOWED 337(223.) THRU 42100(17472.) - 1599.

DO YOU WISH TO ADD ANOTHER DEFECT ? Y OR N <CR> - N
0104.   631.    0.      1599.  TD-MOVED
ARE YOU DONE MODIFYING TD'S -  Y OR N <CR> - Y

---------------------------------------

                                                             Page A-12


                          *** EXAMPLE 10 ***



A.10  Getting run status, CTRL-S.

WHAT MODE (MAN,DEF,VAR OR HELP)? DEF
SINGLE OR MULTIPLE PASSES (S OR M)? S

S RUNNING - TST5 DRIVE-1 RH-570   RP07 SINGLE PORTED  SN=0104.
 RUNTIME(HH:MM:SS) 00:09:42  TESTS EXECUTED = 3460(1840.)

S RUNNING - TST6 DRIVE-1 RH-570   RP07 SINGLE PORTED  SN=0104.
 RUNTIME(HH:MM:SS) 00:09:44  TESTS EXECUTED = 3505(1861.)

S RUNNING - TST7 DRIVE-1 RH-570   RP07 SINGLE PORTED  SN=0104.
 RUNTIME(HH:MM:SS) 00:09:45  TESTS EXECUTED = 3524(1876.)


                                                             Page A-13


                          *** EXAMPLE 11 ***



A.11  Reading the error log


WHAT TEST (OR HELP) ? MAN>TST30
 DRIVE-2 RH-540
THE CONTENTS OF THE ERROR LOG ARE:
ADR (HEX)   TYPE OF ERROR                       NUMBER OF ERRORS (DEC)

32          SEEK TOO LONG ERRORS                4.
33          SEEK OVERSHOOT ERRORS               1.
34          SOFT SEEK OVERSHOOT ERRORS          0.
35          SEEK INCOMPLETE ERRORS              0.
36          INDEX ERRORS                        0.
37          PLO UNSAFE ERRORS                   1.

THIS IS THE MOST RECENT ERROR REPORTED
ADR (HEX)       ERROR CODE
38              6A

HERE ARE THE LATEST TEN (10) UNIQUE ERROR CODES AND THEIR COUNTS.
THE FIRST ENTRY IS THE OLDEST AND THE COUNTS STOP AT 255. IF THERE
HAVE BEEN MORE THAN 10 UNIQUE ERROR CODES THE OLDEST IS LOST AND
THE NEW ERROR CODE AND COUNT IS PLACED ON THE BOTTOM OF THE LIST

ADR (HEX)       ERROR CODE      ADR (HEX)       COUNT
39              6A              3A              7.
3B              41              3C              14.
3D              83              3E              1.

THIS IS THE END OF THE ERROR CODE AND THEIR COUNTS, THE REMAINING LOCATIONS
(IF ANY) ARE EMPTY

71      THE 8080 MICROCODE REVISION LEVEL IS (HEX) 06
72      THE 2901 MICROCODE REVISION LEVEL IS (HEX) 04

WHAT TEST (OR HELP) ? MAN>













                              APPENDIX B

                                                                  Page
                                                                  ----
                                                              Page B-1


B.1  This Document has been Developed for use with the RP07

                             !! BEWARE !!

All information contained in this document has been developed for  the
purpose of preparing the Basic Diagnostic (DFRPN) for the RP07.  There
is much commonality with other disk drives,(i.e.  RP04 and  RP06)  but
beware  there  is  no  guarantee  that  the  information is correct or
complete, therefore for drives other than the RP07, BEWARE !!.



B.2  Contents

B.3  Massbus Registers and Definitions as used with the RP07

There are 16 massbus registers used to control command and  status  of
the RP07.  This is a brief description of there use.

Register  Name                           Type       Writable

   00     Control                        Read/Write <00:05><11>
   01     Status                         Read Only
   02     Error 1                        Read only     
   03     Maintenance 1                  Read/Write

   04     Attention Summary              Read/Write 
   05     Desired Track/Sector Address   Read/Write 
   06     Drive Type                     Read Only
   07     Look Ahead                     Read Only

   10     Serial Number                  Read Only
   11     Offset                         Read/Write 
   12     Desired Cylinder Address       Read/Write 
   13     Current Cylinder Address       Read/Write 

   14     Error 2                        Read Only
   15     Error 3                        Read Only
   16     ECC Position                   Read Only
   17     ECC Pattern                    Read Only

There are 16 registers in the RP07, These registers are accessible via
the Massbus asynchronous interface.  In each of the 16 registers bit 0
is the least significant bit.

All Massbus registers will remain stable during the Massbus read cycle
(i.e., contents will not change).
                                                              Page B-2


B.4  Error Classification and Recovery

                               General

The RP07 device is similar to previous  Massbus  disk  drives  in  the
terms of the general treatment of error conditions and the termination
of commands when errors occur.  One fundamental  difference,  however,
is  the  methodology  used  in  this device to search for a particular
sector address.  The RP07 depends upon  data  written  in  the  header
areas  for  locating  and  verifying  the  rotational  position of the
read/write heads.



B.5  Error Classification and Command Termination

All error conditions in the RP07 device are classified with respect to
their  effect upon the command in progress.  There are two basic error
classifications.



B.6  Class "A" Errors

Class "A" errors are defined as those errors which may be processed at
the  completion  of  a  non-data transfer command or, in the case of a
data transfer command, at a convenient block boundary.



B.7  Class "A" Error Protocol in the RP07

Class "A" errors which  occur  during  a  data  transfer  command  are
processed as follows:

     1.  If an error occurs, the RP07 will assert exception (EXC)  and
         end of block (EBL) at the normal end of the block boundary.
     2.  If during the end of block (EBL) pulse RUN remains  asserted,
         the  device  will  continue  to  assert  exception  (EXC) and
         continue the command in progress
     3.  If during the end of block (EBL) pulse RUN  is  negated,  the
         device  will negate exception (EXC) at the end of block (EBL)
         negation time, reset GO, report the error, set the  attention
         bit and assert the attention line.


Class "A" errors which occur during a non-data transfer command  cause
the error to be reported upon completion of the command when the drive
ready becomes asserted.  The error bit, attention  bit  and  attention
line will be asserted at this time.

Class "A" errors which occur when the RP07 drive is ready (DRY) (i.e.,
GO  is  reset)  cause  the  error  to  be reported upon detection, the
attention bit to set and the attention line to become asserted
                                                              Page B-3


                                 NOTE

               During the period between the  resetting
               of  GO and the subsequent setting of the
               attention  bit  (ATA)  due  to  a  error
               condition,   drive   clear   command  or
               Massbus initialize may cause  the  error
               bit  to be reset by the device hardware,
               but the attention  bit  processing  will
               continue  and result in a attention flag
               to the system without an apparent cause.
               In  order for this to occur, however the
               drive clear command or  initialize  must
               occur  within  seven (7) microseconds of
               the GO bit negation.





B.8  Class "B" Errors

Class "B" errors are defined as thoes errors  which  must  be  handled
immediately.   Class  "B"  errors will cause a command to be terminate
immediately in an orderly manner dependent upon the type of command in
progress.



B.9  Class "B" Errors During Data Transfer Commands


During a data transfer command, if a class "B" error occurs, the  RP07
device will:

     1.  Wait for the normal negation of Sync Clock (SCLK).
     2.  Disable any further assertions of Sync Clock (SCLK).
     3.  Set the error bit in the appropriate error register.
     4.  Assert Exception (EXC) and End Of Block (EBL)
     5.  No longer than seven (7) microseconds after resetting GO  the
         device  will  assert  the  attention  bit (ATA) and raise the
         attention line (ATTN).


Class "B" errors which occur while the RP07 is performing  a  non-data
transfer  command  will  cause  the  command  to  terminate as soon as
possible.  When Drive Ready (DRY) becomes asserted the error will have
been  posted in the error register and the attention bit (ATA) and the
attention  line  (ATTN)  will  become  asserted   within   seven   (7)
microseconds of the Drive Ready Assertion.
                                                              Page B-4


B.10  Class "B" Error Protocol In The RP07


Class "B" errors which occur while the RP07 is idle (DRY=1) will cause
the  attention  bit  (ATA)  and  the  attention line (ATTN) to be come
asserted upon recognition  of  the  error  condition.   The  attention
condition  will  occur, no later than seven (7) microseconds after the
particular error bit becomes set in the appropriate error register.



B.11  Register 00 Control and Status Register

                             Description

This read/write register is used to initiate  all  operations  in  the
RP07.   The  control  register  is physically shared by the RP07 drive
control logic and the RH controller.  The RP07 utilizes seven (7) bits
<00:05>  and  <11>,  the  other  nine (9) bits <06:10> and <12:15> are
located in the RH controller, bits <00:05> are read/write and bit <11>
is  read  only, Drive Available (DVA).  The Drive must supply zeros to
the controller for bits <06:10> and <12:15>.The function of  each  bit
follows:



B.12  Bit 0, GO bit


This bit when asseted will cause the device control logic in the  RP07
to;

     1.  Decipher the function code contained in bits 1 through  5  of
         the  control  register, these are called F0 through F4 in the
         drive.
     2.  Determine if the function code is illegal and if so  set  the
         appropriate error bit.
     3.  Determine if if the command is a data command.
     4.  If the decoded command is  a  data  command,  assert  Massbus
         occupied  (OCC)  line  within 50 microseconds and execute the
         function if and when  the  Massbus  run  (RUN)  line  becomes
         asserted.
     5.  If the decode command is a non-data command,  the  RP07  will
         execute the appropriate function.
     6.  The controller set's the GO bit and the drive resets  the  GO
         bit

                                                              Page B-5


B.13  Bits 1 through 5, Function Codes


These bits are written with the GO bit as two octal digits, the GO bit
is  always  set  or  no  decoding is done therefore only odd codes are
possible, all combinations follow:
Code    Command                         F4  F3  F2  F1  F0  GO

01      No-Op                           0   0   0   0   0   1
03      Illegal                         0   0   0   0   1   1
05      Seek                            0   0   0   1   0   1
07      Recalibrate                     0   0   0   1   1   1
11      Drive Clear                     0   0   1   0   0   1

13      Release                         0   0   1   0   1   1
15      Offset                          0   0   1   1   0   1
17      Return to Centerline            0   0   1   1   1   1
21      Read in Preset                  0   1   0   0   0   1
23      No-Op                           0   1   0   0   1   1

25      Illegal                         0   1   0   1   0   1
27      Illegal                         0   1   0   1   1   1
31      Search                          0   1   1   0   0   1
33      Illegal                         0   1   1   0   1   1
35      Diagnostic                      0   1   1   1   0   1

37      Illegal                         0   1   1   1   1   1
41      Illegal                         1   0   0   0   0   1
43      Illegal                         1   0   0   0   1   1
45      Illegal                         1   0   0   1   0   1
47      Illegal                         1   0   0   1   1   1

51      Write Check Data                1   0   1   0   0   1
53      Write Check Header and Data     1   0   1   0   1   1
55      Illegal                         1   0   1   1   0   1
57      Illegal                         1   0   1   1   1   1
61      Write Data                      1   1   0   0   0   1

63      Format Track                    1   1   0   0   1   1
65      Write Track Descriptor          1   1   0   1   0   1
67      Illegal                         1   1   0   1   1   1
71      Read Data                       1   1   1   0   0   1
73      Read Header and Data            1   1   1   0   1   1

75      Read Track Descriptor           1   1   1   1   0   1
77      Illegal                         1   1   1   1   1   1



B.14  Bits <06:10>, Drive must supply zeros


These bits are reserved for use by the controller.
                                                              Page B-6


B.15  Bit 11, Device Available (DVA), Read only


The device available bit (DVA), in Dual access mode, is  asserted  for
the  controller  which  has  access to the RP07 and reset to the other
controller.  In the single access mode or single ported drive this bit
is always asserted



B.16  Bits 12 through 15


Drive must supply zeros, these bits are used by the controller.



B.17  Register 01, Status Register, Read Only

This register contains status indicators for the selected  drive  This
is a read only register and can not be written form RH.




B.18  Bit 0, Offset Mode (OM)


Offset Mode Conditions, the drive handles this command as an no-op for
reasons of software compatibility, Offset Mode Conditions follow:

     1.  This bit is asserted when an offset command function code and
         GO bit have been written into the control register 00.
     2.  The assertion of the offset mode (OM) bit  will  generate  an
         attention  interrupt  to  the  controller which initiated the
         command when the GO bit is reset.
     3.  The offset mode bit (OM) will  be  reset  when  a  return  to
         centerline  command  function code and GO bit is written into
         the control register.  Resetting the  offset  mode  bit  (OM)
         with  the  Return  to  Centerline  command  will  generate an
         attention interrupt to the  controller  which  initiated  the
         command when the GO bit is reset.
     4.  The offset mode bit (OM)  is  also  reset  by  the  following
         conditions, however no attention interrupt will be generated:

            1.  Any Write Command
            2.  A Mid-transfer Seek
            3.  Power On Reset
            4.  An Implied Seek
            5.  Search Command
            6.  Seek Command
            7.  Recal Command

                                                              Page B-7


B.19  Bit 1, Early Warning (EWN)


This bit is asserted to indicate that an unsafe condition has occurred
that  may result in a permanent error.  If either an airflow unsafe or
a temperature unsafe condition occures the  Early  Warning  bit  (EWN)
will be asserted, and can will only be reset when the drive determines
the out of limit condition is no longer present.  Both the airflow and
temperature unsafe errors can be reset by drive clear or initialize as
long as the drive determines that a permanent error has not occurred.

A permanent airflow unsafe will cause the drive to, assert a composite
error  and  attention  with  error  code (41 hex) in error register-2,
negate medium on line (MOL) or generate a spindle power down sequence.

A continued rise in temperature which exceeds the shutdown limit  will
cause the automatic removal of AC power to the drive.

If prior to the spindle start sequence an Early Warning is detected it
will  inhibit  a  spindle  start,  however  if  the start sequence has
completed it will set the Early  Warning  bit  and  blink  the  unsafe
indicator.



B.20  Bit 2, Interleaved Sectors (ILV)


This  bit  becomes  asserted  when  the  device   microcode   performs
initialization  if  the interleave enable jumper on the backplane (J26
pin 5 to 6) is not present.  Initialization is preformed when DC power
is  applied  or  when  entering  normal  mode  from FE mode via the FE
control panel.



B.21  Bits 3 through 5, Drive must supply zeros.

B.22  Bit 6, volume Valid Bit (VV)


This bit should be a one, it  is  hard  wired  high  (-rvcc1)  on  the
interface control board.



B.23  Bit 7, Drive Ready Bit (DRY)


The Drive Ready Bit (DRY), is the complement of  the  GO  bit  in  the
control and status register, Register 00.
                                                              Page B-8


B.24  Bit 8, Drive Present Bit (DPR)


The drive present bit,  in  the  dual  access  mode,  is  set  to  the
controller  which  has  access  to  the  RP07  and  reset to the other
controller.  In the single access mode or single  ported  drive,  this
bit is always asserted.



B.25  Bit 9, Programmable Bit (PGM)


The programmable bit is set if the controller select switch is in  the
A/B position at the time of the drive transition from an offline to an
online  condition.   This  transition  occures   at   the   successful
completion  of  a  start spindle sequence, or via the online switch on
the operators panel going from offline to online.

When the Drive Request Required (DRQ) bit in the drive  type  register
is  reset  (single  access  drive),  the  programmable  bit  is always
negated, the controller  access  switch  is  ignored,  and  controller
access A is forced.

Regardless of the state of the  controller  select  switch,  power  on
initialization  will  assert  the  (PGM) bit in a drive configured for
dual access (DRQ=1).  The drive will remain in the programmable  state
until online is asserted and the controller select switch is sampled.



B.26  Bit 10, Last Block Transferred (LBT)


The last block transferred bit is set by the RP07 device control logic
during  Data  Transfer Command when the last addressable sector of the
Media is being transferred.  Last Block Transferred bit is reset  when
a new command is issued, a Massbus initialization pulse, or on a power
on reset.  The timing of this bit  is  an  exception  to  the  Massbus
specification (i.e.  assertion of LBT prior to EBL).



B.27  Bit 11,Write Lock (WRL)


The Write Lock bit reflects the write protect condition of  the  drive
logic  as  a result of the write protect switch assertion.  If a write
command is in progress and the write protect switch is  asserted,  the
write  lock  will  be  deferred  until  after  the  write  command  is
completed.
                                                              Page B-9


B.28  Bit 12, Medium On Line (MOL)


The Medium On Line status bit is set when the drive is ready to accept
commands  following  a  power up sequence, the heads are loaded in the
recalibrate position, and the online switch is set online.  Medium  on
line  (MOL)  must  be  set prior to initiation of any command with the
exception of diagnostic mode.  (MOL) will be reset whenever the  drive
can no longer execute commands, such as a permanent error condition.



B.29  Bit 13, Position In Progress (PIP)


Position In Progress bit will be set  whenever  the  servo  positioner
(EMA) is in motion.  At the completion of the movement operation (PIP)
will be reset.  The following table shows the  relationship  of  (PIP)
Drive Ready (DRY) Bit 7 and Attention Active (ATA) Bit 15:

Operation             (PIP)           (ATA)            Note
                                   at completion

Diagnostic              0               Yes
Drive Clear             0               No
Implied Seek            1               No
Mid-transfer Seek       1               No

No Operation            0               No
Offset                  0               Yes             2
Read Data               0               N0              1
Read Header and Data    0               No              1

Read in Preset          0               No
Recalibrate             1               Yes
Return to Centerline    0               Yes             2
Search                  0               Yes             1

Seek (including 0 cyl)  1               Yes
Write Check             0               No              1
Write Data              0               No              1
Write Header and Data   0               No              1

NOTES: (1) PIP is set during the implied seek portion of this command

       (2) PIP will set if the command execution time exceeds the
current Massbus cycle time
                                                             Page B-10


B.30  Bit 14, Error Bit (ERR)


The composite error status bit is the  inclusive  logical  OR  of  all
error  register bits, with one exception, the result of the diagnostic
command.  For the diagnostic command the composite error status bit is
the inclusive logical OR of the bits in the low byte of Error Register
2.  The composite error is reset by one of the  following  conditions,
provided that the error causing it is no longer present.

     1.  Drive Clear Command
     2.  Massbus Reset
     3.  Power On Reset

A composite error asserted upon the initiation of a command other than
a  drive  clear  or  diagnostic  command will inhibit execution of the
command and prevent the GO bit from setting.



B.31  Bit 15, Attention Active (ATA)


The Attention Active Bit in the status register indicates the state of
the  attention flip-flop for the seized switched or locked controller.
The attention signal (ATTN) and status bit (ATA)  are  asserted  under
the following conditions:

     1.  Any error in the error registers will cause ATA to set either
         upon  occurrence  (if the GO bit is reset) or upon completion
         of the command (when the GO bit is set).
     2.  Upon completion  of  a  Seek,  Search,  Recalibrate,  Offset,
         Return to Centerline or Diagnostic command.
     3.  Whenever Medium On Line (MOL) changes state.
     4.  In a dual access RP07 when the access  request  flip-flop  is
         set for one controller and the other controller releases it.
     5.  On a write to any register when composite error is  asserted,
         (except  the  attention summary and maintenance register), or
         writing diagnostic or drive clear functions codes with the GO
         bit in the control register.


The ATA bit will reset under any of the following conditions:

     1.  A Drive Clear Command (if GO is not set).
     2.  A Massbus Initialize.
     3.  Writing the GO bit when there are no error conditions present
         (composite error is reset).
     4.  Writing a 1 into the attention summary  pseudo  register  bit
         position which corresponds to the RP07 logical drive address.

                                                             Page B-11


B.32  Register 02, Error Register 1

This  read  only  register   contains   individual   error   condition
indicators.   All  error bit in Error Register 1 are cleared by either
of the following conditions, provided that the error condition  is  no
longer present.

     1.  Power On Reset
     2.  Drive Clear Command
     3.  Massbus initialize




B.33  Bit 0, Illegal Function (ILF)


The illegal function error bit is set when a function code and GO  bit
are  written  into  the  control  register  00,  and the code does not
correspond  to  an  implemented  command  in  the  drive.   The  error
condition   is   detected  by  the  DCL  microcode  and  will  not  be
instantaneously reported.  The GO bit will remain asserted during  the
processing  interval.   When  the GO bit is reset, composite error and
attention will be asserted along with the ILF bit.  This  is  a  class
"B"  error,  see  table  (  ) under register 00, bits 0-5 for function
codes.



B.34  Bit 1, Illegal Register Bit (ILR)


The illegal register error bit is set when a control bus read or write
is  attempted  from or to a non-existent register (writing into a read
only register does not cause this error).  An ILR error is a class "B"
error.



B.35  Bit 2, Register Modification Refused (RMR)


The register modification refused bit is set when a control bus  write
is  attempted  into  any existing drive register (except the attention
summary register) while an operation is in progress on the drive (i.e.
while the GO bit is set) An RMR error is a class "A" error.



B.36  Bit 3, Parity Bit (PAR)


The parity error bit is set when a parity error  is  detected  on  the
synchronous  data  bus  during  a  write  command operation, or when a
parity error is detected on  the  control  bus  when  writing  into  a
                                                             Page B-12


register.    This   error   bit  applies  only  to  information  being
transmitted from the controller to drive.  A data bus parity error  is
a  class  "A"  error.  A control bus parity error is a class "B" error
which will prevent command execution.



B.37  Bit 4, Format Error Bit (FER)


The format error bit is set if, when reading a header, bit 12  of  the
first  header  word  does  not  match  the  format  bit  in the offset
register.  FER is a class "B" error which causes  termination  of  the
command  in  progress  after  reading  the  entire  header, unless the
command in progress is a "read header and data (73)" or  "write  check
header  and  data  (53)"  command,  in  which cases FER is a class "A"
error.



B.38  Bit 5, Write Clock Failure Bit (WCF)


The write clock failure bit is set if during  any  write  command  the
RP07  failes to receive a response (WCLK) to a request (SCLK) for data
(write clock) from the RH controller within one word time.   One  word
time   is  nominally  1.13  microseconds  for  18  bit  mode  and  1.0
microseconds for 16 bit mode operation.   Write  clock  failure  is  a
class  "B"  error which causes immediate termination of the command in
progress.



B.39  Bit 6, ECC Hard Error Bit (ECH)


The ECC hard error bit is set whenever a data check (DCK) occurs which
cannot  be recovered using ECC.  If the (ECI) error correction inhibit
bit is set the error correction will not be performed  and  the  (ECH)
bit  will  not  set.   ECH is a class "B" error which causes immediate
termination of the command.



B.40  BIT 7, Header Compare Error Bit (HCE)


The Header Compare Error Bit  (HCE)  is  set  if,  while  reading  the
header, one or more of the following occur:

     1.  The cylinder address bits  in  the  first  header  word  bits
         <00:09>  do  not  match  the contents of the cylinder address
         register bits <00:09>.
                                                             Page B-13


     2.  The sector address  bits  in  the  second  header  word  bits
         <00:06> do not match the contents of the sector/track address
         register bits <00:06>.
     3.  The track address bits in the second header word bits <08:13>
         do  not  match  the  contents  of  the  sector/track  address
         register bits <08:13>.
     4.  Bits <10:11> or <13> in the first header word or bits <7>  or
         <14:15> in the second header word are invalid.



                                 NOTE

               HCE is a class "B"  error  which  causes
               termination  of  the command in progress
               after reading the entire header,  unless
               the  command  in  progress  is  a  "Read
               Header and Data" or "Write Check  Header
               and  Data"  command  or  Header  Compare
               Inhibit (HCI) bit <10> Register  11,  is
               asserted  in  which  case HCE is a class
               "A" error.





B.41  Bit 8, Header CRC Error Bit (HCRC)


The Header CRC Error Bit (HCRC) is set whenever the  CRC  register  is
non-zero, after reading the entire header and redundancy bytes.


                                 NOTE

               HCE is a class "B"  error  which  causes
               termination  of  the command in progress
               after reading the entire header,  unless
               the  command  in  progress  is  a  "Read
               Header and Data" or "Write Check  Header
               and  Data"  command  or  Header  Compare
               Inhibit (HCI) bit <10> Register  11,  is
               asserted  in  which  case HCE is a class
               "A" error.


                                                             Page B-14


B.42  Bit 9, Address Overflow Error Bit (AOE)


The Address Overflow Error Bit (AOE) is set whenever the RH controller
attempts to continue a data transfer command beyond the last sector of
the  Head  Disk  Assembly  (HDA),  resulting  in  a  cylinder  address
overflow.


                                 NOTE

               An Address Overflow  Error  (AOE)  is  a
               class  "B"  error which causes immediate
               termination of the command in  progress.
               When  (AOE)  is set, the sector count in
               the Desired Sector Address Register  05,
               is incremented with End of Block (EBL).





B.43  Bit 10, Invalid Address Error Bit (IAE)


The Invalid Address Error Bit (IAE) is set as a result of any  of  the
following  commands,  if  the contents of the Desired Cylinder Address
Register 12, or the  Desired  Sector/Track  Address  Register  05,  is
invalid:

     1.  Format Track Command
     2.  Read Data Command
     3.  Read Header and Data Command
     4.  Read Track Descriptor Command
     5.  Search Command
     6.  Seek Command
     7.  Write Check Data Command
     8.  Write Check Header and Data Command
     9.  Write Data Command
    10.  Write Track Descriptor Command


               Following is a list of all valid address

Desired    18-Bit Mode    18-Bit Mode    16-Bit Mode    16-Bit Mode
Address      Normal       Diagnostic       Normal       Diagnostic

Cylinder
Decimal      <0-629>        <0-631>         <0-629>       <0-631>
Octal        <0-1165>       <0-1167>        <0-1165>      <0-1167>
Hexadecimal  <0-275>        <0-277>         <0-275>       <0-277>

Track
Decimal      <0-31>         <0-31>          <0-31>        <0-31>
Octal        <0-37>         <0-37>          <0-37>        <0-37>
                                                             Page B-15


Hexadecimal  <0-1F>         <0-1F>          <0-1F>        <0-1F>

Sector
Decimal      <0-42>         <0-42>          <0-49>        <0-49>
Octal        <0-52>         <0-52>          <0-61>        <0-61>
Hexadecimal  <0-2A>         <0-2A>          <0-31>        <0-31>

An (IAE) error is a class "B" error which causes command termination.



B.44  Bit 11, Write Lock Error Bit (WLE)


The Write Lock Error Bit (WLE)  is  set  when  a  write  operation  is
attempted  on  a  drive that is in the Write Lock Mode (WLM) asserted.
If during a write command the write protect switch  becomes  asserted,
no  error  condition  will result, the current write operation will be
complete.  Write Lock Error (WLE) is a class "B" error condition which
causes  command  termination  immediately and the write operation will
not take place.



B.45  Bit 12, Drive Timing Error Bit .b1The

(DTE) Drive Timing Error Bit (DTE) is set if during a data transfer  a
timing  failure  is detected by the drive logic.  The (DTE) error is a
class "B" error which causes immediate termination of the  command  in
progress.



B.46  Bit 13, Operation Incomplete Error Bit (OPI)


The Operation Incomplete Error Bit (OPI) is set  under  the  following
conditions:

     1.  Upon arrival on cylinder (implied seek)  the  RP07  does  not
         find the correct sector within the three (3) revolutions from
         the start of the search during  a  Search  or  Data  Transfer
         Command.
     2.  FAilure to detect Index for three (3) revolutions on commands
         which are oriented on the Index marker.  The commands follow:


            1.  Format Track Command
            2.  Read Header and Data Command for sector 0
            3.  Read Track Descriptor Command
            4.  Search Command
            5.  Write Check Header and Data Command for sector 0
            6.  Write Track Descriptor Command

                                                             Page B-16


The  (OPI)  error  is  a  class  "B"  error  which  causes   immediate
termination of the command in progress.



B.47  Bit 14, Unsafe Error Bit (UNS)


The Unsafe Error Bit (UNS) is the inclusive (logical) OR  of  specific
device  errors  which  render  the device unsafe for normal operation.
The device error conditions which set (UNS) follow:

     1.  CPU Unsafe (CPU in RP07)
     2.  DC Unsafe
     3.  Permanent error conditions
     4.  Read/Write Unsafe 1
     5.  Read/Write Unsafe 2
     6.  Read/Write Unsafe 3
     7.  Tachometer Calibration Failure

The  (UNS)  Error  is  a  class  "B"  error  which  causes   immediate
termination of the command in progress.



B.48  Bit 15, Data Check Error Bit (DCK)


The Data Check Error Bit (DCK) is set upon completion of  reading  the
entire  Data  and  ECC  field  of  the sector if the ECC register bits
<11:31> are non-zero.

DCK is a class "A" error, provided the ECC inhibit (ECI) in the Offset
register 11, is set.

DCK is a class "B" error, if the  ECC  inhibit  (ECI)  in  the  Offset
Register  11,  is reset.  The command is terminated upon completion of
the error correction process.



B.49  Register 03 Maintenance Register

The purpose of this read/write register is to provide maintenance  and
diagnostic  capability  for  the  RP07.   This register is utilized to
transfer  information  between  the  CPU  and  the   device   resident
Diagnostic Control Hardware.
                                                             Page B-17


B.50  Bits <0:7>, Diagnostic Parameter Entry Bits


These bits when written by the  Host  CPU,  together  with  a  routine
number and diagnostic mode bit, describe a parameter to be used during
execution of the specific routine.



B.51  Bits <8:14>, Diagnostic Routine Number


These bits when written by the Host CPU direct the RP07 device to  run
a   specific  diagnostic  routine,  when  the  Diagnostic  Command  is
executed.



B.52  Bit 15, Diagnostic Mode Bit


This bit is written by  the  Host  CPU  to  enable  operation  in  the
diagnostic mode.  When asserted this bit will:

     1.  Disable write operations on all cylinders  except  FE  (Field
         Engineer)  cylinders  during  the  execution  of  the  device
         resident diagnostic routines.
     2.  Enable execution of the Diagnostic Command.
     3.  Enable access to the FE cylinders.
     4.  Enable execution of commands with Medium on Line (MOL) reset.




B.53  Register 04, Attention Summary Pseudo Register

This register is called a Pseudo Register, because it  is  implemented
as  one  bit  in  each  drive,  and  all drives respond each time this
register is addressed.  The drive select lines are not required.

      Reading The Attention Summary Register (ATA) Bits <00:07>

Each bit position on this register is assigned  to  the  corresponding
drive  number,  the  Attention Active Bit ATA Bits <00:07> position is
dependent on the drive logical assignment:
Bit       Drive Logical       Bit       Drive Logical
            Address                       Address
00             0              04             4
01             1              05             5
02             2              06             6
03             3              07             7

The controller will receive the (logical) OR of  all  drives  present,
(i.e.   00023  octal means that drives, 0, 1 and 4 are present, if all
eight (8) possible  drives  were  present  the  controller  would  see
                                                             Page B-18


00377).  Bits <08:15> of the register must be zero on a read.

The Attention Summary Register will respond to a read  any  time,  and
does  not  require  that  the  drive select lines be set.  Because all
drives on the bus respond when register 04, is read, the parity bit of
the  control  bus  is  not  valid  on a read, therefore the controller
ignores it.  The ATA Bit <00:07> is used by the drive  to  inform  the
controller of the logical number of the drive requesting service.

                Writing the Attention Summary Register

The Attention Summary flip-flop status on each device can  be  altered
by the controller with the following significance:
   Bit Written       ATA Before       ATA After

       0                 0                0
       0                 1                1
       1                 0                0
       1                 1                0

The above shows the  effect  of  writing  into  an  Attention  Summary
flip-flop.

     1.  Writing a one (1) in it's assigned position causes a set  ATA
         bit to be reset.
     2.  Writing a zero (0) has no effect on the state of the ATA bit.
     3.  This allows the controller to reset the ATA <00:07>  bit  for
         the  drives  that  have  been  serviced without affecting the
         other drives that may also have their ATA bit active.



                                 NOTE

               In  the  event  of  a  persistent  error
               condition,  The  attention  bit  may  be
               reset  by  writing  a  one  (1)  in  the
               appropriate  bit  position  so  that all
               drives on the Massbus are  not  rendered
               inoperable  due  to the attention line's
               constant assertion (the drive error will
               however  remain  set).   If  at  a later
               time, the controller attempts  to  write
               any   register   except   the  attention
               summary  or  maintenance  registers,  or
               writes  the  drive  clear  or diagnostic
               command function codes  in  the  control
               register,  the  attention flip-flop will
               again set.

               If the RP07 sets  the  Attention  Active
               line without the composite error bit set
               (ERR in register  00,  bit  <14>),  upon
               successful  completion  of a positioning
               operation or search command, the  device
                                                             Page B-19


               logic  will  except any command and will
               reset the attention condition.

               On a control bus write to the  attention
               summary  register  while  the  device is
               seized or locked to the other controller
               will  cause  the  RP07  device to ignore
               parity   checking   for    this    write
               operation.





B.54  Register 05, Desired Sector/Track Address Register

The Desired Sector/Track Address Register is implemented as follows:



B.55  Bits <0:6>, Sector Address Bits


Each bit in ascending order has a binary weight.  Bit <6>  having  the
weight  of  64,  is  presently  not  used,  but is checked through the
hardware and must be zero, the purpose is future expansion.

          Bit          Weight          Bit          Weight
           0             1              4             16
           1             2              5             32
           2             4              6             64-Future
           3             8                            Expansion



B.56  Bit 7, Must Be Zero (0), Supplyed Drive

B.57  Bit <8:13>, Track Address Bits


Each bit in ascending order has a binary weight.  Bit <13> having  the
weight  of  32,  is presently not used, but is checked by the hardware
and must be zero, the purpose is future expansion.

          Bit          Weight          Bit          Weight
           8             1              11            8
           9             2              12           16
          10             4              13           32-Future
                                                     Expansion

All bits of the Desired Sector/Track Address Register  are  Read/Write
bits.   This  register  is cleared either by a Read In Preset Command,
Power on Reset or writing zero's (0) into the register.
                                                             Page B-20


                                 NOTE

               The  contents  of  this   register   are
               subject to change by the device hardware
               while the command is in  progress.   The
               register  will  remain  stable  during a
               massbus read of register 05.


                           Spiral Transfers

The desired Sector/Track Address Register increments automatically  at
the  End  Of  Block  (EBL)  time during a Data Transfer Command.  This
feature relieves the software of updating this  register  on  multiple
block  transfers.   The  sequence  is,  Sector Pulse increments Sector
Address, Sector Address overflow (52+1 Octal) in bits  <00:06>  resets
Sector  Address to zero (0) and increments Track Address bits <08:13>,
Track Address overflow (31+1 Octal) increments  the  Desired  Cylinder
Counter,  Register  12.   This  process can go on until we get Desired
Cylinder, Track and Sector overflow which is an Invalid Address  Error
(IAE).



B.58  Register 06, Drive Type Register

The  Drive  Type  Register  is  used  to  provide  the  software  with
information  which  distinguishes  the  RP07 from different classes of
Massbus devices.

This is a Read Only Register and will  contain  (20042  Octal)  for  a
single  port  RP07  and (24042 Octal) for a dual port RP07.  Bit 11 is
field programmable, (with a backplane jumper), and is set  to  a  zero
(0) for a single port RP07 and a one (1) for a dual port RP07.



B.59  Register 07, Look Ahead Register

The Look Ahead Register reflects the exact rotational position of  the
heads  in  relation  to  the  data  track in bits <06:11>.  Rotational
position is monitored by the sector counter in the drive which becomes
reset  to  zero  (0)  each  time  an  Index Pulse is detected, then is
incremented each time a sector pulse  in  detected.   the  Look  Ahead
Register  presents  a  sequential binary regardless of the interleaved
state.

The maximum count is determined by the format bit (FMT) in the  Offset
Register,  and is (53 Octal) in 18 bit format and (61 Octal) in 16 bit
format.
                                                             Page B-21


B.60  Bits <00:05>, Drive Must Supply Zero's (0)

B.61  Bits 06:11>, Look Ahead Count

Each bit in ascending order has a binary weight.

          Bit          Weight          Bit          Weight
           6             1               9            8
           7             2              10           16
           8             4              11           32



B.62  Bits <12:15>, Drive Must Supply Zero's (0)


The Look Ahead Register is only guaranteed  stable  during  a  control
buss read.



B.63  Register 10, Serial Number Register

The Serial Number Register contains the last four (4)  digits  of  the
devices  serial  number  in  binary  coded  decimal (BCD).  The serial
number is programmed with backplane jumpers.   This  is  a  Read  Only
Register.




B.64  Bits <00:03> contain the BCD code for the least

                          significant digit.



B.65  Bits <04:07> contain the BCD code for the next to least

                          significant digit.



B.66  Bits <08:11> contain the BCD code for the next to most

                          significant digit.



B.67  Bits <12:15> contain the BCD code for the most

                          significant digit.

The decimal weight of each digit follows:
                                                             Page B-22


Bit   Weight      Bit   Weight      Bit   Weight      Bit   Weight   
 00     1          04     10         08     100        12     1000
 01     2          05     20         09     200        13     2000
 02     4          06     40         10     400        14     4000
 03     8          07     80         11     800        15     8000

An example for jumper selection is serial number 2476:

                Bit                Weight
                 01                     2
                 02                     4
                 04                    10
                 05                    20
                 06                    40
                 10                   400
                 13          ADD     2000
                                    ________
                                     2476



B.68  Register 11, Offset Register

The Offset Register is a Read/Write register  and  is  implemented  as
follows:



B.69  Bits <00:09>, are Read/Write Bits, but are not used.

B.70  Bit <10>, Header Compare Inhibit (HCI)


Header Compare Inhibit (HCI) is set by the  software  to  inhibit  all
header  errors.   Bad  Sector  Error (BSE), Format Error (FER), Header
Cyclic Redundancy Check Error (HCRC) and Header  Compare  Error  (HCE)
are  inhibited.  It is reset only by a Read in Preset Command, writing
a zero (0) into bit <10> or a Power on Reset.  When the Header Compare
Inhibit  Bit  (HCI)  is set by the software, header errors which occur
during "Read Header  and  Data"  or  "Write  Check  Header  and  Data"
commands will be treated as a class "A" errors.



B.71  Bit 11, Error Correction Inhibit Bit (ECI)


The software sets (ECI) to inhibit the drive hardware from  attempting
to derive the location and error burst after a Data Check Error (DCK).
When the ECI bit is set the drive will treat any DCK error as a  class
"A"  error  and  allow  a  Read  Data  or  Write Check Data Command to
continue beyond the sector where the DCK occurred.

ECI is cleared by Power on Reset, a  Read  in  Preset  Command  or  by
writing the ECI bit to a zero (0).
                                                             Page B-23


B.72  Bit 12, Format Bit (FMT)


This bit when set by the software, enables the RP07 to operate  in  16
bit  mode.   When reset it enables the RP07 to operate in 18 bit mode.
The FMT bit is reset on a Power on Reset, the Read in  Preset  Command
or by writing the FMT bit to a zero (0).



B.73  Bit 13, Drive Must Supply Zero (0)

B.74  Bit 14, Move Track Descriptor Bit (MTD)


This bit when asserted will cause the Track Descriptor  record  to  be
written  an  additional (256) bytes after the index pulse when a Write
Track Descriptor Command is initiated.  The following conditions  will
reset the Move Track Descriptor Bit (MTD).

     1.  Power on Reset
     2.  The completion of and command, (i.e.  GO is Reset)
     3.  Writing a zero to MTD bit
     4.  A Read in Preset Command




B.75  Bit 15, Command Modifier Bit (CMOD)


This bit when written by the  software,  enables  operation  on  Track
Descriptor  or Header Descriptors on the RP07 device.  This bit allows
reading of the six defect displacement words in the track  descriptor,
with  the  Read  Track Descriptor Command, will allow the Format Track
Command to write the entire track, it also modifies other commands for
reading  and  writing, it's use is in formating.  The CMOD bit will be
reset by any of the following conditions:

     1.  Power on Reset
     2.  The completion of any command, (i.e.  GO Reset)
     3.  Writing a zero to CMOD bit
     4.  A Read in Preset Command




B.76  Register 12, Desired Cylinder Address Register

The Desired Cylinder Address Register is loaded by the  software  with
the  address  of  the  cylinder to which the positioner will move as a
result of a Seek, Search or Data handling command.  The 10 bit address
is  contained  in  bits  <00:09> and zero (0) is the least significant
bit.
                                                             Page B-24


There binary weight follows:

          Bit      Weight          Bit      Weight
           00        1              05        32
           01        2              06        64
           02        4              07       128
           03        8              08       256
           04       16              09       512

All bits of this Read/Write register are implemented in the RP07.

This register is reset by any of the following:

     1.  A read in Preset Command
     2.  Power on Reset
     3.  Writing Zeros (0) into this register

                           Spiral Transfers

Spiral transfer capability is provided by  automatically  incrementing
the Desired Cylinder Address if the following conditions exist:

The RP07 is transfering data from the last sector and last track of  a
given  cylinder  and  the RUN line is active at EBL time, and no class
"B" error condition or exception exists at EBL time.

Meeting these conditions will cause the desired cylinder address to be
incremented and a Seek to that address will be automatically initiated
by the RP07 provided that the address is valid.



B.77  Bits <10:15>


These bits <10:15> are not used in the RP07.



B.78  Register 13, Current Cylinder Address Register

The Current Cylinder Address Register is a Read  Only  Register  which
reflects the address of the cylinder below the read/write heads.

The Current Cylinder Address Register is updated upon  the  completion
of a positioning operation.



B.79  Bits <00:09> Current Cylinder Address


The Bits <00:09>, and their weight follow:

          Bit      Weight          Bit      Weight
                                                             Page B-25


          00         1              05        32
          01         2              06        64
          02         4              07       128
          03         8              08       256
          04        16              09       512

The contents of this register are subject  to  change  by  the  device
hardware  while  a  command is in progress, (i.e.  the GO bit is set).
The following conditions will reset this register:

     1.  Recalibrate Command
     2.  Power on Reset
     3.  Initial head load
     4.  A Massbus Initialize Command
     5.  A Drive Clear Command




B.80  Bits <10:15>


Bit <10:15> of this register are always zero (0), as supplied  by  the
drive.



B.81  Register 14, Error Register 2

This is a Read Only Register and contains indicators  associated  with
the RP07 device and control logic within the device.  Error Register 2
is cleared by the following conditions:

     1.  Power on Reset
     2.  A Drive Clear Command
     3.  A Massbus Initialize


The implementation of the bits follow:



B.82  Bits <00:07>, Error Codes


These eight (8) bits contain error status information  in  an  encoded
format for errers that are processed by the device microprocessor.

For example, when  a  diagnostic  command  is  executed  by  the  host
processor  and an error results, then this error code is the result of
a particular diagnostic routine.

The same error code will be displayed in the LED display on the  drive
CPU A1A07 board and also on the FE panel readout.
                                                             Page B-26


Error codes may also be set during normal functional operation of  the
RP07.   When these errors occur during normal operation, the composite
error bit in the Drive Status Register 1, bit <14>, will  also  become
asserted.



B.83  bit 8, Write Ready Unsafe (WRU)


The Write Ready Unsafe Bit (WRU) sets if write current is  active  and
the  drive  logic  determines that the positioner has moved beyond the
track center-line limits.  The detection of a Write Ready unsafe  will
cause  the  RP07 drive to turn-off write current immediately and abort
the write command.  Write Ready Unsafe in a class "B" error.



B.84  Bit 9, Write Overrun Bit (WOR)


The Write Overrun error bit will set if write current is active during
both  the leading and trailing edges of an index pulse.  The detection
of this condition will turn-off write current  immediately  and  abort
the write command.  Write Overrun Error in a class "B" error.



B.85  Bit 10, Read/Write Unsafe Error bit (RWU1)


The Read/Write Unsafe 1 error bit becomes  set  when  during  a  write
operation  (the write gate is on) no write transitions are detected by
the device read/write safty circuits.  The detection of this condition
will  immediately  turn-off write current and abort the write command.
The detection of this error will cause the  unsafe  indicator  on  the
control panel to illuminate.  Read/Write Unsafe 1 Error is a class "B"
error.



B.86  Bit 11, Read/Write Unsafe 2 Error bit (RWU2)


The Read/Write Unsafe 2 error bit becomes set  if  during  a  read  or
write operation the RP07 device logic detects a selection of more than
one (1) read/write head.  A Read/Write Unsafe 2 error will immediately
deselect  all heads, disable write current and abort the data transfer
command.  The detection of this error will cause the unsafe  indicator
on  the  control  panel to illuminate.  Read/Write Unsafe 2 Error is a
class "B" error.
                                                             Page B-27


B.87  Bit 12, Read/Write Unsafe 3 Error Bit (RWU3)


The Read/Write  Unsafe  3  error  bit  becomes  set  when  the  device
read/write  safty circuits detect write current when a write operation
is not in progress (the write gate is off).   The  detection  of  this
condition  will  abort the command in progress.  The detection of this
error will  cause  the  unsafe  indicator  on  the  control  panel  to
illuminate.  Read/Write Unsafe 3 Error is a class "B" error.



B.88  Bit 13, CPU Unsafe (CPU)


This bit is asserted when the RP07  8080  microprocessor  microprogram
fails to retrigger the CPU Unsafe Timer prior to its timeout.

Upon the detection  of  a  CPU  Unsafe  Error  the  RP07  device  will
automatically  execute  a microdiagnostic routine to determine weather
or not the CPU Unsafe Error is permanent.  During the execution of the
diagnostic  routine  the device will appear to the Host Processor as a
dual access device which is seized by the opposite  controller,  (i.e.
on  a register read all zero's (0) will be transmitted with the proper
parity).  The execution of this diagnostic routine will  require  less
than  four  (4)  seconds to complete.  The CPU Unsafe Error is a class
"B" error and will result in a permanent error condition  with  Medium
on Line (MOL) negated.



B.89  Bit 14, Not Used, Drive supplies Zero (0)

B.90  Bit 15, Program Error Bit (PGM)


The Program Error bit (PGE) becomes set if the following commands  are
attempted  without  the  Command Modifier Bit (CMOD) set, register 11,
bit <15>.

     1.  Write Track Descriptor Command
     2.  Read Track Descriptor Command
     3.  Format Track Command
     4.  If on a  Write  Track  Descriptor  Command,  the  Move  Track
         Descriptor  Flag provided by the software in Track Descriptor
         Word 1, does not agree with  the  value  of  the  Move  Track
         Descriptor (MTD) bit in the Offset Register 11, bit <13>, MTD
         is zero (0) for no move and one (1) for a move of (256) bytes
         after the index pulse.

         An incomplete Format Track, Read Track  Descriptor  or  Write
         Track  Descriptor  Command is attempted (i.e.  the command is
         not terminated at the proper word count).

                                                             Page B-28


A Program Error Error (PGE) is a class "B" error condition which  will
prevent execution of the command.



B.91  Register 15, Error Register 3

This Register contains  error  indicators  associated  with  the  RP07
device  and  control  logic  within the device.  Error Register 3 is a
Read Only register  and  can  be  cleared  in  the  following  manner,
provided that the error is not a permanent error:

     1.  Power on Reset
     2.  A Drive Clear Command
     3.  A Massbus Initialize Command


The implementation of the error bits are as follows:



B.92  Bit 0, Run Timeout Error Bit (RTO)


The Run Timeout Error (RTO) bit  becomes  set  if  after  thirty  (30)
milliseconds  from  the assertion of GO the device fails to detect the
Run Line Assertion.



B.93  Bit 1, Sync Clock Failure Bit (SCF)


The Sync Clock Failure (SCF) bit becomes set if the  RP07  sync  clock
counter  has  not  gone  to  zero  (0) within the time allowed for the
function.



B.94  Bit 2, Sync Byte Error Bit (SBE)


The Sync Byte Error (SBE) bit becomes set if the sync byte  associated
with the Data Field or Defect Skip is not found.



B.95  Bit 3, Data Parity Error Bit (DPE)


The Data Parity Error (DPE) bit is set during a write operation if the
Synchronous  Data  Bus  Parity  is  "even" of a Buffer Parity Error is
detected.  A Data Parity Error will also set Parity Bit <03> in  Error
Register  1, which is register 02.  Data Parity Error (DPE) is a class
"A" error.
                                                             Page B-29


B.96  Bit 4, Serdes Data Failure Error Bit (SDF)


This bit becomes asserted as a result of timming failures  related  to
the  Data  Buffer  FIFO (first in first out stack), in the drive.  The
following conditions set the Serdes Data Failure Error (SDF) bit:

     1.  An attempt to shift data into the buffer when it is not ready
         to accept data in read or write operations.
     2.  When an attempt to strobe buffer  output  data  occurs,  when
         output data is not ready.




B.97  Bit 5, DC Unsafe Error Bit (DCU)


The Direct Current Unsafe Error (DCU)  bit  will  set  when  the  RP07
device  detects  a low DC voltage.  Overvoltage protection is provided
by a crowbar circuit.   The  DC  Unsafe  Error  (DCU)  bit  cannot  be
guaranteed  to  set under this overvoltage condition.  DC Unsafe Error
is a class "B" error.



B.98  Bit 6, Index Unsafe Error Bit (IXU)


The Index Unsafe Error (IXU) bit will become set if  during  a  Format
Track  Command  or  a Write Track Descriptor Command an index error is
detected.  An Index Unsafe Error is a  class  "B"  error.   The  Index
Unsafe Error conditions follow:

     1.  Failure to detect an index  pulse  at  the  appropriate  time
         (during the Index Window).
     2.  The detection of an Index Pulse outside the Index Window.


An Index Unsafe Error (IXU) condition can not be reset until  a  valid
Index  Pulse  has  been  detected.   The  Index Unsafe Error (IXU) may
therefore appear persistent for two (2) complete  revolutions  of  the
media.



B.99  Bit 7, Device Check Error Bit (DVC)


The Device Check Error (DVC) condition is the inclusive  (logical)  OR
of  the  error  bits  <08:15>  in Error Register 2 and bits <00:15> in
Error Register 3.  The Device Check Error  (DVC)  does  not  cause  an
attention condition.  The attention bit will be set in accordance with
the specific error bit which cause Device  Check  Error  (DVC)  to  be
asserted.   There  may  be  more  than  one (1) error bit that qualify
                                                             Page B-30


setting attention.



B.100  Bit 8, 8080 Processor Handshake Failure Error Bit (PHF)


The Processor Handshake Failure Error (PHF) becomes set  if  the  8080
microprocessor fails to respond to a command.



B.101  Bit 9, Loss of Cylinder Error Bit (LCE)


The Loss of Cylinder Error (LCE) bit becomes set if  movement  of  the
positioner  is  detected  outside  of  the  cylinder  boundry  when  a
positioning operation is not  in  progress.   The  detection  of  this
condition  will  cause  the  RP07  device  to  automatically  issue  a
recalibrate operation.  The Error and Attention bits will  not  become
asserted until the completion of the recalibration operation, at which
point the heads are positioned at  cylinder  zero  (0).   Position  In
Progress (PIP) status will not be asserted during the positioning.

If a command function code and GO  bit  is  loaded  into  the  Control
Register  during the processing of a Loss Of Cylinder Error (LCE), the
command is deferred until completion of the recalibrate operation when
the  command  shall  be  terminated,  Attention  raised and, if a Data
command, assert Exception and  End  Of  Block  (EBL).   The  automatic
recovery  process  as  a  result  of  a  Loss  Of Cylinder Error (LCE)
condition will take less than four (4) seconds.



B.102  Bit 10, Loss Of Bit Clock Error Bit (LBC)


The Loss Of Bit Clock Error (LBC) sets under the following conditions.

     1.  A microcode timeout condition  occurred  in  which  the  word
         counter  failed  to  attain  the  value loaded in the compare
         register (BC) within the timeout interval.  This is  detected
         by a failure of the end branch condition to assert by the end
         of the timeout interval.
     2.  The end branch condition failed to negate after  the  compare
         register  (BC)  was  loaded  with a new value indicating that
         either the word counter value is greater than or equil to the
         new  (BC) register value at the time the end branch condition
         is tested or the end branch signal failed to reset  with  the
         writing of the (BC) register.

                                                             Page B-31


B.103  Bit 11, Control Logic Failure Error Bit (CLF)


The Control Logic  Failure  Error  (CLF)  bit  is  set  by  the  drive
microprocessor 2901 resulting from one of the following conditions:

     1.  An attempt to write the 8080 communications register when the
         register is full.
     2.  An interrupt failure occurs in the drive microprocessor 2901.
     3.  An invalid function code interrupt occurs.




B.104  Bit 12, Write Current Sense Failure Error Bit (WSF)


The device failed to sense a write current after the  write  gate  had
been enabled.



B.105  Bit 13, Defect Skip Error Bit (DSE)


The Defect Skip Error (DSE) bit is set  by  the  drive  microprocessor
2901 when an invalid value results during the defect skip calculation.
The Defect Skip Error (DSE) is a class "B" error.



B.106  Bit 14, Seek Incomplete Error Bit (SKI)


The Seek Incomplete Error (SKI) bit is set  when  the  internal  drive
logic detects any of the following conditions:

      Error Code     Description

         0A          Seek Too Long
         0B          Guardband Detected During Seek
         0C          Seek Overshoot
         44          Guardband Detect Failure During Recalibrate
         45          Reference Gap or Guardband Pattern One (1)
                     Detection Failure (Recalibrate)
         4A          Attempt to Land in Guardband During Recalibrate

     1.  Upon detection of a Seek  Incomplete  Error  (SKI)  the  RP07
         device  will automatically initiate a recalibration operation
         and position the heads at cylinder zero  (0).   Reporting  of
         the  error  condition  and  setting  Attention  Interrupt  is
         defered until the completion of the above sequence.
     2.  Upon completion of the sequence the device will set the (SKI)
         error bit, raise Attention and display one of the error codes
         which describes the condition causing the error.   The  error
                                                             Page B-32


         code  will  be  in Error Register 2 in bits <00:07>, which is
         register 14.  The automatic recovery process as a result of a
         Seek Incomplete (SKI) condition, will take less than four (4)
         seconds.




B.107  Bit 15, Bad Sector Error Bit (BSE)


The Bad Sector Error (BSE) bit condition becomes set at the completion
of the CRC character check if either bit <14> or bit <15> of the first
header word is found to be zero (0).  If the command is  not  a  "Read
Header  and  Data"  or  "Write  Check Header and Data Command" command
termination will occur at the completion of the CRC  check.   A  "Read
Header  and  Data"  command  will terminate at the normal End Of Block
(EBL) time for the current sector.



B.108  Register 16, ECC Position Register

Following the completion of a Data Transfer command, which results  in
a  Data  Check Error (DCK) without ECC Hard Error (ECH), this register
will contain the binary address minus one, of the  first  bit  of  the
error  burst  within  the  Data  and  ECC  field.  If Error Correction
Inhibit (ECI) or ECH  is  set,  the  contents  of  this  register  are
irrelevant.   Valid  counts  shall  include  the entire ECC redundancy
field.



B.109  Register 17, ECC Pattern Register

Following the completion of a Data Transfer command, which results  in
a  Data  Check Error (DCK) without ECC Hard Error (ECH), this register
will contain the eleven (11) bit error  burst  which,  when  exclusive
(logical)  OR'd  with the data in main memory (located by the position
count, register 16) will correct the error burst.  If Error Correction
Inhibit  (ECI)  or  ECC  Hard Error (ECH) is set, the contents of this
register are irrelevant.  Bit (10) is  the  first  bit  of  the  error
burst.  The bit positions follow:

       Register        Pattern          Register        Pattern
         Bit             Bit              Bit             Bit
       Position        Position         Position        Position

          00             01                06              07
          01             02                07              08
          02             03                08              09
          03             04                09              10
          04             05                10              11
          05             06
                                                             Page B-33


B.110  Bits <11:15>, The Drive Will Supply Zero's (0)


The ECC Pattern Register is reset by any of the following conditions:

     1.  A Drive Clear Command.
     2.  A Massbus Initialize.
     3.  Power on Reset.
     4.  Initiating a command code and the GO bit.
     5.  Command continuance (the result of RUN assertion at the  fall
         of End Of Block (EBL).

The following is a Cross Index Name/Bit/Register for Massbus Registers
as that are used with the RP07.  This is also a subject index.
                                                             Page B-34


B.111  Listed Alphabetically


          Name         Register No.       Bit

          AOE          Register 02        Bit 09   PARAGRAPH =
          ATA          Register 01        Bit 15   8.(REG NO).(BIT)
          ATA0         Register 04        Bit 00
          ATA1         Register 04        Bit 01
          ATA2         Register 04        Bit 02
          ATA3         Register 04        Bit 03
          ATA4         Register 04        Bit 04
          ATA5         Register 04        Bit 05
          ATA6         Register 04        Bit 06
          ATA7         Register 04        Bit 07
          
          BSE          Register 15        Bit 15
          
          CLF          Register 15        Bit 11
          CMD          Register 11        Bit 15
          CPU          Register 14        Bit 13
          CURR SECT    Register 07        Bit 06:12
          CURR CYLN    Register 13        Bit 00:10
          
          DCK          Register 02        Bit 15
          DCU          Register 15        Bit 05
          DESIR TRK    Register 05        Bit 08:15
          DESIR SECT   Register 05        Bit 00:07
          DESIR CYLN   Register 12        Bit 00:15
          DIA ROU NO   Register 03        Bit 08:14
          DIA PAR      Register 03        Bit 00:07
          DMD          Register 03        Bit 15

          DPR          Register 01        Bit 08    PARAGRAPH =
          DPE          Register 15        Bit 03    8.(REG NO).(BIT)
          DRY          Register 01        Bit 07
          DSE          Register 15        Bit 13
          DTE          Register 02        Bit 12
          DVA          Register 00        Bit 11
          DVC          Register 15        Bit 07
          
          ECH          Register 02        Bit 06
          ECI          Register 11        Bit 11
          ECC POSI     Register 16        Bit 00:15
          ECC PAT      Register 17        Bit 00:10
          ERR          Register 01        Bit 14
          ERROR CODE   Register 14        Bit 00:07
          EWN          Register 01        Bit 01
          
          FER          Register 02        Bit 04
          FMT          Register 11        Bit 12
          FUNCT CODE   Register 00        Bit 01:05
          
          GO           Register 00        Bit 00
          
                                                             Page B-35


          HCRC         Register 02        Bit 08
          HCE          Register 02        Bit 07
          HCI          Register 11        Bit 10
          
          IAE          Register 02        Bit 10
          ILV          Register 01        Bit 02
          ILR          Register 02        Bit 01
          ILF          Register 02        Bit 00
          IXU          Register 15        Bit 06
          
          LBT          Register 01        Bit 10
          LBC          Register 15        Bit 10
          LCE          Register 15        Bit 09
          
          MOL          Register 01        Bit 12
          MTD          Register 11        Bit 14
          
          OM           Register 01        Bit 00
          OPI          Register 02        Bit 13
          
          PAR          Register 02        Bit 03
          PGM          Register 01        Bit 09
          PGE          Register 14        Bit 15
          PHF          Register 15        Bit 08
          PIP          Register 01        Bit 13
          
          RMR          Register 02        Bit 02
          RTO          Register 15        Bit 00
          RWU1         Register 14        Bit 10
          RWU2         Register 14        Bit 11
          RWU3         Register 14        Bit 12
          
          SBE          Register 15        Bit 02
          SCF          Register 15        Bit 01      PARAGRAPH =
          SDF          Register 15        Bit 04      8.(REG NO).(BIT)
          SERIAL NO    Register 10        Bit 00:15
          SKI          Register 15        Bit 14
          
          UNS          Register 02        Bit 14
          
          VV           Register 01        Bit 06
          
          WCF          Register 02        Bit 05
          WLE          Register 02        Bit 11
          WOR          Register 14        Bit 09
          WRL          Register 01        Bit 11
          WRU          Register 14        Bit 08
          WSF          Register 15        Bit 12
          
          
          
                                                             Page B-36


B.112  Listed By Bit Position



          Bit Position    Name         Register No.
          
          Bit 00          ATA0         Register 04        
          Bit 00          GO           Register 00        
          Bit 00          ILF          Register 02        
          Bit 00          OM           Register 01        
          Bit 00          RTO          Register 15        
          Bit 00:07       DESIR SECT   Register 05        
          Bit 00:07       DIA PAR      Register 03        
          Bit 00:07       ERROR CODE   Register 14        
          Bit 00:10       CURR CYLN    Register 13        
          Bit 00:10       ECC PAT      Register 17        
          Bit 00:15       DESIR CYLN   Register 12        
          Bit 00:15       ECC POSI     Register 16        
          Bit 00:15       SERIAL NO    Register 10        
          
          Bit 01          ATA1         Register 04        
          Bit 01          EWN          Register 01        
          Bit 01          ILR          Register 02        
          Bit 01          SCF          Register 15        
          Bit 01:05       FUNCT CODE   Register 00        
          
          Bit 02          ATA2         Register 04        
          Bit 02          ILV          Register 01        
          Bit 02          RMR          Register 02        
          Bit 02          SBE          Register 15        
          
          Bit 03          ATA3         Register 04        
          Bit 03          DPE          Register 15        
          Bit 03          PAR          Register 02        
          
          Bit 04          ATA4         Register 04        
          Bit 04          FER          Register 02        
          Bit 04          SDF          Register 15        
          
          Bit 05          ATA5         Register 04    PARAGRAPH =
          Bit 05          DCU          Register 15    8.(REG NO).(BIT)
          Bit 05          WCF          Register 02        
          
          Bit 06          ATA6         Register 04        
          Bit 06          ECH          Register 02        
          Bit 06          IXU          Register 15        
          Bit 06          VV           Register 01        
          Bit 06:12       CURR SECT    Register 07        
          
          Bit 07          ATA7         Register 04        
          Bit 07          DRY          Register 01        
          Bit 07          DVC          Register 15        
          Bit 07          HCE          Register 02        
          
          Bit 08          DPR          Register 01        
                                                             Page B-37


          Bit 08          HCRC         Register 02        
          Bit 08          PHF          Register 15        
          Bit 08          WRU          Register 14        
          Bit 08:14       DIA ROU NO   Register 03        
          Bit 08:15       DESIR TRK    Register 05        
          
          Bit 09          AOE          Register 02        
          Bit 09          LCE          Register 15        
          Bit 09          PGM          Register 01        
          Bit 09          WOR          Register 14        
          
          Bit 10          HCI          Register 11        
          Bit 10          IAE          Register 02        
          Bit 10          LBT          Register 01        
          Bit 10          LBC          Register 15        
          Bit 10          RWU1         Register 14        
          
          Bit 11          CLF          Register 15        
          Bit 11          DVA          Register 00        
          Bit 11          ECI          Register 11        
          Bit 11          RWU2         Register 14        
          Bit 11          WLE          Register 02        
          Bit 11          WRL          Register 01        
          
          Bit 12          DTE          Register 02        
          Bit 12          FMT          Register 11        
          Bit 12          MOL          Register 01        
          Bit 12          RWU3         Register 14        
          Bit 12          WSF          Register 15        
          
          Bit 13          CPU          Register 14        
          Bit 13          DSE          Register 15        
          Bit 13          OPI          Register 02        
          Bit 13          PIP          Register 01        
          
          Bit 14          ERR          Register 01        
          Bit 14          MTD          Register 11        
          Bit 14          SKI          Register 15        

          Bit 14          UNS          Register 02     PARAGRAPH =
                                                       8.(REG NO).(BIT)
          Bit 15          ATA          Register 01        
          Bit 15          BSE          Register 15        
          Bit 15          CMD          Register 11        
          Bit 15          DCK          Register 02        
          Bit 15          DMD          Register 03        
          Bit 15          PGE          Register 14        
          
          
                                                             Page B-38


B.113  Listed By Register and Name Alphabetically


          Reg. No.       Bit Position    Name
          
          Reg. 00        Bit 00          GO
          Reg. 00        Bit 01:05       FUNCT CODE
          Reg. 00        Bit 11          DVA
          
          Reg. 01        Bit 00          OM
          Reg. 01        Bit 01          EWN
          Reg. 01        Bit 02          ILV
          Reg. 01        Bit 06          VV
          Reg. 01        Bit 07          DRY
          Reg. 01        Bit 08          DPR
          Reg. 01        Bit 09          PGM
          Reg. 01        Bit 10          LBT
          Reg. 01        Bit 11          WRL
          Reg. 01        Bit 12          MOL
          Reg. 01        Bit 13          PIP
          Reg. 01        Bit 14          ERR
          Reg. 01        Bit 15          ATA
          
          Reg. 02        Bit 00          ILF
          Reg. 02        Bit 01          ILR
          Reg. 02        Bit 02          RMR
          Reg. 02        Bit 03          PAR
          Reg. 02        Bit 04          FER
          Reg. 02        Bit 05          WCF
          Reg. 02        Bit 06          ECH
          Reg. 02        Bit 07          HCE
          Reg. 02        Bit 08          HCRC
          Reg. 02        Bit 09          AOE
          Reg. 02        Bit 10          IAE
          Reg. 02        Bit 11          WLE
          Reg. 02        Bit 12          DTE
          Reg. 02        Bit 13          OPI
          Reg. 02        Bit 14          UNS
          Reg. 02        Bit 15          DCK
          
          Reg. 03        Bit 00:07       DIA PAR
          Reg. 03        Bit 08:14       DIA ROU NO
          Reg. 03        Bit 15          DMD
          
          Reg. 04        Bit 00          ATA0      PARAGRAPH =
          Reg. 04        Bit 01          ATA1      8.(REG NO).(BIT)
          Reg. 04        Bit 02          ATA2
          Reg. 04        Bit 03          ATA3
          Reg. 04        Bit 04          ATA4
          Reg. 04        Bit 05          ATA5
          Reg. 04        Bit 06          ATA6
          Reg. 04        Bit 07          ATA7
          
          Reg. 05        Bit 00:07       DESIR SECT
          Reg. 05        Bit 08:15       DESIR TRK
                                                             Page B-39


          
          Reg. 07        Bit 06:12       CURR SECT
          
          Reg. 10        Bit 00:15       SERIAL NO
          
          Reg. 11        Bit 10          HCI
          Reg. 11        Bit 11          ECI
          Reg. 11        Bit 12          FMT
          Reg. 11        Bit 14          MTD
          Reg. 11        Bit 15          CMD
          
          Reg. 12        Bit 00:15       DESIR CYLN
          
          Reg. 13        Bit 00:10       CURR CYLN
          
          Reg. 14        Bit 00:07       ERROR CODE
          Reg. 14        Bit 08          WRU
          Reg. 14        Bit 09          WOR
          Reg. 14        Bit 10          RWU1
          Reg. 14        Bit 11          RWU2
          Reg. 14        Bit 12          RWU3
          Reg. 14        Bit 13          CPU
          Reg. 14        Bit 15          PGE
          
          Reg. 15        Bit 00          RTO
          Reg. 15        Bit 01          SCF
          Reg. 15        Bit 02          SBE
          Reg. 15        Bit 03          DPE
          Reg. 15        Bit 04          SDF
          Reg. 15        Bit 05          DCU
          Reg. 15        Bit 06          IXU
          Reg. 15        Bit 07          DVC
          Reg. 15        Bit 08          PHF
          Reg. 15        Bit 09          LCE
          Reg. 15        Bit 10          LBC
          Reg. 15        Bit 11          CLF
          Reg. 15        Bit 12          WSF
          Reg. 15        Bit 13          DSE
          Reg. 15        Bit 14          SKI
          Reg. 15        Bit 15          BSE
          
          Reg. 16        Bit 00:15       ECC POSI
          
          Reg. 17        Bit 00:10       ECC PAT













                              APPENDIX C

                                                                  Page
                                                                  ----
                                                              Page C-1


C.1  Error Code for the RP07



Error Code designations as of 15 February 1982

Error code                                                      
in hexadecimal                  Description                     
================================================================
Err code # 00:    Not used
                
Err code # 01:    State code, not error code:
                        initialization routine

Err code # 02:    State code, not error code:
                        massbus interface

Err code # 03:    State code, not error code:
                        air system purge loop

Err code # 04:    State code, not error code:
                        power sequence wait loop

Err code # 05:    State code, not error code:
                        power sequence start loop

Err code # 06:    State code, not error code:
                        on track monitor

Err code # 07:    State code, not error code:
                        recalibrate state

Err code # 08:    State code, not error code:
                        seek state

Err code # 09:    State code, not error code:
                        hold loop

Err code # 0A:    State code, not error code:
                        spindle stop sequence

Err code # 0B:    State code, not error code:
                        diagnostic command mode

Err code # 0C:    State code, not error code:
                        not used

Err code # 0D:    State code, not error code:
                        not used

Err code # 0E:    State code, not error code:
                        not used

Err code # 0F:    State code, not error code:
                        not used
                                                              Page C-2



Err code # 10:     0 - 2k   prom failed - drive cpu card prom-0
                
Err code # 11:     2 - 4k   prom failed - drive cpu card prom-1

Err code # 12:     4 - 6k   prom failed - drive cpu card prom-2
                
Err code # 13:     Ram  failed - drive cpu card

Err code # 14:     6 - 8k   prom failed - drive cpu card prom-3
                
Err code # 15:     8 - 10k  prom failed - drive cpu card prom-4
                
Err code # 16:    10 - 12k  prom failed - drive cpu card prom-5
                
Err code # 17:    12 - 14k  prom failed - drive cpu card prom-6
                
Err code # 18:    Timer-1 diagnostic failed - drive cpu card
                
Err code # 19:    Timer-2 diagnostic failed - drive cpu card
                
Err code # 1A:    Timer-3 diagnostic failed - drive cpu card
                
Err code # 1B:    Offset adjustment failed
                
Err code # 1C:    Carriage failes to decelerate during retract
                
Err code # 1D:    No guard band detected during retract
                
Err code # 1E:    Tachometer does not respond correctly during retract
                
Err code # 1F:    Data bus failed
                
Err code # 20:    Register test failed - drive cpu card - "swreg"
                        register (addr 06) or input mux not working

Err code # 21:    Register test failed - drive cpu card - output
                        mux's, sel line or shorted traces

Err code # 22:    Register test failed - drive cpu card - "msstat"
                        input register (addr 04) or input mux not working

Err code # 23:    Register test failed - drive cpu card - input
                        reg's "msstat" and "swstat", or input mux

Err code # 24:    Register test failed - drive cpu card - "erstat"
                        register (addr 05) or output mux

Err code # 25:    Register test failed - drive cpu card - "erstat"
                        register (addr 05) not working

Err code # 26:    Register test failed - drive cpu card - "mask"
                        register (addr 01) or output mux addressing

Err code # 27:    Register test failed - drive cpu card - "msstat"
                                                              Page C-3


                        output register (addr 04) or output mux addressing

Err code # 28:    D/A - A/D test failure (pos offset) - analog c
                
Err code # 29:    D/A - A/D test failure (curve d/a reference) - analog c

Err code # 2A:    (Test oscillator even defeat) diff. pos. > -4.5 volt -
                        analog b

Err code # 2B:    (Test oscillator even defeat) *position < +4.5 volt -
                        analog b

Err code # 2C:    (Test oscillator on track) *diff. pos. > +0.5 volt -
                        analog b

Err code # 2D:    (Test oscillator on track) *diff. pos. < -0.5 volt -
                        analog b

Err code # 2E:    (Test oscillator on track) *pos. > +0.5 volt - analog b
                
Err code # 2F:    (Test oscillator on track) *pos. < -0.5 volt - analog b
                
Err code # 30:    Crom 0 - checksum failure - 0000-03ff
                
Err code # 31:    Crom 1 - checksum failure - 0400-07ff
                
Err code # 32:    Crom 2 - checksum failure - 0800-0bff
                
Err code # 33:    Crom 3 - checksum failure - 0c00-0fff
                
Err code # 34:    Reserved for the crom check expansion
                
Err code # 35:    Reserved for the crom check expansion
                
Err code # 36:    Reserved for the crom check expansion
                
Err code # 37:    Reserved for the crom check expansion
                
Err code # 38:    Reserved for the crom check expansion
                
Err code # 39:    Reserved for the crom check expansion
                
Err code # 3A:    Reserved for the crom check expansion
                
Err code # 3B:    Reserved for the crom check expansion
                
Err code # 3C:    CPU unsafe circuit failed (no interrupt) - drive
                        cpu card

Err code # 3D:    CPU unsafe circuit failed (interrupt too soon) -
                        drive cpu card

Err code # 3E:    Interrupt test failed - drive cpu card
                
Err code # 3F:    Drive cpu or dc unsafe
                                                              Page C-4


                
Err code # 40:    Early warning (not displayed on the panel)
                
Err code # 41:    No air flow on pack
                
Err code # 42:    Pack speed unsafe or "plo" (phase locked oscillator)
                        unsafe-1 or index not working

Err code # 43:    "PLO" (phase locked oscillator) unsafe-1
                
Err code # 44:    Guard band detect failure
                
Err code # 45:    Reference gap or guard band pattern-1 detect failure
                
Err code # 46:    Seek incomplete during recal
                
Err code # 47:    Out of coarse cylinder while on track
                
Err code # 48:    (Test oscillator on track) servo error offset
                        > +0.5 volt

Err code # 49:    (Test oscillator on track) servo error offset
                        < -0.5 volt

Err code # 4A:    Attempt to land in guard band during recal
                
Err code # 4B:    Pulser/driver prom failed -pf,-pr,-df,-dr s/b high
                
Err code # 4C:    Pulser driver prom failed -pf,-df s/b low,-pr,-dr high
                
Err code # 4D:    Pulser driver prom failed -pf,-df s/b high,-pr,-dr low
                
Err code # 4E:    (Max reverse drive) ema current sample > -4.5 volt
                
Err code # 4F:    (Max forward drive) ema current sample < +4.5 volt
                
Err code # 50:    Seek too long
                
Err code # 51:    Guard band detected during seek
                
Err code # 52:    Seek overshoot
                
Err code # 53:    "PLO" (phase locked oscillator) unsafe-2
                
Err code # 54:    EMA current offset calibration failed (too negative)
                
Err code # 55:    Calibration of tachometer has failed
                
Err code # 56:    EMA current offset calibration failed (too positive)
                
Err code # 57:    (Diff=x'0000)*curve d/a > +300mv - analog b
                
Err code # 58:    (Diff=x'0000)*curve gen t.p. < -300mv - analog b
                
Err code # 59:    (Diff=x'000a)*curve gen t.p. < -2 volts - analog b
                                                              Page C-5


                
Err code # 5A:    (Diff=x'000a)*curve gen t.p. > -1 volt - analog b
                
Err code # 5B:    (Diff=x'000a)*curve d/a > +900mv - analog b
                
Err code # 5C:    (Diff=x'000a)*curve d/a < +500mv - analog b
                
Err code # 5D:    (Diff=x'007f)*curve d/a > +8 volts - analog b

Err code # 5E:    (Diff=x'007f)*curve gen t.p. > -7 volts - analog b
                
Err code # 5F:    (Diff=x'007f,enable curve)*servo error t.p. > -8
                        volts - analog b

Err code # 60:    Analog c ram test failed - analog c
                
Err code # 61:    (Test oscillator on track) diff pos. offset
                        failed to calibrate - analog a

Err code # 62:    AGC (automatic gain control) failes to respond to
                        changes in the agc value - analog a

Err code # 63:    Pulser/driver prom failed -pf,-df s/b low,-pr,-dr high
                
Err code # 64:    (Test osc even defeat) diff pos. has insufficient
                        negative amplitude - analog a

Err code # 65:    (Test oscillator odd defeat) diff pos. has insufficient
                        positive amplitude - analog a

Err code # 66:    (Test oscillator on track) diff pos. offset too large
                        - analog a

Err code # 67:    PLO unsafe-1 test failed - analog a
                
Err code # 68:    PLO unsafe-2 test failed - analog c
                
Err code # 69:    Crom parity bit check error
                                 *** See note after error code "FF" ***
                
Err code # 6A:    Massfail bits on - or massbus not connected
                
Err code # 6B:    Not used
                
Err code # 6C:    (Test oscillator on track) no fine cylinder - analog b
                
Err code # 6D:    (Test oscillator on track) no coarse cylinder
                        - analog b

Err code # 6E:    (Test oscillator on track) fine or coarse cylinder
                        still set - analog b

Err code # 6F:    (Test oscillator even defeat) fine or coarse cylinder
                        still set - analog b

                                                              Page C-6


Err code # 70:    A/D failed to saturate to x'7f with + 15 volts
                        - analog c

Err code # 71:    A/D failed to saturate to x'80 with - 15 volts
                        - analog c

Err code # 72:    A/D reference failed to calibrate - offset too pos-
                        itive - analog c

Err code # 73:    A/D reference failed to calibrate - offset too neg-
                        itive - analog c

Err code # 74:    Low diff. counter failed - analog b
                
Err code # 75:    Diff > 255 was set (diff = x'0080) - analog b
                
Err code # 76:    Diff > 255 failed to set (diff = x'0100) - analog b
                
Err code # 77:    High diff. counter failed on read back (diff - x'0100)
                        - analog b

Err code # 78:    Diff > 255 failed to set (diff = x'0200) - analog b
                
Err code # 79:    High diff. counter failed on read back (diff = x'0200)
                        - analog b

Err code # 7A:    Low diff. counter clock test failed - analog b
                
Err code # 7B:    High diff. counter clock test failed - analog b

Err code # 7C:    Linear mode reset test failed - analog b

Err code # 7D:    Linear mode set test failed - analog b
                
Err code # 7E:    Self wrap check failure on communication register
                
Err code # 7F:    Maintenance register test failed
                
Err code # 80:    Three (3) phase motor detector failed
                
Err code # 81:    Wrap check failure on the communication register
                         *** See note after error code "FF" ***

Err code # 82:    Handshake failure due to wrong code received from dcl
                         *** See note after error code "FF" ***
                                                
Err code # 83:    Handshake failure due to wrong code received from dcl
                         *** See note after error code "FF" ***
                
Err code # 84:    DCL1 (2901) found unsafe
                         *** See note after error code "FF" ***
                
Err code # 85:    Diagnostic handshake timeout failure
                         *** See note after error code "FF" ***
                
                                                              Page C-7


Err code # 86:    Diagnostic reply from dcl1 (high byte) incorrectly
                        returned *** See note after error code "FF" ***

Err code # 87:    2901 unsafe bit was not set on by 2901 right after being
                        released - check 2901 unsafe bit on A1A8 and A1A9

Err code # 88:    Flag conflict in online diagnostic exit

Err code # 89:    Sector # /index or l.a. failure
                
Err code # 8A:    Unsafe detecting circuit failure
                
Err code # 8B:    Servo error is not  > +4 volts
                
Err code # 8C:    Pulser driver prom failed
                
Err code # 8D:    Servo error is not  < -4 volts
                
Err code # 8E:    Device checked failed in routine #1a
                
Err code # 8F:    DCL crom parity failure in routine #23
                
Err code # 90:    T-bus not floating or something on bus when it
                        should not be

Err code # 91:    Parity is not valid from the t-bus parity checker
                        (both good and bad parity are tested)

Err code # 92:    Massbus read of maintenance register failed
                
Err code # 93:    "DS" register failure - either the 2901 write
                        to the "DS" register failed or the massbus
                        read of the "ds" register failed

Err code # 94:    Massbus read of ER2 not inhibited when no error
                        is present

Err code # 95:    Massbus read of ER2 failed or write from 2901 to
                        ER2 failed

Err code # 96:    Low half of ER2 not working properly
                
Err code # 97:    High half of ER2 not working properly
                
Err code # 98:    Massbus read of file register or 2901 write
                        of file register failed

Err code # 99:    ER1,ER3,EC1, or EC3 are not inhibited when no error
                        is present

Err code # 9A:    Massbus write or read of "DA" register failed
                
Err code # 9B:    Massbus write or read of "DC" register failed
                
Err code # 9C:    Massbus write or read of "OF" register failed
                                                              Page C-8


                
Err code # 9D:    "DA","DC" and "OF" not all valid after all
                        have been written to

Err code # 9E:    Massbus write of CS1 failed
                
Err code # 9F:    Registers "OF", "DA", and "DC" valid after a
                        readin preset command is issued

Err code # A0:    "DA" could be read by massbus while it is invalid
                
Err code # A1:    "DC" could be read by massbus while it is invalid
                
Err code # A2:    "OF" could be read by massbus while it is invalid
                
Err code # A3:    Massbus writes to "DA", "DC" and "OF" did not
                        validate all of them

Err code # A4:    2901 writes to "DA", "DC" and "OF" did not validate
                        all of them

Err code # A5:    Write parity error can not be detected when a command
                        with bad parity is sent to CS1

Err code # A6:    Write parity error did not set A1A12 unsafe and
                        device check

Err code # A7:    Go is not set when an invalid command is sent to CS1
                
Err code # A8:    RMR is not set when a write to "CS" register is
                        attempted while go is set

Err code # A9:    RMR error did not set A1A12 unsafe and device check
                
Err code # AA:    "CS" register was re-written while go was set
                
Err code # AB:    "OF" register was re-written while go was set
                
Err code # AC:    Go can not be reset by 2901
                
Err code # AD:    MB read of illegal register failed to set ILR

Err code # AE:    MB read of illegal register transfered data
                
Err code # AF:    ILR failed to set device check or A1A12 unsafe
                
Err code # B0:    MB read of illegal register transfered data
                
Err code # B1:    MB read of illegal register transfered data
                
Err code # B2:    MB write of illegal register failed to set ILR
                
Err code # B3:    MB write to illegal register modified RPCS1
                
Err code # B4:    MB write to illegal register failed to set ILR
                                                              Page C-9


                
Err code # B5:    MB write to illegal register validated it
                
Err code # B6:    Special attention not set by write with error up
                
Err code # B7:    Write with error up still worked for RPER1
                
Err code # B8:    Write with error up worked for "CC","ER3","EC1", "EC2"

Err code # B9:    Failure in test 11 detected
                
Err code # BA:    Failure in test 12 detected
                
Err code # BB:    Not used
                
Err code # BC:    Not used
                
Err code # BD:    Not used
                
Err code # BE:    A1A12 unexpectedily unsafe
                
Err code # BF:    Go and attention not both reset

Err code # C0:    Tachometer diagnostic         note:
                        failed for low "BW"     this is also
                        and low slew 'DIA19'    a state code: diagnostic
                                                routine in progress

Err code # C1:    Tachometer diagnostic  failed for high "BW" DIA19
                
Err code # C2:    Tachometer diagnostic failed due to insuffecient EMA
                        current integration (+) positive

Err code # C3:    Tachometer diagnostic failed due to insuffecient EMA
                        current integration (-) negative        

Err code # C4:    +/- 1 ampere failure in the tachometer diagnostic

Err code # C5:    Tachometer diagnostic failed due to incorrect high
                        bandwidth differentiator output

Err code # C6:    Tachometer differentiator output either < 4.5 volts
                        or > 6.5 volts for low bandwidth, low slew

Err code # C7:    Not used

Err code # C8:    Not used

Err code # C9:    Not used

Err code # CA:    Not used

Err code # CB:    Not used

Err code # CC:    Not used
                                                             Page C-10



Err code # CD:    Not used

Err code # CE:    Not used      Note: this is also a state code:
                                      CE mode - (locked)

Err code # CF:    Not used      Note: this is also a state code:
                                      diagnostic routine finished

Err code # D0:    "OP" register test failed
                        1. External "BR" failed in force mode
                        2. "OP" register failed in bit test capability
                         *** See note after error code "FF" ***

Err code # D1:    "ST" register test failed, "ST" "BR" register failed
                        in it's individual "BR" conditions

Err code # D2:    "SYNC" register and it's "BR" test failed
                        "SYNC" resister failed in diagnostic clear mode
                        and it's associated branch conditions:
                        1. DCL2BR       5. RWGOOD
                        2. Index        6. DEVCK
                        3. Am detect    7. ECCOK
                        4. Exc in       8. ENDBR

Err code # D3:    Interrupt test failed, interrupt in forced mode at
                        vector address 00 failed

Err code # D4:    "BC" register and "WC" compare test failed
                        failed in endbr or end pulse detect,  caused by
                        the failure of either sync cntr enable latch or
                        word counter or comparator

Err code # D5:    "DCL2" status register failed
                        "DCL2" status register includes the following status:
                        1. Interrupt            5. End pulse
                        2. Ext branch           6.
                        3. Ld. Wd. cntr         7.
                        4. BC bit5              8. XFERCMP

Err code # D6:    "S" clock control test failed
                        data transfer uncompleted failure

Err code # D7:    Not used

Err code # D8:    External register failed on DCL2 board
                        there are two R/W DCL registers on DCL2, "OP"
                        register and "BC" register - either one failing
                        in the wrap test will display "D8"

Err code # D9:    Not used

Err code # DA:    External register wrap failed on A1A12. there are (8)
                        DCL R/W registers on I/O control board according to
                        the test sequence that are "RPEC2","RPEC1","RPER3",
                                                             Page C-11


                        "RPDA","RPCC","RPDC","RP0F" and "RPER1; any one
                        failing in the wrap test will display "DA"

Err code # DB:    Not used

Err code # DC:    Bit ring counter test failed:
                        occurs when end of branch dose not appear within
                        a +/- 3% (three percent) window 1000 words after
                        index. for both 16 and 18 bit modes.

Err code # DD:    Force end "pule" or pattern select failed:
                        occurs when end branch fails to appear immediately
                        after index when ("BC"=0), signifying that diagnostic
                        controls may not have been latched via end pulse.
                        may be caused by bit ring counter failure or end
                        of branch failure

Err code # DE:    Serdes (read) latch b and LIFO test failed:
                        occurs when data transfer timing fails during
                        any of the (3) three transfers in Serdes/LIFO test

Err code # DF:    LIFO data compare test failed:
                        occurs when any of the (3) three data patterns
                        sent from Serdes to lifo fails to arrive correct

Err code # E0:    ECC test failed:
                        occurs when the ECC data generated by the
                        alternating data pattern dose not compare
                        with the expected ECC contents

Err code # E1:    WCF/unsafe A1A14 detected

Err code # E2:    External register wrap failed on serdes board
                        (routine =3A) "RWCTRL" register failed in the wrap test

Err code # E3:    Failed in write/FIFO test (without T-bus):
                        occurs when timing errors are found during any of (3)
                        three data transfers form Serdes to FIFO and from
                        FIFO to LIFO. also occurs when any of the (3) data
                        patterns fails to arrive correct. the T-bus is
                        excluded from these transfers

Err code # E4:    Failed in write/FIFO test (with T-bus):
                        occurs when timing errors are found during any of
                        (3) three data transfers from Serdes to FIFO via
                        T-bus and from FIFO to LIFO via T-bus. also occurs
                        when any of the (3) three data patterns fails to
                        arive correct

Err code # E5:    Not used

Err code # E6:    RWGOOD flag test failed:
                        part 1: Tested "PRIO" to serdes function test
                         failed in the force data good check
                        part 2: Tested "PRIO" to encoder/decoder functional
                                                             Page C-12


                         test failed in either sync complete or data good test

Err code # E7:    Encoder/decoder functional test failed:
                        caused by either timeout failure or write data and
                        read data comparison failure

Err code # E8:    Am detect test failure:
                        failed in either write am attempt or am undetected

Err code # E9:    Not listed

Err code # EA:    Handshake with 8080 failed:
                        command reply by the 8080 is invalid

Err code # EB:    Diagnostic monitor detected invalid command from 8080
                        operator error

Err code # EC:    Not used

Err code # ED:    Massbus fail while setting "DA" or "DC" for r/w tests
                
Err code # EE:    Parameter refused, invalid routine ID or not in FE mode
                        operator error

Err code # EF:    Machine state not as required to run desired test
                        operator error

Err code # F0:    External register failed on r/w safety card:
                        there are two r/w registers on this board
                        "HAR" or "DTCTRL" register failure

Err code # F1:    R/W unsafe-1 test failed:
                        this test will turn off write current. causing r/w
                        preamp unsafe

Err code # F2:    R/W unsafe-2 test failed:
                        this test will cause (2) two chips to be selected,
                        multichip select unsafe

Err code # F3:    R/W unsafe-3 test failed:
                        this test will cause a write attempt with no chip
                        selected. forcing a write current voltage unsafe

Err code # F4:    Write current sense test failed:
                        write attempt with no chips selected will cause
                        write current sense failure

Err code # F5:    Device check summary:
                        device check flag on due to r/w unsafe test or
                        r/w function test failed

Err code # F6:    Read track descriptor failed:
                        track descriptor not found or not the one looking for

Err code # F7:    Write null test failed:
                                                             Page C-13


                        fail in write null (no sync byte)or sync byte detected

Err code # F8:    Write data test failed:
                        drive timing error or write sync uncompleted failure

Err code # F9:    Read data test failed:
                        drive timing error or rwgood undetected failure

Err code # FA:    Invalid cylinder/head detected:
                
Err code # FB:    Not used
                
Err code # FC:    Not used
                
Err code # FD:    Not used
                
Err code # FE:    Not used      Note: State code = CE mode (unlocked)
                                      or online FE (unlocked)

Err code # FF:    Not used

Note:
For the following  error codes: "69, 81, 82, 83, 84, 85, 86 and D0". in normal
operation, the A1A9 led's will track the FE panel, but when running DIA36 the
A1A9 board is beening tested and the led's take on special meaning.

This table is used in conjunction with the error code called out in
the FE panel display, error codes listed here are not the codes in the
FE panel, but indicate internal states or errors in the A1A9 board.

****************************************************************************
***************** Caution this does not apply to DIA37 *********************
****************************************************************************
Error code in           Additional trouble shooting information
in led's                for DIA36 (DCL-1 test)          
=========================================================================
Err code # C0:    Y and S bus wrap failed       DCL1 register failed in
                        wrap test. bit stacked.

Err code # C1:    Unconditional jump failed no jump on unconditional
                        jump instruction.
                
Err code # C2:    Not used

Err code # C3:    Illegal state - program in the wrong state. the
                        contents in the software counter is not correct.

Err code # C4:    Conditional jump failed, no jump when it should.

Err code # C5:    Conditional jump failed jumped when should not.

Err code # C6:    Status not held during jump. no jump when it should.

Err code # C7:    Status not held during jump jumped when should not.

                                                             Page C-14


Err code # C8:    Subroutine return to wrong address.

Err code # C9:    Subroutine call failed or return failed, no jump.

Err code # CA:    File test failed. test Crom bits 00-15, 18-22,
                        (16,17=00,10).

Err code # CB:    Rotate "SP"."OP" failed one of the rotate functions
                        failed - BUP, BDWN, QBUP, QBDWN.

Err code # CC:    Illegal logic operation 2901 failed in logic mode,
                        one of the logic functions is not working.

Err code # CD:    Illegal arithmetic operation. one of the arithmetic
                        operations is not working

Err code # CE:    Parity generator failed. failed in parity generation  

Err  code # CF:    2901 internal register wrap failed. one of the
                        (16) sixteen internal registers failed in the
                        wrap test       

========================================================================
End of note on DIA36 special case led use.












                              APPENDIX D

                                                                  Page
                                                                  ----
                                                              Page D-1


D.1  RP07 Error code to module callout and failing microdiag



Error-Code guide matrix list to be incorperated in error messages
        this matrix taken from Steve Dail memo 18 Feb 81


Error code # 00:        State code only
Error code # 01:        State code only
Error code # 02:        State code only
Error code # 03:        State code only
Error code # 04:        State code only
Error code # 05:        State code only
Error code # 06:        State code only
Error code # 07:        State code only
Error code # 08:        State code only
Error code # 09:        State code only
Error code # 0A:        State code only
Error code # 0B:        State code only
Error code # 0C:        State code only
Error code # 0D:        State code only
Error code # 0E:        State code only
Error code # 0F:        State code only
Error code # 10:        A1A7;DIA0024
Error code # 11:        A1A7;DIA0024
Error code # 12:        A1A7;DIA0024
Error code # 13:        A1A7;DIA0001
Error code # 14:        A1A7;DIA0024
Error code # 15:        A1A7;DIA0024
Error code # 16:        A1A7;DIA0024
Error code # 17:        A1A7;DIA0024
Error code # 18:        A1A7;DIA0028
Error code # 19:        A1A7;DIA0028
Error code # 1A:        A1A7;DIA0028
Error code # 1B:        A1A4,A1A5,A1A6,HDA;TST2050
Error code # 1C:        A1A4,A1A5,A1A6,HDA;TST2050
Error code # 1D:        A1A4,A1A5,A1A6,HDA;TST2051
Error code # 1E:        A1A4,A1A5,A1A6,HDA;TST2050
Error code # 1F:        A1A4,A1A5,A1A6,A1A7,A1A8,A1A9,A1A10,A1A11
                        A1A12,A1A13,A1A14,A1A15,A1A16,A1A20;DIA0029
Error code # 20:        A1A7;DIA0025
Error code # 21:        A1A7;DIA0025
Error code # 22:        A1A7;DIA0025
Error code # 23:        A1A7;DIA0025
Error code # 24:        A1A7;DIA0025
Error code # 25:        A1A7;DIA0025
Error code # 26:        A1A7;DIA0025
Error code # 27:        A1A2,A1A5,A1A7,A1A9;DIA0025
Error code # 28:        A1A4,A1A6;DIA002C
Error code # 29:        A1A4,A1A5;DIA002C
Error code # 2A:        A1A4,A1A6;DIA0031
Error code # 2B:        A1A4,A1A5;DIA0031
Error code # 2C:        A1A4,A1A6;DIA0031
Error code # 2D:        A1A4,A1A6;DIA0031
                                                              Page D-2


Error code # 2E:        A1A4,A1A5;DIA0031
Error code # 2F:        A1A4,A1A5;DIA0031
Error code # 30:        A1A9,A1A10;DIA0035
Error code # 31:        A1A10;DIA0035
Error code # 32:        A1A10;DIA0035
Error code # 33:        A1A9,A1A10;DIA0035
Error code # 34:        A1A10;DIA0035
Error code # 35:        A1A10;DIA0035
Error code # 36:        A1A10;DIA0035
Error code # 37:        A1A10;DIA0035
Error code # 38:        A1A10;DIA0035
Error code # 39:        A1A10;DIA0035
Error code # 3A:        A1A10;DIA0035
Error code # 3B:        A1A10;DIA0035
Error code # 3C:        A1A7;DIA0027
Error code # 3D:        A1A7;DIA0027
Error code # 3E:        A1A7;DIA0026
Error code # 3F:        A1A2,A1A7,A1A10;DIA0001
Error code # 40:        NOT DISPLAYED
Error code # 41:        A1A2,A1A7,BLOWER ASSY;
Error code # 42:        A1A1,A1A2,A1A6,A1A7,A1A8,HDA,3 Phase detector PCB
                        Power transformer,Motor brake assy,Relay K1,
                        Motor belt,Motor spring;DIA0001
Error code # 43:        A1A6,HDA;DIA0001
Error code # 44:        A1A4,A1A5,A1A6,HDA;TST2052
Error code # 45:        A1A4,A1A5,A1A6,HDA;TST2051
Error code # 46:        A1A4,A1A5,A1A6,HDA;TST2050
Error code # 47:        A1A4,A1A5,A1A6,HDA;TST2050
Error code # 48:        A1A4,A1A5;DIA0032
Error code # 49:        A1A4,A1A5;DIA0032
Error code # 4A:        A1A4,AA1A5,A1A6,HDA;TST2051
Error code # 4B:        A1A2,A1A4,A1A5;DIA0019
Error code # 4C:        A1A5;DIA0019
Error code # 4D:        A1A5;DIA0019
Error code # 4E:        A1A1,A1A2,A1A4,A1A6;DIA0019
Error code # 4F:        A1A2,A1A4;DIA0019
Error code # 50:        A1A4,A1A5,A1A6,HDA;TST2050
Error code # 51:        A1A4,A1A5,A1A6,HDA;TST2051
Error code # 52:        A1A4,A1A5,A1A6,HDA;TST2050
Error code # 53:        A1A4,A1A6;DIA0001
Error code # 54:        A1A2,A1A4;DIA0019
Error code # 55:        A1A4,A1A5,A1A6,HDA;TST2050
Error code # 56:        A1A2,A1A4;DIA0019
Error code # 57:        A1A4,A1A5;DIA0033
Error code # 58:        A1A4,A1A5;DIA0033
Error code # 59:        A1A4,A1A5;DIA0033
Error code # 5A:        A1A4,A1A5;DIA0033
Error code # 5B:        A1A4,A1A5;DIA0033
Error code # 5C:        A1A4,A1A5;DIA0033
Error code # 5D:        A1A4,A1A5;DIA0033
Error code # 5E:        A1A4,A1A5;DIA0033
Error code # 5F:        A1A4,A1A5;DIA0033
Error code # 60:        A1A4,A1A5,A1A7,A1A8,Operators panel;DIA002A
Error code # 61:        A1A4,A1A5,A1A6,HDA;DIA002D
Error code # 62:        A1A4,A1A6;DIA002D
                                                              Page D-3


Error code # 63:        A1A5;DIA0019
Error code # 64:        A1A4,A1A5,A1A6,A1A7,A1A9,A1A12,HDA;DIA002D
Error code # 65:        A1A4,A1A6,A1A7,A1A9,A1A12;DIA002D
Error code # 66:        A1A4,A1A5,A1A6;DIA002D
Error code # 67:        A1A6;DIA0018
Error code # 68:        A1A4,A1A6;DIA0018
Error code # 69:        A1A8;DIA0036
Error code # 6A:        A1A8,A1A12,Massbus cable;TST206A
Error code # 6B:        Not used
Error code # 6C:        A1A5,A1A6,A1A7;DIA0030
Error code # 6D:        A1A5,A1A6,A1A7;DIA0030
Error code # 6E:        A1A5,A1A6;DIA0030
Error code # 6F:        A1A5,A1A6;DIA0030
Error code # 70:        A1A4,A1A5,A1A7;DIA002B
Error code # 71:        A1A2,A1A4;DIA002B
Error code # 72:        A1A2,A1A4;DIA002B
Error code # 73:        A1A4;DIA002B
Error code # 74:        A1A5;DIA002E
Error code # 75:        A1A5;DIA002E
Error code # 76:        A1A5;DIA002E
Error code # 77:        A1A5;DIA002E
Error code # 78:        A1A5;DIA002E
Error code # 79:        A1A5;DIA002E
Error code # 7A:        A1A5;DIA002E
Error code # 7B:        A1A5;DIA002E
Error code # 7C:        A1A5;DIA002F
Error code # 7D:        A1A5;DIA002F
Error code # 7E:        A1A7,A1A8,A1A9,A1A10,A1A12,A1A14
                        A1A15,A1A16,A1A17,HDA;DIA0034
Error code # 7F:        A1A8,A1A11,A1A12,A1A13;DIA0034
Error code # 80:        A1A7,3 Phase detector PCA;DIA0001
Error code # 81:        A1A8,A1A9,A1A10;DIA0036
Error code # 82:        A1A9,A1A10;DIA0036
Error code # 83:        A1A7,A1A8,A1A9,A1A10;DIA0036
Error code # 84:        A1A8,A1A9,A1A10,A1A12,A1A14;DIA0036
Error code # 85:        A1A9,A1A10;DIA0036
Error code # 86:        A1A9,A1A10;DIA0036
Error code # 87:        A1A8,A1A9;TST2087
Error code # 88:        No callout;DIA0088
Error code # 89:        A1A8;DIA001A
Error code # 8A:        A1A6,A1A8;DIA001A
Error code # 8B:        A1A5;DIA0019
Error code # 8C:        A1A5;DIA0019
Error code # 8D:        A1A5;DIA0019
Error code # 8E:        A1A8,A1A10,A1A12,A1A14,A1A115,A1A16,HDA;DIA001A
Error code # 8F:        A1A9,A1A10;DIA0023
Error code # 90:        A1A12;DIA0039
Error code # 91:        A1A8,A1A12;DIA0039
Error code # 92:        A1A12;DIA0039
Error code # 93:        A1A8,A1A12;DIA0039
Error code # 94:        A1A12;DIA0039
Error code # 95:        A1A7,A1A8,A1A12;DIA0039
Error code # 96:        A1A8;DIA0039
Error code # 97:        A1A12;DIA0039
Error code # 98:        A1A8,A1A12;DIA0039
                                                              Page D-4


Error code # 99:        A1A8,A1A12;DIA0039
Error code # 9A:        A1A8,A1A12;DIA0039
Error code # 9B:        A1A8,A1A12;DIA0039
Error code # 9C:        A1A8,A1A12;DIA0039
Error code # 9D:        A1A12;DIA0039
Error code # 9E:        A1A12;DIA0039
Error code # 9F:        A1A12;DIA0039
Error code # A0:        A1A12;DIA0039
Error code # A1:        A1A12;DIA0039
Error code # A2:        A1A12;DIA0039
Error code # A3:        A1A12;DIA0039
Error code # A4:        A1A12;DIA0039
Error code # A5:        A1A8,A1A12;DIA0039
Error code # A6:        A1A8,A1A12;DIA0039
Error code # A7:        A1A12;DIA0039
Error code # A8:        A1A12;DIA0039
Error code # A9:        A1A12;DIA0039
Error code # AA:        A1A12;DIA0039
Error code # AB:        A1A12;DIA0039
Error code # AC:        A1A12;DIA0039
Error code # AD:        A1A12;DIA0039
Error code # AE:        A1A12;DIA0039
Error code # AF:        A1A12;DIA0039
Error code # B0:        A1A12;DIA0039
Error code # B1:        A1A12;DIA0039
Error code # B2:        A1A12;DIA0039
Error code # B3:        A1A12;DIA0039
Error code # B4:        A1A12;DIA0039
Error code # B5:        A1A12;DIA0039
Error code # B6:        A1A12;DIA0039
Error code # B7:        A1A12;DIA0039
Error code # B8:        A1A12;DIA0039
Error code # B9:        A1A7,A1A8,A1A12;DIA0039
Error code # BA:        A1A8,A1A12;DIA0039
Error code # BB:        Not used
Error code # BC:        Not used
Error code # BD:        Not used
Error code # BE:        A1A12;DIA0039
Error code # BF:        A1A12;DIA0039
Error code # C0:        A1A5;DIA0014
Error code # C1:        A1A5;DIA0014
Error code # C2:        A1A4,A1A5;DIA0014
Error code # C3:        A1A5;DIA0014
Error code # C4:        A1A5;DIA0014
Error code # C5:        A1A5,A1A6;DIA0014
Error code # C6:        A1A5;DIA0014
Error code # C7:        Not used
Error code # C8:        Not used
Error code # C9:        Not used
Error code # CA:        Not used
Error code # CB:        Not used
Error code # CC:        Not used
Error code # CD:        Not used
Error code # CE:        Not used
Error code # CF:        Not used
                                                              Page D-5


Error code # D0:        A1A9,A1A10;DIA0037
Error code # D1:        A1A9,A1A10,A1A14;DIA0037
Error code # D2:        A1A10;DIA0037
Error code # D3:        A1A9,A1A10,A1A12;DIA0037
Error code # D4:        A1A10,A1A14;DIA0037
Error code # D5:        A1A9,A1A10,A1A12,A1A14;DIA0037
Error code # D6:        A1A10,A1A14,A1A15,A1A17;DIA001C,DIA0037
Error code # D7:        Not used
Error code # D8:        A1A10;DIA0037
Error code # D9:        Not used
Error code # DA:        A1A9,A1A12;DIA0038
Error code # DB:        Not used
Error code # DC:        A1A14,A1A15;DIA001C
Error code # DD:        A1A10,A1A14,A1A15;DIA001C
Error code # DE:        A1A14;DIA001C
Error code # DF:        A1A14;DIA001C
Error code # E0:        A1A14;DIA001C
Error code # E1:        A1A14;DIA001C
Error code # E2:        A1A14;DIA003A
Error code # E3:        A1A14;DIA001C
Error code # E4:        A1A14;DIA001C
Error code # E5:        Not used
Error code # E6:        A1A14,A1A15,A1A16;DIA001D
Error code # E7:        A1A15;DIA001D
Error code # E8:        A1A10,A1A15,A1A16;DIA0022
Error code # E9:        A1A10;DIA001B,DIA001C
Error code # EA:        A1A8,A1A9;TST20EA
Error code # EB:        Operator error
Error code # EC:        Not used
Error code # ED:        A1A7;TST20ED
Error code # EE:        Operator error
Error code # EF:        Operator error
Error code # F0:        A1A16;DIA003B
Error code # F1:        A1A8,A1A16,A1A17,HDA;DIA001B
Error code # F2:        A1A16,HDA;DIA001B
Error code # F3:        A1A16,HDA;DIA001B
Error code # F4:        A1A16,HDA;DIA001B
Error code # F5:        A1A16;DIA001B
Error code # F6:        A1A10,A1A15,A1A16,A1A17,HDA;DIA001E
Error code # F7:        A1A16,A1A17,HDA;DIA001E
Error code # F8:        A1A16;DIA001E
Error code # F9:        A1A16;DIA001E
Error code # FA:        Not used
Error code # FB:        Not used
Error code # FC:        Not used
Error code # FD:        Not used
Error code # FE:        No callout;DIA001E
Error code # FF:        No callout;DIA001E












                              APPENDIX E

                                                                  Page
                                                                  ----
                                                              Page E-1


E.1  RP07 Drive register bit definitions.


                  |           |           |           |            |          |
RH20 BIT POSI | 20| 21| 22| 23| 24| 25| 26| 27| 28| 29| 30| 31| 32| 33| 34| 35|
-------------------------------------------------------------------------------
RP07 BIT POSI | 15| 14| 13| 12| 11| 10| 09| 08| 07| 06| 05| 04| 03| 02| 01| 00|
===============================================================================
R/W 00  DRCR  | 0 | 0 | 0 | 0 |DVA| 0 | 0 | 0 | 0 | 0 |   FUNCTION  CODE  | GO|
-------------------------------------------------------------------------------
R   01  DRSR  |ATA|ERR|PIP|MOL|WLR|LBT|PGM|DPR|DRY| VV| 0 | 0 | 0 |ILV|EWN| OM|
-------------------------------------------------------------------------------
R   02  DRER1 |DCK|UNS|OPI|DTE|WLE|IAE|AOE|HC-|HCE|ECH|WCF|FER|PAR|RMR|ILR|ILF|
              |   |   |   |   |   |   |   |RC |   |   |   |   |   |   |   |   |
-------------------------------------------------------------------------------
R/W 03  DRMR  |DMD| DIAGNOSTIC ROUTINE NUMBER |      DIAGNOSTIC PARAMETER     |
-------------------------------------------------------------------------------
R/W 04  DRAS  | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |ATA|ATA|ATA|ATA|ATA|ATA|ATA|ATA|
              |   |   |   |   |   |   |   |   | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
-------------------------------------------------------------------------------
R/W 05  DRDA  |         DESIRED TRACK         |         DESIRED SECTOR        |
-------------------------------------------------------------------------------
R   06  DRDT  | 0 | 0 | 1 | 0 | X | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 |
-------------------------------------------------------------------------------
R   07  DRLA  | 0 | 0 | 0 |  CURRENT SECTOR (PHYSCAL) | 0 | 0 | 0 | 0 | 0 | 0 |
-------------------------------------------------------------------------------
R   10  DRSN  |      BCD      |      BCD      |      BCD      |      BCD      |
-------------------------------------------------------------------------------
R/W 11  DROF  |CMD|MTD| 0 |FMT|ECI|HCI| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
-------------------------------------------------------------------------------
R/W 12  DRDCY |                   DESIRED CYLINDER REGISTER                   |
-------------------------------------------------------------------------------
R   13  DRCCY | 0 | 0 | 0 | 0 | 0 | 0 |            CURRENT CYLINDER           |
-------------------------------------------------------------------------------
R   14  DRER2 |PGE| 0 |CPU|RW-|RW-|RW-|WOR|WRU|   ERROR CODE (2 HEX DIGITS)   |
              |   |   |   |U3 |U2 |U1 |   |   |                               |
-------------------------------------------------------------------------------
R   15  DRER3 |BSE|SKI|DSE|WSF|CLF|LBC|LCE|PHF|DVC|IXU|DCU|SDF|DPE|SBE|SCF|RTO|
-------------------------------------------------------------------------------
R   16  DREC1 |                       ECC POSITION                            |
-------------------------------------------------------------------------------
R   17  DREC2 | 0 | 0 | 0 | 0 | 0 |                ECC PATTERN                |
-------------------------------------------------------------------------------
              |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
                  |           |           |           |           |           |

                     ******  ACRONYM TO NAME  ******

AOE     ADDRESS OVERFLOW                FUNCTION CODE
ATA     ATTENTION ACTIVE                GO      EXECUTE COMMAND (FUNCTION CODE)
ATA0    LOGICAL NUMBER (PSEUDO REG)     HCE     HEADER COMPARE ERROR
ATA1       "      "          "          HCI     HEADER COMPAIR INHIBIT
ATA2       "      "          "          HCRC    HEADER CRC ERROR

ATA3       "      "          "          IAE     INVALID ADDRESS ERROR
                                                              Page E-2


ATA4       "      "          "          ILF     ILLEGAL FUNCTION
ATA5       "      "          "          ILR     ILLEGAL REGISTER
ATA6       "      "          "          ILV     INTERLEAVED SECTORS
ATA7       "      "          "          IXU     INDEX UNSAFE
          
BSE     BAD SECTOR ERROR                LBC     LOSS OF BIT CLOCK ERROR
CLF     CONTROL LOGIC FAILURE           LBT     LAST BLOCK TRANSFERRED
CMD     COMMAND MODIFIER (ALSO CMOD)    LCE     LOSS OF CYLINDER ERROR
CPU     8080 CPU TIMEOUT                MOL     MEDIUM ON LINE
CURRENT CYLINDER                        MTD     MOVE TRACK DESCRIPTOR

CURRENT SECTOR                          OM      OFFSET MODE
DCK     DATA CHECK                      OPI     OPERATION INCOMPLETE ERROR
DCU     DC UNSAFE                       PAR     PARITY
DESIRED CYLINDER                        PGE     PROGRAM ERROR
DESIRED SECTOR                          PHF     8080 MICROPROCESSOR FAILURE

DESIRED TRACK                           PGM     PROGRAMMABLE (DUAL PORT)
DIAG    PARAMETER                       PIP     POSITION IN PROGRESS
DIAG    ROUTINE NUMBER                  RMR     REGISTER MODIFICATION REFUSED
DMD     DIAGNOSTIC MODE                 RTO     RUN TIMEOUT ERROR
DPE     DATA PARITY ERROR               RWU1    R/W UNSAFE (NO TRANSISIONS)

DPR     DRIVE PRESENT                   RWU2    R/W UNSAFE (MULTI HEAD SELECT)
DRY     DRIVE READY                     RWU3    R/W UNSAFE (WRITE CUR ON READ)
DSE     DEFECT SKIP ERROR               SBE     SYNC BYTE ERROR
DTE     DRIVE TIMING ERROR              SCF     SYNC CLOCK FAILURE
DVA     DEVICE AVAILABLE                        SDF     SERDES DATA FAILURE

DVC     DEVICE CHECK                    SERIAL  NUMBER
ECC     PATTERN                         SKI     SEEK INCOMPLETE
ECC     POSITION                        UNS     UNSAFE ERROR
ECH     ECC HARD                        VV      VOLUME VALID
ECI     ERROR CORRECTION INHIBIT        WCF     WRITE CLOCK FAILED

ERR     COMPOSITE ERROR                 WLE     WRITE LOCKED ERROR
ERROR   CODE    (MICRODIAGNOSTIC)       WLR     WRITE LOCKED
EWN     EARLY WARNING                   WOR     WRITE OVERRUN ERROR
FER     FORMAT ERROR                    WRU     WRITE READY UNSAFE
FMT     FORMAT                          WSF     WRITE CURRENT SENSE FAILURE

                ******  DRIVE REGISTER NAMES  ******

DRAS    DRIVE ATTN SUMMARY REG          DRER1   DRIVE ERROR REG 1
DRCCY   DRIVE CURRENT CYLINDER REG      DRER2   DRIVE ERROR REG 2
DRCR    DRIVE CONTROL REG               DRER3   DRIVE ERROR REG 3
DRDA    DRIVE DESIRED TR/SEC ADDRESS    DRLA    DRIVE LOOK AHEAD REG

DRDCY   DRIVE DESIRED CYLINDER REG      DRMR    DRIVE MAINTENANCE REG
DRDT    DRIVE TYPE REG                  DROF    DRIVE OFFSET REG
DREC1   DRIVE ECC POSITION REG          DRSN    DRIVE SERIAL NUMBER REG
DREC2   DRIVE ECC PATTERN REG           DRSR    DRIVE STATUS REG

