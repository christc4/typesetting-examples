



	                       FASP User's Guide

	            (FORTRAN Alphameric Subroutine Package)

	                          24 June 1978





	  FFFFFFFFFFFFFF    AA             SSSSSSSSSS   PPPPPPPPPP
	  FFFF             AAAA         SSSSS           PPPP    PPPPP
	  FFFF            AAAAAA       SSSS             PPPP      PPPP
	  FFFF           AAAA  AA       SSSSS           PPPP      PPPP
	  FFFF          AAAA    AA         SSSSSS       PPPP    PPPPP
	  FFFFFFFFF    AAAA      AA            SSSSS    PPPPPPPPPP
	  FFFF        AAAAAAAAAAAAAA             SSSS   PPPP
	  FFFF        AAAA        AA           SSSSS    PPPP
	  FFFF        AAAA        AA   SSSSSSSSSS       PPPP



	  UU     UU     SSSSSS   EEEEEEEE   RRRRRRR     '''     SSSSSS
	  UU     UU   SS         EE         RR     RR    ''   SS
	  UU     UU   SS         EE         RR     RR   ''    SS
	  UU     UU     SSSS     EEEEEE     RRRRRRR             SSSS
	  UU     UU         SS   EE         RR   RR                 SS
	   UU   UU          SS   EE         RR    RR                SS
	    UUUUU     SSSSSS     EEEEEEEE   RR     RR         SSSSSS



	     GGGGGGG    UU     UU    IIIIII    DDDDDDD       EEEEEEEEE
	   GG           UU     UU      II      DD     DD     EE
	  GG            UU     UU      II      DD      DD    EE
	  GG    GGGG    UU     UU      II      DD      DD    EEEEEE
	  GG      GG    UU     UU      II      DD      DD    EE
	   GG     GG     UU   UU       II      DD     DD     EE
	     GGGGGGG      UUUUU      IIIIII    DDDDDDD       EEEEEEEEE





	                        Donald E. Barth

	                 Division of Computer Services

	           Graduate School of Business Administration

	                       Harvard University
	  
	  


	  An Introduction to the FORTRAN Alphameric Subroutine Package
	  -- ------------ -- --- ------- ---------- ---------- -------

	  FASP, a FORTRAN Alphameric Subroutine Package, is a  package
	  of FORTRAN subroutines which provide alphameric input/output
	  features not provided directly  by  FORTRAN.   Most  of  the
	  subroutines  in  this package either write characters with a
	  multiple of an A1 format, or else  generate,  manipulate  or
	  interpret  characters  which the calling program has read in
	  with or will write out with a multiple of an A1 format.  The
	  following types of routines are included in this package.

	    A. Routines  which  evaluate   the   words,   numbers   or
	       combinations of these which the user has typed.
	    B. Routines which generate the representations of numbers.
	    C. Routines which allow the user to specify  by  name  and
	       subscripts,  to examine and to manipulate the values of
	       multiply   subscripted   FORTRAN   arrays   which   are
	       equivalenced  with  or  otherwise  loaded  into  singly
	       subscripted buffers.
	    D. Routines  which  perform   tab   character   to   space
	       conversions,   lower   case   letter   to   upper  case
	       conversions, and other manipulations of text.
	    E. Routines which generate  bar  charts,  point  and  line
	       plots, vertical time axis plots and pin maps.
	    F. Routines which generate large multiple-line lettering.

	  This documentation and all programs and  routines  described
	  in  this documentation were written at PDP-10 (DECsystem-10)
	  installations at Aiken  Computation  Laboratory  of  Harvard
	  University,  and at the Harvard Business School by Donald E.
	  Barth, who can be contacted at the following address

	       Division of Computer Services, Baker Library 21
	       Graduate School of Business Administration
	       Harvard University, Soldiers Field
	       Boston, Massachusetts 02163

	  The author requests that the comment lines stating his  name
	  be  retained  in  the  routines and programs which form this
	  package and which are described in this document.

	  The routines described in this  documentation  were  written
	  for  specific applications in which these routines appear to
	  produce the expected results.  However, FASP  includes  over
	  6000  FORTRAN  statements,  and  the routines in the package
	  have up to 37 arguments each  in  their  calling  sequences.
	  Any package of this size and complexity will contain errors,
	  and cannot  produce  reasonable  results  for  all  possible
	  illogical  values  of  the  input  arguments.   Neither  the
	  author, nor Harvard University,  assume  any  responsibility
	  for  errors  in  the  documentation  of  this  package,  for
	  malfunctions of the routines within  this  package,  or  for
	  difficulties which may arise in the use of these routines.
	  FASP, FORTRAN Alphameric Subroutine Package           Page 2
	  An Introduction to the FORTRAN Alphameric Subroutine Package


	  This manual contains a collection of 1 line descriptions  of
	  each  of  the  routines  in  this  package,  followed  by  a
	  collection of  1  paragraph  descriptions  of  each  of  the
	  routines, and finally a collection of detailed multiple-page
	  descriptions  of  each  of  the  routines.   Each  of  these
	  collections  is  arranged  in  the alphabetical order of the
	  routine names.  Each detailed description contains a summary
	  of  the  purpose of the routine, a listing of the SUBROUTINE
	  statement as found in  the  routine  and  of  the  DIMENSION
	  statement if any, and a description of each of the variables
	  and arrays in the order in which they appear in the argument
	  list.   A  few  of  the  routines in this package which have
	  argument lists which include all of  the  arguments  of  the
	  primitives   which   they   call   are   described   in  the
	  documentation of these primitives, rather than separately so
	  as  to  prevent  duplication  of  the  descriptions  of  the
	  identical arguments.  The 1 paragraph  descriptions  specify
	  the  locations  of the detailed descriptions of such wrapper
	  routines and similarly specify the locations of the detailed
	  descriptions  of  the  reduced capability versions which are
	  supplied as alternatives for some of the routines.   At  the
	  end  of  the  detailed  description  will usually be found a
	  listing of a program which calls the routine and  a  listing
	  of  a  typical  program-user  dialog.  Such calling programs
	  range  from  simple  interactive   demonstrations   to   the
	  prototypes   of  the  application  programs  for  which  the
	  routines were written.

	  In the argument lists of most of the routines  described  in
	  this  documentation,  input  arguments  which  are  returned
	  unchanged appear first, arguments which are  used  both  for
	  input  to  this  routine  and  for  output from this routine
	  either to the calling program or to the subsequent  call  to
	  the  same  routine  appear next, and arguments for which the
	  input values are ignored and which are used only for  output
	  appear  last.   The  argument  lists  of  a few of the older
	  routines in this package are not arranged  in  this  manner,
	  but   these   argument   lists  are  usually  short  anyway.
	  Arguments having the same names in different routines  often
	  have  similar  definitions.   However,  such definitions can
	  vary in obscure  ways.   For  example,  the  argument  named
	  LOWBFR is returned pointing to the character to the right of
	  an illegal character by DASPAN and DANEXT, but  is  returned
	  pointing  to  the  illegal  character  itself by most of the
	  other routines.

	  The programs and routines in this  package  are  written  in
	  machine independent FORTRAN but do require that the compiler
	  support the 1H notation  in  DATA  statements  to  define  1
	  character per array location, and that the runtime system be
	  able to use the A1 format to read a single character into  a
	  single  array  location  or  to  write out an array location
	  containing such a single character.  The fill characters  to
	  pad  to  the full word size of the particular computer being
	  FASP, FORTRAN Alphameric Subroutine Package           Page 3
	  An Introduction to the FORTRAN Alphameric Subroutine Package


	  used are of no  concern  except  that  the  fill  characters
	  supplied  during  reading with an A1 format must match those
	  supplied when the 1H notation is used  in  DATA  statements.
	  If  the  routines  in  this package are used on some IBM 370
	  systems in which the 1H notation in DATA statements  results
	  in  padding  with zero character codes while characters read
	  with a multiple of  an  A1  format  are  padded  with  space
	  characters,   then  it  will  be  necessary  to  change  the
	  character  definitions  in  the  DATA  statements  in  these
	  routines  from  1H  notation  to 4H notation and to insert 3
	  extra spaces to the right of each character so defined.

	  Most of the arguments of these  routines  have  names  which
	  begin  with  the letters I through N and must contain either
	  integer values or else characters which have each been  read
	  by  the use of an A1 format or which have been defined using
	  a  1H  notation.   Those  few  arguments  which  have  names
	  beginning  with  the  letters  A  through H or else with the
	  letters O through Z are used for real values.  None  of  the
	  machine-independent routines in this package store more than
	  a single character per computer  location.   A  few  of  the
	  machine-dependent  demonstration programs and routines which
	  are listed as examples  in  this  document  use  single  and
	  double  precision  variables  to  contain several characters
	  which  have  been  packed  into   individually   addressable
	  computer  locations,  but no special naming conventions have
	  been used for these variables.

	  Most of the routines in this package  were  developed  using
	  the  DECsystem-10  F40  compiler.   The  DIMENSION  and DATA
	  statements have since  been  reordered  to  conform  to  the
	  somewhat  stricter  sequencing  rules  enforced by the newer
	  DECsystem-10 FORTRAN-10 compiler and this compiler has  been
	  used  for all of the more recent development of the package.
	  The use of the FORTRAN-10  compiler  has  allowed  the  DATA
	  statement in the DAFLAG routine which defines the characters
	  1H[ and 1H] to be changed from octal machine  word  notation
	  to  Hollerith  character  notation.  The octal notation DATA
	  statement has been commented out, but must  be  restored  if
	  this  routine is to be compiled using the F40 compiler.  The
	  lower case letters which appear in Hollerith  strings  in  a
	  few  of  the  routines will be translated into upper case if
	  the F40 compiler is used, but this will cause no  difficulty
	  other  than that the routines will then be unable to process
	  lower case input.

	  Although the routines in the package use  the  1H  Hollerith
	  notation in DATA statements to define variables which are to
	  be matched against characters which the calling program  has
	  read 1 to a computer storage location using a multiple of an
	  A1 format, the array arguments used for  passing  characters
	  to   the  routines  are  not  used  for  any  other  numeric
	  information so that the routines in this package  should  be
	  easily   converted  to  the  character  conventions  of  the
	  FASP, FORTRAN Alphameric Subroutine Package           Page 4
	  An Introduction to the FORTRAN Alphameric Subroutine Package


	  FORTRAN77 standards.  Similarly, to permit  subscript  range
	  checking, all of the argument lists include size information
	  for the array arguments even though  this  size  information
	  may  not  be needed by the logic of the routines.  Since the
	  FORTRAN77 standards require  the  explicit  preservation  of
	  values   across   calls   to   a   particular  routine,  all
	  non-dimensioned variables and all fixed  dimensioned  arrays
	  which contain values which are needed by the subsequent call
	  to the same routine but which are not needed by the  calling
	  program  are  placed  into  labeled COMMON, and all variably
	  dimensioned arrays appear in the argument lists.

	  The  routines  in  this  package  make  extensive   use   of
	  punctuation  characters  which  are not part of the standard
	  FORTRAN character set.  In particular, many of the  routines
	  in  FASP  use  the  semicolon  to  separate statements which
	  appear together on a single line, the exclamation  point  to
	  indicate  that  the  current  statement is complete with the
	  remainder of the current line being taken as a comment,  and
	  the   ampersand  to  indicate  that  the  current  statement
	  continues on the next line with the remainder of the current
	  line  being taken as a comment.  If these characters are not
	  available,  then  it  will  be  necessary  to  select  other
	  characters  which  can  be  used  for  these purposes and to
	  change  the  DATA  statements  accordingly.   Most  of   the
	  routines in this package accept a tabulation (tab) character
	  as equivalent to a space character.  Each  test  for  a  tab
	  character is preceded by a test for a space character, so it
	  is merely necessary to change the tab characters in the DATA
	  statements to spaces if the computer system upon which these
	  routines are used does not include the tab character in  its
	  character set.

	  The routines named DACASE (the  lower  case  to  upper  case
	  converter)  and DAVERB (the word interpreter) each contain a
	  list  of  the  lower  case  letters  and  a  list   of   the
	  corresponding  upper  case  letters.  The lower case letters
	  are defined by DATA  statements  to  be  in  the  order  1Ha
	  through  1Hz  which  on the DECsystem-10 computer results in
	  the  associated  integer  values  being   sorted   into   an
	  increasing  order.   If  these  routines  are  used  upon  a
	  computer system in  which  the  alphabetical  order  of  the
	  letters  1Ha  through  1Hz  does not result in an increasing
	  order for the  associated  integer  values,  then  the  DATA
	  statements  which  define the arrays which contain the lower
	  case  letters  should  be  rewritten  so  that  the   values
	  associated  with the letters will be in increasing numerical
	  order,  and  then  the  DATA  statements  which  define  the
	  corresponding  upper  case letters must be rewritten so that
	  the lower and upper case versions of each letter  appear  in
	  locations   in   the   respective  arrays  having  the  same
	  subscripts.  If these routines  are  used  upon  a  computer
	  system  which  does  not support lower case letters then the
	  arrays which would otherwise contain the list of lower  case
	  FASP, FORTRAN Alphameric Subroutine Package           Page 5
	  An Introduction to the FORTRAN Alphameric Subroutine Package


	  letters  as  well  as  the  arrays which contain the list of
	  upper case letters can each contain the upper  case  letters
	  1HA  through 1HZ in alphabetical order even if this order is
	  not the numerically sorted order.

	  Since the routines in this package are designed to be usable
	  in  a  wide  variety of applications, many of their argument
	  lists are long.  If any one routine is to be called  several
	  times  within  a  particular  program,  then  the writing of
	  separate CALL statements is both error prone and consumptive
	  of  machine  space.   If  the  argument lists in the various
	  calls would be similar then it is often worthwhile to  write
	  a  short  wrapper  routine  having  a  minimal argument list
	  consisting only of those arguments  which  would  differ  in
	  value  for the individual calls.  An error which is commonly
	  made in writing calls to routines having such long  argument
	  lists is the omission of an argument.  Such omissions can be
	  detected by comparing the number of arguments  in  the  CALL
	  and  SUBROUTINE  statements, but can usually be prevented by
	  writing the CALL statements with exactly the same number  of
	  arguments  per  line as appear in the SUBROUTINE statements.
	  An error which is often made when using the  routines  which
	  permit  the  user  to  specify by name and to manipulate the
	  values of FORTRAN arrays is the failure to declare the array
	  arguments  of these routines in a DIMENSION statement in the
	  calling  program  since  these  arrays   usually   are   not
	  manipulated by the calling program itself.
	  FASP, FORTRAN Alphameric Subroutine Package           Page 6
	  One-Line Descriptions of Each of the Routines in FASP


	     One-Line Descriptions of Each of the Routines in FASP
	     --- ---- ------------ -- ---- -- --- -------- -- ----

	  FASP includes the routines listed below.  The names of  most
	  of  these  routines are constructed from the 2 letter prefix
	  "DA", standing for the word DAta, together with a  4  letter
	  word  indicating  the  purpose of the routine.  Two versions
	  are  provided  of  some  routines.   The  shorter  of  these
	  versions,  named  with  the DA prefix followed by the single
	  letter I and a 3 letter contraction of the normal  4  letter
	  name, provides only a selected subset of the capabilities of
	  the longer, more general version.  For example,  several  of
	  the  input  text  buffer  interpretation  routines,  such as
	  DAHEST and DANEXT, are provided in  general  versions  which
	  will  handle  both real numbers and integers, and in shorter
	  versions, such as DAIHST and DAINXT, which will accept  only
	  integer numbers.

	  DABASE  locates start of region in dictionary made by DALOAD

	  DABELT  constructs a band of column identification numbers

	  DACASE  converts lower case letters in buffer to upper case

	  DACOPY  expands tabs to spaces while copying text

	  DAFILL  expands tabs to spaces without using extra buffer

	  DAFLAG  locates components of PDP-10 file specification

	  DAFONT  constructs FORTRAN statements describing DATEXT font

	  DAGRID  rationalizes scales of plots produced by DAPLAT

	  DAHEFT  evaluates integer and real numbers

	  DAHELP  determines if text begins with question mark

	  DAHEST  identifies command and all associated items

	  DAIBLT  version of DABELT for column numbers increasing by 1

	  DAIFLL  version of DAFILL which always copies initial spaces

	  DAIHFT  integer only version of DAHEFT

	  DAIHST  integer only version of DAHEST

	  DAINXT  integer only version of DANEXT

	  DAIPAR  version of DAPAIR not accepting range specifications

	  DAIRNK  version of DARANK not accepting range specifications
	  FASP, FORTRAN Alphameric Subroutine Package           Page 7
	  One-Line Descriptions of Each of the Routines in FASP


	  DAISPN  integer only version of DASPAN

	  DAJOIN  evaluates whole numbers, fractions and mixed numbers

	  DALEAD  identifies command and next associated item

	  DALINE  bar chart plotter for printer

	  DALIST  summarizes contents of dictionary made by DALOAD

	  DALOAD  constructs dictionary describing FORTRAN arrays

	  DALONE  summarizes single entry in dictionary made by DALOAD

	  DALOOP  returns next loop indexes varied in any order

	  DALOSS  entry for DAVERB allowing missing words

	  DAMENU  constructs dictionaries for DAVERB or DAHEST

	  DAMISS  entry for DAHEFT allowing missing values

	  DAMOVE  justify or center group of characters in field

	  DANAME  finds multiple subscripts corresponding to single

	  DANEXT  returns next value in series of numbers or ranges

	  DANUMB  represents any integer

	  DAPAIR  returns next pair of leading and following values

	  DAPATH  represent unsigned integers sequence in form 1.2.3

	  DAPICK  interprets array notation using DALOAD dictionary

	  DAPLAT  plots lines, points or point clusters on printer

	  DARANK  returns evaluated integers sorted without duplicates

	  DARITE  represents real number in floating or exponent form

	  DAROLL  returns next loop indexes varied in fixed order

	  DAROME  represents integer as Roman numeral

	  DASAVE  makes DATA statements for integer or Hollerith array

	  DASHOW  simple entry for DARITE

	  DASITE  finds single subscript corresponding to multiple

	  DASPAN  returns next number or description of range
	  FASP, FORTRAN Alphameric Subroutine Package           Page 8
	  One-Line Descriptions of Each of the Routines in FASP


	  DASWAP  interchanges adjacent groups of characters in buffer

	  DATALL  constructs printer plot with extended vertical scale

	  DATEAM  evaluates and returns several values at once

	  DATEXT  represents text using large, multiple-line lettering

	  DATREE  returns next line in tree structure representation

	  DATREK  evaluates series of unsigned integers of form 1.2.3

	  DATURN  version of DATEXT lettering top to bottom of page

	  DAVARY  displays and changes value identified by DAPICK

	  DAVERB  identifies word or abbreviation of word

	  TEXT1   description for DATEXT of letters 9 wide by 5 high

	  TEXT2   description for DATEXT of letters 5 wide by 5 high

	  TEXT3   description for DATEXT of letters 12 wide by 11 high

	  TEXT4   description for DATEXT of letters 8 wide by 7 high

	  TEXT5   description for DATEXT of letters 14 wide by 9 high
	  FASP, FORTRAN Alphameric Subroutine Package           Page 9
	  One-Paragraph Descriptions of Each of the Routines in FASP


	   One-Paragraph Descriptions of Each of the Routines in FASP
	   --- --------- ------------ -- ---- -- --- -------- -- ----

	  The routines having asterisks following their names  in  the
	  list   below   are  used  for  the  specification  by  name,
	  examination and  modification  of  the  values  of  multiply
	  subscripted  FORTRAN  arrays  equivalenced with or otherwise
	  loaded into  singly  subscripted  buffers.   These  routines
	  share   a   common  data  base,  and  use  the  same  naming
	  conventions  for  their  arguments.   In  addition  to   the
	  routines  devoted soley to the manipulation of named arrays,
	  the routines DASITE and either  DAROLL  or  DALOOP  must  be
	  called  by  the user's program.  The latter routines use the
	  same argument naming conventions as do  the  other  routines
	  designed  for  the  manipulation of arrays by name, but were
	  written independently, and so accept a somewhat more general
	  data base.

	  DABASE *  finds the start of a particular logical  group  of
	            array    names   contained   in   the   dictionary
	            constructed by the DALOAD routine.

	  DABELT    outputs into a text buffer the representation of a
	            band  of column numbers.  The numbers can increase
	            or decrease from left to right.  Each line of  the
	            representation    can    contain   digits   either
	            corresponding to the same power of 10, or  of  the
	            same  significance.   Either the most or the least
	            significant digits can be  generated  first.   The
	            following  are  typical bands of column numbers as
	            generated by this routine.
	                 -                       ----------01234567891
	                 1---------          1   1987654321          0
	                 098765432101234567890   0

	  DACASE    converts all lower case letters in an  input  text
	            buffer  to upper case so that these letters can be
	            recognized by the other routines in FASP.

	  DACOPY    copies the contents of one input text buffer  into
	            another, expanding tab characters to enough spaces
	            to fill to the corresponding tab stops.

	  DAFILL    expands tab characters in an input text buffer  to
	            enough  spaces  to  fill  to the corresponding tab
	            stops without the use of a  separate  intermediate
	            buffer.

	  DAFLAG    locates in an input  text  buffer,  but  does  not
	            evaluate,  the  components of a file specification
	            of the general form
	            WORD:WORD.WORD[WORD,WORD]/WORD:'TEXT'/WORD:WORD
	            in  which  there  can  be  only  one  name   field
	            consisting of words connected by periods, and only
	  FASP, FORTRAN Alphameric Subroutine Package          Page 10
	  One-Paragraph Descriptions of Each of the Routines in FASP


	            one bracketed field consisting of words  connected
	            by  commas.   There  can  be several switch fields
	            starting with slashes and consisting of  words  or
	            quoted  text  strings  connected  by  colons.  Any
	            field can be missing, or can consist of any number
	            of subfields, some of which can be missing.

	  DAGRID    adjusts the limiting data unit coordinates and the
	            grid  line  separations  and  offsets  to  produce
	            neater scale numbers in the printer plots produced
	            by  DAPLAT.  DAGRID is described at the end of the
	            DAPLAT documentation.

	  DAHEFT    evaluates  the  integers  or  the   real   numbers
	            represented   in  an  input  text  buffer.   These
	            numbers can be  represented  with  decimal  points
	            and/or  in  scientific notation.  DAMISS should be
	            called instead of DAHEFT if comments  and  missing
	            numbers are to be allowed.

	  DAHELP    determines whether the input text buffer  contains
	            leading question marks.

	  DAHEST    evaluates simple commands  issued  to  interactive
	            programs.  These commands consist of a leading key
	            word followed by arguments which can  be  numbers,
	            text  strings  and/or  words.   Only  one  type of
	            argument can appear more  than  once  following  a
	            particular  command,  and extra commas between the
	            arguments indicate missing arguments of this type.
	            Several  statements  can  appear on a single line,
	            but  statements  cannot  be   continued   onto   a
	            following  line.   Each  call  to  DAHEST  returns
	            information about an entire command.

	  DAIBLT    outputs into a text buffer the representation of a
	            band  of  column  numbers.  DAIBLT is described in
	            the documentation of DABELT.  DABELT must be  used
	            instead  of  DAIBLT  if  the numbers must decrease
	            from  left  to  right  or  if  each  line  of  the
	            representation  must  contain  digits  of the same
	            significance.

	  DAIFLL    expands tab characters in an input text buffer  to
	            enough  spaces  to  fill  to the corresponding tab
	            stops without the use of a  separate  intermediate
	            buffer.   DAIFLL is described in the documentation
	            of DAFILL.  DAFILL must be used instead of  DAIFLL
	            if  initial  tabs  or spaces in the buffer must be
	            suppressed.

	  DAIHFT    evaluates the integers  represented  in  an  input
	            text   buffer.    DAIHFT   is   described  in  the
	            documentation of  DAHEFT.   DAHEFT  must  be  used
	  FASP, FORTRAN Alphameric Subroutine Package          Page 11
	  One-Paragraph Descriptions of Each of the Routines in FASP


	            instead   of   DAIHFT  if  real  numbers  must  be
	            evaluated.

	  DAIHST    evaluates simple commands  issued  to  interactive
	            programs.     DAIHST    is    described   in   the
	            documentation of  DAHEST.   DAHEST  must  be  used
	            instead   of   DAIHST  if  real  numbers  must  be
	            evaluated in  the  argument  lists  following  the
	            command words.

	  DAINXT    returns the next integer value represented by  the
	            contents of an input text buffer which can contain
	            representations  of  any  combination  of   single
	            values,  range  specifications and/or values to be
	            repeated a specified number of times.   DAINXT  is
	            described  in the documentation of DANEXT.  DANEXT
	            must be used instead of  DAINXT  if  real  numbers
	            must be evaluated.

	  DAIPAR    returns the next pair of values represented by the
	            contents   of   an  input  text  buffer.   If  the
	            representation of a third value appears after  the
	            representation of a pair of values, then the third
	            number can be interpreted as either an  additional
	            number   to   be   associated   with  the  leading
	            (leftmost) number of the previous pair, or as  the
	            leading number of a new pair.  DAIPAR is described
	            in the documentation of DAPAIR.   DAPAIR  must  be
	            used  instead  of DAIPAR if ranges of numbers must
	            be evaluated.

	  DAIRNK    returns the decimal integer values represented  by
	            the  contents  of an input text buffer, sorted and
	            excluding duplicate values.  DAIRNK  is  described
	            in  the  documentation  of DARANK.  DARANK must be
	            used instead of DAIRNK if the  values  are  to  be
	            specified as ranges of values.

	  DAISPN    interprets an input  text  buffer  containing  the
	            representation   of   a   single   integer  value,
	            specification of an integer range, or  an  integer
	            value  to be repeated a specified number of times.
	            DAISPN  is  described  in  the  documentation   of
	            DASPAN.   DASPAN must be used instead of DAISPN if
	            real numbers must be evaluated.

	  DAJOIN    evaluates the whole numbers, fractions  and  mixed
	            numbers  represented  in  an  input  text  buffer.
	            DAJOIN would return the value -3.5  if  the  input
	            text buffer contains -3 1/2.

	  DALEAD    identifies  a  command  word   and   a   following
	            associated  word  or  number or quoted text string
	            represented by  the  contents  of  an  input  text
	  FASP, FORTRAN Alphameric Subroutine Package          Page 12
	  One-Paragraph Descriptions of Each of the Routines in FASP


	            buffer.  If an associated word or number or string
	            is found without a preceding  command  word,  then
	            the  command  word identified by the previous call
	            to this routine is again identified.  An ampersand
	            at  the  right  end  of  a line indicates that the
	            items found at the start of the following line are
	            to  continue  to  be  associated  with the current
	            command  word  until  a  new   command   word   is
	            encountered.

	  DALINE    constructs printable plots  containing  horizontal
	            bars  formed  of  segments  the  lengths  of which
	            represent  the  magnitudes  of  the  corresponding
	            values.

	  DALIST *  types a summary of the array names  and  subscript
	            limits  contained in the dictionary constructed by
	            the DALOAD routine.

	  DALOAD *  reads FORTRAN statements which  would  define  the
	            dimensions  of  arrays and, from these statements,
	            constructs a dictionary which can be used  by  the
	            rest  of  the  routines  in  this  list  having an
	            asterisk to the right of their names.

	  DALONE *  outputs into a text buffer the  characters  of  an
	            array name contained in the dictionary constructed
	            by the DALOAD  routine,  together  with  either  a
	            representation  of  the  subscript  limits  of the
	            array or a representation of the current values of
	            these subscripts.

	  DALOOP    simulates  variably  embedded  DO  loops  to   any
	            desired depth.

	  DALOSS    identifies words and abbreviations appearing in an
	            input  text  buffer.   An abbreviation consists of
	            sufficient initial characters to uniquely identify
	            the  desired  word  from  all  other  words in the
	            dictionary.  Commas can  separate  the  words  and
	            extra commas can indicate missing items.  Comments
	            in the input text buffer are ignored.   DALOSS  is
	            described at the end of the DAVERB documentation.

	  DAMISS    evaluates  the  integers  or  the   real   numbers
	            represented  in  an input text buffer.  Commas can
	            separate  the  number  representations  and  extra
	            commas  can  indicate  missing items.  Comments in
	            the input text  buffer  are  ignored.   DAMISS  is
	            described at the end of the DAHEFT documentation.

	  DAMOVE    left justifies, centers or right justifies a group
	            of  characters within a larger section of the text
	            buffer in which these characters are contained.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 13
	  One-Paragraph Descriptions of Each of the Routines in FASP


	  DANAME *  finds  the  array  name  and  its  subscripts  (as
	            defined  by  the  dictionary  constructed  by  the
	            DALOAD)  routine)  associated  with  a  particular
	            location  in  the  singly  subscripted buffer with
	            which the array is equivalenced or into which  the
	            array is otherwise loaded.

	  DANEXT    returns the next numeric value represented by  the
	            contents of an input text buffer which can contain
	            the representations of any combination  of  single
	            values,  range  specifications and/or values to be
	            repeated a specified number of times.  The  values
	            10,  15,  20, -120 and -120 would be returned by 5
	            calls to this routine if  the  input  text  buffer
	            contains 10/5/20,2*-120.

	  DANUMB    outputs into a text buffer the  representation  of
	            an integer (not real) value.

	  DAPAIR    returns the next pair of values represented by the
	            contents  of  an  input text buffer.  Either value
	            can be specified as a member of a range of values.
	            If the leading value is specified as a member of a
	            range of values, if the the  associated  value  is
	            specified  either as a single value or as a member
	            of a range of values containing fewer values  than
	            the   leading   range,   and   if   an  additional
	            specification of a single value or of a  range  of
	            values  appears  to the right of the specification
	            of the associated value or range of  values,  then
	            the  additional  value  or values will be returned
	            with the remaining values of  the  initial  range.
	            The  pairs  of values 10 and 50, 15 and 60, 20 and
	            70 and 25 and 100 would be returned by 4 calls  to
	            this  routine  if  the  input text buffer contains
	            10/5/25,50/10/70,100.

	  DAPATH    outputs into a text buffer the representation of a
	            sequence   of   unsigned   integers  separated  by
	            periods.  This representation can  be  interpreted
	            by the DATREK routine.

	  DAPICK *  identifies an array name and subscript  ranges  in
	            an  input  text buffer by matching the contents of
	            the buffer against the  entries  in  a  dictionary
	            constructed by the DALOAD routine.

	  DAPLAT    generates printer or  terminal  plots  of  points,
	            point clusters and/or curves.

	  DARANK    returns the decimal integer values represented  by
	            the  contents  of an input text buffer, sorted and
	            excluding duplicate values.   The  values  can  be
	            specified as members of ranges of values.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 14
	  One-Paragraph Descriptions of Each of the Routines in FASP


	  DARITE    outputs into a text buffer the representation of a
	            real  (not integer) value in either floating point
	            notation or scientific  (exponent)  notation.   If
	            necessary,  DARITE  can alter these formats within
	            ranges specified by the calling program.

	  DAROLL    returns the next values of an integer  (not  text)
	            array  being  varied  between  a  set of lower and
	            upper bounds.  Either the lowest  or  the  highest
	            subscript  can be varied the most rapidly.  DAROLL
	            is  described  in  the  documentation  of  DALOOP.
	            DALOOP  must  be  used  instead  of  DAROLL if the
	            values in the array must be advanced in a sequence
	            other than that specified by the subscripts of the
	            array.

	  DAROME    outputs into a text buffer the  representation  in
	            Roman numeral notation of an integer value.

	  DASAVE    generates  compilable  FORTRAN   DATA   statements
	            representing  the contents of any single precision
	            array containing either  integer  values  or  text
	            characters.

	  DASHOW    outputs into a text buffer the representation of a
	            real  (not integer) value in either floating point
	            notation or scientific  (exponent)  notation.   If
	            necessary,  DASHOW  can alter these formats within
	            ranges   specified   by   the   calling   program.
	            Rightmost  zeroes  which  are  to the right of the
	            decimal point are suppressed.   DARITE  should  be
	            used  instead  of  DASHOW  if  centering  or right
	            justification or rightmost  fill  with  spaces  is
	            needed.

	  DASITE    returns the location within a  singly  dimensioned
	            buffer  (containing any data type) of a particular
	            location  within  a  multiply  subscripted   array
	            contained in the buffer.

	  DASPAN    interprets an input  text  buffer  containing  the
	            representation  of  a  single numeric value, range
	            specification or value to be repeated a  specified
	            number  of  times.  DANEXT would usually be called
	            instead of DASPAN if the values within the  range,
	            rather  than  just  a description of the range, is
	            required.

	  DASWAP    swaps 2 adjacent groups of characters in an  input
	            text  buffer  without  the  use  of  an additional
	            buffer.

	  DATALL    generates a plot with a  vertical  axis  extending
	            onto  as  many  lines  and  pages  as necessary to
	  FASP, FORTRAN Alphameric Subroutine Package          Page 15
	  One-Paragraph Descriptions of Each of the Routines in FASP


	            represent the data.

	  DATEAM    returns all  of  the  values  represented  by  the
	            contents  of  an input text buffer.  Extra commas,
	            which indicate missing values to some routine, are
	            ignored.

	  DATEXT    generates large multiple line lettering  extending
	            from  left  to right across the width of the page.
	            Also included is DAFONT, a  program  which  allows
	            user specification of character shapes.

	  DATREE    identifies the items appearing in the next line of
	            a  simple  tree  structure  in  which  the root is
	            placed in the left column, those nodes  which  lie
	            immediately  above  the  root  are  placed  in the
	            second column, those which are above the nodes  in
	            the  second column are placed in the third column,
	            and so on.

	  DATREK    evaluates   a   series   of   unsigned    integers
	            represented  by  groups  of  digits  separated  by
	            periods in an input text buffer.  A value of -1 is
	            returned  for  any  integer  which is indicated as
	            missing  by  an  initial  period,  by  a  trailing
	            period,  or  by  2  adjacent  periods.   Signs and
	            exponents are not recognized.  This representation
	            of  a series of unsigned integers can be generated
	            by the DAPATH routine.

	  DATURN    generates large multiple line lettering  extending
	            from  top  to  bottom  of page and onto subsequent
	            pages.  DATURN is described  at  the  end  of  the
	            DATEXT documentation.

	  DAVARY *  displays  the  values  contained  in   the   array
	            locations  identified  by  the DAPICK routine, and
	            accepts the user specification of  the  values  in
	            these array locations.

	  DAVERB    identifies words and abbreviations appearing in an
	            input  text  buffer.   An abbreviation consists of
	            sufficient initial characters to uniquely identify
	            the  desired  word  from  all  other  words in the
	            dictionary.  DALOSS should be  called  instead  of
	            DAVERB  if  comments  and  missing words are to be
	            allowed.


	  The  FASP  package  also  includes  the  following   support
	  programs  which  are  used  to construct the DATA statements
	  necessary for the use of  some  of  the  routines  described
	  above.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 16
	  One-Paragraph Descriptions of Each of the Routines in FASP


	  DAFONT    reads a lettering pattern file which can be easily
	            created  or  modified  by  the user, and generates
	            from this file the FORTRAN statements which define
	            a  bit  coded array which contains the information
	            needed by DATEXT and by DATURN  to  generate  this
	            style  of  lettering.   DAFONT is described at the
	            end of the DATEXT documentation.

	  DAMENU    reads a file containing the words which are to  be
	            recognized  by  DAVERB,  or  by  any routine which
	            calls DAVERB, and generates the FORTRAN statements
	            which define this dictionary.  DAMENU can maintain
	            the array of  argument  types  to  be  allowed  by
	            DAHEST  parallel  to  the words in the dictionary.
	            DAMENU  is   described   at   the   end   of   the
	            documentation of DAHEST.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 17
	  Routines in FASP Used to Evaluate Typical Lines of Text


	    Routines in FASP Used to Evaluate Typical Lines of Text
	    -------- -- ---- ---- -- -------- ------- ----- -- ----

	  Several typical lines of text which could be interpreted  by
	  the  routines in this package are listed below together with
	  descriptions of the results which would be returned  to  the
	  calling  program.   The exclamation point is used in some of
	  the examples to start comments, but is not supported by  the
	  more primitive routines such as DAHEFT, DAVERB and DATREK.

	  -7366.2
	      or
	  -7.3662K
	      or
	  -7.3662E3

	      evaluated by DAHEFT, or by most of  the  routines  which
	      call  DAHEFT  (some  don't  allow  octal),  as  an octal
	      integer having the decimal value -3830 (- 7x512 - 3x64 -
	      6x8  - 6) or as a decimal integer having the value -7366
	      or as a decimal real having -7366.2 as its value.

	      DARITE can represent the real value -7366.2  in  any  of
	      the forms shown in the above examples.

	  -1/2

	      evaluated by DAJOIN as a decimal real having -0.5 as its
	      value.

	      evaluated by DANEXT as the sequence of octal integers or
	      of  decimal  integers  or  of  decimal  reals having the
	      values -1, 0, 1 and 2.  An increment of 1 is assumed.

	  -1 3/5

	      evaluated by DAJOIN as a decimal real having -1.6 as its
	      value.   This  interpretation  does  not  allow  a comma
	      between the -1 and the 3.

	      evaluated by DANEXT as the sequence of octal integers or
	      of  decimal  integers  or  of  decimal  reals having the
	      values -1, 3, 4 and 5.  A comma could appear between the
	      -1 and the 3.

	      evaluated by DAPAIR as the pair of octal integers or  of
	      decimal  integers  or of decimal reals having the values
	      -1 and 3, followed by the initial -1 associated with the
	      values  4  and  5 in turn.  A comma could appear between
	      the -1 and the 3.

	  FASP, FORTRAN Alphameric Subroutine Package          Page 18
	  Routines in FASP Used to Evaluate Typical Lines of Text


	  1.5377E5,,-1 3/5!ANY CHARACTERS FORMING COMMENT

	      evaluated by DAJOIN as a decimal real having  the  value
	      153770  followed by a missing number and then by a mixed
	      fraction having the value -1.6.

	      evaluated by DANEXT as a leading  octal  integer  having
	      the  value  55288 or as a leading decimal integer having
	      the value 153770 or as a leading decimal real having the
	      value  153770,  the  leading  number being followed by a
	      missing item indicated  by  the  extra  comma  and  then
	      followed by a sequence having the values -1, 3, 4 and 5.

	  20/5/40!ANY CHARACTERS FORMING COMMENT

	      evaluated by DANEXT as the sequence of decimal  integers
	      or of decimal reals having the values 20, 25, 30, 35 and
	      40 or as the  sequence  of  octal  integers  having  the
	      decimal values 16, 21, 26 and 31.

	  5*-100!ANY CHARACTERS FORMING COMMENT

	      evaluated by  DANEXT  as  5  occurrences  of  a  decimal
	      integer  having  the  value  -100  or  of a decimal real
	      having the value -100 or of an octal integer having  the
	      decimal value -64.

	  44.120.0

	      evaluated by DATREK as the sequence of unsigned  decimal
	      integers having the values 44, 120 and 0.

	      DAPATH can represent the sequence  of  unsigned  decimal
	      integers having the values 44, 120 and 0 in this form.

	  -12 70 16 4!ANY CHARACTERS FORMING COMMENT

	      evaluated by DAPAIR as the pair of decimal  integers  or
	      of  decimal  reals having the values -12 and 70 followed
	      by the pair having the values 16 and 4, or as  the  pair
	      of octal integers having the decimal values -10 (- 1x8 -
	      2) and 56 (7x8) followed by the pair having the  decimal
	      values 14 (1x8 + 6) and 4.  A comma could appear between
	      any of the number representations.

	      evaluated by DAPAIR alternatively as a  decimal  integer
	      or  as  a  decimal  real  having  the value -12 which is
	      associated in turn with each of the numbers 70, 16 and 4
	      or  as  an  octal  integer  having the decimal value -10
	      which is associated in  turn  with  numbers  having  the
	      decimal  values  56,  14  and  4.   A comma could appear
	      between any of the number representations.

	      evaluated by DAMISS or by DATEAM or  by  DANEXT  as  the
	  FASP, FORTRAN Alphameric Subroutine Package          Page 19
	  Routines in FASP Used to Evaluate Typical Lines of Text


	      sequence  of decimal integers or of decimal reals having
	      the values -12, 70, 16 and 4,  or  as  the  sequence  of
	      octal integers having the decimal values -10, 56, 14 and
	      4.  A comma could  appear  between  any  of  the  number
	      representations.

	  10/5/20 100 200 300!ANY CHARACTERS FORMING COMMENT

	      evaluated by DAPAIR as the pair of decimal  integers  or
	      of  decimal reals having the values 10 and 100, followed
	      by the pair having the values 15 (5  is  the  increment)
	      and 200 and finally by the pair having the values 20 and
	      300, or as the pair of octal integers having the decimal
	      values 8 and 64, followed by the pair having the decimal
	      values 13 (octal 10 plus 5)  and  128.   A  comma  could
	      appear  between the 20 and the 100 or between any of the
	      following number representations.  If the evaluation  is
	      done  in  octal, then the 13 exhausts the first range of
	      numbers so that the  octal  300  (decimal  192)  can  be
	      associated  with  an  additional  13 or can be the first
	      number of the following pair of numbers.

	      evaluated by DANEXT as the sequence of decimal  integers
	      or  of  decimal reals having the values 10, 15, 20, 100,
	      200 and 300 or as the sequence of octal integers  having
	      the  decimal  values  8,  13,  64, 128 and 192.  A comma
	      could appear between the 20 and the 100 or  between  any
	      of the following number representations.

	  20/5/10 -400/100/-200!ANY CHARACTERS FORMING COMMENT

	      evaluated by DAPAIR as the pair of decimal  integers  or
	      of decimal reals having the values 20 and -400, followed
	      by the pair having the values 15 and -300 and finally by
	      the  pair  having the values 10 and -200, or as the pair
	      of octal integers having the decimal values 16 and  -256
	      (-  4x64) followed by the pair having the decimal values
	      11 (octal 20 minus 5) and -192 (octal  -400  plus  octal
	      100).  A comma could appear between the 10 and the -400.
	      If the evaluation is done in octal, then the 11 exhausts
	      the first range of numbers so that the octal -200 can be
	      associated with an additional 11 or  can  be  the  first
	      number of the following pair of numbers.

	      evaluated by DANEXT as the sequence of decimal  integers
	      or  of decimal reals having the values 20, 15, 10, -400,
	      -300 and -200 or  as  the  sequence  of  octal  integers
	      having  the  decimal values 16, 11, -256, -192 and -128.
	      A comma could appear between the 10 and the -400.

	  FASP, FORTRAN Alphameric Subroutine Package          Page 20
	  Routines in FASP Used to Evaluate Typical Lines of Text


	  WORD

	      identified by DAVERB or by DALOSS by matching  the  word
	      against all of the words in a dictionary supplied by the
	      calling  program.   DAVERB   can   also   identify   any
	      abbreviation which uniquely selects the word.

	  WORD,,WORD!ANY CHARACTERS FORMING COMMENT

	      identified by DALOSS as an appearance of the word  named
	      WORD,  followed by a missing item indicated by the extra
	      comma, and then by an appearance of the word named WORD.

	  COMMAND 5.3 WORD 'QUOTED TEXT STRING'!ANY COMMENT

	      evaluated by DALEAD or by DAHEST  as  the  command  word
	      named COMMAND followed by the associated decimal integer
	      having the value 5 or by  the  associated  decimal  real
	      having  the  value  5.3, followed by the word named WORD
	      associated with the same command and then  by  the  text
	      between the delimiting apostrophes again associated with
	      the same command.  If evaluated by DALEAD, commas  could
	      appear  between the command and the first following item
	      or between the following items,  and  the  number  could
	      also  be evaluated as an octal integer.  If evaluated by
	      DAHEST, a  comma  between  the  command  and  the  first
	      following  item  would indicate a missing item, and 2 or
	      more commas between any pair of  following  items  would
	      similarly indicate 1 or more missing items.

	  ARRAY(12,3/5)=-10.2,16E-3,3K!ANY CHARACTERS FORMING COMMENT

	      The combination of DAPICK and DAVARY used together  with
	      several  other routines would evaluate the above text as
	      the  instructions   to   set   ARRAY(12,3)   to   -10.2,
	      ARRAY(12,4)  to  0.016  and  ARRAY(12,5)  to  3000.  The
	      numbers appearing to the right of the equals sign  could
	      also  be  evaluated  as  octal  integers  or  as decimal
	      integers if indicated by the dictionary which  describes
	      the named array.

	  DEVICE:NAME.NAME[NUMBER,NUMBER]/OPTION:NUMBER/OPTION:'TEXT'

	      DAFLAG locates but  does  not  evaluate  or  verify  the
	      component  parts  of a PDP-10 file specification such as
	      that shown above.  The name field can consist of several
	      words  separated  by  periods.   The bracketed field can
	      contain several numbers or words  separated  by  commas.
	      The several option fields can each contain several words
	      or numbers or quoted text strings separated by colons.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 21
	  Character Set Used by these Routines


	            The Character Set Used by these Routines
	            --- --------- --- ---- -- ----- --------

	  Although the logic of  the  routines  in  this  package  was
	  written  in  simple,  machine independent FORTRAN, character
	  sets are not standardized.  In addition  to  the  space  (or
	  blank),  the  upper  and lower case letters of the alphabet,
	  and the characters customarily used for  the  representation
	  of  numbers in scientific notation, the following characters
	  are also used

	     / (slash)  used  in  range  specifications  to   separate
	       starting  value  from increment from final value.  Used
	       in fractions to separate  numerator  from  denominator.
	       Used  in  a  file  specification  to  start each switch
	       field.

	     * (asterisk) used in a range  specification  to  separate
	       the  number  of  times  a  particular  value  is  to be
	       repeated  from   the   value   itself.    In   a   file
	       specification  interpreted  by the DAFLAG routine, each
	       appearance of the asterisk becomes a separate component
	       of the corresponding field even if not separated within
	       the text from  the  other  characters  which  form  the
	       field.

	     ' (apostrophe) used to mark the start  and  end  of  text
	       strings  which  appear  either  as  the  argument  of a
	       command or as the  argument  of  a  switch  in  a  file
	       specification.

	     ! (exclamation) used to indicate that  the  remainder  of
	       the  buffer  contents  are  to be ignored.  Used by the
	       plotting routines  for  the  ruling  of  vertical  grid
	       lines.

	     & (ampersand) used to indicate that the remainder of  the
	       buffer  contents  are  to be ignored, but that the user
	       intends to continue input on the following line.   Used
	       by    the   plotting   routines   to   indicate   curve
	       intersections and superimposed points.

	     ; (semicolon)  used  to   separate   commands   or   file
	       specifications typed on the same line.

	     , (comma) used to separate adjacent words and/or  numbers
	       in  a  list.   Used  to  separate  the  arguments  of a
	       command.  Used in a file specification to separate  the
	       components  of  a  bracketed  field.  Used by the named
	       array manipulation routines to separate the  subscripts
	       of an array.

	     = (equal) used by the named array  manipulation  routines
	       to  separate  the  identification  of an array location
	  FASP, FORTRAN Alphameric Subroutine Package          Page 22
	  Character Set Used by these Routines


	       from the value to be inserted into that location.  Used
	       in  a  file  specification to separate destination file
	       from source file.

	     % (percent) used to indicate  that  a  number  is  to  be
	       divided by 100.

	     [ (left square bracket) used in a file  specification  to
	       start  a  bracketed  field.   A  DATA  statement in the
	       DAFLAG routine defines this character in  1H  notation.
	       A  second  DATA  statement which has been commented out
	       with  a  C  in  column  1  contains  the  octal   value
	       corresponding to 5H[ on the PDP10, and must be restored
	       if this routine is compiled using the F40 compiler.

	     ] (right square bracket) used in a file specification  to
	       end  a bracketed field.  A DATA statement in the DAFLAG
	       routine defines  this  character  in  1H  notation.   A
	       second DATA statement which has been commented out with
	       a C in column 1 contains the octal value  corresponding
	       to  5H]  on  the  PDP10,  and  must be restored if this
	       routine is compiled using the F40 compiler.

	     ( (left parenthesis) used by the named array manipulation
	       routines  to  begin the specification of the subscripts
	       of an array.  Used by DAHEST to mark  the  start  of  a
	       text  string  which will be terminated by a matching ),
	       or as the terminator of such a text  string  which  has
	       been begun by an initial ).

	     ) (right parenthesis)   used   by   the    named    array
	       manipulation routines to terminate the specification of
	       the subscripts of an array.  Used by DAHEST to mark the
	       start  of  a  text string which will be terminated by a
	       matching (, or as the terminator of such a text  string
	       which has been begun by an initial (.

	     : (colon)  used  in  range  specifications  to   separate
	       starting  value  from increment from final value.  Used
	       in a file specification to terminate a device  name  or
	       to separate the components of a switch field.

	     @ (at) used in a file specification to indicate that  the
	       file   being   specified   itself   contains   a   file
	       specification.

	     $ (dollar) used within text strings  being  converted  to
	       large printable lettering to mark a following character
	       which is to be treated as a command rather  than  as  a
	       character to be represented.

	     - (minus) in addition to its traditional use to  indicate
	       that  the  number appearing immediately to its right is
	       negative, the  minus  sign  is  used  by  the  plotting
	  FASP, FORTRAN Alphameric Subroutine Package          Page 23
	  Character Set Used by these Routines


	       routines for the ruling of horizontal grid lines.

	     + (plus) in addition to its traditional use  to  indicate
	       that  the  number appearing immediately to its right is
	       positive,  the  plus  sign  is  used  by  the  plotting
	       routines for the marking of grid line intersections.

	     ? (question) typed by the user at the start of a line  to
	       request assistance.

	   tab (nonprinting horizontal tabulation) equivalent  to  one
	       or  more  spaces  such  that  the  next character would
	       appear beyond the next whole number multiple of the tab
	       stop  interval.   Each  test  for  a  tab  character is
	       preceded by a test for a space  (blank).   If  the  tab
	       character  is  not  available,  the variable named ITAB
	       should in each routine in which it appears  be  defined
	       as  a Hollerith space character rather than a Hollerith
	       tab character.

	  In some cases, such as the inclusion of an @ sign or =  sign
	  in  a file specification, the FASP routines merely report to
	  the calling program that the character was found, and it  is
	  the  responsibility  of  the  calling  program  to  take the
	  appropriate action.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 24
	  Characters Recognized by Interpretative Routines in FASP


	    Characters Recognized by Interpretative Routines in FASP
	    ---------- ---------- -- -------------- -------- -- ----

	  The most primitive routines in FASP  recognize  no  printing
	  characters  other than those which can form numbers or which
	  are contained in words in the  dictionary  supplied  by  the
	  calling  program.   Most  of  the  routines which call these
	  primitives allow punctuation characters such  as  the  comma
	  between  adjacent  items,  the  semicolon  between  adjacent
	  statements on a single line, the exclamation point before  a
	  comment, and the ampersand before a comment when the current
	  statement is to  be  continued  onto  the  next  line.   The
	  special  printing  characters  recognized  by  each  of  the
	  interpretative routines in FASP  are  listed  in  the  table
	  below.   The  routines  devoted to the manipulation of named
	  arrays are not included in this table.

	  DAFLAG                      . * / : , ; ! & ' [ ] @ =

	  DAHEFT       0-9  EKM%  + - .
	  DAIHFT       0-9  EKM%  + - .

	  DAHELP                                                    ?

	  DAHEST  A-Z  0-9  EKM%  + - .   / : , ; !   '         ( )
	  DAIHST  A-Z  0-9        + -     / : , ; !   '         ( )

	  DAJOIN       0-9  EKM%  + - .   /

	  DALEAD  A-Z  0-9  EKM%  + - .       , ; ! & '

	  DALOSS  A-Z                         , ; ! &

	  DAMISS       0-9  EKM%  + - .       , ; ! &

	  DANEXT       0-9  EKM%  + - . * / : , ; ! &
	  DAINXT       0-9        + -   * / : , ; ! &

	  DAPAIR       0-9  EKM%  + - . * / : , ; ! &
	  DAIPAR       0-9  EKM%  + - .       , ; ! &

	  DARANK       0-9  EKM%  + - . * / : , ; ! &
	  DAIRNK       0-9  EKM%  + - .       , ; ! &

	  DASPAN       0-9  EKM%  + - . * / : , ; ! &
	  DAISPN       0-9        + -   * / : , ; ! &

	  DATEAM       0-9  EKM%  + - .       , ; ! &

	  DATREK       0-9            .

	  DAVERB  A-Z
	  FASP, FORTRAN Alphameric Subroutine Package          Page 25
	  Calling Hierarchies and Sizes of the FASP Routines


	       Calling Hierarchies and Sizes of the FASP Routines
	       ------- ----------- --- ----- -- --- ---- --------

	  For each of the routines listed in the left  column  in  the
	  following  table,  the routines named to its right must also
	  be  loaded.   The  externally  called  routines  are  listed
	  alphabetically except for those routines which have names in
	  which the third letter is I, these being listed  just  below
	  the corresponding routine with real number capabilities.  In
	  parentheses to the right of each routine name is the  number
	  of FORTRAN statements, both executable and nonexecutable but
	  excluding comments,  in  that  particular  routine.   As  an
	  example, the table entry

	  DATALL(119)-DAPLAT(455)-DARITE(312)
	                         -PLTCUT( 61)

	  indicates that DATALL which contains 119 FORTRAN statements,
	  calls DAPLAT which contains 455 statements and which in turn
	  calls the 2 routines DARITE and PLTCUT.

	  DABASE( 36)

	  DABELT(133)
	  DAIBLT( 66)

	  DACASE( 29)

	  DACOPY( 44)

	  DAFILL( 82)
	  DAIFLL( 58)

	  DAFLAG(205)

	  DAGRID( 90)

	  DAHEFT(177)
	  DAIHFT(149)

	  DAHELP( 14)

	  DAHEST(328)-DAHEFT(177)
	             -DAVERB(112)
	  DAIHST(322)-DAVERB(112)

	  DAJOIN( 82)-DAHEFT(177)

	  DALEAD(104)-DAHEFT(177)
	             -DAVERB(112)

	  DALINE(263)-DARITE(312)

	  DALIST( 42)-DALONE( 75)-DANUMB( 62)
	  FASP, FORTRAN Alphameric Subroutine Package          Page 26
	  Calling Hierarchies and Sizes of the FASP Routines


	  DALOAD(271)

	  DALONE( 75)-DANUMB( 62)

	  DALOOP( 76)

	  DALOSS( 49)-DAVERB(112)

	  DAMISS( 54)-DAHEFT(177)

	  DAMOVE( 33)

	  DANAME( 69)

	  DANEXT( 83)-DASPAN(120)-DAHEFT(177)
	  DAINXT( 42)-DAISPN(118)

	  DANUMB( 62)

	  DAPAIR(146)-DANEXT( 83)-DASPAN(120)-DAHEFT(177)
	  DAIPAR( 98)-DAHEFT(177)

	  DAPATH( 25)-DAMOVE( 33)
	             -DANUMB( 62)

	  DAPICK(199)

	  DAPLAT(455)-DARITE(312)
	             -PLTCUT( 61)

	  DARANK( 88)-DANEXT( 83)-DASPAN(120)-DAHEFT(177)
	  DAIRNK( 60)-DAMISS( 54)-DAHEFT(177)

	  DARITE(312)

	  DAROME( 71)

	  DASAVE(230)-DABOTH( 42)-DANUMB( 62)
	             -DANUMB( 62)

	  DASHOW( 23)-DANUMB( 62)
	             -DARITE(312)

	  DASITE( 76)

	  DASPAN(120)-DAHEFT(177)
	  DAISPN(118)

	  DASWAP( 25)

	  DATALL(119)-DAPLAT(455)-DARITE(312)
	                         -PLTCUT( 61)

	  DATEAM( 38)-DAHEFT(177)
	  FASP, FORTRAN Alphameric Subroutine Package          Page 27
	  Calling Hierarchies and Sizes of the FASP Routines


	  DATEXT(269)-one font of approximately 20 statements *

	  DATREE(105)

	  DATREK( 43)

	  DATURN(273)-one font of approximately 20 statements *

	  DAVARY( 58)-DANEXT( 83)-DASPAN(120)-DAHEFT(177)
	             -DANUMB( 62)
	             -DARITE(312)

	  DAVERB(112)

	  * The fonts contain descriptions of  the  character  shapes,
	    and are named TEXT1, TEXT2, TEXT3 and so on.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 28
	  An Introduction to Character Manipulation in FORTRAN


	      An Introduction to Character Manipulation in FORTRAN
	      -- ------------ -- --------- ------------ -- -------

	  Interactive programs often allow the user to select one item
	  from  a  group of possible choices.  The easiest way for the
	  programmer to provide this feature is to assign a  different
	  number to each possible choice, then to have the program ask
	  for and accept the number.  This places upon  the  user  the
	  burden  either  of  remembering  or  of  finding  the number
	  corresponding to the item  being  selected.   Using  such  a
	  method,  a  typical  interaction  with  the  user  could  be
	  performed by the FORTRAN statements (in which the $  in  the
	  format merely allows the user to answer on the same line)

	      1 TYPE 2
	      2 FORMAT(' METHOD OF SHIPMENT (TYPE 0 FOR LIST)? ',$)
	        ACCEPT 3,METHOD
	      3 FORMAT(I)
	        IF((METHOD.GT.0).AND.(METHOD.LE.3))GO TO 5
	        TYPE 4
	      4 FORMAT(' POSSIBLE CHOICES ARE:'/
	       1' 1 TRUCK'/
	       2' 2 TRAIN'/
	       3' 3 PLANE')
	        GO TO 1
	      5 CONTINUE

	  The sample question would be easier to answer  correctly  if
	  the  words  TRUCK,  TRAIN  and PLANE could be typed directly
	  instead of the numbers selecting these  responses.   If  the
	  accepted  words  are  selected  to each begin with different
	  letters, then a single letter response can be read  with  an
	  A1  format.  In the above example, the words TRUCK and TRAIN
	  both start with the letter T, but  the  TRAIN  response  can
	  instead  be  changed  to  RAIL.   The  FORTRAN statements to
	  perform the interaction could then be rewritten

	        DIMENSION LETTER(3)
	        DATA LETTER/1HT,1HR,1HP/
	      1 TYPE 2
	      2 FORMAT(' METHOD OF SHIPMENT? ',$)
	        ACCEPT 3,IRSPNS
	      3 FORMAT(1A1)
	        METHOD=1
	      4 IF(IRSPNS.EQ.LETTER(METHOD))GO TO 6
	        METHOD=METHOD+1
	        IF(METHOD.LE.3)GO TO 4
	        TYPE 5
	      5 FORMAT(' POSSIBLE CHOICES ARE:'/
	       1' TRUCK'/
	       2' RAIL'/
	       3' PLANE')
	        GO TO 1
	      6 CONTINUE
	  FASP, FORTRAN Alphameric Subroutine Package          Page 29
	  An Introduction to Character Manipulation in FORTRAN


	  Free format responses are not accepted by the above  FORTRAN
	  statements.   The  identifying  character  must be the first
	  character typed by the user.  The response is not recognized
	  if   preceded   by   a  space.   This  difficulty  could  be
	  circumvented by reading the response with a larger A format,
	  perhaps A4, and testing against the possible sequences

	            4HT   ,4H T  ,4H  T ,4H   T
	            4HR   ,4H R  ,4H  R ,4H   R
	            4HP   ,4H P  ,4H  P ,4H   P

	  However, the user who typed more  than  a  single  character
	  abbreviation  would  find  that  such  a  response  would be
	  rejected, so the range of character sequences tested against
	  for  just  the  single  word TRUCK would have to be expanded
	  still further to include

	            4HT   ,4H T  ,4H  T ,4H   T
	            4HTR  ,4H TR ,4H  TR
	            4HTRU ,4H TRU
	            4HTRUC

	  Such a scheme becomes impractical.  An alternative method is
	  to  read  the user's response into an array, 1 character per
	  array location, with a multiple of an A1 format.  If, as  is
	  probable, the user types fewer characters than the array can
	  hold, then spaces are placed into the array locations to the
	  right  of  (having  higher subscripts than) those containing
	  the characters actually typed.  The FORTRAN statements shown
	  below  can  then  search for the first printing character in
	  the array.

	        DIMENSION LETTER(3),IRSPNS(10)
	        DATA ISPACE/1H /,LETTER/1HT,1HR,1HP/
	      1 TYPE 2
	      2 FORMAT(' METHOD OF SHIPMENT? ',$)
	        ACCEPT 3,IRSPNS
	      3 FORMAT(10A1)
	        INITAL=1
	      4 IF(IRSPNS(INITAL).NE.ISPACE)GO TO 5
	        IF(INITAL.GE.10)GO TO 7
	        INITAL=INITAL+1
	        GO TO 4
	      5 METHOD=1
	      6 IF(IRSPNS(INITAL).EQ.LETTER(METHOD))GO TO 9
	        METHOD=METHOD+1
	        IF(METHOD.LE.3)GO TO 6
	      7 TYPE 8
	      8 FORMAT(' POSSIBLE CHOICES ARE:'/
	       1' TRUCK'/
	       2' RAIL'/
	       3' PLANE')
	        GO TO 1
	      9 CONTINUE
	  FASP, FORTRAN Alphameric Subroutine Package          Page 30
	  An Introduction to Character Manipulation in FORTRAN


	  If the program must accept either an alphabetic or a numeric
	  response  to the question, then the first printing character
	  must also be compared with each of the possible digits.   If
	  a  digit  is found, then the currently stored numeric value,
	  if any, must be shifted, and the  value  of  the  new  digit
	  inserted into the least significant end of the stored value,
	  following which the next character typed by the user must be
	  similarly   tested.   Either  an  alphabetic  or  a  numeric
	  response is identified by the following FORTRAN statements

	        DIMENSION LETTER(3),IRSPNS(10),IDIGIT(10)
	        DATA IDIGIT/1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9/
	        DATA ISPACE/1H /,LETTER/1HT,1HR,1HP/
	  C
	  C     ASK FOR AND ACCEPT RESPONSE
	      1 TYPE 2
	      2 FORMAT(' METHOD OF SHIPMENT OR MONTHS TO STORE? ',$)
	        ACCEPT 3,IRSPNS
	      3 FORMAT(10A1)
	  C
	  C     LOOK FOR FIRST PRINTING CHARACTER
	        INITAL=1
	      4 IF(IRSPNS(INITAL).NE.ISPACE)GO TO 5
	        IF(INITAL.GE.10)GO TO 10
	        INITAL=INITAL+1
	        GO TO 4
	  C
	  C     CHECK FOR WORDS TRUCK, RAIL AND PLANE
	      5 METHOD=1
	      6 IF(IRSPNS(INITAL).EQ.LETTER(METHOD))GO TO 12
	        METHOD=METHOD+1
	        IF(METHOD.LE.3)GO TO 6
	        MONTHS=0
	  C
	  C     CHECK IF NUMBER ISSUED INSTEAD OF TRANSFER METHOD
	      7 LTRTST=IRSPNS(INITAL)
	        DO 8 JDIGIT=1,10
	        IF(LTRTST.NE.IDIGIT(JDIGIT))GO TO 8
	        MONTHS=(10*MONTHS)+JDIGIT-1
	        INITAL=INITAL+1
	        IF(INITAL.LE.10)GO TO 7
	        GO TO 9
	      8 CONTINUE
	      9 IF(MONTHS.GT.0)GO TO 12
	  C
	  C     PROMPT USER IF WRONG RESPONSE GIVEN
	     10 TYPE 11
	     11 FORMAT(' POSSIBLE CHOICES ARE:'/
	       1' TRUCK'/
	       2' RAIL'/
	       3' PLANE'/
	       4' OR NUMBER OF MONTHS WHICH PRODUCT IS TO BE STORED')
	        GO TO 1
	     12 CONTINUE
	  FASP, FORTRAN Alphameric Subroutine Package          Page 31
	  An Introduction to Character Manipulation in FORTRAN


	  The appearance of a  similar  group  of  FORTRAN  statements
	  after  each  question  for  the  identification  of the user
	  response might be acceptable if only  a  few  questions  are
	  asked  by the entire program.  However, if the program is to
	  ask many questions, then it becomes reasonable  to  separate
	  the   evaluation   statements   into  one  or  more  general
	  subroutines which are called whenever  a  response  must  be
	  evaluated.  Each subroutine can then do much more evaluation
	  and validation since the statements appear only  within  the
	  subroutines  rather  than  being  duplicated  at many sites.
	  FASP includes several  such  subroutines.   Calling  two  of
	  these   subroutines,   DALOSS  for  the  identification  and
	  validation  of  words  and  DAHEFT  for  the  evaluation  of
	  numbers, the FORTRAN statements shown above can be rewritten

	        DIMENSION LETTER(14),KNTLTR(3),IRSPNS(10)
	        DATA LETTER/1HT,1HR,1HU,1HC,1HK,1HR,1HA,1HI,1HL,
	       11HP,1HL,1HA,1HN,1HE/,KNTLTR/5,4,5/
	  C
	  C     ASK FOR AND ACCEPT RESPONSE
	      1 TYPE 2
	      2 FORMAT(' METHOD OF SHIPMENT OR MONTHS TO STORE? ',$)
	        ACCEPT 3,IRSPNS
	      3 FORMAT(10A1)
	        INITAL=1
	        MANY=0
	  C
	  C     CHECK FOR WORDS TRUCK, RAIL AND PLANE
	      4 CALL DALOSS(1,14,LETTER,1,3,KNTLTR,IRSPNS,10,INITAL,
	       1KIND,METHOD,LCNWRD,LCNKNT,LCNBFR,MANY,LCNERR)
	        GO TO(1,5,8,8,6,6,6,6,4,1,4),KIND
	  C
	  C     CHECK IF NUMBER ISSUED INSTEAD OF TRANSFER METHOD
	      5 METHOD=4
	        CALL DAHEFT(0,1,0,IRSPNS,10,INITAL,KIND,
	       1ISHIFT,JSHIFT,KSHIFT,LSHIFT,MONTHS,VALUE)
	        IF(KIND.NE.3)GO TO 6
	        IF(MONTHS.GT.0)GO TO 8
	  C
	  C     PROMPT USER IF WRONG RESPONSE GIVEN
	      6 TYPE 7
	      7 FORMAT(' POSSIBLE CHOICES ARE:'/
	       1' TRUCK'/
	       2' RAIL'/
	       3' PLANE'/
	       4' OR NUMBER OF MONTHS WHICH PRODUCT IS TO BE STORED')
	        GO TO 1
	      8 CONTINUE

	  Through the use of  the  FASP  routines,  abbreviations  are
	  rejected  if ambiguous or if misspelled, numbers can include
	  sign and decimal point and exponent,  and  comments  can  be
	  included  to  the  right  of  either  exclamation  points or
	  ampersands.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 32
	  DABASE, Routine to Locate Logical Group of Named Arrays


	  DDDDD          AAA  BBBBBB          AAA    SSSSSS  EEEEEEEE
	  DD   DD       AAAA  BB    BB       AAAA  SS        EE
	  DD    DD     AA AA  BB    BB      AA AA  SS        EE
	  DD    DD    AA  AA  BBBBBB       AA  AA    SSSS    EEEEE
	  DD    DD   AAAAAAA  BB    BB    AAAAAAA        SS  EE
	  DD   DD   AA    AA  BB    BB   AA    AA        SS  EE
	  DDDDD    AA     AA  BBBBBB    AA     AA  SSSSSS    EEEEEEEE



	    DABASE, Routine to Locate Logical Group of Named Arrays
	    ------  ------- -- ------ ------- ----- -- ----- ------

	  DABASE locates a desired logical group of array names within
	  the  dictionary which is created by DALOAD and which is used
	  by several other  routines  in  the  FASP  package  for  the
	  manipulation  of  multiply  subscripted  arrays equivalenced
	  with or otherwise loaded into a singly  subscripted  buffer.
	  DABASE  can  identify  the logical group by its name, by its
	  position in the dictionary relative  to  the  other  logical
	  groups,  or  by a particular value being stored as subscript
	  range information associated with the name.

	  After DABASE has located the logical  group  of  names,  the
	  routine  DANAME can be called to identify the array name and
	  subscripts associated with a known location  in  the  singly
	  subscripted  buffer.   The  combination of DABASE and DANAME
	  enable a program to cycle through  the  data  base  in  some
	  predetermined  fashion.   Typical applications of DABASE and
	  DANAME would be to allow a program to  report  the  non-zero
	  values  in its common blocks, or in the writing of a program
	  to compare the values in  data  files  containing  different
	  versions of the values to be loaded into such common blocks.



	                    The DABASE Argument List
	                    --- ------ -------- ----

	  The argument list of routine DABASE is

	        SUBROUTINE DABASE(LOCATE,LTRLFT,LTRRIT,LTRNAM,IVALUE,
	       1    LTRLOW,LTRUSD,LTRSTR,NUMLOW,NUMUSD,NUMSTR,LRGLTR,
	       2    LRGNUM,LRGKNT)

	  with the associated DIMENSION statement

	        DIMENSION LTRNAM(LTRRIT),LTRSTR(LTRUSD),NUMSTR(NUMUSD)

	  The following are input arguments left unchanged.

	  LOCATE = identifies how the logical group of array names  is
	           to be selected.
	         = -1, look for the logical group having as  its  name
	  FASP, FORTRAN Alphameric Subroutine Package          Page 33
	  DABASE, Routine to Locate Logical Group of Named Arrays


	           the characters stored in LTRNAM(LTRLFT) through and
	           including LTRNAM(LTRRIT).  The name of the  logical
	           group  is the name appearing between slashes at the
	           start of the specification of the contents  of  the
	           group   as   read   by  the  DALOAD  routine.   The
	           characters in LTRNAM are  stored  1  character  per
	           array  location  as read by a multiple of A1 format
	           or defined by  several  1H  fields.   The  name  in
	           LTRNAM(LTRLFT) through and including LTRNAM(LTRRIT)
	           must match the name of the logical  group  exactly.
	           Abbreviations   are   not  recognized,  and  excess
	           characters  prevent  a  match.   If  a   particular
	           logical group is not named, then that logical group
	           cannot be identified in this manner.
	         = 0, look for the logical group the position of which
	           relative  to  all  logical groups in the dictionary
	           matches the value input  in  argument  IVALUE.   If
	           IVALUE  has  the  value  4, then the fourth logical
	           group in the dictionary would be searched for.
	         = greater than  zero,  search  for  a  logical  group
	           having  a  value  equal  to  the input value of the
	           argument IVALUE  in  the  subscript  range  storage
	           location   identified   by  the  value  of  LOCATE.
	           LOCATE=1 would test against the lower bound of  the
	           first  subscript, =2 against the upper bound of the
	           first subscript, and =4 against the upper bound  of
	           the  second  subscript.   If  the  subscript  range
	           information associated with  a  particular  logical
	           group  contains  less than LOCATE values, then that
	           logical group cannot be identified in this manner.

	  LTRLFT = subscript of the LTRNAM array  location  containing
	           the  first  character  of  the  name  to be matched
	           against if LOCATE=-1.

	  LTRRIT = subscript of the LTRNAM array  location  containing
	           the  final  character  of  the  name  to be matched
	           against if LOCATE=-1.

	  LTRNAM = array  containing   in   locations   LTRNAM(LTRLFT)
	           through and including LTRNAM(LTRRIT) the characters
	           of the name to be  matched  against  if  LOCATE=-1.
	           The characters in LTRNAM are stored 1 character per
	           array location as read  by  a  multiple  of  an  A1
	           format or defined by several 1H fields.

	  IVALUE = the sequence number of  the  logical  group  to  be
	           found  (the count relative to all logical groups in
	           the dictionary) if LOCATE=0.
	         = the value to be matched against  in  the  subscript
	           range  storage  location identified by the value of
	           LOCATE if LOCATE is greater than zero.

	  LTRLOW = lowest subscript of the  locations  in  the  LTRSTR
	  FASP, FORTRAN Alphameric Subroutine Package          Page 34
	  DABASE, Routine to Locate Logical Group of Named Arrays


	           array containing the characters of the names in the
	           dictionary as originally read  by  DALOAD  using  a
	           multiple  of an A1 format.  LTRSTR(LTRLOW) contains
	           either the first letter of the name  of  the  first
	           logical  group  of  names in the dictionary or else
	           (if the first group itself isn't named)  the  first
	           letter  of  the first name within the first logical
	           group in the dictionary.

	  LTRUSD = highest subscript of the locations  in  the  LTRSTR
	           array containing the characters of the names in the
	           dictionary as originally read  by  DALOAD  using  a
	           multiple  of an A1 format.  LTRSTR(LTRUSD) contains
	           the  last  character  of  the  last  name  in   the
	           dictionary.

	  LTRSTR = array containing the characters forming  the  names
	           in  the  dictionary, 1 character per array location
	           as originally read by DALOAD using a multiple of an
	           A1 format.

	  NUMLOW = lowest subscript of the  locations  in  the  NUMSTR
	           array    containing    the    numeric   information
	           corresponding to the names  stored  in  the  LTRSTR
	           array.   NUMSTR(NUMLOW)  must  contain the start of
	           the description of a logical group  of  names,  not
	           the start of the description of an individual name.

	  NUMUSD = highest subscript of the locations  in  the  NUMSTR
	           array    containing    the    numeric   information
	           corresponding to the names  stored  in  the  LTRSTR
	           array.

	  NUMSTR = array   containing    the    numeric    information
	           corresponding  to  the  names  stored in the LTRSTR
	           array.  The construction of  the  NUMSTR  array  is
	           described  in  detail  in the DALOAD documentation.
	           For each name in the dictionary, the  NUMSTR  array
	           contains

	             a. the number of characters in the name

	             b. an indication of the associated data type

	             c. the number of subscript ranges

	             d. pairs of starting and ending values  of  these
	                ranges.

	           If the number of  characters  is  instead  zero  or
	           negative,  then its absolute value is the number of
	           characters in the name of a logical group of names,
	           and  the  next location, rather than indicating the
	           data type, contains the number of locations  within
	  FASP, FORTRAN Alphameric Subroutine Package          Page 35
	  DABASE, Routine to Locate Logical Group of Named Arrays


	           a  singly  subscripted buffer which would be needed
	           to store the values  of  the  multiply  subscripted
	           arrays  which  are  within  the  logical  group and
	           equivalenced with or otherwise loaded into  such  a
	           singly subscripted buffer.

	  The following  arguments  are  used  for  output  from  this
	  routine.  Their input values are ignored.

	  LRGLTR = returned containing the  subscript  of  the  LTRSTR
	           array  location  which contains the first letter of
	           the name associated with the logical group of names
	           in the dictionary which has been identified by this
	           routine.  If the logical group does not have a name
	           (NUMSTR(LRGNUM)   being   zero),   then  LRGLTR  is
	           returned pointing  to  the  LTRSTR  array  location
	           containing  the  first  letter  of  the  first name
	           within the group.

	  LRGNUM = returned containing the  subscript  of  the  NUMSTR
	           array  location  which  contains  the  first of the
	           numeric information  associated  with  the  logical
	           group   of   names  in  the  dictionary  which  was
	           identified   by   this   routine.    NUMSTR(LRGNUM)
	           contains  as  its  absolute  value  the  number  of
	           characters starting  at  LTRSTR(LRGLTR)  which  are
	           contained in the name, if any, of the logical group
	           of names.  NUMSTR(LRGNUM+1) contains the number  of
	           locations  within a singly subscripted buffer which
	           would be needed to store the values of the multiply
	           subscripted  arrays  which  are  within the logical
	           group and equivalenced  with  or  otherwise  loaded
	           into such a singly subscripted buffer.

	  LRGKNT = returned containing the sequence number within  the
	           dictionary of the logical group of names identified
	           by this routine.  If the third logical group in the
	           dictionary  is  identified,  then  LRGKNT  would be
	           returned containing the value 3.  If more than  one
	           logical  group  matches  the  given specifications,
	           then   the   first   group   which   matches    the
	           specifications  is  that  identified to the calling
	           program.  LRGKNT is returned containing zero if  no
	           logical  group  in the dictionary matched the given
	           specifications.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 36
	  DABELT, Routine to Represent Column Numbers


	  DDDDD           AAA   BBBBBB     EEEEEEEE   LL      TTTTTTTT
	  DD   DD        AAAA   BB    BB   EE         LL         TT
	  DD    DD      AA AA   BB    BB   EE         LL         TT
	  DD    DD     AA  AA   BBBBBB     EEEEE      LL         TT
	  DD    DD    AAAAAAA   BB    BB   EE         LL         TT
	  DD   DD    AA    AA   BB    BB   EE         LL         TT
	  DDDDD     AA     AA   BBBBBB     EEEEEEEE   LLLLLLLL   TT



	          DABELT, Routine to Represent Column Numbers
	          ------  ------- -- --------- ------ -------

	  When a program needs to  display  to  the  user  a  line  of
	  characters  in which the characters are oriented by columns,
	  a band of numbers identifying the columns  can  be  printed,
	  either  above  or  below  the  main  display, by calling the
	  DABELT routine to generate each line of  the  representation
	  of  the  column  numbers in a buffer array which the calling
	  program can then print with a  multiple  of  an  A1  format.
	  DABELT  is  called  as  many times as there are lines in the
	  representation of the column numbers,  the  calling  program
	  printing  the returned characters before again asking DABELT
	  to generate the next line.

	  The numbers can  be  generated  with  each  line  containing
	  digits  corresponding  to  the  same  power  of 10 as in the
	  following example

	                5432109876543210123456789012345
	                111111---------          111111
	                ------

	  or with each line containing digits of the same significance
	  as in the following example.

	                ---------------0123456789111111
	                111111987654321          012345
	                543210

	  The numbers can decrease  from  left  to  right  as  in  the
	  following example

	                5432109876543210123456789012345
	                111111          ---------111111
	                                         ------

	  and can have  any  desired  spacing  and  increment  between
	  adjacent numbers as in the following example.

	         - - 0 1 2 3 4 5 6 7 8 9 1 1 1 1 1 1 1 1 1 1 2
	         2 1   0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 0
	         0 0   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	         0 0                     0 0 0 0 0 0 0 0 0 0 0
	  FASP, FORTRAN Alphameric Subroutine Package          Page 37
	  DABELT, Routine to Represent Column Numbers


	  Two versions  of  the  routine  are  provided.   DABELT  can
	  produce  all  of  the  format  variations  described  above.
	  DAIBLT can only produce numbers of the  form  shown  in  the
	  first   illustration   above.    Each  line  of  the  number
	  representation   produced   by   DAIBLT   contains    digits
	  corresponding to the same power of 10, with adjacent numbers
	  increasing by an increment of one from left to right with no
	  extra  spacing.   Both  DABELT  and  DAIBLT  can produce any
	  selected line of  the  representation  of  the  numbers,  so
	  columns  can be printed to be read either from top to bottom
	  or from bottom to top.



	              The DABELT and DAIBLT Argument Lists
	              --- ------ --- ------ -------- -----

	  The argument lists of routines DABELT and DAIBLT are

	        SUBROUTINE DABELT(KOLUMN,INTRVL,JSTIFY,LINE  ,ILEFT ,
	       1    IRIGHT,LFTCOL,MAXBFR,IBUFFR,MAXLIN,MAXPRT,MAXUSD)

	  and

	        SUBROUTINE DAIBLT(                     LINE  ,ILEFT ,
	       1    IRIGHT,LFTCOL,MAXBFR,IBUFFR,MAXLIN,MAXPRT,MAXUSD)

	  both with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR)

	  The argument lists of the 2 routines  are  identical  except
	  that  the  first  3 arguments in the DABELT argument list do
	  not appear in the DAIBLT argument list.   For  DAIBLT  these
	  missing  arguments  effectively  have  the  values KOLUMN=1,
	  INTRVL=1 and  JSTIFY=0.   Also,  for  DAIBLT,  if  ILEFT  is
	  greater  than  IRIGHT,  then no representation is generated,
	  and MAXPRT and MAXUSD are both returned  set  equal  to  the
	  input value of LFTCOL.

	  The following are input arguments left unchanged.

	  KOLUMN = number of columns to be used for a  single  number.
	           If  KOLUMN is greater than 1, then KOLUMN-1 columns
	           of spaces will be inserted between the numbers.  No
	           extra  spaces will appear to the right of the right
	           number even if  KOLUMN  is  greater  than  1.   The
	           effective  value  of KOLUMN is 1 if KOLUMN is input
	           less than or equal to zero.

	  INTRVL = difference between adjacent numbers which are to be
	           represented  in  the  IBUFFR array.  If the sign of
	           INTRVL is wrong to proceed from  ILEFT  to  IRIGHT,
	           then  the  sign of the effective value of INTRVL is
	  FASP, FORTRAN Alphameric Subroutine Package          Page 38
	  DABELT, Routine to Represent Column Numbers


	           reversed, but the sign and value  of  the  argument
	           supplied by the calling program are left unchanged.
	           The effective value of INTRVL is  1  if  INTRVL  is
	           input equal to zero.

	  JSTIFY = 0, each line is to contain digits corresponding  to
	           the same power of 10 as in the first example at the
	           start of the documentation of this  routine.   LINE
	           equal  to  1  selects  the  digits  of  the  lowest
	           significance in the numbers.  LINE equal to  MAXLIN
	           will  select either the minus sign or the digits of
	           highest significance if positive in the  number  or
	           numbers requiring the most characters to represent.
	         = 1, each line is  to  contain  digits  of  the  same
	           significance  as in the second example at the start
	           of the documentation of this routine.  LINE equal 1
	           selects  either  the  minus  signs or the digits of
	           highest significance if positive  in  the  numbers.
	           LINE  equal  to  MAXLIN  will  select the digits of
	           lowest  significance  in  the  number  or   numbers
	           requiring the most characters to represent.

	  LINE   = selects which line of  the  representation  of  the
	           numbers  is  to  be constructed.  LINE equal 1 will
	           select the digits of lowest significance if  JSTIFY
	           is  zero,  or  the minus signs or digits of highest
	           significance of positive numbers if JUSTIFY  equals
	           1.   LINE  equal  to  MAXLIN  will select the minus
	           signs or the  digits  of  highest  significance  if
	           positive  of  the  number  or numbers requiring the
	           most characters to represent if JSTIFY is zero,  or
	           the  digits of lowest significance of the number or
	           numbers requiring the most characters to  represent
	           if  JSTIFY  equals  1.   MAXPRT and MAXUSD are both
	           returned equal to the input value of LFTCOL if LINE
	           is input greater than MAXLIN.

	           The following examples illustrate the definition of
	           LINE for JSTIFY equal to both zero and one.

	           KOLUMN=2,INTRVL=75,JSTIFY=0,ILEFT=-1052,IRIGHT=2000
	           LINE=1  2 7 2 7 2 7 2 7 2 7 2 7 2 7 2 3 8 3 8 3 8 3
	           LINE=2  5 7 0 2 5 7 0 2 5 7 0 2 5 7 - 7 4 2 9 7 4 2
	           LINE=3  0 9 9 8 7 6 6 5 4 3 3 2 1 -     1 2 2 3 4 5
	           LINE=4  1 - - - - - - - - - - - -
	           LINE=5  -
	           LINE=6

	  FASP, FORTRAN Alphameric Subroutine Package          Page 39
	  DABELT, Routine to Represent Column Numbers


	           KOLUMN=2,INTRVL=75,JSTIFY=1,ILEFT=-1052,IRIGHT=2000
	           LINE=1  - - - - - - - - - - - - - - - 7 1 2 2 3 4 5
	           LINE=2  1 9 9 8 7 6 6 5 4 3 3 2 1 7 2 3 4 2 9 7 4 2
	           LINE=3  0 7 0 2 5 7 0 2 5 7 0 2 5 7     8 3 8 3 8 3
	           LINE=4  5 7 2 7 2 7 2 7 2 7 2 7 2
	           LINE=5  2
	           LINE=6

	           Since the effective value of MAXLIN  is  not  known
	           prior  to  the first call to this routine, LINE can
	           be set to zero to represent the  same  line  as  if
	           LINE  was  input  equal  to  the  returned value of
	           MAXLIN.  LINE is returned unchanged, so the calling
	           program  would  in this case have to set LINE equal
	           to the returned value  of  MAXLIN-1  prior  to  the
	           second call to this routine.

	  ILEFT  = the left or first number to be represented.

	  IRIGHT = the right or final  limit  of  the  numbers  to  be
	           represented.    Unlike   ILEFT   which   is  always
	           represented, IRIGHT  is  represented  only  if  the
	           buffer  is  large  enough  to  include  the numbers
	           through IRIGHT plus the extra spaces if  KOLUMN  is
	           greater  than  1,  and if IRIGHT-ILEFT is exactly a
	           whole number multiple of INTRVL.   If  IRIGHT-ILEFT
	           is  not  exactly a whole number multiple of INTRVL,
	           then  the   rightmost   number   which   could   be
	           represented  if  the  buffer is large enough is the
	           number which  is  equal  to  ILEFT  plus  the  next
	           smaller whole number multiple of INTRVL.

	  LFTCOL = the subscript of the IBUFFR array location  to  the
	           immediate  left of the location into which is to be
	           placed the digit or sign forming the representation
	           upon the current line of the left number.

	  MAXBFR = subscript of the highest  location  in  the  IBUFFR
	           array  into which can be placed the representations
	           of the numbers from  ILEFT  through  IRIGHT.   This
	           would  normally  be  the  dimension  of  the IBUFFR
	           array.

	  The following arguments are used for  output.   Their  input
	  values are ignored.

	  IBUFFR = array in which the numbers are  to  be  represented
	           and  which  can  then  be  printed  by  the calling
	           program using a multiple of an A1 format.

	  MAXLIN = returned containing the number of lines  needed  to
	           represent  the  numbers  ILEFT through IRIGHT.  The
	           actual number of lines which would include printing
	           characters  may  be  less  since  the  right number
	  FASP, FORTRAN Alphameric Subroutine Package          Page 40
	  DABELT, Routine to Represent Column Numbers


	           actually displayed can require fewer characters for
	           its representation than would IRIGHT.

	  MAXPRT = returned containing  the  subscript  of  the  right
	           location  in the IBUFFR array containing a printing
	           character  generated  by  this  routine.   If   the
	           current  call  to  this  routine  has not added any
	           printing characters to IBUFFR, then MAXPRT will  be
	           returned equal to LFTCOL.

	  MAXUSD = returned containing  the  subscript  of  the  right
	           location   in   the  IBUFFR  array  containing  any
	           character generated by this routine.   If  LINE  is
	           less  than  or equal to MAXLIN, then MAXUSD will be
	           returned equal to the value of MAXPRT  which  would
	           be  returned  if  LINE  was  input as 1.  Since the
	           rightmost  printing  character  generated  by   the
	           current  call to this routine can be to the left of
	           that generated if LINE is 1,  the  array  locations
	           starting at IBUFFR(MAXPRT+1) through IBUFFR(MAXUSD)
	           will contain spaces.  If LINE is greater  than  the
	           returned  value  of MAXLIN, then MAXUSD is returned
	           equal to LFTCOL.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 41
	  DABELT, Routine to Represent Column Numbers


	   DABELT output for Various Values of Arguments and JSTIFY=0
	   ------ ------ --- ------- ------ -- --------- --- ------ -

	  KOLUMN=  1, INTRVL=       1, ILEFT=     -25, IRIGHT=      25
	   
	  LINE=3   ----------------
	  LINE=2   2222221111111111---------          1111111111222222
	  LINE=1   543210987654321098765432101234567890123456789012345
	   
	  KOLUMN=  1, INTRVL=       1, ILEFT=      25, IRIGHT=     -25
	   
	  LINE=3                                      ----------------
	  LINE=2   2222221111111111          ---------1111111111222222
	  LINE=1   543210987654321098765432101234567890123456789012345
	   
	  KOLUMN=  1, INTRVL=       5, ILEFT=    -125, IRIGHT=     125
	   
	  LINE=4   ------
	  LINE=3   111111------------------                     111111
	  LINE=2   221100998877665544332211-  112233445566778899001122
	  LINE=1   505050505050505050505050505050505050505050505050505
	   
	  KOLUMN=  2, INTRVL=      10, ILEFT=    -125, IRIGHT=     125
	   
	  LINE=4   - - -
	  LINE=3   1 1 1 - - - - - - - - -                       1 1 1
	  LINE=2   2 1 0 9 8 7 6 5 4 3 2 1 -   1 2 3 4 5 6 7 8 9 0 1 2
	  LINE=1   5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
	   
	  KOLUMN=  2, INTRVL=      10, ILEFT=    -250, IRIGHT=       0
	   
	  LINE=4   - - - - - - - - - - - - - - - -
	  LINE=3   2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 - - - - - - - - -
	  LINE=2   5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1
	  LINE=1   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	   
	  KOLUMN=  2, INTRVL=      10, ILEFT=       0, IRIGHT=     250
	   
	  LINE=3                       1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2
	  LINE=2     1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
	  LINE=1   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	   
	  KOLUMN=  5, INTRVL=       6, ILEFT=     -30, IRIGHT=      30
	   
	  LINE=3   -    -    -    -
	  LINE=2   3    2    1    1    -              1    1    2    3
	  LINE=1   0    4    8    2    6    0    6    2    8    4    0
	   
	  KOLUMN=  5, INTRVL=       6, ILEFT=     -29, IRIGHT=      31
	   
	  LINE=3   -    -    -    -
	  LINE=2   2    2    1    1    -              1    1    2    3
	  LINE=1   9    3    7    1    5    1    7    3    9    5    1
	  FASP, FORTRAN Alphameric Subroutine Package          Page 42
	  DABELT, Routine to Represent Column Numbers


	                An Example of the Use of DABELT
	                -- ------- -- --- --- -- ------

	  The sample program listed on the following page demonstrates
	  the  manner  in  which DABELT is used.  The program asks the
	  user for the desired spacing, interval, and left  and  right
	  limits,  then  generates  the  highest numbered line through
	  line 1 and back again to and  beyond  the  highest  numbered
	  line for JSTIFY equal first to zero then to one.

	  A  sample  dialog  between  the  program  and  the  user  is
	  presented following the listing of the program.

	  For a practical application of the DABELT routine,  see  the
	  first demonstration program in the description of the DALOAD
	  routine.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 43
	  DABELT, Routine to Represent Column Numbers


	        DATA MAXBFR,ITTY,ISPACE/51,5,1H /
	        DIMENSION IBUFFR(51),JBUFFR(51)
	  C
	  C     GET VALUES OF ARGUMENTS FROM USER
	      1 WRITE(ITTY,2)
	      2 FORMAT(' LFTCOL, KOLUMN, INTRVL, ILEFT, IRIGHT ',$)
	        READ(ITTY,3)LFTCOL,KOLUMN,INTRVL,ILEFT,IRIGHT
	      3 FORMAT(10I)
	  C
	  C     REPRESENT THE NUMBERS
	        DO 4 I=1,MAXBFR
	      4 IBUFFR(I)=ISPACE
	        DO 9 JSTIFY=0,1
	        WRITE(ITTY,5)JSTIFY
	      5 FORMAT(' JSTIFY=',1I1)
	        LINE=0
	      6 CALL DABELT(KOLUMN,INTRVL,JSTIFY,LINE,ILEFT,
	       1IRIGHT,LFTCOL,MAXBFR,IBUFFR,MAXLIN,MAXPRT,MAXUSD)
	        IF(LINE.EQ.0)LINE=MAXLIN
	        WRITE(ITTY,7)LINE,(IBUFFR(I),I=1,MAXPRT)
	      7 FORMAT(' LINE=',I1,3X,100A1)
	        LINE=LINE-1
	        IF(LINE.GT.0)GO TO 6
	        LINE=1
	      8 LINE=LINE+1
	        CALL DABELT(KOLUMN,INTRVL,JSTIFY,LINE,ILEFT,
	       1IRIGHT,LFTCOL,MAXBFR,IBUFFR,MAXLIN,MAXPRT,MAXUSD)
	        IF(MAXPRT.LE.LFTCOL)WRITE(ITTY,7)LINE
	        IF(MAXPRT.GT.LFTCOL)WRITE(ITTY,7)LINE,
	       1(IBUFFR(I),I=1,MAXPRT)
	        IF(LINE.LE.MAXLIN)GO TO 8
	      9 CONTINUE
	  C
	  C     REPORT THE EXPECTED VALUES
	        KOUNT=0
	        IF(INTRVL.LT.0)INTRVL=-INTRVL
	        IF(INTRVL.EQ.0)INTRVL=1
	        IF(ILEFT.GT.IRIGHT)INTRVL=-INTRVL
	        IF(KOLUMN.LE.0)KOLUMN=1
	     10 LFTCOL=LFTCOL+1
	        IF(LFTCOL.GT.MAXBFR)GO TO 13
	        IF(INTRVL.GT.0)GO TO 11
	        IF(ILEFT.LT.IRIGHT)GO TO 13
	        GO TO 12
	     11 IF(ILEFT.GT.IRIGHT)GO TO 13
	     12 KOUNT=KOUNT+1
	        JBUFFR(KOUNT)=ILEFT
	        LFTCOL=LFTCOL+KOLUMN-1
	        ILEFT=ILEFT+INTRVL
	        GO TO 10
	     13 IF(KOUNT.GT.0)WRITE(ITTY,14)(JBUFFR(I),I=1,KOUNT)
	     14 FORMAT(6I10)
	        GO TO 1
	        END
	  FASP, FORTRAN Alphameric Subroutine Package          Page 44
	  DABELT, Routine to Represent Column Numbers


	  Typical Dialog Between DABELT Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  LFTCOL, KOLUMN, INTRVL, ILEFT, IRIGHT 0 2 6 108 -108

	  JSTIFY=0
	  LINE=4
	  LINE=3   1 1                                     - - - - - -
	  LINE=2   0 0 9 9 8 7 7 6 6 5 4 4 3 3 2 1 1     - 1 1 2 3 3 4
	  LINE=1   8 2 6 0 4 8 2 6 0 4 8 2 6 0 4 8 2 6 0 6 2 8 4 0 6 2
	  LINE=2   0 0 9 9 8 7 7 6 6 5 4 4 3 3 2 1 1     - 1 1 2 3 3 4
	  LINE=3   1 1                                     - - - - - -
	  LINE=4
	  LINE=5
	  JSTIFY=1
	  LINE=4
	  LINE=3   8 2                                     2 8 4 0 6 2
	  LINE=2   0 0 6 0 4 8 2 6 0 4 8 2 6 0 4 8 2     6 1 1 2 3 3 4
	  LINE=1   1 1 9 9 8 7 7 6 6 5 4 4 3 3 2 1 1 6 0 - - - - - - -
	  LINE=2   0 0 6 0 4 8 2 6 0 4 8 2 6 0 4 8 2     6 1 1 2 3 3 4
	  LINE=3   8 2                                     2 8 4 0 6 2
	  LINE=4
	  LINE=5
	        108       102        96        90        84        78
	         72        66        60        54        48        42
	         36        30        24        18        12         6
	          0        -6       -12       -18       -24       -30
	        -36       -42
	  LFTCOL, KOLUMN, INTRVL, ILEFT, IRIGHT 0 2 6 -108 108

	  JSTIFY=0
	  LINE=4   - -
	  LINE=3   1 1 - - - - - - - - - - - - - - -
	  LINE=2   0 0 9 9 8 7 7 6 6 5 4 4 3 3 2 1 1 -     1 1 2 3 3 4
	  LINE=1   8 2 6 0 4 8 2 6 0 4 8 2 6 0 4 8 2 6 0 6 2 8 4 0 6 2
	  LINE=2   0 0 9 9 8 7 7 6 6 5 4 4 3 3 2 1 1 -     1 1 2 3 3 4
	  LINE=3   1 1 - - - - - - - - - - - - - - -
	  LINE=4   - -
	  LINE=5
	  JSTIFY=1
	  LINE=4   8 2
	  LINE=3   0 0 6 0 4 8 2 6 0 4 8 2 6 0 4 8 2
	  LINE=2   1 1 9 9 8 7 7 6 6 5 4 4 3 3 2 1 1 6     2 8 4 0 6 2
	  LINE=1   - - - - - - - - - - - - - - - - - - 0 6 1 1 2 3 3 4
	  LINE=2   1 1 9 9 8 7 7 6 6 5 4 4 3 3 2 1 1 6     2 8 4 0 6 2
	  LINE=3   0 0 6 0 4 8 2 6 0 4 8 2 6 0 4 8 2
	  LINE=4   8 2
	  LINE=5
	       -108      -102       -96       -90       -84       -78
	        -72       -66       -60       -54       -48       -42
	        -36       -30       -24       -18       -12        -6
	          0         6        12        18        24        30
	         36        42
	  FASP, FORTRAN Alphameric Subroutine Package          Page 45
	  DACASE, Converts Lower Case Letters to Upper Case


	  DDDDD          AAA     CCCCC        AAA    SSSSSS  EEEEEEEE
	  DD   DD       AAAA   CC            AAAA  SS        EE
	  DD    DD     AA AA  CC            AA AA  SS        EE
	  DD    DD    AA  AA  CC           AA  AA    SSSS    EEEEE
	  DD    DD   AAAAAAA  CC          AAAAAAA        SS  EE
	  DD   DD   AA    AA   CC        AA    AA        SS  EE
	  DDDDD    AA     AA     CCCCC  AA     AA  SSSSSS    EEEEEEEE


	       DACASE, Converts Lower Case Letters to Upper Case
	       ------  -------- ----- ---- ------- -- ----- ----

	  Although  lower  case  alphabetic  letters  are  treated  as
	  equivalent  to  the upper case forms of these letters by the
	  FASP routines DAHEFT, DAIHFT and DAVERB (and  by  any  other
	  FASP  routines  such as DAHEST and DANEXT which call DAHEFT,
	  DAIHFT or DAVERB either directly or indirectly), lower  case
	  letters  are  not  recognized  by  the FASP routines DALOAD,
	  DAPICK, DATEXT and DATURN.  If  these  latter  routines  are
	  called upon a computer system which supports lower case, but
	  requiring that the user lock the terminal  into  upper  case
	  shift is not acceptable, then the contents of the input text
	  buffer can instead be processed by the DACASE routine  which
	  replaces  lower  case  letters  with the corresponding upper
	  case letters.  All other characters are  returned  unchanged
	  by the DACASE routine.

	  DACASE contains a list of the lower case letters and a  list
	  of  the  corresponding  upper  case letters.  The lower case
	  letters are defined by a DATA statement to be in  the  order
	  1Ha  through  1Hz which on the PDP10 computer results in the
	  associated integer values being sorted  into  an  increasing
	  order.   Each  lower case letter in the input text buffer is
	  identified by a ternary search for a match within the sorted
	  list  of lower case letters.  If this routine is used upon a
	  computer system in  which  the  alphabetical  order  of  the
	  letters  1Ha  through  1Hz  does not result in an increasing
	  order for the  associated  integer  values,  then  the  DATA
	  statement  which  defines the array which contains the lower
	  case  letters  should  be  rewritten  so  that  the   values
	  associated  with the letters will be in increasing numerical
	  order,  and  then  the  DATA  statement  which  defines  the
	  corresponding  upper  case letters must be rewritten so that
	  the lower and upper case versions of each letter  appear  in
	  locations   in   the   respective  arrays  having  the  same
	  subscripts.

	  Operation of the DACASE routine requires that  the  compiler
	  not  translate  into  upper  case  any  lower  case  letters
	  included in Hollerith strings in the routine.  On the  PDP10
	  computer,  this  routine  can be used with the F10 compiler,
	  but not with the  older  F40  compiler  which  does  such  a
	  translation  of lower case letters in Hollerith strings into
	  upper case.  Of course, this routine is not needed at all if
	  FASP, FORTRAN Alphameric Subroutine Package          Page 46
	  DACASE, Converts Lower Case Letters to Upper Case


	  the  run time system itself translates lower case letters to
	  upper case before these are sent to the user's program.


	                    The DACASE Argument List
	                    --- ------ -------- ----

	  The argument list of routine DACASE is

	        SUBROUTINE DACASE(MINBFR,MAXBFR,IBUFFR)

	  with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR)

	  The following arguments are used for input and are  returned
	  unchanged.

	  MINBFR = subscript of the first location in the IBUFFR array
	           containing  a character which is to be converted to
	           upper case if input in lower case.

	  MAXBFR = subscript of the final location in the IBUFFR array
	           containing  a character which is to be converted to
	           upper case if input in lower case.

	  The following argument is used both for  input  to  and  for
	  output from this routine.

	  IBUFFR = array containing  in  locations  having  subscripts
	           MINBFR  through  MAXBFR  the  characters  read by a
	           multiple of an 1A format which are to be  converted
	           to upper case if input in lower case.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 47
	  DACOPY, Routine to Expand Tab Characters to Spaces


	   DDDDD          AAA     CCCCC   OOOOO    PPPPPP    YY    YY
	   DD   DD       AAAA   CC       OO   OO   PP    PP   YY  YY
	   DD    DD     AA AA  CC       OO     OO  PP    PP    YYYY
	   DD    DD    AA  AA  CC       OO     OO  PPPPPP       YY
	   DD    DD   AAAAAAA  CC       OO     OO  PP           YY
	   DD   DD   AA    AA   CC       OO   OO   PP           YY
	   DDDDD    AA     AA     CCCCC   OOOOO    PP           YY

	       DACOPY, Routine to Expand Tab Characters to Spaces
	       ------  ------- -- ------ --- ---------- -- ------

	  Computer terminals often can generate  2  types  of  forward
	  spacing  but  nonprinting characters.  The simpler of these,
	  the space, merely causes the character to its  right  to  be
	  shifted  over  by  1  column and is exactly equivalent to an
	  empty  column  on  a  punched  card.   The   tab   character
	  (sometimes called HT or horizontal tab), however, shifts the
	  character to its right beyond the next column position which
	  is a whole multiple of 8 (or some other, generally fixed tab
	  stop interval), and is convenient for quickly spacing across
	  the  width  of  the  input  line.   The  reading program can
	  distinguish a tab character from  a  space,  so  appropriate
	  treatment of the tab character poses little or no difficulty
	  to a program which is doing  parsing  or  which  is  reading
	  numeric  information, since the tab character can be treated
	  as equivalent to a space or not, whichever is appropriate to
	  the particular application.

	  If the program must insert text  containing  tab  characters
	  into  printed or typed output, the original alignment of the
	  text  with  the  tab  stop  columns  will  probably  not  be
	  maintained,  causing  the appearance of the text upon output
	  to be  quite  different  from  that  seen  on  the  original
	  terminal  from  which the text was entered into the computer
	  system.  Also, when this alignment  changes,  the  effective
	  number  of  columns across the width of the text changes, so
	  that information inserted into fields to the  right  of  the
	  text containing the tab characters will also be shifted into
	  different columns than intended.   This  difficulty  can  be
	  avoided by conversion of the tab characters into the correct
	  number of spaces prior to output.

	  DACOPY is one of two routines  in  the  FASP  package  which
	  convert  tab  characters  to spaces in buffers read by an A1
	  format.   DACOPY  performs  the  tab  character   to   space
	  expansion  while  copying from an input buffer to a separate
	  output buffer which can be written by  the  calling  program
	  with  a  multiple of an A1 format.  The expanded text is not
	  copied back into the original buffer  since  the  number  of
	  characters  can increase during the conversion.  DAFILL, the
	  other tab to space conversion routine, copies  the  expanded
	  text  back into the input buffer, overwriting any characters
	  which could not be represented due to the buffer  being  too
	  small.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 48
	  DACOPY, Routine to Expand Tab Characters to Spaces


	                    the DACOPY Argument List
	                    --- ------ -------- ----

	  The argument list of routine DACOPY is

	        SUBROUTINE DACOPY(INITAL,INTRVL,IBUFFR,IBEGIN,IFINAL,
	       1JFINAL,JUSED,JBUFFR,NXTINI,NXTBGN,MAXPRT)

	  with the associated DIMENSION statement

	        DIMENSION IBUFFR(IFINAL),JBUFFR(JFINAL)

	  The arguments INITAL, INTRVL, IBUFFR,  IBEGIN,  IFINAL,  and
	  JFINAL are used only for input and their original values are
	  returned unchanged.  The argument JUSED  is  used  for  both
	  input  and  output.   The  portion of the JBUFFR array above
	  JBUFFR(JUSED) as well as the arguments  NXTINI,  NXTBGN  and
	  MAXPRT  are  used  only for output and their original values
	  are ignored.

	  INITAL = less than zero and providing that INTRVL is greater
	           than  zero,  the  absolute  value  of INITAL is the
	           number of extra spaces to be inserted at the  start
	           of  the  output  buffer  before the contents of the
	           input buffer are copied into the output buffer.  If
	           INITAL  is  less  than  zero, regardless of whether
	           INTRVL is positive or negative, the first tab  stop
	           will  be  of  the  width  specified by the absolute
	           value of INTRVL.  If INTRVL is less than  or  equal
	           to  zero,  then  no leading spaces will be inserted
	           into the  output  buffer  whether  requested  by  a
	           negative  value  of  INITAL or by leading spaces or
	           tab characters in the input buffer.
	         = equal to  or  greater  than  zero,  INITAL  is  the
	           distance  to the first tab stop.  (Distance is here
	           defined as a number of  characters  or,  since  the
	           buffers contain a single character in each location
	           of the arrays, as a subscript range.) If INITAL  is
	           zero,  then  it is assumed that copying has already
	           passed beyond the first tab stop and  the  distance
	           to  the next tab stop is then taken as the absolute
	           value of INTRVL.  If the left tab stop is to be  of
	           the  same  width as those to its right, then INITAL
	           can equal either zero  or  the  absolute  value  of
	           INTRVL.  If the first character in the input buffer
	           is a tab character, then it will be expanded to the
	           number  of  spaces  specified  by  INITAL  (or by a
	           positive value of INTRVL if INITAL  is  zero).   If
	           the first character is not a tab character, but the
	           second character  is  a  tab  character,  then  the
	           second  character  will  be  expanded  to  INITAL-1
	           spaces,  and  so  on  through  the   first   INITAL
	           characters  providing in each case that none of the
	           characters to the left are tab  characters.   After
	  FASP, FORTRAN Alphameric Subroutine Package          Page 49
	  DACOPY, Routine to Expand Tab Characters to Spaces


	           the sum of the number of characters which have been
	           inserted into  the  output  buffer,  whether  these
	           characters   are   printing  characters  or  spaces
	           originally in the input buffer or spaces  resulting
	           from  the  expansion  of  tab  characters,  and, if
	           INTRVL is equal to or less than zero, of the number
	           of  spaces  which  have been suppressed, equals the
	           value of INITAL, then the tab stop interval becomes
	           that  given  by  the absolute value of the argument
	           INTRVL.

	  INTRVL = not equal to zero, the absolute value of INTRVL  is
	           the tab stop interval.  On the PDP-10 computer, the
	           appropriate absolute value of  INTRVL  is  8,  and,
	           assuming  that  the  first  character  in the input
	           buffer corresponds to column 1, the value of INITAL
	           at  the  start of the processing of the contents of
	           the input buffer can be either 0 or 8.   After  the
	           sum  of  the number of characters inserted into the
	           output buffer and of the number of spaces, if  any,
	           suppressed  by  a negative or zero value of INTRVL,
	           has reached at least the absolute value of  INITAL,
	           then  a  tab  character  encountered  in  the input
	           buffer causes sufficient spaces to be inserted into
	           the  output buffer or else to be suppressed so that
	           the total number of characters  inserted  into  the
	           output  buffer or suppressed by the present call to
	           DACOPY equals the sum  of  the  absolute  value  of
	           INITAL  and  the  next higher whole multiple of the
	           absolute value of INTRVL.
	         = less  than  zero,  no  leading  spaces  are  to  be
	           inserted   into  the  output  buffer  whether  such
	           leading spaces are requested by a negative value of
	           INITAL  or  by  leading spaces or tab characters in
	           the input buffer.  Once a  printing  character  has
	           been  copied  into the output buffer, however, then
	           all  subsequent  spaces  will  be  copied  and  all
	           subsequent  tab  characters  will  be  expanded  to
	           spaces.
	         = zero, no spaces are to be inserted into the  output
	           buffer.   Tab  characters  and  spaces in the input
	           buffer are ignored.
	         = greater than zero, all spaces whether requested  by
	           a  negative  value  of  INITAL  or by spaces or tab
	           characters in the input buffer are to  be  inserted
	           into the output buffer.

	  IBUFFR = the input buffer containing  the  characters  which
	           are  to  be copied into the output buffer expanding
	           any tabs found.  The characters in the IBUFFR array
	           must have been read by a multiple of an A1 format.

	  IBEGIN = the subscript of the IBUFFR array location at which
	           is to be found the first character to be copied.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 50
	  DACOPY, Routine to Expand Tab Characters to Spaces


	  IFINAL = the subscript of the IBUFFR array location at which
	           is to be found the final character to be copied.

	  JFINAL = the dimension  of,  or  subscript  of  the  highest
	           available location within, the JBUFFR array.

	  JUSED  = the subscript of the lowest location in the  JBUFFR
	           array  which is currently in use and which contains
	           data which must be maintained.  JUSED  is  returned
	           containing  the  subscript  of the highest location
	           into which DACOPY has placed a character.

	  JBUFFR = the array into which the contents of IBUFFR are  to
	           be copied expanding tab characters to spaces.

	  NXTINI = returned containing the value which should be  next
	           given  to  INITAL  if  the  current  call could not
	           completely represent  the  contents  of  the  input
	           buffer  due  to  the  room  available in the output
	           buffer being to small.   If  a  tab  character  was
	           encountered  in  the  input buffer but could not be
	           completely represented in the output  buffer,  then
	           NXTINI  will  be  returned  negative.   If the last
	           character encountered in the input buffer was not a
	           tab   character,   then  NXTINI  will  be  returned
	           containing the remaining distance to the  next  tab
	           stop.

	  NXTBGN = returned containing the subscript within the IBUFFR
	           array  of  the  first  character which could not be
	           represented  in  the   output   buffer.    If   all
	           characters  could  be represented, then NXTBGN will
	           be returned equal to IFINAL+1.  Note that if a  tab
	           character is represented even by single space, then
	           NXTBGN is passed beyond this tab character although
	           there might not be enough room in the output buffer
	           to fill completely to the next tab stop.

	  MAXPRT = returned containing the subscript  of  the  highest
	           location  in the JBUFFR array into which DACOPY has
	           placed a  printing  (nonspace)  character.   If  no
	           printing  characters  are  placed  into  the output
	           buffer, then MAXPRT will be returned equal  to  the
	           input value of JUSED.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 51
	  DACOPY, Routine to Expand Tab Characters to Spaces


	              Examples of Tab Character Expansions
	              -------- -- --- --------- ----------

	  In the following examples of the expansion of tabs to spaces
	  with  a tab stop interval of 8 (INITAL=INTRVL=8), the symbol
	  <HT> represents a single tab character stored  in  a  single
	  computer  word,  and  the  digits represent characters other
	  than the tab character stored one per  computer  word.   If,
	  according to this notation, the input buffer contains

	  1<HT>90<HT>789<HT>5678<HT>34567<HT>123456<HT>9012345<HT>7

	  then after expansion, the output buffer would contain

	  1       90      789     5678    34567   123456  9012345 7

	  In similar manner, the input buffer contents

	  1234567<HT>901234<HT>78901<HT>5678<HT>345<HT>12<HT>9<HT>7

	  would be changed to the following in the output buffer

	  1234567 901234  78901   5678    345     12      9       7



	                An Example of the Use of DACOPY
	                -- ------- -- --- --- -- ------

	  The sample program listed on the following page demonstrates
	  the manner in which DACOPY is used.  The program prompts the
	  user with an asterisk, then reads a line of  text  including
	  tabs  to  be expanded to the corresponding number of spaces.
	  The tab stop interval is 8.  Since the asterisk typed by the
	  program  appears  in  column  1,  an  initial tab would only
	  correspond to an additional 7 spaces.

	  The  program  allocates  the  output  buffer  in   sections,
	  allowing  as  much  as  possible  of  the input buffer to be
	  represented in a particular section, then moving to the next
	  section of the output buffer and again calling DACOPY.  This
	  sequence is repeated until either the output buffer fills or
	  the  input  buffer is exhausted.  If the rightmost character
	  of the input buffer which has been represented in the output
	  section  is  a  tab,  then  the  location  of  the rightmost
	  character of the output  section  is  marked  with  a  digit
	  corresponding  to  the  position  of the tab relative to the
	  other tabs in the input buffer.  The  program  displays  the
	  expansion  for  output  buffer section sizes 1, 5, 9, 13, 17
	  and 21.

	  A  sample  dialog  between  the  program  and  the  user  is
	  presented following the listing of the program.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 52
	  DACOPY, Routine to Expand Tab Characters to Spaces


	        DIMENSION IBUFFR(70),JBUFFR(85),IDIGIT(10)
	        DATA INTRVL,IWIDTH,IFINAL,MAXOUT/8,59,70,85/
	        DATA IDIGIT/1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,1H0/
	        DATA ITAB/1H      /
	  C     ASK FOR AND READ TEXT CONTAINING TABS TO BE CONVERTED
	        LOWER=IFINAL-IWIDTH+1
	        ISTART=MAXOUT-IWIDTH+1
	      1 TYPE 2
	      2 FORMAT(1X/' *',$)
	        ACCEPT 3,(IBUFFR(I),I=LOWER,IFINAL)
	      3 FORMAT(60A1)
	  C     LOOP THRU DESTINATION FIELD SIZES 1 TO 21, INCREMENT 4
	        DO 9 ISIZE=1,21,4
	        IBEGIN=LOWER
	        JUSED=ISTART-1
	        INITAL=INTRVL-1
	        LIMIT=JUSED
	      4 JFINAL=JUSED+ISIZE
	        IF(JFINAL.GT.MAXOUT)JFINAL=MAXOUT
	        JSTART=JUSED+1
	  C     CONVERT TAB CHARACTERS INTO SPACES
	        CALL DACOPY(INITAL,INTRVL,IBUFFR,IBEGIN,IFINAL,JFINAL,
	       1JUSED,JBUFFR,NXTINI,NXTBGN,MAXPRT)
	        IF(JUSED.LT.JSTART)GO TO 8
	        IF(MAXPRT.GE.JSTART)LIMIT=MAXPRT
	  C     MARK RIGHT END OF AREA INTO WHICH TAB WAS EXPANDED
	        IF(IBUFFR(NXTBGN-1).NE.ITAB)GO TO 7
	        KOUNT=0
	        INDEX=LOWER-1
	      5 INDEX=INDEX+1
	        IF(INDEX.GE.NXTBGN)GO TO 6
	        IF(IBUFFR(INDEX).NE.ITAB)GO TO 5
	        KOUNT=KOUNT+1
	        IF(KOUNT.GT.10)KOUNT=1
	        GO TO 5
	      6 JBUFFR(JUSED)=IDIGIT(KOUNT)
	  C     PREPARE FOR NEXT AREA INTO WHICH TAB CAN BE EXPANDED
	      7 INITAL=NXTINI
	        IBEGIN=NXTBGN
	        GO TO 4
	  C     REPORT RESULTS TO USER
	      8 IF(LIMIT.LT.ISTART)GO TO 1
	      9 TYPE 10,(JBUFFR(I),I=ISTART,LIMIT)
	     10 FORMAT(2X,200A1)
	  C     IDENTIFY COLUMNS
	        LINE=1
	        IRIGHT=LIMIT-ISTART+2
	     11 CALL DABELT(1,1,0,LINE,2,
	       1IRIGHT,0,MAXOUT,JBUFFR,MAXLIN,MAXPRT,MAXUSD)
	        TYPE 10,(JBUFFR(I),I=1,MAXPRT)
	        LINE=LINE+1
	        IF(LINE.LE.MAXLIN)GO TO 11
	        GO TO 1
	        END
	  FASP, FORTRAN Alphameric Subroutine Package          Page 53
	  DACOPY, Routine to Expand Tab Characters to Spaces


	  Typical Dialog Between DACOPY Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  The first line typed by the user consisted merely of  7  tab
	  characters  followed  by  the  letter  A.   The  second line
	  consists of alternating tabs and letters.   The  third  line
	  consists  of  several  repetitions  of  a sequence formed of
	  several spaces, a single letter and a single tab.  The final
	  line  consists  of  a  random  sequence  of tabs, spaces and
	  letters.

	  *                                                       A

	   1111111222222223333333344444444555555556666666677777777A
	       1    2    2    3    4    4    5    6    6    7    7A
	           2        3        4        5        6        7 A
	               2            4            5            7   A
	                   3                5                7    A
	                       3                    6             A
	   23456789012345678901234567890123456789012345678901234567
	           111111111122222222223333333333444444444455555555

	  *       A       B       C       D       E       F       G

	   1111111A2222222B3333333C4444444D5555555E6666666F7777777G
	       1  A 2    2B   3   C4    4 D  5    E    6  F 7    7G
	          A2      B 3     C  4    D   5   E    6  F     7 G
	          A    2  B       C 4     D      5E       F   7   G
	          A       B3      C       D 5     E       F  7    G
	          A       B    3  C       D       E 6     F       G
	   23456789012345678901234567890123456789012345678901234567
	           111111111122222222223333333333444444444455555555

	  *   A       B       C       D       E       F       G

	      A111    B222    C333    D444    E555    F666    G
	      A1      B  2    C       D 4     E       F6      G
	      A       B       C       D       E       F6      G
	      A       B2      C       D       E  5    F       G
	      A       B       C       D       E       F       G
	      A       B       C3      D       E       F       G
	   2345678901234567890123456789012345678901234567890123
	           11111111112222222222333333333344444444445555

	  *               A       B C      D       EF     GH I    J K

	   1111111  222222A   3333B C 4444 D  5555 EF66666GH I7777J K
	       1    2    2A   3   B C   4  D       EF  6  GH I   7J K
	                  A       B C      D  5    EF  6  GH I  7 J K
	               2  A       B C      D     5 EF     GH I7   J K
	                  A       B C      D       EF     GH I    J K
	                  A    3  B C      D       EF     GH I    J K
	   2345678901234567890123456789012345678901234567890123456789
	           11111111112222222222333333333344444444445555555555
	  FASP, FORTRAN Alphameric Subroutine Package          Page 54
	  DAFILL, Routine to Expand Tab Characters to Spaces


	  DDDDDDD       AAA     FFFFFFFFF  IIIII  LLL        LLL
	  DDD   DDD   AAA AAA   FFF         III   LLL        LLL
	  DDD   DDD  AAA   AAA  FFFFFF      III   LLL        LLL
	  DDD   DDD  AAAAAAAAA  FFF         III   LLL        LLL
	  DDDDDDD    AAA   AAA  FFF        IIIII  LLLLLLLLL  LLLLLLLLL


	       DAFILL, Routine to Expand Tab Characters to Spaces
	       ------  ------- -- ------ --- ---------- -- ------

	  Computer terminals often can generate  2  types  of  forward
	  spacing  but  nonprinting characters.  The simpler of these,
	  the space, merely causes the character to its  right  to  be
	  shifted  over  by  1  column and is exactly equivalent to an
	  empty  column  on  a  punched  card.   The   tab   character
	  (sometimes called HT or horizontal tab), however, shifts the
	  character to its right beyond the next column position which
	  is a whole multiple of 8 (or some other, generally fixed tab
	  stop interval), and is convenient for quickly spacing across
	  the  width  of  the  input  line.   The  reading program can
	  distinguish a tab character from  a  space,  so  appropriate
	  treatment of the tab character poses little or no difficulty
	  to a program which is doing  parsing  or  which  is  reading
	  numeric  information, since the tab character can be treated
	  as equivalent to a space or not, whichever is appropriate to
	  the particular application.

	  If the program must insert text  containing  tab  characters
	  into  printed or typed output, the original alignment of the
	  text  with  the  tab  stop  columns  will  probably  not  be
	  maintained,  causing  the appearance of the text upon output
	  to be  quite  different  from  that  seen  on  the  original
	  terminal  from  which the text was entered into the computer
	  system.  Also, when this alignment  changes,  the  effective
	  number  of  columns across the width of the text changes, so
	  that information inserted into fields to the  right  of  the
	  text containing the tab characters will also be shifted into
	  different columns than intended.   This  difficulty  can  be
	  avoided by conversion of the tab characters into the correct
	  number of spaces prior to output.

	  DAFILL is one of two routines  in  the  FASP  package  which
	  convert  tab  characters  to spaces in buffers read by an A1
	  format.  DAFILL copies the expanded text back into the input
	  buffer,  overwriting  any  characters  which  could  not  be
	  represented due to the buffer being too small.  DACOPY,  the
	  other  tab  to  space  conversion  routine, copies the input
	  buffer into  a  separate  output  buffer  and  provides  the
	  calling  program  with  sufficient  information  to properly
	  continue the  expansion  of  any  text  which  might  remain
	  unprocessed  due  to  the  output  buffer  being  too small.
	  DAFILL requires more execution time since the processing  is
	  iterative,  and is a longer routine, but it does not require
	  the extra output buffer.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 55
	  DAFILL, Routine to Expand Tab Characters to Spaces


	  A shorter version of DAFILL, named DAIFLL, is also  provided
	  which  does  not  provide for the insertion of extra initial
	  spaces other than those  resulting  from  the  expansion  of
	  initial tabs, and which does not provide for the suppression
	  of either tabs or spaces.



	              the DAFILL and DAIFLL Argument Lists
	              --- ------ --- ------ -------- -----

	  The argument lists of routines DAFILL and DAIFLL are

	        SUBROUTINE DAFILL(INITAL,INTRVL,IBEGIN,IFINAL,MAXBFR,
	       1IBUFFR,MAXPRT,MAXUSD)

	  and

	        SUBROUTINE DAIFLL(INITAL,INTRVL,IBEGIN,IFINAL,MAXBFR,
	       1IBUFFR,MAXPRT,MAXUSD)

	  both with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR)

	  The argument lists of the 2 routines  are  identical  except
	  that,  for  DAIFLL, the argument INITAL must be greater than
	  or equal to zero, and the argument INTRVL  must  be  greater
	  than zero.

	  The arguments INITAL, INTRVL, IBEGIN, IFINAL, and MAXBFR are
	  used  only  for input and their original values are returned
	  unchanged.  The array IBUFFR is  used  for  both  input  and
	  output.   The  arguments MAXPRT and MAXUSD are used only for
	  output and their original values are ignored.

	  INITAL = less than zero and providing that INTRVL is greater
	           than  zero,  the  absolute  value  of INITAL is the
	           number of extra spaces to be inserted at the  start
	           of  the  processed  text.   If  INITAL is less than
	           zero, regardless of whether INTRVL is  positive  or
	           negative,  then  the  first tab stop will be of the
	           width specified by the absolute  value  of  INTRVL.
	           If  INTRVL  is  less than or equal to zero, then no
	           leading spaces will be inserted into the  processed
	           text  whether  requested  by  a  negative  value of
	           INITAL or by leading spaces or  tab  characters  in
	           the original text.
	         = equal to  or  greater  than  zero,  INITAL  is  the
	           distance  to the first tab stop.  (Distance is here
	           defined as a number of  characters  or,  since  the
	           buffers contain a single character in each location
	           of the array, as a subscript range.)  If INITAL  is
	           zero,  then  the  distance to the first tab stop is
	  FASP, FORTRAN Alphameric Subroutine Package          Page 56
	  DAFILL, Routine to Expand Tab Characters to Spaces


	           taken to be the absolute value of INTRVL.   If  the
	           left  tab  stop is to be same width as those to its
	           right, then INITAL can equal  either  zero  or  the
	           absolute  value  of INTRVL.  If the first character
	           in the original text is a tab  character,  then  it
	           will  be expanded to the number of spaces specified
	           by INITAL (or by a  positive  value  of  INTRVL  if
	           INITAL  is  zero).  If the first character is not a
	           tab character, but the second character  is  a  tab
	           character,   then  the  second  character  will  be
	           expanded to INITAL-1 spaces, and so on through  the
	           first INITAL characters providing in each case that
	           none  of  the  characters  to  the  left  are   tab
	           characters.    After  the  sum  of  the  number  of
	           characters  which  have  been  inserted  into   the
	           processed   text,   whether  these  characters  are
	           printing characters or spaces in the original  text
	           or  spaces  resulting  from  the  expansion  of tab
	           characters, and, if INTRVL is equal to or less than
	           zero,  of  the  number  of  spaces  which have been
	           suppressed, equals the value of  INITAL,  then  the
	           tab   stop  interval  becomes  that  given  by  the
	           absolute value of the argument INTRVL.

	  INTRVL = not equal to zero, the absolute value of INTRVL  is
	           the tab stop interval.  On the PDP-10 computer, the
	           appropriate absolute value of  INTRVL  is  8,  and,
	           assuming  that  the  first  character in the buffer
	           corresponds to column 1, the value of INITAL at the
	           start  of  the  processing  of  the contents of the
	           original text can be either 0 or 8.  After the  sum
	           of  the  number  of  characters  inserted  into the
	           processed text and of the number of spaces, if any,
	           suppressed  by  a negative or zero value of INTRVL,
	           has reached at least the absolute value of  INITAL,
	           then  a  tab  character encountered in the original
	           text causes sufficient spaces to be  inserted  into
	           the processed text or else to be suppressed so that
	           the total number of characters  inserted  into  the
	           processed text or suppressed by the present call to
	           DAFILL equals the sum  of  the  absolute  value  of
	           INITAL  and  the  next higher whole multiple of the
	           absolute value of INTRVL.
	         = less  than  zero,  no  leading  spaces  are  to  be
	           inserted  into  the  processed  text  whether  such
	           leading spaces are requested by a negative value of
	           INITAL  or  by  leading spaces or tab characters in
	           the original text.  Once a printing  character  has
	           been  copied into the processed text, however, then
	           all  subsequent  spaces  will  be  copied  and  all
	           subsequent  tab  characters  will  be  expanded  to
	           spaces.
	         = zero,  no  spaces  are  to  be  inserted  into  the
	           processed  text.   Tab characters and spaces in the
	  FASP, FORTRAN Alphameric Subroutine Package          Page 57
	  DAFILL, Routine to Expand Tab Characters to Spaces


	           original text are ignored.
	         = greater than zero, all spaces whether requested  by
	           a  negative  value  of  INITAL  or by spaces or tab
	           characters in the original text are to be  inserted
	           into the processed text.

	  IBEGIN = the subscript of the IBUFFR array location at which
	           is  to  be found the first character of the text to
	           be processed.   Following  the  conversion  of  tab
	           characters  in  the  text  to  the proper number of
	           spaces, the processed text is placed back into  the
	           IBUFFR array starting at subscript IBEGIN.

	  IFINAL = the subscript of the IBUFFR array location at which
	           is  to  be found the final character of the text to
	           be processed.

	  MAXBFR = the subscript of the highest location in the IBUFFR
	           array  at  which  a character of the processed text
	           can be placed.  MAXBFR must  equal  or  be  greater
	           than IFINAL.  Any characters which require shifting
	           to a higher subscript than that indicated by MAXBFR
	           are instead discarded.

	  IBUFFR = the array used for input of the text containing tab
	           characters  which  are to be expanded to the proper
	           number of spaces, and used for output of  the  text
	           after  this  expansion  of tab characters to spaces
	           has been performed.  The characters in  the  IBUFFR
	           array  must  have  been read by a multiple of an A1
	           format.

	  MAXPRT = returned containing the subscript  of  the  highest
	           location  in  the  processed text into which DAFILL
	           has placed a printing (nonspace) character.  If  no
	           printing  characters  are placed into the processed
	           text, then MAXPRT will be returned  containing  the
	           value IBEGIN-1.

	  MAXUSD = returned containing the subscript  of  the  highest
	           location in the IBUFFR array containing a character
	           of the text after processing.  If  INTRVL  is  less
	           than  or  equal  to  zero,  and  the  original text
	           contained only spaces and/or tab  characters,  then
	           MAXUSD  is  returned containing the value IBEGIN-1.
	           If INTRVL is greater than zero, then MAXUSD will be
	           returned  containing  a  value  in the range IFINAL
	           through MAXBFR.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 58
	  DAFILL, Routine to Expand Tab Characters to Spaces


	                An Example of the Use of DAFILL
	                -- ------- -- --- --- -- ------

	  The sample program listed below and on  the  following  page
	  demonstrates  the  manner  in  which  DAFILL  is  used.  The
	  program asks the user for the values of the arguments INITAL
	  and  INTRVL,  then  prompts the user with an asterisk before
	  reading a line of text including tabs to be expanded to  the
	  corresponding number of spaces.  Since the asterisk is typed
	  in the first column, the first tab stop interval would be  1
	  less   than   the  subsequent  intervals.   On  the  PDP-10,
	  appropriate values would be INITAL=7 and  INTRVL=+/-8.   The
	  use  of  other values for these arguments would give results
	  different than  that  shown  directly  on  the  terminal  in
	  response to the user's typing.

	  The program calls DACOPY once for each  character  typed  by
	  the  user  to  mark  with  digits  in  a  second  buffer the
	  locations of the spaces resulting from the expansion of  tab
	  characters.   If  merely  copying  with  tab  expansion  was
	  desired, a single call to DACOPY similar  to  the  following
	  single call to DAFILL would be sufficient to expand the tabs
	  while copying the text typed by the user.

	  A  sample  dialog  between  the  program  and  the  user  is
	  presented following the listing of the program.



	        DATA ITTY,JTTY/5,5/
	        DATA IBEGIN,IFINAL,MAXBFR/6,55,72/
	        DATA IBLANK,ITAB/1H ,1H   /
	        DIMENSION IBUFFR(72),JBUFFR(72),IDIGIT(10)
	        DATA IDIGIT/1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,1H0/
	  C
	  C     ASK USER FOR THE INITIAL AND SUBEQUENT TAB STOPS
	      1 WRITE(JTTY,2)
	      2 FORMAT(1X/15H INITAL,INTRVL=,$)
	        READ(ITTY,3)INITAL,INTRVL
	      3 FORMAT(2I)
	  C
	  C     ASK FOR THE TEXT IN WHICH TABS ARE TO BE EXPANDED
	        WRITE(JTTY,4)
	      4 FORMAT(2H *,$)
	        READ(ITTY,5)(IBUFFR(I),I=IBEGIN,IFINAL)
	      5 FORMAT(60A1)
	  C
	  C     USE DACOPY TO REPORT LOCATIONS OF TABS
	        JUSED=IBEGIN-1
	        JNITAL=INITAL
	        KOUNT=0
	        MOST=JUSED
	        JNTRVL=INTRVL
	        DO 8 JBEGIN=IBEGIN,IFINAL
	  FASP, FORTRAN Alphameric Subroutine Package          Page 59
	  DAFILL, Routine to Expand Tab Characters to Spaces


	        KUSED=JUSED
	        CALL DACOPY(JNITAL,JNTRVL,IBUFFR,JBEGIN,JBEGIN,
	       1MAXBFR,JUSED,JBUFFR,NXTINI,NXTBGN,MAXPRT)
	        IF(JUSED.EQ.KUSED)GO TO 8
	        IF(JNTRVL.LT.0)JNTRVL=-JNTRVL
	        IF(IBUFFR(JBEGIN).EQ.IBLANK)GO TO 8
	        IF(IBUFFR(JBEGIN).NE.ITAB)GO TO 7
	        KOUNT=KOUNT+1
	        IF(KOUNT.GT.10)KOUNT=1
	      6 KUSED=KUSED+1
	        JBUFFR(KUSED)=IDIGIT(KOUNT)
	        IF(KUSED.LT.JUSED)GO TO 6
	        GO TO 8
	      7 MOST=MAXPRT
	      8 JNITAL=NXTINI
	        IF(MOST.GE.IBEGIN)WRITE(JTTY,11)
	       1(JBUFFR(I),I=IBEGIN,MOST)
	  C
	  C     USE DAFILL TO EXPAND SAME TEXT
	        CALL DAFILL(INITAL,INTRVL,IBEGIN,IFINAL,MAXBFR,
	       1IBUFFR,MAXPRT,MAXUSD)
	        IF(MAXUSD.LT.IBEGIN)GO TO 1
	        DO 9 I=IBEGIN,MAXUSD
	      9 IF(IBUFFR(I).EQ.ITAB)WRITE(JTTY,10)
	     10 FORMAT(6H ERROR)
	        IF(MAXPRT.LT.IBEGIN)GO TO 1
	        WRITE(JTTY,11)(IBUFFR(I),I=IBEGIN,MAXPRT)
	     11 FORMAT(2H  ,100A1)
	  C
	  C     REPORT COLUMN NUMBERS
	        LINE=1
	        IRIGHT=MAXPRT-IBEGIN+2
	     12 CALL DABELT(1,1,0,LINE,2,
	       1IRIGHT,0,MAXBFR,IBUFFR,MAXLIN,MAXPRT,MAXUSD)
	        WRITE(JTTY,11)(IBUFFR(I),I=1,MAXPRT)
	        LINE=LINE+1
	        IF(LINE.LE.MAXLIN)GO TO 12
	        GO TO 1
	        END



	  Typical Dialog Between DAFILL Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  INITAL,INTRVL=7 8

	  *       A        B                C                        D

	   1111111A 222222 B  333344444444  C   55   66666   77777   D
	          A        B                C                        D
	   23456789012345678901234567890123456789012345678901234567890
	           111111111122222222223333333333444444444455555555556
	  FASP, FORTRAN Alphameric Subroutine Package          Page 60
	  DAFILL, Routine to Expand Tab Characters to Spaces


	  INITAL,INTRVL=7 8

	  *       A               B               C               D

	   1111111A2222222 3333333B4444444  555555C6666666   77777D
	          A               B               C               D
	   23456789012345678901234567890123456789012345678901234567
	           111111111122222222223333333333444444444455555555

	  INITAL,INTRVL=7 8

	  *ABCDEF GHIJK   LMNO    PQR     ST      U

	   ABCDEF1GHIJK222LMNO3333PQR44444ST555555U
	   ABCDEF GHIJK   LMNO    PQR     ST      U
	   2345678901234567890123456789012345678901
	           11111111112222222222333333333344

	  INITAL,INTRVL=7 8

	  *A      BC      DEF     GHIJ    KLMNO   PQRSTU

	   A111111BC222222DEF33333GHIJ4444KLMNO555PQRSTU
	   A      BC      DEF     GHIJ    KLMNO   PQRSTU
	   234567890123456789012345678901234567890123456
	           1111111111222222222233333333334444444

	  INITAL,INTRVL=7 8

	  *                 ABC             DEF             GHI

	     1111122222222  ABC  344444444  DEF  566666666  GHI
	                    ABC             DEF             GHI
	   2345678901234567890123456789012345678901234567890123
	           11111111112222222222333333333344444444445555

	  INITAL,INTRVL=7 -8

	  *                 ABC             DEF             GHI

	   ABC  122222222  DEF  344444444  GHI
	   ABC             DEF             GHI
	   23456789012345678901234567890123456
	           111111111122222222223333333

	  INITAL,INTRVL=-7 -8

	  *                 ABC             DEF             GHI

	   ABC  122222222  DEF  344444444  GHI
	   ABC             DEF             GHI
	   23456789012345678901234567890123456
	           111111111122222222223333333
	  FASP, FORTRAN Alphameric Subroutine Package          Page 61
	  DAFLAG, Routine to Locate Components of File Specification


	  DDDDD          AAA  FFFFFFFF  LL              AAA     GGGGG
	  DD   DD       AAAA  FF        LL             AAAA   GG
	  DD    DD     AA AA  FF        LL            AA AA  GG
	  DD    DD    AA  AA  FFFFF     LL           AA  AA  GG  GGGG
	  DD    DD   AAAAAAA  FF        LL          AAAAAAA  GG    GG
	  DD   DD   AA    AA  FF        LL         AA    AA   GG   GG
	  DDDDD    AA     AA  FF        LLLLLLLL  AA     AA     GGGGG


	   DAFLAG, Routine to Locate Components of File Specification
	   ------  ------- -- ------ ---------- -- ---- -------------

	  DAFLAG  locates  the  components  of  a  file  specification
	  contained  in  a  buffer  read by the calling program with a
	  multiple  of  an  A1  format.   Although  the  leading   and
	  separating   characters   are   those   expected   in   file
	  specifications  for  Digital  Equipment  Corporation   (DEC)
	  computers,  no evaluation of the components is performed, so
	  this  routine  could  be  used  to   find   the   parts   of
	  specifications   having  the  same  leading  and  separating
	  characters but which are meant for other purposes.

	  The basic form of a file specification is

	  DEVICE:NAME.EXT[NUMBER,NUMBER]/SWITCH:'TEXT'/SWITCH:NUMBER

	  or

	  [NUMBER,NUMBER]DEVICE:NAME.EXT/SWITCH:'TEXT'/SWITCH:NUMBER

	  in which NUMBER merely implies a location at which a  number
	  might  be  present,  but  which  could  instead  contain any
	  sequence of printing characters other  than  the  separation
	  and  delimiter  characters.  Only one device field, one name
	  field and one bracketed  field  can  appear  together  in  a
	  single  file  specification.   The  device field must appear
	  before the name  field,  but  the  bracketed  field  can  be
	  before,  between,  or after the device and name fields.  The
	  calling program is also  informed  if  an  at  sign  appears
	  anywhere  within  the file specification other than within a
	  switch field.  Switch fields consisting of  initial  slashes
	  followed   by   words   connected  by  colons  are  reported
	  separately from the  rest  of  the  file  specification  and
	  separately  from  each  other  by  separate  calls  to  this
	  routine.  Complete file specifications can be  separated  by
	  commas,  semicolons  or  equal  signs.   Comments  which are
	  otherwise ignored can appear to  the  right  of  exclamation
	  points and ampersands.

	  Spaces and/or tab characters can appear to  either  side  of
	  the items enclosed within the brackets, and can appear after
	  the leading slashes of switch fields  and  both  before  and
	  after  the  connecting colons in switch fields.  The calling
	  program can specify whether other spaces  are  to  terminate
	  FASP, FORTRAN Alphameric Subroutine Package          Page 62
	  DAFLAG, Routine to Locate Components of File Specification


	  the  file  specification,  or  are to terminate a particular
	  field  within  the  file  specification  or  are  to  merely
	  terminate  a  particular  component  within the field.  In a
	  bracketed field, commas  are  not  necessary  between  items
	  which   are   separated  by  spaces  and/or  tab  characters
	  providing  the  items  being  separated  are  present.   For
	  example,  the  file specification DAFLAG[6001,56] could also
	  be written as DAFLAG[6001 56] or  as  DAFLAG[6001 , 56]  but
	  the comma in DAFLAG[,56] or DAFLAG[ , 56] is necessary since
	  this comma  indicates  that  the  first  number  within  the
	  bracketed field is missing.

	  The components of each field within the  file  specification
	  are  identified  to  the  calling  program  by length and by
	  starting location within the buffer.   This  information  is
	  returned within the 2 arrays KNTLTR and INILTR respectively.
	  The descriptions of the components of each field are grouped
	  together  in  the  arrays  returned  to the calling program.
	  Since each field can consist of  any  number  of  components
	  connected  by  the  appropriate  character  (colon, comma or
	  period),  and  since  for  some  applications   a   terminal
	  separator  character  has  special meaning, an extra zero is
	  returned in the  KNTLTR  array  if  a  connecting  character
	  terminates  the  field but is not necessary.  Since there is
	  never any question about whether an item in the device field
	  was followed by the connecting character, the description of
	  the device field does not include an extra zero.  Whether an
	  extra  zero  appears within the description of the bracketed
	  field  is  independent  of  whether  the  right  bracket  is
	  present.

	  Text strings delimited by apostrophes  are  recognized  only
	  within  the  switch fields.  If a text string is found which
	  has not been preceded by a slash then this  text  string  is
	  treated  as  though  it  were the only component of a switch
	  field which cannot be extended by  a  subsequent  colon,  so
	  that  anything  appearing  to  the  right of the text string
	  would have to be evaluated by the next call to this routine.
	  The  location  of  a  text string as returned to the calling
	  program is that of the initial apostrophe, and the length of
	  the  text  string  includes  the initial, but not the final,
	  apostrophe.  If the final apostrophe is  missing,  then  the
	  text  string  is  assumed  to  extend  through the rightmost
	  printing character in the buffer.  Within a text string, two
	  immediately   adjacent   apostrophes   indicate   a   single
	  apostrophe which is to be included within  the  string.   If
	  two  immediately adjacent apostrophes are encountered within
	  the text string, then the remaining portion of the string is
	  moved  1 character to the left so that the returned contents
	  of the buffer and the returned length in the KNTLTR array do
	  not include the extra apostrophe.

	  FASP, FORTRAN Alphameric Subroutine Package          Page 63
	  DAFLAG, Routine to Locate Components of File Specification


	  For example, if the contents of the buffer are

	  DSK:DAFLAG.F4[6001,56,FASP]/LINE:60:/TITLE:'(JAN 76)'

	  then the information returned by  the  first  call  to  this
	  routine would be

	       field         KNTLTR contents      INILTR contents

	       device              3                    1

	       name                6                    5
	                           2                   12

	       bracketed           4                   15
	                           2                   20
	                           4                   23

	  and the information returned by  the  second  call  to  this
	  routine would be

	       switch              4                   29
	                           2                   34
	                           0                undefined

	  and the information returned  by  the  third  call  to  this
	  routine would be

	       switch              5                   38
	                           9                   44

	  Some DECsystem-10 programs interpret an  asterisk  which  is
	  attached  directly to the right end of one of the components
	  of a file specification as indicating a wild-card  match  of
	  any  and  of  all  characters  at  or  to  the right of that
	  position within the component.  A  leftmost  asterisk  would
	  then  be  matched  by  any  character  sequence.   Since the
	  asterisk  logically  terminates  the  specification   of   a
	  particular   component,   any  asterisk  which  is  followed
	  immediately by a printing character other than a punctuation
	  mark  is  treated  by the DAFLAG routine as though separated
	  from this following character by a period if within  a  name
	  field, by a comma if within a bracketed field, or by a colon
	  if within a  switch  field.   Therefore,  the  text  strings
	  FASP*.F4[*,56]  and  FASP*F4[*56]  would both be treated the
	  same by  the  DAFLAG  routine.   These  text  strings  would
	  specify  all  files  in which the first name begins with the
	  letters FASP, which have the second name F4 and which belong
	  to  any  user  identified  by  the  second  number 56.  This
	  interpretation of the asterisk is of course  dependent  upon
	  the  existence  of the proper logic within the program which
	  calls DAFLAG and is  in  no  way  supported  by  the  DAFLAG
	  routine itself.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 64
	  DAFLAG, Routine to Locate Components of File Specification


	                    The DAFLAG Argument List
	                    --- ------ -------- ----

	  The argument list of routine DAFLAG is

	        SUBROUTINE DAFLAG(KONECT,LOWSTR,MAXSTR,MAXBFR,IBUFFR,
	       1    LOWBFR,MANY  ,KIND  ,INILTR,KNTLTR,MAXDSK,MAXNAM,
	       2    MAXNUM,MAXFLG,KONTNT,MINPRT,MAXPRT)

	  with the associated DIMENSION statement

	        DIMENSION KNTLTR(MAXSTR),INILTR(MAXSTR),IBUFFR(MAXBFR)

	  The following arguments are used only  for  input,  and  are
	  returned unchanged.

	  KONECT = -1, spaces and tab characters mark the end  of  the
	           current  component of the current field, but do not
	           indicate either the end of the field or the end  of
	           the  file specification.  Spaces and tab characters
	           can appear before and after any field,  before  and
	           after  colons  in  the  device  field,  between the
	           components  of  the   name   field,   between   the
	           components  of  the  bracketed field, and following
	           the  initial  slash  and  before  and   after   the
	           separating colons in the switch field.  Periods are
	           not necessary between components of the name  field
	           which   are   separated   by   spaces   and/or  tab
	           characters.   Commas  are  not  necessary   between
	           components   of   the  bracketed  field  which  are
	           separated by spaces  and/or  tab  characters.   The
	           file  specification  will extend through the end of
	           the buffer,  or  up  to  the  following  ampersand,
	           equals  sign, semicolon or exclamation point, or up
	           to the following comma which is not in a  bracketed
	           field.   All  of  the  special characters mentioned
	           here including the space and tab characters are  of
	           course   treated  no  differently  than  any  other
	           characters when these appear within a  text  string
	           delimited  by  apostrophes.  If KONECT=-1, then the
	           text strings
	           DSK : DAFLAG F4 [ 6007 56 ] / HEADER : 0 / DISPOSE
	                and
	           DSK:DAFLAG.F4[6007,56]/HEADER:0/DISPOSE
	           are equivalent.
	         = 0, spaces and tab characters which are  not  within
	           either  bracketed  fields or switch fields mark the
	           end of the  file  specification.   Spaces  and  tab
	           characters can appear between the components of the
	           bracketed field, and following  the  initial  slash
	           and  before  and after the separating colons in the
	           switch field.  Commas  are  not  necessary  between
	           components   of   the  bracketed  field  which  are
	           separated by spaces  and/or  tab  characters.   The
	  FASP, FORTRAN Alphameric Subroutine Package          Page 65
	  DAFLAG, Routine to Locate Components of File Specification


	           file  specification  will extend through the end of
	           the buffer,  or  up  to  the  following  ampersand,
	           equals  sign, semicolon or exclamation point, or up
	           to the following comma which is not in a  bracketed
	           field,  or  up  the the next space or tab character
	           which is  within  neither  a  bracketed  field  nor
	           within   a   switch  field.   All  of  the  special
	           characters mentioned here including the  space  and
	           tab characters are of course treated no differently
	           than any other characters when these appear  within
	           a   text   string  delimited  by  apostrophes.   If
	           KONECT=0, then the text strings
	           DSK:DAFLAG.F4[6007 56]/ HEADER : 0 / DISPOSE
	                and
	           DSK:DAFLAG.F4[6007,56]/HEADER:0/DISPOSE
	           are equivalent.
	         = 1, spaces and tab characters which are  not  within
	           either  bracketed  fields or switch fields mark the
	           end of  the  device  or  name  field,  but  do  not
	           indicate the end of the file specification.  Spaces
	           and tab characters can appear before and after  any
	           field,  between  the  components  of  the bracketed
	           field, and following the initial slash  and  before
	           and  after  the  separating  colons  in  the switch
	           field.  Commas are not necessary between components
	           of  the  bracketed  field  which  are  separated by
	           spaces   and/or   tab   characters.     The    file
	           specification  will  extend  through the end of the
	           buffer, or up to the  following  ampersand,  equals
	           sign,  semicolon or exclamation point, or up to the
	           following comma which is not in a bracketed  field.
	           All   of  the  special  characters  mentioned  here
	           including the  space  and  tab  characters  are  of
	           course   treated  no  differently  than  any  other
	           characters when these appear within a  text  string
	           delimited  by  apostrophes.   If KONECT=1, then the
	           text strings
	           DSK: DAFLAG.F4 [6007 56] / HEADER : 0 / DISPOSE
	                and
	           DSK:DAFLAG.F4[6007,56]/HEADER:0/DISPOSE
	           are equivalent.

	  LOWSTR = subscript of the first location within  the  INILTR
	           and  KNTLTR  arrays  which  can  be  used to hold a
	           description  of  the   components   of   the   file
	           specification.

	  MAXSTR = subscript of the final location within  the  INILTR
	           and  KNTLTR  arrays  which  can  be  used to hold a
	           description  of  the   components   of   the   file
	           specification.

	  MAXBFR = subscript of the final (rightmost) location  within
	           the  IBUFFR  array which contains a character which
	  FASP, FORTRAN Alphameric Subroutine Package          Page 66
	  DAFLAG, Routine to Locate Components of File Specification


	           can be part of the file specification.

	  The following arguments are used  for  both  input  to,  and
	  output from this routine.

	  IBUFFR = array  containing   in   locations   IBUFFR(LOWBFR)
	           through  IBUFFR(MAXBFR)  the characters read by the
	           calling program with a multiple of an A1 format and
	           which   can   form  the  file  specification.   The
	           contents  of  the   IBUFFR   array   are   returned
	           unchanged, with the exception that the portion of a
	           text string to the right of adjacent apostrophes in
	           a  text  string  in  a  switch  field  is  moved  1
	           character to the left.

	  LOWBFR = subscript of the first (leftmost)  location  within
	           the  IBUFFR  array which contains a character which
	           can be part of the file specification.   LOWBFR  is
	           returned  pointing  to  the  first  character which
	           should be evaluated by the subsequent call to  this
	           routine,  or  else  is returned pointing beyond the
	           end of the buffer if the buffer is empty or if  the
	           buffer  contains  merely  a  comment indicated by a
	           leading  exclamation  point   or   by   a   leading
	           ampersand.

	  MANY   = should be input  containing  zero  each  time  this
	           routine  is  called  to  begin  processing of a new
	           logical  section  of  text,  as  for  example  when
	           beginning  processing of a line of text not tied to
	           the previous line by an ampersand at the end of the
	           previous  line,  or when processing the text to the
	           right of a semicolon or to the right of  an  equals
	           sign.  The initial zeroing of this argument must be
	           done by the calling  program,  but  thereafter  the
	           value returned by the previous call to this routine
	           can usually be used.
	         = returned containing the  value  which  MANY  should
	           have  when  this  routine  or any other in the FASP
	           package having MANY as an argument is next  called.
	           The returned value of MANY should not be changed by
	           the calling program unless  the  interpretation  of
	           the  contents  of  the  buffer  is  being abandoned
	           prematurely, in which case MANY should be reset  to
	           have a zero value.
	         = -1, returned if a missing item is to  be  indicated
	           if  the  next routine encounters a leading comma or
	           finds that the buffer contains nothing other than a
	           possible comment indicated by a leading exclamation
	           point.  MANY is returned containing -1 if  a  comma
	           precedes either an ampersand or a switch field.
	         = 0, returned if a missing item is to be indicated if
	           the  next routine encounters a leading comma, but a
	           missing  item  is  not  indicated  if  the   buffer
	  FASP, FORTRAN Alphameric Subroutine Package          Page 67
	  DAFLAG, Routine to Locate Components of File Specification


	           contains  nothing  other  than  a  possible comment
	           indicated by a leading exclamation point.  MANY  is
	           returned  containing zero if the buffer is found to
	           be empty, or if the first printing character at  or
	           to  right  of  IBUFFR(LOWBFR)  is  found  to  be an
	           exclamation point, a semicolon or an  equals  sign.
	           These  are all conditions under which the next call
	           to this routine would evaluate the start of  a  new
	           group  of  file  specifications.   MANY is returned
	           unchanged if a switch field is found at  the  start
	           of the contents of the buffer.
	         = 1,  returned  if  a  missing  item  is  not  to  be
	           indicated  if the next routine encounters a leading
	           comma or finds that  the  buffer  contains  nothing
	           other  than  a  possible  comment  indicated  by  a
	           leading  exclamation  point.   MANY   is   returned
	           containing  one  if a file specification consisting
	           of more than just a switch field is found, or if  a
	           missing item is being indicated.

	  The following arguments are used  only  for  output.   Their
	  input values are ignored.

	  KIND   = returned describing the type of item encountered.
	         = 1, nothing, except possibly a comment indicated  by
	           a leading exclamation point, was found at or to the
	           right  of  IBUFFR(LOWBFR).   LOWBFR   is   returned
	           pointing beyond the end of the buffer.
	         = 2, the first printing character at or to the  right
	           of   IBUFFR(LOWBFR)  is  a  semicolon.   LOWBFR  is
	           returned pointing to the character to the right  of
	           the  semicolon.   It  is suggested that the calling
	           program treat this as an  indication  by  the  user
	           that  the  preceding command has been completed and
	           that a subsequent command will follow on  the  same
	           line.
	         = 3, the first printing character at or to the  right
	           of  IBUFFR(LOWBFR)  is  an  equals sign.  LOWBFR is
	           returned pointing to the character to the right  of
	           the equals sign.  On the PDP-10 computer, an equals
	           sign is used in file transfer commands to  separate
	           destination and source file specifications.
	         = 4, the first printing character at or to the  right
	           of  IBUFFR(LOWBFR) is an ampersand.  The characters
	           to the right of the ampersand are  taken  to  be  a
	           comment.   LOWBFR  is  returned pointing beyond the
	           end of  the  buffer.   It  is  suggested  that  the
	           calling program treat this as a request by the user
	           that the command  be  continued  on  the  following
	           line.   The  effect is not quite the same as if the
	           user had typed all of the file specifications on  a
	           single  line  since  a file specification cannot be
	           split across a line boundary.
	         = 5, a missing file specification was indicated by an
	  FASP, FORTRAN Alphameric Subroutine Package          Page 68
	  DAFLAG, Routine to Locate Components of File Specification


	           extra comma.
	         = 6, a partial file  specification  was  found  which
	           will  be  continued  by the subsequent call to this
	           routine.  A single call to this  routine  can  only
	           return the description of a single switch field, or
	           of the portion of a file specification exclusive of
	           a trailing switch field if any.

	           For example, if the text buffer contains:
	                NAME.EXT/FIRST:SECOND/THIRD:FOURTH
	           then the first call to this  routine  would  return
	           the  description  of  the  name  field NAME.EXT and
	           would return KIND=6, the second call  would  return
	           the  description  of the switch field /FIRST:SECOND
	           and would again return KIND=6, and the  third  call
	           would  return  the  description of the switch field
	           /THIRD:FOURTH and would finally return KIND=7.
	         = 7, a file specification (possibly consisting merely
	           of a switch field) was found.  If the previous call
	           to  this  routine  returned  KIND=6  indicating   a
	           partial   specification,   then   the   information
	           returned  by  the  current  call  to  this  routine
	           completes  the  file  specification.  If the entire
	           file specification consisted only of switch fields,
	           and if these switch fields were preceded by a comma
	           and/or are followed by a comma, then the next  call
	           to  this  routine  will  return KIND=5 indicating a
	           missing item unless the calling program first  sets
	           MANY to have the value 1.
	         = 8, a file specification was  found,  but  this  was
	           followed  by  an unexpected character pointed to by
	           the returned value of  LOWBFR.   For  example,  the
	           text  DEVICE:NAME.EXTENSION:  would be evaluated as
	           though the buffer terminated prior  to  the  second
	           colon,  and  LOWBFR  would  be returned pointing to
	           this      second       colon.        The       text
	           DEVICE:NAME.EXTENSION[6001,56][22,56]    would   be
	           evaluated as though the buffer terminated prior  to
	           the  second  bracketed  field,  and LOWBFR would be
	           returned pointing to the second left bracket.

	  INILTR = array returned containing the subscripts within the
	           the  IBUFFR  array of the initial characters of the
	           words forming the file specification.

	           Locations INILTR(LOWSTR) through INILTR(MAXDSK) are
	           returned  containing the locations in the buffer of
	           the initial characters of the device names.

	           Locations INILTR(MAXDSK+1)  through  INILTR(MAXNAM)
	           are returned containing the locations in the buffer
	           of the initial characters of the words in the  name
	           field.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 69
	  DAFLAG, Routine to Locate Components of File Specification


	           Locations INILTR(MAXNAM+1)  through  INILTR(MAXNUM)
	           are returned containing the locations in the buffer
	           of the initial  characters  of  the  words  in  the
	           bracketed field.

	           If MAXFLG is returned  greater  than  or  equal  to
	           LOWSTR,  then  MAXDSK and MAXNAM and MAXNUM are all
	           returned set to LOWSTR-1, KONTNT is returned set to
	           zero,    and   locations   INILTR(LOWSTR)   through
	           INILTR(MAXFLG)   are   returned   containing    the
	           locations  in  the buffer of the initial characters
	           of the words and  text  strings  appearing  in  the
	           switch field.  If a text string appears in a switch
	           field, the location in the IBUFFR  array  indicated
	           by the INILTR array will contain an apostrophe.

	           If  a  switch  is  found  which  can  take  a  file
	           specification as its argument, and if an additional
	           switch field component was found to  the  right  of
	           this  switch  name,  then LOWBFR should be reset to
	           the value returned for this next component  in  the
	           INILTR array and this routine should then be called
	           again to  evaluate  the  file  specification  which
	           appears as an argument.

	  KNTLTR = array returned containing the numbers of characters
	           in each of the words for which the first characters
	           are in the buffer locations indicated by the values
	           in  the INILTR array.  The subscripts of the INILTR
	           array  and  KNTLTR  array  locations  describing  a
	           particular  word  are  identical.   If  a  location
	           within the KNTLTR array is returned  set  to  zero,
	           then  the  corresponding location within the INILTR
	           array is returned undefined.

	  MAXDSK = returned containing the subscript of the INILTR and
	           KNTLTR  array  locations  describing  the rightmost
	           component  of  the  device  field   of   the   file
	           specification.   If  a  device  field is not found,
	           then MAXDSK will be returned containing LOWSTR-1.

	  MAXNAM = returned containing the subscript of the INILTR and
	           KNTLTR  array  locations  describing  the rightmost
	           component  of  the   name   field   of   the   file
	           specification.   If a name field is not found, then
	           MAXNAM will be returned equal to MAXDSK.

	  MAXNUM = returned containing the subscript of the INILTR and
	           KNTLTR  array  locations  describing  the rightmost
	           component  of  the  bracketed  field  of  the  file
	           specification.   If a bracketed field is not found,
	           then MAXNUM will be returned equal to MAXNAM.

	  MAXFLG = returned containing the subscript of the INILTR and
	  FASP, FORTRAN Alphameric Subroutine Package          Page 70
	  DAFLAG, Routine to Locate Components of File Specification


	           KNTLTR  array  locations  describing  the rightmost
	           component of the switch field.  If a  switch  field
	           is  not  found,  then  MAXFLG  is returned equal to
	           LOWSTR-1.

	  KONTNT = bit coded number returned describing  the  location
	           of  the  bracketed field relative to the device and
	           name fields.  The right bit is one if and only if a
	           name field is found.  The second bit from the right
	           is one if and only if a device field is found.  The
	           fourth  and  third bits from the right are 00 if no
	           bracketed field is found, 01 if a  bracketed  field
	           appears  first,  10  if a bracketed field follows a
	           device field, and 11 if a bracketed field follows a
	           name field.

	           The following table presents the values  of  KONTNT
	           returned  for  all possible combinations of device,
	           name  and  bracketed  fields.   The   minus   signs
	           represent   values   of   KONTNT  which  cannot  be
	           returned.  The value zero  indicates  that  neither
	           device,  nor  name nor bracketed fields were found,
	           but does not indicate if a switch field was found.

	           decimal binary          decimal binary
	                 0    0  nothing         8 1000  ------
	                 1    1  NAME            9 1001  ------
	                 2   10  DEVICE:        10 1010  DEVICE:[]
	                 3   11  DEVICE:NAME    11 1011  DEVICE:[]NAME
	                 4  100  []             12 1100  ------
	                 5  101  []NAME         13 1101  NAME[]
	                 6  110  []DEVICE:      14 1110  ------
	                 7  111  []DEVICE:NAME  15 1111  DEVICE:NAME[]

	           16 is added to KONTNT if an at sign  (@)  is  found
	           before  or  after  device, name or bracketed field.
	           The at sign, like  the  brackets  and  period,  are
	           treated   no   differently   than   any  alphabetic
	           character within a switch field.

	  MINPRT = the subscript of the IBUFFR  array  location  which
	           contains  the  leftmost  printing  character in the
	           portion of the file specification evaluated by  the
	           current  call  to  this routine if KIND is returned
	           containing the value  6  or  greater.   MINPRT  and
	           MAXPRT  can  be  used  as  the limits of the IBUFFR
	           array subscripts  if  the  text  evaluated  by  the
	           current  call  to this routine must be displayed to
	           the user.  MINPRT and MAXPRT are returned undefined
	           if KIND is returned set to a value less than 6.

	  MAXPRT = the subscript of the IBUFFR  array  location  which
	           contains  the  rightmost  printing character of the
	           portion of the file specification evaluated by  the
	  FASP, FORTRAN Alphameric Subroutine Package          Page 71
	  DAFLAG, Routine to Locate Components of File Specification


	           current  call  to  this routine if KIND is returned
	           containing the value 6 or greater.  MAXPRT  can  be
	           returned  set  to  less  than the returned value of
	           LOWBFR if  the  text  to  the  right  of  the  file
	           specification had to be searched for a continuation
	           of the file specification.



	       Demonstration Program to Interactively Test DAFLAG
	       ------------- ------- -- ------------- ---- ------

	  The program listed on the following pages accepts a line  of
	  text  from  the  user, then summarizes the components of the
	  file specifications located within this text by DAFLAG.  The
	  argument named KONECT initially has the value zero, but this
	  value can be changed to -1, back to 0 or to  1  if  a  minus
	  sign,  a zero or a plus sign respectively is is found as the
	  first character of a new line typed by the user.  After each
	  call  to  DAFLAG,  the program reports the returned value of
	  the argument named KONTNT, together with  a  description  of
	  the type of item found as indicated by the returned value of
	  the argument named KIND.  This is followed by a  listing  of
	  the  length  of  and  the  characters  forming  each  of the
	  components of each of the fields of the file specification.

	  A  sample  dialog  between  the  program  and  the  user  is
	  presented following the listing of the program.

	  C     PROGRAM TO DEMONSTRATE DAFLAG ROUTINE
	  C
	        DIMENSION KNTLTR(25),INILTR(25),IBUFFR(60)
	        DATA ITTY,JTTY/5,5/
	        DATA MINUS,IZERO,IPLUS,IONE,IGREAT/
	       11H-,1H0,1H+,1H1,1H>/
	        DATA LOWSTR,MAXSTR,MAXBFR/4,20,60/
	        KONECT=0
	        MANY=0
	        WRITE(JTTY,1)
	      1 FORMAT(1X,37HPROGRAM TO DEMONSTRATE DAFLAG ROUTINE/
	       146H INDICATE KONECT BY -, 0 OR + AS 1ST CHARACTER/
	       244H KONECT IS UNCHANGED IF -, 0 OR + IS NOT 1ST)
	      2 WRITE(JTTY,3)
	      3 FORMAT(1X,1H*,$)
	        READ(ITTY,4)IBUFFR
	      4 FORMAT(60A1)
	        LOWBFR=1
	  C
	  C     OBTAIN VALUE OF KONECT FROM START OF TEXT
	        I=-2
	        IF(IBUFFR(1).EQ.MINUS)I=-1
	        IF(IBUFFR(1).EQ.IZERO)I=0
	        IF(IBUFFR(1).EQ.IPLUS)I=1
	        IF(IBUFFR(1).EQ.IONE)I=1
	  FASP, FORTRAN Alphameric Subroutine Package          Page 72
	  DAFLAG, Routine to Locate Components of File Specification


	        IF(I.EQ.-2)GO TO 5
	        KONECT=I
	        LOWBFR=2
	  C
	  C     LOCATE COMPONENTS OF FILE DESCRIPTION
	      5 CALL DAFLAG(KONECT,LOWSTR,MAXSTR,MAXBFR,IBUFFR,
	       1LOWBFR,MANY,KIND,INILTR,KNTLTR,MAXDSK,MAXNAM,
	       2MAXNUM,MAXFLG,KONTNT,MINPRT,MAXPRT)
	  C
	  C     REPORT TYPE OF ITEM LOCATED
	        IF(KIND.GE.6)WRITE(JTTY,6)
	       1(IBUFFR(I),I=MINPRT,MAXPRT),IGREAT
	      6 FORMAT(1X,1H<,100A1)
	        IF(KIND.EQ.1)WRITE(JTTY,7)
	      7 FORMAT(6H EMPTY)
	        IF(KIND.EQ.2)WRITE(JTTY,8)
	      8 FORMAT(10H SEMICOLON)
	        IF(KIND.EQ.3)WRITE(JTTY,9)
	      9 FORMAT(7H EQUALS)
	        IF(KIND.EQ.4)WRITE(JTTY,10)
	     10 FORMAT(10H AMPERSAND)
	        IF(KIND.EQ.5)WRITE(JTTY,11)
	     11 FORMAT(8H MISSING)
	        IF(KIND.EQ.6)WRITE(JTTY,12)KONTNT
	     12 FORMAT(8H PARTIAL,I4)
	        IF(KIND.EQ.7)WRITE(JTTY,13)KONTNT
	     13 FORMAT(9H TERMINAL,I3)
	        IF(KIND.EQ.8)WRITE(JTTY,14)KONTNT
	     14 FORMAT(8H ERROR  ,I4)
	  C
	  C     SUMMARIZE COMPONENTS OF FILE SPECIFICATION
	        LIMIT=LOWSTR-1
	        DO 20 IPART=1,4
	        ISTART=LIMIT+1
	        IF(IPART.EQ.1)LIMIT=MAXDSK
	        IF(IPART.EQ.2)LIMIT=MAXNAM
	        IF(IPART.EQ.3)LIMIT=MAXNUM
	        IF(IPART.EQ.4)LIMIT=MAXFLG
	     15 IF(ISTART.GT.LIMIT)GO TO 20
	        J=INILTR(ISTART)
	        K=KNTLTR(ISTART)
	        K=J+K-1
	        IF(K.LT.J)K=J
	        IF(IPART.EQ.1)WRITE(JTTY,16)KNTLTR(ISTART),
	       1(IBUFFR(I),I=J,K)
	     16 FORMAT(9H   DEVICE,I3,1X,100A1)
	        IF(IPART.EQ.2)WRITE(JTTY,17)KNTLTR(ISTART),
	       1(IBUFFR(I),I=J,K)
	     17 FORMAT(9H   NAME  ,I3,1X,100A1)
	        IF(IPART.EQ.3)WRITE(JTTY,18)KNTLTR(ISTART),
	       1(IBUFFR(I),I=J,K)
	     18 FORMAT(9H   BRCKTD,I3,1X,100A1)
	        IF(IPART.EQ.4)WRITE(JTTY,19)KNTLTR(ISTART),
	       1(IBUFFR(I),I=J,K)
	  FASP, FORTRAN Alphameric Subroutine Package          Page 73
	  DAFLAG, Routine to Locate Components of File Specification


	     19 FORMAT(9H   SWITCH,I3,1X,100A1)
	        ISTART=ISTART+1
	        GO TO 15
	     20 CONTINUE
	        IF(KIND.EQ.1)GO TO 2
	        IF(KIND.EQ.4)GO TO 2
	        GO TO 5
	        END



	  Typical Dialog Between DAFLAG Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  PROGRAM TO DEMONSTRATE DAFLAG ROUTINE
	  INDICATE KONECT BY -, 0 OR + AS 1ST CHARACTER
	  KONECT IS UNCHANGED IF -, 0 OR + IS NOT 1ST
	  */ONE:TWO [THREE,FOUR,FIVE]SIX:SEVEN.EIGHT.NINE/'TEN':'ZERO'
	  </ONE:TWO>
	  PARTIAL   0
	    SWITCH  3 ONE
	    SWITCH  3 TWO
	  <[THREE,FOUR,FIVE]SIX:SEVEN.EIGHT.NINE>
	  PARTIAL   7
	    DEVICE  3 SIX
	    NAME    5 SEVEN
	    NAME    5 EIGHT
	    NAME    4 NINE
	    BRCKTD  5 THREE
	    BRCKTD  4 FOUR
	    BRCKTD  4 FIVE
	  </'TEN':'ZERO>
	  TERMINAL  0
	    SWITCH  4 'TEN
	    SWITCH  5 'ZERO
	  EMPTY
	  *-/ ONE : TWO [ THREE FOUR , FIVE ] SIX : SEVEN EIGHT . NINE
	  </ ONE : TWO>
	  PARTIAL   0
	    SWITCH  3 ONE
	    SWITCH  3 TWO
	  <[ THREE FOUR , FIVE ] SIX : SEVEN EIGHT . NINE>
	  TERMINAL  7
	    DEVICE  3 SIX
	    NAME    5 SEVEN
	    NAME    5 EIGHT
	    NAME    4 NINE
	    BRCKTD  5 THREE
	    BRCKTD  4 FOUR
	    BRCKTD  4 FIVE
	  EMPTY
	  FASP, FORTRAN Alphameric Subroutine Package          Page 74
	  DAFLAG, Routine to Locate Components of File Specification


	  *0/ ONE : TWO [ THREE FOUR , FIVE ] SIX : SEVEN EIGHT . NINE
	  </ ONE : TWO>
	  PARTIAL   0
	    SWITCH  3 ONE
	    SWITCH  3 TWO
	  <[ THREE FOUR , FIVE ]>
	  TERMINAL  4
	    BRCKTD  5 THREE
	    BRCKTD  4 FOUR
	    BRCKTD  4 FIVE
	  <SIX>
	  TERMINAL  1
	    NAME    3 SIX
	  <:>
	  TERMINAL  2
	    DEVICE  0
	  <SEVEN>
	  TERMINAL  1
	    NAME    5 SEVEN
	  <EIGHT>
	  TERMINAL  1
	    NAME    5 EIGHT
	  <.>
	  TERMINAL  1
	    NAME    0
	    NAME    0
	  <NINE>
	  TERMINAL  1
	    NAME    4 NINE
	  EMPTY
	  *+/ ONE : TWO [ THREE FOUR , FIVE ] SIX : SEVEN EIGHT . NINE
	  </ ONE : TWO>
	  PARTIAL   0
	    SWITCH  3 ONE
	    SWITCH  3 TWO
	  <[ THREE FOUR , FIVE ] SIX>
	  ERROR     5
	    NAME    3 SIX
	    BRCKTD  5 THREE
	    BRCKTD  4 FOUR
	    BRCKTD  4 FIVE
	  <: SEVEN>
	  ERROR     3
	    DEVICE  0 :
	    NAME    5 SEVEN
	  <EIGHT>
	  ERROR     1
	    NAME    5 EIGHT
	  <.>
	  ERROR     1
	    NAME    0 .
	    NAME    0
	  FASP, FORTRAN Alphameric Subroutine Package          Page 75
	  DAFLAG, Routine to Locate Components of File Specification


	  <NINE>
	  TERMINAL  1
	    NAME    4 NINE
	  EMPTY
	  *,'ONE'TWO'THREE',=,FOUR,;@FIVE,SIX@&SPECIAL CHARACTERS
	  MISSING
	  <'ONE>
	  PARTIAL   0
	    SWITCH  4 'ONE
	  <TWO>
	  PARTIAL   1
	    NAME    3 TWO
	  <'THREE>
	  TERMINAL  0
	    SWITCH  6 'THREE
	  MISSING
	  EQUALS
	  MISSING
	  <FOUR>
	  TERMINAL  1
	    NAME    4 FOUR
	  MISSING
	  SEMICOLON
	  <@FIVE>
	  TERMINAL 17
	    NAME    4 FIVE
	  <SIX@>
	  TERMINAL 17
	    NAME    3 SIX
	  AMPERSAND
	  *,SEVEN,&NO MISSING ITEM AT START OF THIS LINE
	  <SEVEN>
	  TERMINAL  1
	    NAME    5 SEVEN
	  AMPERSAND
	  *,EIGHT!COMMAS IN BOTH LINES INDICATE SINGLE MISSING ITEM
	  MISSING
	  <EIGHT>
	  TERMINAL  1
	    NAME    5 EIGHT
	  EMPTY
	  *!DEMONSTRATE POSSIBLE VALUES OF KONTNT IN RANGE 1 THRU 15
	  EMPTY
	  *A,B:,C:D,[E],[F]G,[H]I:,[J]K:L,M:[N],O:[P]Q,R[S],T:U[V]
	  <A>
	  TERMINAL  1
	    NAME    1 A
	  <B:>
	  TERMINAL  2
	    DEVICE  1 B
	  <C:D>
	  TERMINAL  3
	    DEVICE  1 C
	    NAME    1 D
	  FASP, FORTRAN Alphameric Subroutine Package          Page 76
	  DAFLAG, Routine to Locate Components of File Specification


	  <[E]>
	  TERMINAL  4
	    BRCKTD  1 E
	  <[F]G>
	  TERMINAL  5
	    NAME    1 G
	    BRCKTD  1 F
	  <[H]I:>
	  TERMINAL  6
	    DEVICE  1 I
	    BRCKTD  1 H
	  <[J]K:L>
	  TERMINAL  7
	    DEVICE  1 K
	    NAME    1 L
	    BRCKTD  1 J
	  <M:[N]>
	  TERMINAL 10
	    DEVICE  1 M
	    BRCKTD  1 N
	  <O:[P]Q>
	  TERMINAL 11
	    DEVICE  1 O
	    NAME    1 Q
	    BRCKTD  1 P
	  <R[S]>
	  TERMINAL 13
	    NAME    1 R
	    BRCKTD  1 S
	  <T:U[V]>
	  TERMINAL 15
	    DEVICE  1 T
	    NAME    1 U
	    BRCKTD  1 V
	  EMPTY
	  *!DEMONSTRATE EMPTY STATEMENTS AND  MISSING COMPONENTS
	  EMPTY
	  *;:ONE::TWO:.THREE..FOUR.[,FIVE,,SIX,]/:SEVEN::EIGHT:;
	  SEMICOLON
	  FASP, FORTRAN Alphameric Subroutine Package          Page 77
	  DAFLAG, Routine to Locate Components of File Specification


	  <:ONE::TWO:.THREE..FOUR.[,FIVE,,SIX,]>
	  PARTIAL  15
	    DEVICE  0 :
	    DEVICE  3 ONE
	    DEVICE  0 :
	    DEVICE  3 TWO
	    NAME    0 .
	    NAME    5 THREE
	    NAME    0 .
	    NAME    4 FOUR
	    NAME    0 [
	    BRCKTD  0 ,
	    BRCKTD  4 FIVE
	    BRCKTD  0 ,
	    BRCKTD  3 SIX
	    BRCKTD  0 ]
	  </:SEVEN::EIGHT:>
	  TERMINAL  0
	    SWITCH  0 :
	    SWITCH  5 SEVEN
	    SWITCH  0 :
	    SWITCH  5 EIGHT
	    SWITCH  0 ;
	  SEMICOLON
	  EMPTY
	  *!DEMONSTRATE ASTERISKS IN ALL BUT DEVICE FIELD
	  EMPTY
	  *DSK:ONE*[THREE*]/FIVE*/'SEVEN'*
	  <DSK:ONE*[THREE*]>
	  PARTIAL  15
	    DEVICE  3 DSK
	    NAME    4 ONE*
	    BRCKTD  6 THREE*
	  </FIVE*>
	  PARTIAL   0
	    SWITCH  5 FIVE*
	  </'SEVEN>
	  PARTIAL   0
	    SWITCH  6 'SEVEN
	  <*>
	  TERMINAL  1
	    NAME    1 *
	  EMPTY
	  *DSK:*TWO[*FOUR]/*SIX/*'EIGHT'
	  <DSK:*TWO[*FOUR]>
	  PARTIAL  15
	    DEVICE  3 DSK
	    NAME    1 *
	    NAME    3 TWO
	    BRCKTD  1 *
	    BRCKTD  4 FOUR
	  FASP, FORTRAN Alphameric Subroutine Package          Page 78
	  DAFLAG, Routine to Locate Components of File Specification


	  </*SIX>
	  PARTIAL   0
	    SWITCH  1 *
	    SWITCH  3 SIX
	  </*'EIGHT>
	  TERMINAL  0
	    SWITCH  1 *
	    SWITCH  6 'EIGHT
	  EMPTY
	  *DSK:**[**]/** !**:** WOULD BE TAKEN AS *.* FOLLOWED BY :*.*
	  <DSK:**[**]>
	  PARTIAL  15
	    DEVICE  3 DSK
	    NAME    1 *
	    NAME    1 *
	    BRCKTD  1 *
	    BRCKTD  1 *
	  </**>
	  TERMINAL  0
	    SWITCH  1 *
	    SWITCH  1 *
	  EMPTY


	  Typical but Machine Dependent Wrapper for the DAFLAG Routine
	  ------- --- ------- --------- ------- --- --- ------ -------

	  DAFLAG   locates   the   components   of   a   single   file
	  specification,  but  does not pack the characters which form
	  these  components  into  the  single  or  double   precision
	  computer  locations  which  can  be used as arguments in the
	  system subroutine calls or FORTRAN OPEN statements which are
	  necessary  to  prepare for reading or writing of the desired
	  file.  Listed on the following pages is a  wrapper  for  the
	  DAFLAG   routine  which  packs  the  components  of  a  file
	  specification  into  the  form  required  for   DECsystem-10
	  FORTRAN OPEN statements.  The wrapper routine, named GETFIL,
	  supports a multiple file specification of the form

	       LIST OF OUTPUT FILES=LIST OF INPUT FILES
	  or
	       LIST OF INPUT FILES

	  and so must scan the command from left to  right  until  one
	  more  than  the number of files which can appear in the list
	  of output files has been found.   If  the  user  desires  to
	  input several lines, all but the last line can be terminated
	  by an ampersand, or, if the command consists of  a  list  of
	  file specifications, all but the last line can be terminated
	  by a rightmost comma.  Although GETFIL  initially  interacts
	  with  the  user,  the user can at any point specify that the
	  remainder of the command is to be read from a file by giving
	  its name along with an at (@) sign.  If the command is being
	  read from a file, then the continuation indications are  not
	  FASP, FORTRAN Alphameric Subroutine Package          Page 79
	  DAFLAG, Routine to Locate Components of File Specification


	  necessary  since  the entire command file will be read until
	  the end of file is encountered.

	  Switches  can  appear  either  before  or  after  the   file
	  specifications   with   which   they  are  associated.   The
	  interpretation of switches is left to the  calling  program.
	  Switches  are  reported  individually  when  they are found,
	  since many switches appearing on more  than  just  a  single
	  command  line  could precede the file specification to which
	  the switches apply.  The file specification associated  with
	  the  switch is identified only by its serial position in the
	  arrays in which the file specification will be reported by a
	  subsequent  call  of  this  routine,  both  since  the  file
	  specification might not yet have been read, and  because  it
	  is   not   immediately   known   whether   a   leading  file
	  specification appears to the left of an equal sign or if  no
	  equal sign at all is present.

	  The argument list of routine GETFIL is

	        SUBROUTINE GETFIL(MAXFIL,  ITTY,  JTTY,KMDNUM,KMDDVC,
	       1    KMDNAM,KMDEXT,MAXSTR,MAXBFR,  KIND,NEWNUL,NEWDSK,
	       2    NEWNAM,NEWPTH,LCNRIT,IBUFFR,MAXFLG,INILTR,KNTLTR,
	       3    LCNOWN)

	  with  the  associated   DIMENSION   and   DOUBLE   PRECISION
	  statements

	        DIMENSION NEWNUL(MAXFIL),NEWDSK(MAXFIL),
	       1IBUFFR(MAXBFR),INILTR(MAXSTR),KNTLTR(MAXSTR)
	        DOUBLE PRECISION KMDNAM,NEWNAM(MAXFIL),
	       1NEWPTH(3,MAXFIL)

	  The following arguments are used  only  for  input  and  are
	  returned unchanged.

	  MAXFIL = 1 more than the number of files which can appear to
	           the  left  of the equal sign.  The single precision
	           arrays NEWNUL and NEWDSK, and the double  precision
	           array  NEWNAM  must  be dimensioned to at least the
	           value of MAXFIL.  The double precision  and  doubly
	           dimensioned  array  NEWPTH must have 3 as its first
	           dimension  and  MAXFIL  as  its  second  dimension.
	           Switches   are   always  returned  individually  by
	           separate calls to this routine prior to the call or
	           calls to this routine which return a description of
	           the file specifications with which  these  switches
	           are  associated.   All  switches  left of the equal
	           sign and the switches  associated  with  the  first
	           file  specification  right  of  the equal sign will
	           have been returned to the  calling  program  before
	           any  file  specifications  are returned.  The first
	           call   to   this   routine   which   returns   file
	           specifications   can   return  up  to  MAXFIL  file
	  FASP, FORTRAN Alphameric Subroutine Package          Page 80
	  DAFLAG, Routine to Locate Components of File Specification


	           specifications,   of   which    only    the    file
	           specification  which is returned in the location in
	           each array  having  the  value  of  LCNRIT  as  its
	           subscript  is  to the right of the equal sign.  The
	           subsequent calls to this routine will return either
	           a  single  switch  specification  or  a single file
	           specification.  An equal sign found after an  equal
	           sign  has  already  been  found  or after more than
	           MAXFIL file specifications have been found is taken
	           to be equivalent to a comma.

	  ITTY   = number  of  the  unit  from  which   commands   are
	           initially to be read.

	  JTTY   = number of the unit  to  which  error  messages  and
	           prompts for more user input are to be written.

	  KMDNUM = number of the unit  from  which  the  command  file
	           indicated  by  an at (@) sign appearing with a file
	           specification is to be read.

	  KMDDVC = name in 5H  form  of  the  device  from  which  the
	           command  file  is  to  be read if the user fails to
	           supply a device name followed by a colon.

	  KMDNAM = name in 6H form which is to be used  as  the  first
	           component  of  the name of the command file if none
	           is supplied by the user.  On the PDP10, KMDNAM must
	           be  a double precision variable if the name of this
	           variable appears in the argument list.

	  KMDEXT = name in 3H form which is to be used as  the  second
	           component  (the file name extension) of the name of
	           the command file if none is supplied by  the  user.
	           If  the  command  file  name  is not to have such a
	           second component, then the user must type a  period
	           following the first component of the name.

	  MAXSTR = dimension of the INILTR and KNTLTR arrays in  which
	           the  descriptions of the components of the switches
	           are returned and which are used  internally  within
	           this routine for the storage of the descriptions of
	           the components of each file specification.   MAXSTR
	           should  have  a  value of at least 6 which would be
	           sufficient to allow either a 6 component switch  or
	           else  the  combination of a 1 part device name, a 2
	           part file name,  and  a  3  part  path  (directory)
	           description.

	  MAXBFR = dimension of the IBUFFR array into which each  line
	           of  the commands typed by the user or read from the
	           command file are stored in  a  multiple  of  an  A1
	           format.  MAXBFR is the maximum number of characters
	           which can appear in a single command line.   MAXBFR
	  FASP, FORTRAN Alphameric Subroutine Package          Page 81
	  DAFLAG, Routine to Locate Components of File Specification


	           must not exceed 132.

	  The following argument must be zeroed by the calling program
	  before  this  routine  is  first  called, but then the value
	  returned by this routine should be  sent  to  the  following
	  call of this routine unchanged.

	  KIND   = should be set to zero before this routine is  first
	           called,  or  whenever  the  interpretation  of  the
	           previous set of commands is to be abandoned.   KIND
	           is  returned  describing the reason why control has
	           been transferred back to the calling  program,  and
	           should  not  be  changed  by the calling program if
	           this routine is to be called again to continue  the
	           interpretation of the same sequence of commands.
	         = 1, returned if no more file  specifications  remain
	           to  be  evaluated.   The description of the last of
	           the  previous  set  of  file   specifications   was
	           returned  to  the  calling  program by the previous
	           call to this routine and  that  file  specification
	           was  not  followed  by  either  an  ampersand  or a
	           semicolon.
	         = 2, returned if a  semicolon  was  found.   If  this
	           routine  is  called again without KIND having first
	           been zeroed, then the evaluation of a  new  set  of
	           file  specifications  will  be  begun  in  the text
	           appearing to  the  right  of  the  semicolon.   The
	           appearance   of   a   semicolon   when   the   file
	           specification  is  known  by  this  routine  to  be
	           incomplete  will  not  be  reported  to the calling
	           program  since  the  text  to  the  right  of   the
	           semicolon  is  treated  as if it continued the file
	           specifications on a  subsequent  input  line.   For
	           example, the file specifications
	                A=B,;C
	           and
	                A=B,
	                C
	           are both equivalent to
	                A=B,C
	         = 3, returned if this routine is currently  reporting
	           all  of  the  file  specifications appearing to the
	           left of the equal sign together with the first file
	           specification to the right of the equal sign, or if
	           this routine is currently reporting the first  file
	           specification  in  a  series of file specifications
	           which does not include an equal sign.
	         = 4, returned if this routine is currently  reporting
	           the  second  or  a subsequent file specification to
	           the right of the equal sign, or if this routine  is
	           currently reporting the second or a subsequent file
	           specification in a series  of  file  specifications
	           which does not include an equal sign.
	         = 5, returned if this routine is currently  returning
	  FASP, FORTRAN Alphameric Subroutine Package          Page 82
	  DAFLAG, Routine to Locate Components of File Specification


	           the  description  of  a  switch  in  the INILTR and
	           KNTLTR array  locations  having  the  subscripts  1
	           through  the  returned  value of MAXFLG.  LCNOWN is
	           returned containing the value of the  subscript  of
	           the  locations  in  the  NEWNUL, NEWDSK, NEWNAM and
	           NEWPTH  arrays  which  will   describe   the   file
	           specification  when  KIND  is  next returned set to
	           either 3 or 4.

	  The  following  arguments  are  used  both   for   returning
	  information  to  the  calling  program  and for transferring
	  information from the current call of  this  routine  to  the
	  subsequent  call  of  this  routine.   The  values  of these
	  arguments returned by  the  current  call  of  this  routine
	  should  be  sent  to  the  following  call  of  this routine
	  unchanged.  The original contents  of  these  arguments  are
	  ignored.

	  NEWNUL = if KIND is returned set to either 3 or 4, then  the
	           locations in the NEWNUL array having the subscripts
	           1 through the returned value of LCNRIT are returned
	           describing  whether a file specification was found,
	           and if so, whether the file name consisted of 1  or
	           2 components.
	         = 0, an extra comma indicated that no file was  being
	           specified.  The locations in the NEWDSK, NEWNAM and
	           NEWPTH arrays having the  same  subscripts  as  the
	           location  in  the  NEWNUL array containing the zero
	           are returned undefined.
	         = 1, either a device name or a path (a directory) was
	           specified,  but a file name was not specified.  The
	           unspecified items are returned set either to zeroes
	           or to spaces as is appropriate.
	         = 2, a file name was  specified,  but  this  did  not
	           include  either  a period or a second component.  A
	           null second component consisting  of  3  spaces  is
	           being  returned  following  a  period in the NEWNAM
	           array.  The calling program can  supply  a  default
	           second component if such is appropriate.
	         = 3, a file  name  was  specified  which  included  a
	           period.   A second component consisting of 3 spaces
	           is  being  returned  if  no  second  component  was
	           specified.
	         = 4, a file  name  was  specified  which  included  a
	           period   and  a  second  component,  but  no  first
	           component was included.   A  null  first  component
	           consisting  of 6 spaces is being returned preceding
	           a period in the NEWNAM array.  It is expected  that
	           the  calling  program  will  supply a default first
	           component.

	  NEWDSK = if KIND is returned set to either 3 or 4, then  the
	           locations in the NEWDSK array having the subscripts
	           1 through the returned value of LCNRIT are returned
	  FASP, FORTRAN Alphameric Subroutine Package          Page 83
	  DAFLAG, Routine to Locate Components of File Specification


	           containing  in  5H form the device names associated
	           with each of the file specifications.  If no device
	           names  are  specified in the file specifications to
	           the left of the  equal  sign,  then  the  locations
	           corresponding  to  these file specifications in the
	           NEWDSK array will contain  spaces.   If  no  device
	           names  are  specified in the file specifications to
	           the right of the equal sign, then  these  locations
	           either contain the previously specified device name
	           if any has been specified to the right of the equal
	           sign, or else contain spaces if no devices name has
	           yet been specified to the right of the equal sign.

	  NEWNAM = if KIND is returned set to either 3 or 4, then  the
	           locations  in  the  NEWNAM  double  precision array
	           having the subscripts 1 through the returned  value
	           of  LCNRIT  are returned containing both components
	           of the file name (the 6 character file name and its
	           3  character  extension)  in  an  A10  form (format
	           1A6,1H.,1A3).

	  NEWPTH = if KIND is returned set to either 3 or 4, then  the
	           locations in the NEWPTH double precision and doubly
	           dimensioned array having  1  through  the  returned
	           value  of  LCNRIT  as  their  second subscripts are
	           returned containing the path (the  directory)  upon
	           which  the  file  is  located.   If  no  paths  are
	           specified in the file specifications to the left of
	           the equal sign, then the locations corresponding to
	           these file specifications in the NEWPTH array  will
	           contain  zeroes.   If no paths are specified in the
	           file specifications to the right of the equal sign,
	           then  these locations either contain the previously
	           specified path if any has  been  specified  to  the
	           right  of the equal sign, or else contain zeroes if
	           no path has yet been specified to the right of  the
	           equal  sign.   NEWPTH(1,...)  contains  in its left
	           half the octal project number and in its right half
	           the  octal programmer number (the first two numbers
	           appearing within the square brackets), or  contains
	           zero  if no path has been specified.  NEWPTH(2,...)
	           contains the sub file  directory  (SFD)  name  (the
	           third  component  within the square brackets) in 6H
	           form if any has been specified,  or  contains  zero
	           otherwise.  NEWPTH(3,...) always contains zero.

	  LCNRIT = if KIND is returned set to  either  3  or  4,  then
	           LCNRIT  is  returned  containing  the  value of the
	           subscript of the locations in the  NEWNUL,  NEWDSK,
	           NEWNAM  and  NEWPTH  arrays which describe the file
	           specification which appears to  the  right  of  the
	           equal  sign.   If  KIND is returned set to 3 and if
	           LCNRIT  is  greater  than  one,  then   the   lower
	           locations   in   these  arrays  describe  the  file
	  FASP, FORTRAN Alphameric Subroutine Package          Page 84
	  DAFLAG, Routine to Locate Components of File Specification


	           specifications appearing to the left of  the  equal
	           sign.   If  KIND  is  returned  set  to 4, then the
	           values of the locations within these arrays  having
	           subscripts  less  than the returned value of LCNRIT
	           should be ignored.

	  IBUFFR = array in which this routine can  return  characters
	           typed  by  the  user or read from the command file.
	           These characters represent  only  the  most  recent
	           command line and have been read by a multiple of an
	           A1 format.  It is the responsibility of the calling
	           program  to  evaluate  the  switch appearing within
	           this array if KIND is returned set to 5.

	  The  following  arguments  are  used  only   for   returning
	  information  to the calling program.  Their input values are
	  ignored.

	  MAXFLG = if KIND is  returned  set  to  5,  then  MAXFLG  is
	           returned  containing the subscript of the locations
	           in the INILTR and KNTLTR arrays which describe  the
	           rightmost component of the switch.

	  INILTR = if KIND is returned set to 5, then the locations in
	           the  INILTR  array  having the subscripts 1 through
	           the  returned  value   of   MAXFLG   are   returned
	           containing  the  values  of  the  subscripts of the
	           locations within the IBUFFR array in which  are  to
	           be  found  the  initial  characters  of each of the
	           components of the switch.

	  KNTLTR = if KIND is returned set to 5, then the locations in
	           the  INILTR  array  having the subscripts 1 through
	           the  returned  value   of   MAXFLG   are   returned
	           containing  the number of characters within each of
	           the components of the switch.  A missing  component
	           of  the  switch is indicated by a zero value in the
	           KNTLTR array.

	  LCNOWN = if KIND is  returned  set  to  5,  then  LCNOWN  is
	           returned  containing  the value of the subscript of
	           the locations in the  NEWNUL,  NEWDSK,  NEWNAM  and
	           NEWPTH   arrays   which   will  describe  the  file
	           specification when KIND is  next  returned  set  to
	           either 3 or 4.

	  The GETFIL routine is listed below.  The first half  of  the
	  routine  calls  DAFLAG  and  then decides what is to be done
	  with the information returned by DAFLAG.  The GETFIL routine
	  manipulates  the  value of the DAFLAG argument named MANY to
	  simulate a rightmost ampersand when a statement ends with  a
	  rightmost equal sign or rightmost comma.  The second half of
	  the routine uses DECsystem-10 FORTRAN ENCODE  statements  to
	  pack  the  characters  read 1 to a computer storage location
	  FASP, FORTRAN Alphameric Subroutine Package          Page 85
	  DAFLAG, Routine to Locate Components of File Specification


	  into a form which might have been read with an A5 or  double
	  precision  A10  format.   The octal numbers are evaluated by
	  matching the individual digits against an  array  containing
	  1H0  through  1H7  rather  than  by use of ENCODE and DECODE
	  statements since these statements do not have any  provision
	  for  continuing  after a non-numeric character is found in a
	  numeric field.

	        SUBROUTINE GETFIL(MAXFIL,  ITTY,  JTTY,KMDNUM,KMDDVC,
	       1    KMDNAM,KMDEXT,MAXSTR,MAXBFR,  KIND,NEWNUL,NEWDSK,
	       2    NEWNAM,NEWPTH,LCNRIT,IBUFFR,MAXFLG,INILTR,KNTLTR,
	       3    LCNOWN)
	  C     RENBR(/EVALUATE FORM FILE,FILE=FILE,FILE)
	        COMMON/FASPZ/KNTFIL,MANY,IEOF,IAFTER,LSTPTH,LSTDSK,
	       1LOWBFR
	        DIMENSION INILTR(MAXSTR),KNTLTR(MAXSTR),
	       1IBUFFR(MAXBFR),NEWNUL(MAXFIL),NEWDSK(MAXFIL),
	       2LETTER(8),KOLECT(10),NUMTWO(2)
	        DOUBLE PRECISION NEWNAM(MAXFIL),NEWPTH(3,MAXFIL),
	       1KOMAND,ONEPTH(3),LSTPTH(3),TWONUM,KMDNAM
	        EQUIVALENCE (TWONUM,NUMTWO),(NEWPRJ,NUMTWO(1)),
	       1(NEWUSR,NUMTWO(2))
	        DATA LETTER/1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7/
	        DATA IBLANK,JBLANK,IDOT/1H ,5H     ,1H./
	  C
	  C     DECIDE WHETHER ARE STARTING OR CONTINUING EVALUATION
	        IF(KIND.EQ.5)GO TO 9
	        IF(KIND.GE.3)GO TO 30
	        LCNRIT=0
	        KNTFIL=0
	        IAFTER=0
	        MANY=0
	        IF(KIND.EQ.2)GO TO 9
	  C
	  C     READ CONTENTS OF NEXT LINE
	        WRITE(JTTY,1)
	      1 FORMAT(2H *,$)
	        GO TO 4
	      2 WRITE(JTTY,3)
	      3 FORMAT(2H &,$)
	      4 READ(ITTY,5,END=10)IBUFFR
	      5 FORMAT(132A1)
	        IEOF=0
	        GO TO 7
	      6 READ(KMDNUM,5,END=10)IBUFFR
	        IEOF=1
	      7 LOWBFR=1
	        GO TO 9
	      8 LCNRIT=1
	        KNTFIL=0
	  C
	  C     LOCATE NEXT FILE SPECIFICATION
	      9 CALL DAFLAG(1,1,MAXSTR,MAXBFR,IBUFFR,
	       1LOWBFR,MANY,KIND,INILTR,KNTLTR,MAXDSK,MAXNAM,
	  FASP, FORTRAN Alphameric Subroutine Package          Page 86
	  DAFLAG, Routine to Locate Components of File Specification


	       2MAXNUM,MAXFLG,KONTNT,MINPRT,MAXPRT)
	        GO TO(11,11,13,15,16,17,17,17),KIND
	  C
	  C     END OF LINE, END OF FILE OR SEMICOLON FOUND
	     10 KIND=1
	        IEOF=0
	     11 IF(IAFTER.LT.0)GO TO 14
	        IF(IAFTER.EQ.1)GO TO 14
	        IF(KNTFIL.GT.0)GO TO 12
	        IF(LCNRIT.EQ.0)GO TO 15
	        IF(KIND.EQ.2)GO TO 37
	        IF(IEOF.EQ.0)GO TO 37
	        GO TO 6
	     12 IF(KIND.EQ.2)LOWBFR=LOWBFR-1
	        GO TO 29
	  C
	  C     EQUAL SIGN FOUND
	     13 IF(IAFTER.GT.0)GO TO 27
	        MANY=-1
	        IAFTER=0
	        LCNRIT=-1
	        GO TO 9
	  C
	  C     AMPERSAND FOUND OR MORE FILES NEEDED
	     14 KNTFIL=KNTFIL-1
	        MANY=-1
	        IAFTER=0
	     15 IF(KIND.EQ.2)GO TO 9
	        IF(IEOF.NE.0)GO TO 6
	        GO TO 2
	  C
	  C     EXTRA COMMA FOUND
	     16 IF(IAFTER.GT.0)GO TO 27
	        KNTFIL=KNTFIL+1
	        NEWNUL(KNTFIL)=0
	        IAFTER=1
	        GO TO 19
	  C
	  C     EVALUATE LOCATION AND REPACK DEVICE AND FILE NAME
	     17 IF(KONTNT.EQ.0)GO TO 20
	        IF(IAFTER.GT.0)GO TO 28
	        NXTFIL=KNTFIL+1
	        GO TO 38
	     18 IF(KONTNT.GE.16)GO TO 21
	        KNTFIL=NXTFIL
	        IAFTER=2
	     19 IF(LCNRIT.NE.0)GO TO 9
	        IF(KNTFIL.LT.MAXFIL)IAFTER=IAFTER-2
	        GO TO 9
	  C
	  C     ALLOW CALLING PROGRAM TO EVALUATE SWITCH
	     20 LCNOWN=KNTFIL
	        KIND=5
	        IF(MANY.GT.0)GO TO 37
	  FASP, FORTRAN Alphameric Subroutine Package          Page 87
	  DAFLAG, Routine to Locate Components of File Specification


	        IF(IAFTER.GT.0)GO TO 28
	        MANY=-1
	        LCNOWN=LCNOWN+1
	        GO TO 37
	  C
	  C     OPEN COMMAND FILE SPECIFIED BY USER
	     21 KOMAND=NEWNAM(NXTFIL)
	        IF(NEWNUL(NXTFIL).LE.1)ENCODE(10,22,KOMAND)
	       1KMDNAM,KMDEXT
	        IF(NEWNUL(NXTFIL).EQ.2)ENCODE(10,22,KOMAND)
	       1NEWNAM(NXTFIL),KMDEXT
	     22 FORMAT(1A6,1H.,1A3)
	        IF(NEWNUL(NXTFIL).EQ.4)ENCODE(10,23,KOMAND)
	       1KMDNAM,(KOLECT(I),I=8,10)
	     23 FORMAT(1A6,1H.,3A1)
	        INDISK=NEWDSK(NXTFIL)
	        IF(INDISK.EQ.JBLANK)INDISK=KMDDVC
	        DO 24 I=1,3
	     24 ONEPTH(I)=NEWPTH(I,NXTFIL)
	        OPEN(UNIT=KMDNUM,DEVICE=INDISK,FILE=KOMAND,
	       1DIRECTORY=ONEPTH,ACCESS=5HSEQIN,ERR=25)
	        GO TO 6
	     25 WRITE(JTTY,26)(IBUFFR(I),I=MINPRT,MAXPRT)
	     26 FORMAT(26H CANNOT READ COMMAND FROM ,100A1)
	        GO TO 2
	  C
	  C     PREPARE TO RETURN RESULTS TO CALLING PROGRAM
	     27 MANY=-1
	        GO TO 29
	     28 LOWBFR=MINPRT
	     29 IAFTER=0
	        IF(LCNRIT.GT.0)GO TO 31
	        KIND=3
	        IF(LCNRIT.LT.0)GO TO 33
	        LCNRIT=1
	        GO TO 34
	     30 LCNRIT=LCNRIT+1
	     31 IF(LCNRIT.GT.KNTFIL)GO TO 8
	        KIND=4
	        IF(NEWNUL(LCNRIT).EQ.0)GO TO 37
	        IF(NEWDSK(LCNRIT).EQ.JBLANK)NEWDSK(LCNRIT)=LSTDSK
	        IF(NEWPTH(1,LCNRIT).NE.0)GO TO 34
	        DO 32 I=1,3
	     32 NEWPTH(I,LCNRIT)=LSTPTH(I)
	        GO TO 36
	     33 LCNRIT=KNTFIL
	     34 DO 35 I=1,3
	     35 LSTPTH(I)=NEWPTH(I,LCNRIT)
	     36 LSTDSK=NEWDSK(LCNRIT)
	  C
	  C     RETURN TO CALLING PROGRAM
	     37 RETURN
	  C
	  C     *****************************************************
	  FASP, FORTRAN Alphameric Subroutine Package          Page 88
	  DAFLAG, Routine to Locate Components of File Specification


	  C     *                                                   *
	  C     *  A10 PACK NAME, A5 PACK DEVICE, EVALUATE NUMBERS  *
	  C     *                                                   *
	  C     *****************************************************
	  C
	  C     SET SWITCHES WHICH STATE IF ANYTHING WAS FOUND
	     38 NEWPRJ=0
	        NEWUSR=0
	        DO 39 I=1,3
	     39 NEWPTH(I,NXTFIL)=TWONUM
	        NEWNUL(NXTFIL)=0
	        NEWDSK(NXTFIL)=JBLANK
	  C
	  C     PACK DEVICE NAME INTO A5 FORM
	        IF(MAXDSK.LT.1)GO TO 42
	        KOUNT=KNTLTR(1)
	        IF(KOUNT.LE.0)GO TO 42
	        IBGN=INILTR(1)
	        DO 40 I=1,5
	        KOLECT(I)=IBLANK
	        IF(KOUNT.GT.0)KOLECT(I)=IBUFFR(IBGN)
	        IBGN=IBGN+1
	     40 KOUNT=KOUNT-1
	        ENCODE(5,41,NEWDSK(NXTFIL))(KOLECT(I),I=1,5)
	     41 FORMAT(5A1)
	        NEWNUL(NXTFIL)=1
	  C
	  C     EVALUATE OCTAL PROJECT, PROGRAMMER NUMBERS
	     42 INDEX=MAXNAM+1
	        IF(INDEX.GE.MAXNUM)GO TO 48
	     43 KOUNT=KNTLTR(INDEX)
	        IF(KOUNT.LE.0)GO TO 48
	        IBGN=INILTR(INDEX)
	        IEND=IBGN+KOUNT-1
	        NEWPRJ=NEWUSR
	        NEWUSR=0
	        DO 45 I=IBGN,IEND
	        LTRNOW=IBUFFR(I)
	        NEWUSR=8*NEWUSR
	        DO 44 J=1,8
	        IF(LETTER(J).NE.LTRNOW)GO TO 44
	        NEWUSR=NEWUSR+J-1
	        GO TO 45
	     44 CONTINUE
	     45 CONTINUE
	        IF(NEWUSR.LE.0)GO TO 48
	        INDEX=INDEX+1
	        IF(INDEX.LE.(MAXNAM+2))GO TO 43
	        NEWPTH(1,NXTFIL)=TWONUM
	        NEWNUL(NXTFIL)=1
	  C
	  C     PACK SUB FILE DIRECTORY NAME
	        IF(MAXNUM.LE.(MAXNAM+2))GO TO 48
	        KOUNT=KNTLTR(MAXNAM+3)
	  FASP, FORTRAN Alphameric Subroutine Package          Page 89
	  DAFLAG, Routine to Locate Components of File Specification


	        IF(KOUNT.LE.0)GO TO 48
	        IBGN=INILTR(MAXNAM+3)
	        DO 46 I=1,6
	        KOLECT(I)=IBLANK
	        IF(KOUNT.GT.0)KOLECT(I)=IBUFFR(IBGN)
	        IBGN=IBGN+1
	     46 KOUNT=KOUNT-1
	        ENCODE(10,47,NEWPTH(2,NXTFIL))(KOLECT(I),I=1,6)
	     47 FORMAT(6A1,4X)
	  C
	  C     PACK FILE NAME AND ITS EXTENSION INTO A10 FORM
	     48 DO 49 I=1,10
	     49 KOLECT(I)=IBLANK
	        IF(MAXNAM.LE.MAXDSK)GO TO 55
	        KOUNT=KNTLTR(MAXDSK+1)
	        IF(KOUNT.LE.0)GO TO 51
	        NEWNUL(NXTFIL)=2
	        IBGN=INILTR(MAXDSK+1)
	        IF(KOUNT.GT.6)KOUNT=6
	        DO 50 I=1,KOUNT
	        KOLECT(I)=IBUFFR(IBGN)
	     50 IBGN=IBGN+1
	        IF(MAXNAM.LE.(MAXDSK+1))GO TO 54
	        NEWNUL(NXTFIL)=3
	        KOUNT=KNTLTR(MAXDSK+2)
	        GO TO 52
	     51 IF(MAXNAM.LE.(MAXDSK+1))GO TO 55
	        KOUNT=KNTLTR(MAXDSK+2)
	        IF(KOUNT.LE.0)GO TO 55
	        NEWNUL(NXTFIL)=4
	     52 IBGN=INILTR(MAXDSK+2)
	        IF(KOUNT.GT.3)KOUNT=3
	        DO 53 I=8,10
	        IF(KOUNT.GT.0)KOLECT(I)=IBUFFR(IBGN)
	        IBGN=IBGN+1
	     53 KOUNT=KOUNT-1
	     54 KOLECT(7)=IDOT
	     55 ENCODE(10,56,NEWNAM(NXTFIL))KOLECT
	     56 FORMAT(10A1)
	        GO TO 18
	  C610045095007$&
	        END

	  The program listed below calls GETFIL, reports the  results,
	  then repeats the process.

	  C     DEMONSTRATE GETFIL WHICH IN TURN DEMONSTRATES DAFLAG
	        DIMENSION IBUFFR(72),INILTR(20),KNTLTR(20),
	       1NEWNUL(10),NEWDSK(10),INTPTH(4)
	        DOUBLE PRECISION NEWNAM(10),NEWPTH(3,10),DBLPTH(2),
	       1KMDNAM
	        EQUIVALENCE(INTPTH,DBLPTH)
	        DATA KMDNAM,KMDEXT,KMDDVC/6HGETFIL,3HCCL,3HDSK/
	        DATA ITTY,JTTY,KMDNUM/5,5,1/
	  FASP, FORTRAN Alphameric Subroutine Package          Page 90
	  DAFLAG, Routine to Locate Components of File Specification


	        WRITE(JTTY,1)
	      1 FORMAT(8H MAXFIL ,$)
	        READ(ITTY,2)MAXFIL
	      2 FORMAT(I)
	        IF(MAXFIL.LE.0)MAXFIL=1
	        IF(MAXFIL.GT.10)MAXFIL=10
	        KIND=0
	  C
	  C     GET NEXT PORTION OF FILE SPECIFICATIONS
	      3 CALL GETFIL(MAXFIL,ITTY,JTTY,KMDNUM,KMDDVC,
	       1KMDNAM,KMDEXT,20,72,KIND,NEWNUL,NEWDSK,
	       2NEWNAM,NEWPTH,LCNRIT,IBUFFR,MAXFLG,INILTR,KNTLTR,
	       3LCNOWN)
	        GO TO(4,6,9,8,21),KIND
	  C
	  C     END OF FILE SPECIFICATIONS
	      4 WRITE(JTTY,5)
	      5 FORMAT(5H DONE)
	        GO TO 3
	      6 WRITE(JTTY,7)
	      7 FORMAT(10H SEMICOLON)
	        GO TO 3
	  C
	  C     LIST FILES
	      8 INDEX=LCNRIT
	        GO TO 11
	      9 IF(LCNRIT.LE.0)GO TO 3
	        INDEX=0
	     10 INDEX=INDEX+1
	     11 IF(NEWNUL(INDEX).NE.0)GO TO 13
	        IF(INDEX.GE.LCNRIT)GO TO 16
	        WRITE(JTTY,12)INDEX
	     12 FORMAT(5H LEFT,I4,8H MISSING)
	        GO TO 10
	     13 IF(NEWPTH(1,INDEX).NE.0)GO TO 15
	        IF(INDEX.GE.LCNRIT)GO TO 18
	        WRITE(JTTY,14)INDEX,NEWNUL(INDEX),NEWDSK(INDEX),
	       1NEWNAM(INDEX)
	     14 FORMAT(5H LEFT,I4,I2,1X,A5,1H:,1A10,1X,O6,1X,O6,
	       11X,A5,A1)
	        GO TO 10
	     15 DBLPTH(1)=NEWPTH(1,INDEX)
	        DBLPTH(2)=NEWPTH(2,INDEX)
	        IF(INDEX.GE.LCNRIT)GO TO 20
	        WRITE(JTTY,14)INDEX,NEWNUL(INDEX),NEWDSK(INDEX),
	       1NEWNAM(INDEX),INTPTH
	        GO TO 10
	     16 WRITE(JTTY,17)INDEX
	     17 FORMAT(6H RIGHT,I3,8H MISSING)
	        GO TO 3
	     18 WRITE(JTTY,19)INDEX,NEWNUL(INDEX),NEWDSK(INDEX),
	       1NEWNAM(INDEX)
	     19 FORMAT(6H RIGHT,I3,I2,1X,A5,1H:,1A10,1X,O6,1X,O6,
	       11X,A5,A1)
	  FASP, FORTRAN Alphameric Subroutine Package          Page 91
	  DAFLAG, Routine to Locate Components of File Specification


	        GO TO 3
	     20 WRITE(JTTY,19)INDEX,NEWNUL(INDEX),NEWDSK(INDEX),
	       1NEWNAM(INDEX),INTPTH
	        GO TO 3
	  C
	  C     LIST SWITCHES
	     21 M=0
	        DO 24 I=1,MAXFLG
	        J=INILTR(I)
	        K=J+KNTLTR(I)-1
	        IF(K.LT.J)GO TO 24
	        IF(M.EQ.0)WRITE(JTTY,22)LCNOWN,(IBUFFR(L),L=J,K)
	     22 FORMAT(7H SWITCH,I2,3X,72A1)
	        IF(M.NE.0)WRITE(JTTY,23)LCNOWN,(IBUFFR(L),L=J,K)
	     23 FORMAT(7H  "  " ,I2,3X,72A1)
	        M=1
	     24 CONTINUE
	        GO TO 3
	        END

	  The following is a typical dialog between the user  and  the
	  program listed above.

	  MAXFIL 3
	  *FIRST.1ST,SECOND.2ND=THIRD.3RD,FOURTH.4TH
	  LEFT   1 3      :FIRST .1ST
	  LEFT   2 3      :SECOND.2ND
	  RIGHT  3 3      :THIRD .3RD
	  RIGHT  1 3      :FOURTH.4TH
	  DONE
	  *FIRST.1ST,SECOND.2ND,THIRD.3RD,FOURTH.4TH
	  RIGHT  1 3      :FIRST .1ST
	  RIGHT  2 3      :SECOND.2ND
	  RIGHT  3 3      :THIRD .3RD
	  RIGHT  1 3      :FOURTH.4TH
	  DONE
	  *FIRST,
	  &SECOND=
	  &THIRD,
	  LEFT   1 2      :FIRST .
	  LEFT   2 2      :SECOND.
	  RIGHT  3 2      :THIRD .
	  &FOURTH
	  RIGHT  1 2      :FOURTH.
	  DONE
	  *FIRST,
	  &SECOND,
	  &THIRD,
	  RIGHT  1 2      :FIRST .
	  RIGHT  2 2      :SECOND.
	  RIGHT  3 2      :THIRD .
	  &FOURTH
	  RIGHT  1 2      :FOURTH.
	  DONE
	  FASP, FORTRAN Alphameric Subroutine Package          Page 92
	  DAFLAG, Routine to Locate Components of File Specification


	  */A 1ST/B,/C 2ND/D=/E 3RD/F,/G 4TH/H
	  SWITCH 1   A
	  SWITCH 1   B
	  SWITCH 2   C
	  SWITCH 2   D
	  SWITCH 3   E
	  SWITCH 3   F
	  LEFT   1 2      :1ST   .
	  LEFT   2 2      :2ND   .
	  RIGHT  3 2      :3RD   .
	  SWITCH 1   G
	  SWITCH 1   H
	  RIGHT  1 2      :4TH   .
	  DONE
	  */A 1ST/B,/C 2ND/D,/E 3RD/F,/G 4TH/H
	  SWITCH 1   A
	  SWITCH 1   B
	  SWITCH 2   C
	  SWITCH 2   D
	  SWITCH 3   E
	  SWITCH 3   F
	  RIGHT  1 2      :1ST   .
	  RIGHT  2 2      :2ND   .
	  RIGHT  3 2      :3RD   .
	  SWITCH 1   G
	  SWITCH 1   H
	  RIGHT  1 2      :4TH   .
	  DONE
	  *LPT:FIRST.[6000,56],SECOND=
	  &THIRD,DSK:FOURTH,FIFTH[6002,56,RENBR],SIXTH
	  LEFT   1 3 LPT  :FIRST .    006000 000056
	  LEFT   2 2      :SECOND.
	  RIGHT  3 2      :THIRD .
	  RIGHT  1 2 DSK  :FOURTH.
	  RIGHT  1 2 DSK  :FIFTH .    006002 000056 RENBR
	  RIGHT  1 2 DSK  :SIXTH .    006002 000056 RENBR
	  DONE
	  *=FIRST
	  RIGHT  1 2      :FIRST .
	  DONE
	  */A::C=SECOND
	  SWITCH 1   A
	   "  "  1   C
	  LEFT   1 MISSING
	  RIGHT  2 2      :SECOND.
	  DONE
	  FASP, FORTRAN Alphameric Subroutine Package          Page 93
	  DAFLAG, Routine to Locate Components of File Specification


	  *,SECOND=,FOURTH;FIRST,=THIRD,!TERMINAL COMMA IMPLIES &
	  LEFT   1 MISSING
	  LEFT   2 2      :SECOND.
	  RIGHT  3 MISSING
	  RIGHT  1 2      :FOURTH.
	  SEMICOLON
	  LEFT   1 2      :FIRST .
	  LEFT   2 MISSING
	  RIGHT  3 2      :THIRD .
	  &FOURTH
	  RIGHT  1 2      :FOURTH.
	  DONE
	  *,=,!THIS AND NEXT 3 LINES ARE REPEATED WITH ; BELOW
	  LEFT   1 MISSING
	  LEFT   2 MISSING
	  RIGHT  3 MISSING
	  &FOURTH
	  RIGHT  1 2      :FOURTH.
	  DONE
	  */A,/B=/C,/D
	  SWITCH 1   A
	  SWITCH 2   B
	  SWITCH 3   C
	  LEFT   1 MISSING
	  LEFT   2 MISSING
	  RIGHT  3 MISSING
	  SWITCH 1   D
	  &FOURTH
	  RIGHT  1 2      :FOURTH.
	  DONE
	  *,=,;FOURTH;/A,/B=/C,/D;FOURTH!SAME AS ABOVE 4 LINES
	  LEFT   1 MISSING
	  LEFT   2 MISSING
	  RIGHT  3 MISSING
	  RIGHT  1 2      :FOURTH.
	  SEMICOLON
	  SWITCH 1   A
	  SWITCH 2   B
	  SWITCH 3   C
	  LEFT   1 MISSING
	  LEFT   2 MISSING
	  RIGHT  3 MISSING
	  SWITCH 1   D
	  RIGHT  1 2      :FOURTH.
	  DONE


	  The GETFIL routine  demonstrated  above  repacks  each  file
	  specification  into  a  form  which  can be used in a PDP-10
	  FORTRAN OPEN statement, but does not actually open the files
	  and  does not evaluate the associated switches.  The routine
	  named OPNFIL which is listed below is a typical  example  of
	  the   manner   in  which  GETFIL  could  be  called  for  an
	  application in which the user is allowed to specify up to  2
	  FASP, FORTRAN Alphameric Subroutine Package          Page 94
	  DAFLAG, Routine to Locate Components of File Specification


	  output  files  and many input files.  OPNFIL identifies each
	  output file as being of either of  2  types,  designated  as
	  types one and two, depending upon the letters which form the
	  switches which appear with the  output  file  specification.
	  Although  the  calling  program specifies default extensions
	  for the output file names of each type, the first  component
	  of  the  name  of  the first input file is used as the first
	  component of the name  of  the  output  file  if  the  first
	  component of the name of the output file is not specified by
	  the user.  If no more than 1 output files is specified,  and
	  if  a switch does not identify the type of this output file,
	  then the single output file is of type one.

	  For example, if the default  extensions  for  the  type  one
	  output file, for the type two output file, and for the input
	  files are .ONE, .TWO  and  .SRC  respectively,  and  if  the
	  switch /O identifies a type one output file while the switch
	  /T identifies a type two output file, then the  short  forms
	  of  the  commands  shown  at the left in the table below are
	  equivalent to the longer forms shown at the right.

	  THIRD    or   =THIRD   to THIRD.ONE=THIRD.SRC
	  THIRD/O  or /O=THIRD   to THIRD.ONE/O=THIRD.SRC
	  THIRD/T  or /T=THIRD   to THIRD.TWO/T=THIRD.SRC
	  THIRD/O/T              to THIRD.ONE/O,THIRD.TWO/T=THIRD.SRC
	  /O=THIRD/T             to     "           "           "
	  /T=THIRD/O             to     "           "           "
	  /O/T=THIRD             to     "           "           "
	  /O,SECOND=THIRD        to THIRD.ONE/O,SECOND.TWO=THIRD.SRC
	  /T,SECOND=THIRD        to THIRD.TWO/T,SECOND.ONE=THIRD.SRC
	  ,SECOND/O=THIRD        to THIRD.TWO,SECOND.ONE/O=THIRD.SRC
	  ,SECOND/T=THIRD        to THIRD.ONE,SECOND.TWO/T=THIRD.SRC
	  FIRST/O,SECOND=THIRD   to FIRST.ONE/O,SECOND.TWO=THIRD.SRC
	  FIRST/T,SECOND=THIRD   to FIRST.TWO/T,SECOND.ONE=THIRD.SRC
	  FIRST,SECOND/O=THIRD   to FIRST.TWO,SECOND.ONE/O=THIRD.SRC
	  FIRST,SECOND/T=THIRD   to FIRST.ONE,SECOND.TWO/T=THIRD.SRC
	  FIRST/O,SECOND/T=THIRD to FIRST.ONE/O,SECOND.TWO/T=THIRD.SRC
	  FIRST/O,SECOND=THIRD/T to     "           "           "
	  FIRST,SECOND/T=THIRD/O to     "           "           "
	  FIRST/T,SECOND/O=THIRD to FIRST.TWO/T,SECOND.ONE/O=THIRD.SRC
	  FIRST/T,SECOND=THIRD/O to     "           "           "
	  FIRST,SECOND/O=THIRD/T to     "           "           "

	  As can be seen in the above examples, switches implying both
	  types  of  output  files can be present if no output file is
	  specified since then the default  characteristics  are  used
	  for   both  output  files.   If  a  single  output  file  is
	  specified, but switches implying  both  types  are  present,
	  then  the OPNFIL routine does not attempt to determine which
	  output file has  been  specified  and  which  has  not  been
	  specified,  so  the  command  is considered to be ambiguous.
	  None of the following commands would be allowed.

	  FASP, FORTRAN Alphameric Subroutine Package          Page 95
	  DAFLAG, Routine to Locate Components of File Specification


	  FIRST=THIRD/O/T    FIRST/O=THIRD/T    FIRST,SECOND=THIRD/O/T
	  FIRST/O/T=THIRD    FIRST/T=THIRD/O    FIRST/O/T,SECOND=THIRD
	                                        FIRST,SECOND/O/T=THIRD

	  The argument list of routine OPNFIL is

	        SUBROUTINE OPNFIL(  ITTY,  JTTY,KMDNUM,KMDDVC,KMDNAM,
	       1    KMDEXT,ID1NUM,ID1DVC,ID1EXT,ID2NUM,ID2DVC,ID2EXT,
	       2    ID3NUM,ID3DVC,ID3EXT,MAXTTL,MAXBFR,  KIND,KNDFLG,
	       3    NUMFLG,LTRTTL,ID1OPN,ID2OPN,IBUFFR)

	  with  the  associated   DIMENSION   and   DOUBLE   PRECISION
	  statements

	        DIMENSION KNDFLG(27),NUMFLG(27),LTRTTL(MAXTTL),
	       1IBUFFR(MAXBFR)
	        DOUBLE PRECISION KMDNAM

	  The OPNFIL  arguments  named  ITTY,  JTTY,  KMDNUM,  KMDDVC,
	  KMDNAM,  KMDEXT,  MAXBFR  and  IBUFFR  are  identical to the
	  GETFIL arguments having the same names and have already been
	  described.   The  following  arguments,  together with ITTY,
	  JTTY, KMDNUM, KMDDVC, KMDNAM, KMDEXT and  MAXBFR,  are  used
	  only for input and are returned unchanged.

	  ID1NUM = number of the unit upon which this  routine  is  to
	           open an output file which is to be of type one.  An
	           output file  will  be  of  type  one  if  its  file
	           specification is associated with a switch for which
	           the corresponding value in the KNDFLG array is 1.

	  ID1DVC = name in 5H form of the device upon which  the  type
	           one  output  file is to be written if the user does
	           not supply a device name followed by a colon at the
	           start  of  the specification of the type one output
	           file.

	  ID1EXT = name in 3H form which is to be used as  the  second
	           component  (the file name extension) of the name of
	           the type one output file if no second component  of
	           the name of the type one output file is supplied by
	           the user.  If the name of the type one output  file
	           is  not  to  have such a second component, then the
	           user  must  type  a  period  following  the   first
	           component  of  its  name.   If  the  user  does not
	           specify the first component of the name of the type
	           one  output  file,  then the first component of the
	           name of the first input file is used as  the  first
	           component of the name of the type one output file.

	  ID2NUM = number of the unit upon which this  routine  is  to
	           open an output file which is to be of type two.  An
	           output file  will  be  of  type  two  if  its  file
	           specification is associated with a switch for which
	  FASP, FORTRAN Alphameric Subroutine Package          Page 96
	  DAFLAG, Routine to Locate Components of File Specification


	           the corresponding value in the KNDFLG array is 2.

	  ID2DVC = name in 5H form of the device upon which  the  type
	           two  output  file is to be written if the user does
	           not supply a device name followed by a colon at the
	           start  of  the specification of the type two output
	           file.

	  ID2EXT = name in 3H form which is to be used as  the  second
	           component  (the file name extension) of the name of
	           the type two output file if no second component  of
	           the name of the type two output file is supplied by
	           the user.  If the name of the type two output  file
	           is  not  to  have such a second component, then the
	           user  must  type  a  period  following  the   first
	           component  of  its  name.   If  the  user  does not
	           specify the first component of the name of the type
	           two  output  file,  then the first component of the
	           name of the first input file is used as  the  first
	           component of the name of the type two output file.

	  ID3NUM = number of the unit upon which this  routine  is  to
	           open the next input file specified by the user.

	  ID3DVC = name in 5H form of the device upon which  the  next
	           input  file  is  to be opened if no device name has
	           been specified by the user for any  previous  input
	           file and if no device name is specified by the user
	           for  this  new  input  file.   Once  the  user  has
	           specified a device name for an input file, however,
	           then  the  device  name  specified  by   the   user
	           continues to be applied to any subsequent files for
	           which the device name is not  specified  until  the
	           processing   of   the   current  command  has  been
	           completed.

	  ID3EXT = name in 3H form which is to be used as  the  second
	           component  (the file name extension) of the name of
	           each input file for which no  second  component  of
	           the file name is supplied by the user.  If the file
	           name is not to have such a second  component,  then
	           the  user  must  type  a period following the first
	           component of the name.

	  MAXTTL = maximum number of locations  in  the  LTRTTL  array
	           which  can  be  used  to  return the text which was
	           found to the right of a  leading  apostrophe.   The
	           text extends through the next apostrophe or through
	           the rightmost printing character on the line if the
	           text is not terminated by a second apostrophe.  The
	           output file with which the  text  appears  will  be
	           identified  as  either  a  type  one  or a type two
	           output  file  if  the  initial  absolute  value  of
	           KNDFLG(27)  is either 1 or 2 respectively.  If such
	  FASP, FORTRAN Alphameric Subroutine Package          Page 97
	  DAFLAG, Routine to Locate Components of File Specification


	           text  is  found,  then   KNDFLG(27)   is   returned
	           containing  the  negative  of  its initial absolute
	           value and NUMFLG(27)  is  returned  containing  the
	           number of characters returned in the LTRTTL array.

	  The following argument must be zeroed by the calling program
	  before  this  routine  is  first  called, but then the value
	  returned by this routine should be  sent  to  the  following
	  call of this routine unchanged.

	  KIND   = defined similarly to the argument of the same  name
	           in  the argument list of the GETFIL routine, except
	           that the OPNFIL  routine  does  not  return  KIND=5
	           since  the  OPNFIL  routine  itself  evaluates  the
	           switches which the GETFIL routine has indicated  by
	           setting  KIND=5.  KIND should be set to zero (or to
	           1) before this routine is first called, or whenever
	           the  interpretation  of  the  current  set  of file
	           specifications  is  to  be  abandoned.    KIND   is
	           returned describing the reason why control has been
	           transferred back to the calling program, and should
	           not  be  changed  by  the  calling  program if this
	           routine is to  be  called  again  to  continue  the
	           interpretation   of   the  same  sequence  of  file
	           specifications.
	         = 1, returned if the previous call  to  this  routine
	           opened  the final input file specified by the user.
	           The next call to this routine will ask the user  to
	           type a new set of file specifications.
	         = 2, returned if the previous call  to  this  routine
	           opened  the  final input file specified to the left
	           of a semicolon.  If this routine  is  called  again
	           without  KIND  having  first  been zeroed, then the
	           evaluation of a new set of file specifications will
	           be  begun in the text appearing to the right of the
	           semicolon.
	         = 3, the current call to this routine has opened  the
	           output file or files and has opened the first input
	           file.
	         = 4, the current call to this routine has opened  the
	           second or a subsequent input file.

	  The following argument is used both for sending  information
	  to  this routine when KIND is input set to a value less than
	  3, and for returning information to the calling program when
	  KIND  is  returned set to 3.  The contents of this array are
	  returned unchanged if KIND is returned set to a value  other
	  than  3.   The  calling  program must define the contents of
	  this array before this routine is first called.

	  KNDFLG = an array dimensioned at  27  which  must  initially
	           indicate  the  output  file  types to be associated
	           with each of the single letter switches /A  through
	           /Z  and  /'  (or  lone  ')  respectively.   If this
	  FASP, FORTRAN Alphameric Subroutine Package          Page 98
	  DAFLAG, Routine to Locate Components of File Specification


	           routine is called with KIND set to 2 or less,  then
	           this  routine redefines the KNDFLG array to contain
	           the absolute values of its original  contents.   If
	           the   current  call  to  this  routine  begins  the
	           processing of a  new  command  such  that  KIND  is
	           returned   containing   the  value  3,  then  those
	           locations within the KNDFLG array having  as  their
	           subscripts the serial locations within the alphabet
	           of the letters which are found as switches  (taking
	           the  apostrophe  to  be  the  27th  letter  in  the
	           alphabet)  are   then   returned   containing   the
	           negatives  of  their absolute values.  The contents
	           of the KNDFLG array are returned unchanged if  KIND
	           is  returned  set  to 4 indicating that the current
	           call to this routine has continued  the  processing
	           of  a  command  begun  by  a  previous call to this
	           routine.

	           If either of the values  -1  or  1  appear  in  the
	           KNDFLG  array  location having as its subscript the
	           serial location within the alphabet of  the  letter
	           which  is used as a switch appearing with an output
	           file specification, then this type one output  file
	           will  be  opened upon the unit number identified by
	           ID1NUM, upon the device specified by ID1DVC  if  no
	           device  is specified by the user, and with the file
	           name extension specified by ID1EXT if no  extension
	           is  specified  by  the  user,  and  ID1OPN  will be
	           returned set to 1.  If either of the values -2 or 2
	           appear  in  the KNDFLG array location having as its
	           subscript the serial location within  the  alphabet
	           of  the  letter which is used as a switch appearing
	           with an output file specification, then  this  type
	           two output file will be opened upon the unit number
	           identified by ID2NUM, upon the device specified  by
	           ID2DVC  if  no device is specified by the user, and
	           with the file name extension specified by ID2EXT if
	           no  extension  is specified by the user, and ID2OPN
	           will be returned set to 1.  For example, if  either
	           /C or /c appear with the name of an output file and
	           if  KNDFLG(3)=2  or  -2,  then  KNDFLG(3)  will  be
	           returned containing -2 and this output file will be
	           opened upon the unit identified by ID2NUM.

	           Switches for which the corresponding  locations  in
	           the  KNDFLG  array contain the value zero cause the
	           routine named HLPFIL to be called to display a help
	           message  to the user, then force the user to supply
	           a new set of  file  specifications.   For  example,
	           KNDFLG(8)  might  contain the value zero so that /H
	           would generate the help message.  HLPFIL has as its
	           single  argument  the  terminal  unit  number.  The
	           HLPFIL routine must  be  supplied  by  the  calling
	           program.
	  FASP, FORTRAN Alphameric Subroutine Package          Page 99
	  DAFLAG, Routine to Locate Components of File Specification


	           Switches for which the corresponding  locations  in
	           the  KNDFLG  array do not contain one of the values
	           -2 through 2 can appear  with  either  output  file
	           specification  or  with  the  leftmost  input  file
	           specification but do not identify the type  of  the
	           output files.

	  The  following  arguments  are  used  only   for   returning
	  information  to the calling program when the processing of a
	  new set of commands is being begun by the  current  call  to
	  this  routine.  Their input values are returned unchanged if
	  KIND is returned set to a value other than 3.

	  NUMFLG = an array  dimensioned  at  27  which  is  used  for
	           returning the values which appeared with separating
	           colons   after   the   switches   in    the    file
	           specifications.   The  NUMFLG  array  locations  in
	           which these  values  are  returned  have  as  their
	           subscripts the serial locations within the alphabet
	           of the letters which  are  used  as  the  switches.
	           Such numbers must be specified as decimal integers,
	           but cannot contain exponents.  If the switch /C:123
	           appears  in  the file specification, then KNDFLG(3)
	           will be returned containing  the  negative  of  its
	           original  absolute  value,  and  NUMFLG(3)  will be
	           returned containing the integer value 123.   If  an
	           apostrophe   is   found   with   the  set  of  file
	           specifications,   then   NUMFLG(27)   is   returned
	           containing  the number of characters which appeared
	           to the  right  of  the  apostrophe  and  which  are
	           returned in the LTRTTL array.

	  LTRTTL = array in which the characters which were  found  to
	           the right of a leading apostrophe are returned with
	           1  character  per  array  location  as  read  by  a
	           multiple of an A1 format.  The LTRTTL array must be
	           dimensioned to at least the value  of  MAXTTL.   If
	           such  text  is  found  to  the  right  of a leading
	           apostrophe, then KNDFLG(27) is returned  containing
	           the  negative  of  its  initial  absolute value and
	           NUMFLG(27) is returned  containing  the  number  of
	           characters  returned  in  the  LTRTTL  array.   The
	           terminal apostrophes  are  never  returned  in  the
	           LTRTTL  array and are not included in the character
	           count returned in NUMFLG(27).

	  ID1OPN = 0, returned if a  type  one  output  file  was  not
	           opened.
	         = 1, returned if a type one output file was opened.

	  ID2OPN = 0, returned if a  type  two  output  file  was  not
	           opened.
	         = 1, returned if a type two output file was opened.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 100
	  DAFLAG, Routine to Locate Components of File Specification


	  The OPNFIL routine is listed below.   It  is  expected  that
	  this  routine will have to be modified to fit the particular
	  application for which this routine is used.

	        SUBROUTINE OPNFIL(  ITTY,  JTTY,KMDNUM,KMDDVC,KMDNAM,
	       1    KMDEXT,ID1NUM,ID1DVC,ID1EXT,ID2NUM,ID2DVC,ID2EXT,
	       2    ID3NUM,ID3DVC,ID3EXT,MAXTTL,MAXBFR,  KIND,KNDFLG,
	       3    NUMFLG,LTRTTL,ID1OPN,ID2OPN,IBUFFR)
	  C     RENBR(/OPEN FILES FOR FILE,FILE=FILE,FILE COMMAND)
	  C
	        COMMON/FASPY/NEWNUL(3),NEWDSK(3),NEWNAM(3),
	       1NEWPTH(3,3),LCNRIT
	        DIMENSION KNDFLG(27),NUMFLG(27),LTRTTL(MAXTTL),
	       1IBUFFR(MAXBFR),LTRABC(27),LWRABC(27),LTRDGT(10),
	       2INILTR(6),KNTLTR(6)
	        DOUBLE PRECISION KMDNAM,NEWNAM,NEWPTH,PTHONE(3),
	       1PTHTWO(3),PTHTHR(3),FILONE,FILTWO,FILTHR,FILNAM
	        DATA LTRABC/1HA,1HB,1HC,1HD,1HE,1HF,1HG,1HH,1HI,1HJ,
	       1            1HK,1HL,1HM,1HN,1HO,1HP,1HQ,1HR,1HS,1HT,
	       2            1HU,1HV,1HW,1HX,1HY,1HZ,1H'/
	        DATA LWRABC/1Ha,1Hb,1Hc,1Hd,1He,1Hf,1Hg,1Hh,1Hi,1Hj,
	       1            1Hk,1Hl,1Hm,1Hn,1Ho,1Hp,1Hq,1Hr,1Hs,1Ht,
	       2            1Hu,1Hv,1Hw,1Hx,1Hy,1Hz,1H'/
	        DATA LTRDGT/1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9/
	        DATA LTRPLS,LTRMNS,IBLANK/1H+,1H-,5H     /
	  C
	  C     INITIALIZE STORAGE OF COMMAND
	        INITAL=KIND-2
	        IF(INITAL.GT.0)GO TO 4
	        GO TO 2
	      1 KIND=0
	      2 ID1OPN=0
	        ID2OPN=0
	        DO 3 I=1,27
	        IF(KNDFLG(I).LT.0)KNDFLG(I)=-KNDFLG(I)
	      3 NUMFLG(I)=0
	        KNDONE=0
	        KNDTWO=0
	        KNDTHR=0
	  C
	  C     GET NEXT COMPONENT OF COMMAND TYPED BY USER
	      4 CALL GETFIL(3,ITTY,JTTY,KMDNUM,KMDDVC,
	       1KMDNAM,KMDEXT,6,MAXBFR,KIND,NEWNUL,NEWDSK,
	       2NEWNAM,NEWPTH,LCNRIT,IBUFFR,MAXFLG,INILTR,KNTLTR,
	       3LCNOWN)
	        GO TO(45,45,23,31,5),KIND
	  C
	  C     DECIDE WHICH SWITCH WAS GIVEN
	      5 IF(MAXFLG.LE.0)GO TO 4
	        IF(KNTLTR(1).LE.0)GO TO 4
	        IF(INITAL.GT.0)GO TO 4
	        LOCLTR=INILTR(1)
	        LTRNOW=IBUFFR(LOCLTR)
	        NEWFLG=0
	  FASP, FORTRAN Alphameric Subroutine Package         Page 101
	  DAFLAG, Routine to Locate Components of File Specification


	      6 NEWFLG=NEWFLG+1
	        IF(NEWFLG.GT.27)GO TO 4
	        IF(LTRABC(NEWFLG).EQ.LTRNOW)GO TO 7
	        IF(LWRABC(NEWFLG).NE.LTRNOW)GO TO 6
	      7 IF(KNDFLG(NEWFLG).EQ.0)GO TO 35
	        IF(KNDFLG(NEWFLG).GT.0)KNDFLG(NEWFLG)=-KNDFLG(NEWFLG)
	        IF(KNDFLG(NEWFLG).EQ.-2)GO TO 11
	        IF(KNDFLG(NEWFLG).NE.-1)GO TO 15
	  C
	  C     MARK THAT FILE BEARS TYPE ONE SWITCH
	        ID1OPN=1
	        GO TO(8,9,10),LCNOWN
	      8 IF(KNDONE.EQ.1)GO TO 15
	        IF(KNDONE.NE.3)KNDONE=KNDONE+1
	        GO TO 15
	      9 IF(KNDTWO.EQ.1)GO TO 15
	        IF(KNDTWO.NE.3)KNDTWO=KNDTWO+1
	        GO TO 15
	     10 IF(KNDTHR.EQ.1)GO TO 15
	        IF(KNDTHR.NE.3)KNDTHR=KNDTHR+1
	        GO TO 15
	  C
	  C     MARK THAT FILE BEARS TYPE TWO SWITCH
	     11 ID2OPN=1
	        GO TO(12,13,14),LCNOWN
	     12 IF(KNDONE.LE.1)KNDONE=KNDONE+2
	        GO TO 15
	     13 IF(KNDTWO.LE.1)KNDTWO=KNDTWO+2
	        GO TO 15
	     14 IF(KNDTHR.LE.1)KNDTHR=KNDTHR+2
	  C
	  C     STORE QUOTED TEXT STRING
	     15 IVALUE=0
	        IF(NEWFLG.LT.27)GO TO 17
	        LMTLTR=LOCLTR+KNTLTR(1)
	     16 IF(IVALUE.GE.MAXTTL)GO TO 22
	        LOCLTR=LOCLTR+1
	        IF(LOCLTR.GE.LMTLTR)GO TO 22
	        IVALUE=IVALUE+1
	        LTRTTL(IVALUE)=IBUFFR(LOCLTR)
	        GO TO 16
	  C
	  C     EVALUATE NUMBERS IN RANGE OF SWITCH
	     17 IF(MAXFLG.LE.1)GO TO 22
	        IF(KNTLTR(2).LE.0)GO TO 22
	        LOCLTR=INILTR(2)
	        LMTLTR=LOCLTR+KNTLTR(2)
	        I=0
	        IF(IBUFFR(LOCLTR).EQ.LTRPLS)GO TO 18
	        IF(IBUFFR(LOCLTR).NE.LTRMNS)GO TO 19
	        I=1
	     18 LOCLTR=LOCLTR+1
	     19 IF(LOCLTR.GE.LMTLTR)GO TO 21
	        LTRNOW=IBUFFR(LOCLTR)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 102
	  DAFLAG, Routine to Locate Components of File Specification


	        DO 20 L=1,10
	        IF(LTRDGT(L).NE.LTRNOW)GO TO 20
	        IVALUE=(10*IVALUE)+L-1
	        GO TO 18
	     20 CONTINUE
	     21 IF(I.NE.0)IVALUE=-IVALUE
	     22 NUMFLG(NEWFLG)=IVALUE
	        GO TO 4
	  C
	  C     SET DEFAULT OUPUT DEVICE NAMES AND PATHS
	     23 IF(NEWNUL(LCNRIT).LE.1)GO TO 38
	        IF(NEWNUL(LCNRIT).EQ.4)GO TO 38
	        IF(ID1OPN.EQ.ID2OPN)ID1OPN=1
	        FILONE=NEWNAM(LCNRIT)
	        FILTWO=FILONE
	        MORONE=ID1EXT
	        MORTWO=ID2EXT
	        PTHONE(1)=0
	        PTHTWO(1)=0
	        LOCONE=ID1DVC
	        LOCTWO=ID2DVC
	        GO TO(31,24,25),LCNRIT
	  C
	  C     SINGLE FILE LEFT OF EQUAL SIGN
	     24 IF(NEWNUL(1).EQ.0)GO TO 31
	        IF(ID1OPN.EQ.ID2OPN)GO TO 36
	        KNDONE=1
	        KNDTWO=1
	        GO TO 26
	  C
	  C     TWO FILES LEFT OF EQUAL SIGN
	     25 IF(KNDONE.GE.3)GO TO 36
	        IF(KNDTWO.GE.3)GO TO 36
	        IF(KNDONE.EQ.KNDTWO)GO TO 36
	        ID1OPN=1
	        ID2OPN=1
	        IF(KNDONE.EQ.0)KNDONE=3-KNDTWO
	        IF(KNDTWO.EQ.0)KNDTWO=3-KNDONE
	     26 IF(NEWNUL(KNDONE).EQ.0)GO TO 29
	        IF(NEWDSK(KNDONE).NE.IBLANK)LOCONE=NEWDSK(KNDONE)
	        DO 27 I=1,3
	     27 PTHONE(I)=NEWPTH(I,KNDONE)
	        IF(NEWNUL(KNDONE).LE.1)GO TO 29
	        FILNAM=NEWNAM(KNDONE)
	        IF(NEWNUL(KNDONE).LE.3)FILONE=FILNAM
	        IF(NEWNUL(KNDONE).GE.3)DECODE(10,28,FILNAM)MORONE
	     28 FORMAT(7X,1A3)
	     29 IF(NEWNUL(KNDTWO).EQ.0)GO TO 31
	        IF(NEWDSK(KNDTWO).NE.IBLANK)LOCTWO=NEWDSK(KNDTWO)
	        DO 30 I=1,3
	     30 PTHTWO(I)=NEWPTH(I,KNDTWO)
	        IF(NEWNUL(KNDTWO).LE.1)GO TO 31
	        FILNAM=NEWNAM(KNDTWO)
	        IF(NEWNUL(KNDTWO).LE.3)FILTWO=FILNAM
	  FASP, FORTRAN Alphameric Subroutine Package         Page 103
	  DAFLAG, Routine to Locate Components of File Specification


	        IF(NEWNUL(KNDTWO).GE.3)DECODE(10,28,FILNAM)MORTWO
	  C
	  C     OPEN INPUT FILE
	     31 IF(NEWNUL(LCNRIT).EQ.0)GO TO 4
	        FILTHR=NEWNAM(LCNRIT)
	        MORTHR=ID3EXT
	        IF(NEWNUL(LCNRIT).GE.3)DECODE(10,28,FILTHR)MORTHR
	        LOCTHR=NEWDSK(LCNRIT)
	        IF(LOCTHR.EQ.IBLANK)LOCTHR=ID3DVC
	        DO 32 I=1,3
	     32 PTHTHR(I)=NEWPTH(I,LCNRIT)
	        ENCODE(10,33,FILNAM)FILTHR,MORTHR
	     33 FORMAT(1A6,1H.,1A3)
	        OPEN(UNIT=ID3NUM,FILE=FILNAM,DIRECTORY=PTHTHR,
	       1DEVICE=LOCTHR,ACCESS='SEQIN',ERR=43)
	        IF(INITAL.GT.0)GO TO 47
	  C
	  C     OPEN OUTPUT FILES
	        IF(ID1OPN.EQ.0)GO TO 34
	        ENCODE(10,33,FILNAM)FILONE,MORONE
	        OPEN(UNIT=ID1NUM,FILE=FILNAM,DIRECTORY=PTHONE,
	       1DEVICE=LOCONE,ACCESS='SEQOUT',ERR=40)
	        IF(ID2OPN.EQ.0)GO TO 46
	     34 ENCODE(10,33,FILNAM)FILTWO,MORTWO
	        OPEN(UNIT=ID2NUM,FILE=FILNAM,DIRECTORY=PTHTWO,
	       1DEVICE=LOCTWO,ACCESS='SEQOUT',ERR=42)
	        GO TO 46
	  C
	  C     ISSUE HELP MESSAGE AND THEN CLEAR COMMAND IF ANY
	     35 CALL HLPFIL(JTTY)
	        GO TO 1
	  C
	  C     ERROR IN COMMAND TYPED BY USER
	     36 WRITE(JTTY,37)
	     37 FORMAT(31H AMBIGUOUS OUTPUT SPECIFICATION)
	        GO TO 1
	     38 WRITE(JTTY,39)
	     39 FORMAT(34H 1ST SOURCE FILE MUST BE SPECIFIED)
	        GO TO 1
	     40 WRITE(JTTY,41)LOCONE,FILNAM
	     41 FORMAT(26H CANNOT WRITE OUTPUT FILE ,1A5,1H:,1A10)
	        GO TO 1
	     42 WRITE(JTTY,41),LOCTWO,FILNAM
	        GO TO 1
	     43 WRITE(JTTY,44)LOCTHR,FILNAM
	     44 FORMAT(25H CANNOT READ SOURCE FILE ,1A5,1H:,1A10)
	        GO TO 4
	  C
	  C     RETURN TO CALLING PROGRAM
	     45 IF(INITAL.LE.0)GO TO 2
	        GO TO 47
	     46 KIND=3
	     47 RETURN
	  C024147266970'abcdefghijklmnopqrstuvwxyz:
	  FASP, FORTRAN Alphameric Subroutine Package         Page 104
	  DAFLAG, Routine to Locate Components of File Specification


	        END

	  The following program demonstrates the manner in  which  the
	  OPNFIL routine might be called.

	  C     RENBR(TSTOPN/DEMONSTRATE OPNFIL ROUTINE)
	        DOUBLE PRECISION KMDNAM
	        DIMENSION IBUFFR(72),JBUFFR(72),KNDFLG(27),
	       1NUMFLG(27),LTRTTL(30),LTRABC(26)
	        DATA LTRABC/1HA,1HB,1HC,1HD,1HE,1HF,1HG,1HH,1HI,1HJ,
	       1            1HK,1HL,1HM,1HN,1HO,1HP,1HQ,1HR,1HS,1HT,
	       2            1HU,1HV,1HW,1HX,1HY,1HZ/
	        DATA KMDDVC,KMDNAM,KMDEXT/3HDSK,6HOPNFIL,3HCCL/
	        DATA ID1DVC,ID1EXT/3HDSK,3HONE/
	        DATA ID2DVC,ID2EXT/3HDSK,3HTWO/
	        DATA ID3DVC,ID3EXT/3HDSK,3HSRC/
	        DATA MAXTTL,MAXBFR/30,72/
	        DATA KMDNUM,ITTY,JTTY,ID1NUM,ID2NUM,ID3NUM/
	       124,5,5,1,20,21/
	  C
	  C     DEFINE FILE TYPE ASSOCIATED WITH EACH FLAG
	  C     /H, /O, /T GIVE HELP, TYPE ONE, TYPE TWO RESPECTIVELY
	  C     NO OTHER LETTERS IMPLY ASSOCIATED FILE TYPES
	        DO 1 I=1,27
	      1 KNDFLG(I)=3
	        KNDFLG(8)=0
	        KNDFLG(15)=1
	        KNDFLG(20)=2
	        KIND=0
	  C
	  C     OPEN NEXT INPUT FILE
	      2 CALL OPNFIL(ITTY,JTTY,KMDNUM,KMDDVC,KMDNAM,
	       1KMDEXT,ID1NUM,ID1DVC,ID1EXT,ID2NUM,ID2DVC,ID2EXT,
	       2ID3NUM,ID3DVC,ID3EXT,MAXTTL,MAXBFR,KIND,KNDFLG,
	       3NUMFLG,LTRTTL,ID1OPN,ID2OPN,IBUFFR)
	        GO TO(12,14,3,10),KIND
	  C
	  C     REPORT VALUES OF SWITCHES
	      3 NEEDED=0
	      4 NEEDED=NEEDED-1
	        DO 6 INDEX=1,26
	        IF(KNDFLG(INDEX).EQ.NEEDED)WRITE(JTTY,5)
	       1LTRABC(INDEX),NUMFLG(INDEX)
	      5 FORMAT(1X,1A1,I5)
	      6 CONTINUE
	        IF(NEEDED.GE.-2)GO TO 4
	        J=NUMFLG(27)
	        IF(J.GT.0)WRITE(JTTY,7)(LTRTTL(I),I=1,J)
	      7 FORMAT(8H TITLE: ,30A1)
	        IF(ID1OPN.NE.0)WRITE(JTTY,8)
	      8 FORMAT(21H TYPE ONE OUTPUT FILE)
	        IF(ID2OPN.NE.0)WRITE(JTTY,9)
	      9 FORMAT(21H TYPE TWO OUTPUT FILE)
	  C
	  FASP, FORTRAN Alphameric Subroutine Package         Page 105
	  DAFLAG, Routine to Locate Components of File Specification


	  C     COPY INPUT FILE INTO OUTPUT FILES
	     10 READ(ID3NUM,11,END=2)JBUFFR
	     11 FORMAT(72A1)
	        IF(ID1OPN.NE.0)WRITE(ID1NUM,11)JBUFFR
	        IF(ID2OPN.NE.0)WRITE(ID2NUM,11)JBUFFR
	        GO TO 10
	  C
	  C     END OF USER COMMAND FOUND
	     12 WRITE(JTTY,13)
	     13 FORMAT(' DONE')
	        GO TO 16
	     14 WRITE(JTTY,15)
	     15 FORMAT(' SEMICOLON')
	     16 IF(ID1OPN.NE.0)CLOSE(UNIT=ID1NUM)
	        IF(ID2OPN.NE.0)CLOSE(UNIT=ID2NUM)
	        GO TO 2
	        END
	        SUBROUTINE HLPFIL(JTTY)
	        WRITE(JTTY,1)
	      1 FORMAT(13H HELP MESSAGE)
	        RETURN
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 106
	  DAHEFT, Free Format Numeric Input Routine


	   DDDDD          AAA  HH    HH  EEEEEEEE  FFFFFFFF  TTTTTTTT
	   DD   DD       AAAA  HH    HH  EE        FF           TT
	   DD    DD     AA AA  HH    HH  EE        FF           TT
	   DD    DD    AA  AA  HHHHHHHH  EEEEE     FFFFF        TT
	   DD    DD   AAAAAAA  HH    HH  EE        FF           TT
	   DD   DD   AA    AA  HH    HH  EE        FF           TT
	   DDDDD    AA     AA  HH    HH  EEEEEEEE  FF           TT


	           DAHEFT, Free Format Numeric Input Routine
	           ------  ---- ------ ------- ----- -------

	  DAHEFT interprets an array read by the calling program  with
	  a  multiple of an A1 format and returns the values contained
	  in this array.  Numbers interpreted by  DAHEFT  can  contain
	  leading  sign, embedded decimal point and/or trailing E with
	  possibly signed exponent.   A  percent  sign  following  the
	  number  implies  E-2,  trailing  letter  K  implies  E3  and
	  trailing letter M implies E6.  To be recognized as part of a
	  number,  the percent sign or letters K or M or E must follow
	  either a sign or a digit or a decimal point.

	  If a number contains no value digits but does contain a sign
	  or  decimal  point, then the value is taken as zero.  If the
	  letter E appears in a number but no  digits  appear  to  the
	  right  of  the  letter  E, then the value of the exponent is
	  taken as zero.  Trailing E, E0,  E-  and  E+  are  therefore
	  equivalent to multiplication by 10**0 or 1.

	  DAHEFT can return the value either as a real number or as an
	  integer.   If  only  integer  values  are required, then the
	  shorter routine named DAIHFT can be called instead of DAHEFT
	  to  evaluate  the  numbers.   DAIHFT  can  evaluate  integer
	  numbers in the full range of E, K and M notations, and  will
	  accept percent signs and negative exponents.  As an example,
	  DAIHFT would return the integer value 123  after  evaluation
	  of any of the following alphameric representations.

	  123.  12.3E+1  0.0123E4  0.123K  .000123M  12300%  +12300E-2


	              The DAHEFT and DAIHFT Argument Lists
	              --- ------ --- ------ -------- -----

	  The argument lists of routines DAHEFT and DAIHFT are

	        SUBROUTINE DAHEFT(KONTRL,ITRAIL,IEXTRA,IBUFFR,MAXBFR,
	       1    LOWBFR,KIND  ,ISHIFT,JSHIFT,KSHIFT,LSHIFT,IVALUE,
	       2    VALUE )

	  and

	        SUBROUTINE DAIHFT(KONTRL,ITRAIL,IEXTRA,IBUFFR,MAXBFR,
	       1    LOWBFR,KIND  ,ISHIFT,JSHIFT,KSHIFT,LSHIFT,IVALUE)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 107
	  DAHEFT, Free Format Numeric Input Routine


	  both with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR)

	  The argument lists of the 2 routines  are  identical  except
	  that the DAHEFT argument VALUE does not appear in the DAIHFT
	  argument list.  Since DAIHFT cannot evaluate  real  numbers,
	  DAIHFT evaluates decimal integers if KONTRL is input greater
	  than or equal to zero.

	  The following arguments are used for input and are  returned
	  unchanged.

	  KONTRL = 1  or  greater,  the  item  in  the  IBUFFR   array
	           represents  a  real  number.  If possible, the real
	           number will be accumulated as an integer,  then  be
	           converted   to   a   real  number  and  shifted  if
	           necessary.  KONTRL is then the  maximum  number  of
	           digits  in the integer.  The value is output as the
	           argument VALUE.  If the item has more  than  KONTRL
	           digits  (not  counting  leftmost  zeroes), then the
	           entire evaluation is done as a  real  number.   The
	           advantage of calculating the real values in integer
	           as long as the precision of  the  computer  is  not
	           overflowed  is  that the calculation of the portion
	           of the number right of the decimal  point  is  more
	           exact.  As an example, if KONTRL is greater than or
	           equal to 4, then the number 33.33 can be stored  as
	           the  integer  3333,  then  be converted to the real
	           value 3333.0 and divided by  100.0  to  obtain  the
	           final  answer.   If  it makes no difference whether
	           the number  typed  as  33.33  has  value  33.33  or
	           33.32999...  then KONTRL can be given the value 1.
	         = 0,  the  item  in   the   IBUFFR   array   is   the
	           representation  of  a  decimal integer.  The number
	           can be typed with  a  decimal  point  (for  example
	           1.23K  or  1.23E3 equals 1230), but is stored as an
	           integer  in  DAHEFT,  and  is  output  as  argument
	           IVALUE.  Any decimal integer which the computer can
	           represent can be evaluated.  This includes, on twos
	           complement  computers,  the largest negative number
	           the absolute value of which cannot be  stored.   On
	           the  PDP-10, a 36 bit computer with twos complement
	           notation,  the  range  of   decimal   integers   is
	           -34359738368 through 34359738367 (octal notation of
	           bit    patterns    being    400000000000    through
	           377777777777).
	         = -1,  the  item  in  the   IBUFFR   array   is   the
	           representation of an octal integer.  The number can
	           be typed  with  a  decimal  point  and/or  with  an
	           exponent.  However, the number following the letter
	           E of the exponent is  evaluated  in  decimal.   The
	           value  of  the  octal  number  is  returned  as the
	           argument IVALUE.  It must  be  noted  that  numbers
	  FASP, FORTRAN Alphameric Subroutine Package         Page 108
	  DAHEFT, Free Format Numeric Input Routine


	           evaluated  as  negative  octal  integers  have  the
	           negative octal integer as their value, not as their
	           bit   representation   in  computer  storage.   For
	           example, on a 36 bit twos complement computer,  the
	           octal  number  -400000000000  (which  could also be
	           typed as -4E11 or -4E+11 where the 11 after  the  E
	           is  in  decimal)  is represented as the bit pattern
	           having the  octal  notation  400000000000  and  the
	           octal  number  -377777777777  is represented by the
	           bit pattern 400000000001.
	         = -2,  do  not  evaluate  numbers.   LOWBFR  will  be
	           returned   pointing   to   the   leftmost  printing
	           character  in  the  buffer,  or  will  be  returned
	           pointing  beyond the right end of the buffer if the
	           buffer contains no printing characters.

	  ITRAIL = selects whether exponents are to be recognized.  If
	           not,  then  each number will terminate prior to the
	           exponent, and LOWBFR will be returned  pointing  to
	           the  letter  starting the exponent.  The subsequent
	           call to this routine will return KIND=2  indicating
	           that  an  illegal  character  has been found if the
	           calling program does not first increment the  value
	           of LOWBFR.

	         = -1, exponents expressed in E  notation  are  to  be
	           recognized  if  and  only  if  preceded either by a
	           digit, a decimal point or by a plus or minus  sign.
	           The   returned   value   will   already  have  been
	           multiplied by the radix  raised  to  the  indicated
	           power.   The  percent  sign and the letters K and M
	           are to be treated the same as any other  alphabetic
	           character.
	         = 0, no exponents are to be recognized.  Numbers will
	           be  terminated  prior  to  percent  signs or to the
	           letters E or K or M.
	         = 1,  percent  signs,  the  letters  K  and  M,   and
	           exponents  expressed  in  E notation, are all to be
	           recognized if and only  if  preceded  either  by  a
	           digit,  a decimal point or by a plus or minus sign.
	           The  returned  value   will   already   have   been
	           multiplied  by  the  radix  raised to the indicated
	           power.

	  IEXTRA = an extra shift, stated as the power  of  the  radix
	           (the  radix  being  8  if  KONTRL  is  -1,  and  10
	           otherwise), which is always to be  applied  to  the
	           evaluated   number  (regardless  of  the  value  of
	           ITRAIL) before the evaluated number is returned  to
	           the  calling  program.  For example, IEXTRA=2 would
	           return the  number  of  cents  corresponding  to  a
	           dollar price specified by the contents of the input
	           text buffer.  The shift specified  by  IEXTRA  does
	           not  change  the returned values of ISHIFT, JSHIFT,
	  FASP, FORTRAN Alphameric Subroutine Package         Page 109
	  DAHEFT, Free Format Numeric Input Routine


	           KSHIFT or LHSIFT which reflect the shifts specified
	           by the contents of the input text buffer.

	  IBUFFR = input buffer array containing characters  typed  by
	           user,  read by a multiple of an A1 format, which is
	           to be searched for numbers.  IBUFFR then contains 1
	           character per computer storage location.

	  MAXBFR = subscript of the final (rightmost) location in  the
	           IBUFFR array which can be searched for a number.

	  The following argument must be set by  the  calling  program
	  before this routine is first called, and then is returned by
	  this routine describing the location of the first  character
	  in the input buffer not yet processed.

	  LOWBFR = subscript within the  IBUFFR  array  of  the  first
	           (leftmost)  character  which can be scanned for the
	           representation of numbers.  If a number  is  found,
	           then  LOWBFR will be returned pointing to the first
	           character beyond the number which could not be part
	           of  the  number.   If  a  number is not found, then
	           LOWBFR will  be  returned  pointing  to  the  first
	           printing  character  (which  would  have  to  be  a
	           character other than a plus sign or a minus sign or
	           a  decimal  point  or a digit through 7 if octal or
	           through 9 if decimal), or beyond  the  end  of  the
	           buffer  if the buffer does not contain any printing
	           characters at or to the  right  of  IBUFFR(LOWBFR).
	           LOWBFR  must  be  set by the calling program before
	           this  routine  is  first  called  to  process   the
	           contents  of  the buffer, and should not be changed
	           by the calling program if this  routine  locates  a
	           number.   If  a  printing  character is found which
	           cannot start a number, then  the  contents  of  the
	           buffer  should  be  processed  by  some  other FASP
	           routine, or at least  the  calling  program  should
	           increment  the  value  of  LOWBFR by 1 before again
	           calling this routine.

	  The following arguments are used for  returning  information
	  to the calling program.  Their input values are ignored.

	  KIND   = returned describing the kind of item located in the
	           IBUFFR array.
	         = 1, no printing character was found  at  or  to  the
	           right   of   IBUFFR(LOWBFR).   LOWBFR  is  returned
	           pointing beyond the end of the IBUFFR  array.   The
	           calling  program  should  read  a new line into the
	           IBUFFR array and reset LOWBFR to point to the first
	           character in this array.
	         = 2, a number was not found, but a printing character
	           which  cannot start a number was found at or to the
	           right of IBUFFR(LOWBFR).  LOWBFR will  be  returned
	  FASP, FORTRAN Alphameric Subroutine Package         Page 110
	  DAHEFT, Free Format Numeric Input Routine


	           pointing  to  the  printing character.  The calling
	           program must increment the value of  LOWBFR  before
	           again calling this routine since supplying the same
	           initial character would produce identical  results.
	           VALUE  or  IVALUE,  whichever  is  appropriate,  is
	           returned with the value zero (even if ITRAIL is  in
	           the  range  -13  to  -7  as described later in this
	           documentation),  so  KIND=2   can   be   considered
	           equivalent  to KIND=3 if such is appropriate to the
	           application for which DAHEFT is being used.
	         = 3, a number was found.  LOWBFR is returned pointing
	           to the character to the right of the representation
	           of the number.   If  ITRAIL=0  and  the  number  is
	           followed  by  a percent sign or the letters K, M or
	           E, or if ITRAIL is equal to -1 and  the  number  is
	           followed  by  a percent sign or the letters K or M,
	           then LOWBFR  will  be  returned  pointing  to  this
	           printing   character   and   no  exponent  will  be
	           evaluated.

	  ISHIFT = if KIND is returned containing 3,  then  ISHIFT  is
	           returned describing which of the characters E, %, K
	           or M, if any, appeared in the number specification.
	           If  KIND  is returned containing a value other than
	           3, then ISHIFT, JSHIFT, KSHIFT and LSHIFT  are  all
	           returned undefined but probably changed.
	         = -4, the number was followed by the  letter  E,  but
	           neither  sign  nor digits appeared in the exponent.
	           JSHIFT is returned zeroed.  No exponent other  than
	           that  specified  by  IEXTRA has been applied to the
	           returned value (providing that ITRAIL is not in the
	           range   -13  to  -7  as  described  later  in  this
	           documentation).
	         = -3, the number was followed by  the  letter  E  and
	           then by a minus sign, but no digits appeared in the
	           exponent.  JSHIFT is returned zeroed.  No  exponent
	           other  than  that  specified  by  IEXTRA  has  been
	           applied  to  the  returned  value  (providing  that
	           ITRAIL  is  not in the range -13 to -7 as described
	           later in this documentation).
	         = -2, the number was followed by  the  letter  E  and
	           then  by a plus sign, but no digits appeared in the
	           exponent.  JSHIFT is returned zeroed.  No  exponent
	           other  than  that  specified  by  IEXTRA  has  been
	           applied  to  the  returned  value  (providing  that
	           ITRAIL  is  not in the range -13 to -7 as described
	           later in this documentation).
	         = -1, the number was followed by  the  letter  E  and
	           then  by  the number which is returned as the value
	           of JSHIFT.
	         = 0, returned if none of the characters E, %, K or  M
	           follow  the  number.  JSHIFT is returned containing
	           0.
	         = 1, the number  was  followed  by  a  percent  sign.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 111
	  DAHEFT, Free Format Numeric Input Routine


	           JSHIFT is returned containing -2.
	         = 2, the number was followed by the letter K.  JSHIFT
	           is returned containing 3.
	         = 3, the number was followed by the letter M.  JSHIFT
	           is returned containing 6.

	  JSHIFT = if KIND is returned containing 3,  then  JSHIFT  is
	           returned  containing  the  value  of  the  exponent
	           evaluated  at  the  right   end   of   the   number
	           representation.   JSHIFT is the shift stated as the
	           power of the radix.  If the letter  E  follows  the
	           number,  then JSHIFT is the number appearing to the
	           right of the letter E, or  is  returned  containing
	           zero  if  no  digits were found to the right of the
	           letter E.  If one of  the  characters  %,  K  or  M
	           follow   the   number,   then  JSHIFT  is  returned
	           containing -2, 3 and 6 respectively.  The  returned
	           value  of  JSHIFT is independent of the input value
	           of  IEXTRA.   JSHIFT  is  returned  undefined   but
	           probably  changed  if KIND is returned containing a
	           value other than 3.

	  KSHIFT = if KIND is returned containing 3,  then  KSHIFT  is
	           returned  describing  the  precision  of  the least
	           significant digit specified by the contents of  the
	           input  text  buffer.   KSHIFT  is  the power of the
	           radix which if used as the shift  would  result  in
	           the  same  value if the same digits where found but
	           without a decimal point.  KSHIFT would be  returned
	           containing  -2  if  the  input text buffer contains
	           12.34 since this could have been written as 1234E-2
	           instead.   A KSHIFT value of -2 would indicate that
	           the tenths and hundredths  digits  were  specified.
	           If  the  input  text  buffer  contains  12.34K then
	           KSHIFT would be returned containing  1  since  this
	           could be written as 1234E1 instead.  A KSHIFT value
	           of 1 would indicate that the ones (units) digit was
	           not  specified.   The  returned  value of KSHIFT is
	           independent of the input value of  IEXTRA.   KSHIFT
	           is  returned undefined but probably changed if KIND
	           is returned containing a value other than 3.

	  LSHIFT = returned specifying the number of digits which were
	           found  counting the leftmost non-zero digit and all
	           digits which were specified to its  right.   LSHIFT
	           is  returned undefined but probably changed if KIND
	           is returned containing a value other than 3.
	         = -4, the  number  representation  contained  neither
	           leading  sign  nor  decimal point nor value digits.
	           In order for this value of LSHIFT to  be  returned,
	           ITRAIL  would  have to have a value other than -11,
	           -10, -9, -1, 0, 1, 9, 10 or 11 as  described  later
	           in  this  documentation,  and  the  first  printing
	           characters in the text buffer would  have  to  form
	  FASP, FORTRAN Alphameric Subroutine Package         Page 112
	  DAHEFT, Free Format Numeric Input Routine


	           the   representation  of  an  exponent.   VALUE  or
	           IVALUE,  whichever  is  appropriate,  is   returned
	           containing  zero  (providing  that ITRAIL is not in
	           the range -13 to -7).
	         = -3, the number representation began  with  a  minus
	           sign  but  contained  no  value  digits.   VALUE or
	           IVALUE,  whichever  is  appropriate,  is   returned
	           containing  zero  (providing  that ITRAIL is not in
	           the range -13 to -7).
	         = -2, the number representation  began  with  a  plus
	           sign  but  contained  no  value  digits.   VALUE or
	           IVALUE,  whichever  is  appropriate,  is   returned
	           containing  zero  (providing  that ITRAIL is not in
	           the range -13 to -7).
	         = -1, the number representation began with a  decimal
	           point  but  contained  no  value  digits.  VALUE or
	           IVALUE,  whichever  is  appropriate,  is   returned
	           containing  zero  (providing  that ITRAIL is not in
	           the range -13 to -7).
	         = 0, one or more zero value digits  were  found,  but
	           the number representation contained no value digits
	           other than zero.  The number representation may  or
	           may  not  have  contained  either  sign  or decimal
	           point.
	         = greater than zero, LSHIFT is the number  of  digits
	           which  were  specified  in  the  input text buffer,
	           counting the leftmost non-zero value digit and  all
	           value  digits  which  were  specified to its right.
	           LSHIFT is the number of  significant  digits  which
	           were  evaluated  and is independent of the location
	           of the decimal point or the value of  the  exponent
	           or  of  IEXTRA.  IF KONTRL is less than or equal to
	           zero so that the value is returned as  the  integer
	           IVALUE,  then  those digits which are discarded due
	           to their being to the  right  of  adjusted  decimal
	           point  (after  application  of  IEXTRA  and  of the
	           exponent indicated in  the  number  representation)
	           are still included within the value of LSHIFT.

	  IVALUE = returned with the value of the evaluated number  if
	           KONTRL is less than or equal to zero.  Note that if
	           KONTRL is less than or  equal  to  zero,  then  the
	           original content of IVALUE is always destroyed.  In
	           particular, if KONTRL is less than or equal to zero
	           and  if KIND is returned not equal to 3 then IVALUE
	           will be zeroed.

	  VALUE  = returned with the value of the evaluated number  if
	           KONTRL  is  greater than zero.  Note that if KONTRL
	           is greater than zero, then the original content  of
	           VALUE  is  always  destroyed.   In  particular,  if
	           KONTRL is greater than zero and if KIND is returned
	           not equal to 3 then VALUE will be zeroed.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 113
	  DAHEFT, Free Format Numeric Input Routine


	                An Example of the Use of DAHEFT
	                -- ------- -- --- --- -- ------

	  The following sample subroutine reads a requested number  of
	  real  values.  Additional lines are read until the requested
	  number of values has been obtained.  Input  lines  which  do
	  not  contain  numbers  are  ignored.   The  routine does not
	  return to the calling program until the requested number  of
	  items has been read.

	  The arguments of the sample routine are as follow

	  IUNIT  = the number of the input unit from which the  values
	           are to be read.

	  IWANT  = the number of values to be read.

	  VALUE  = the array into which the floating point values  are
	           to be stored.

	        SUBROUTINE READIN(IUNIT,IWANT,VALUE)
	        DIMENSION IBUFFR(100),VALUE(IWANT)
	        IF(IWANT.LE.0)GO TO 4
	        IHAVE=1
	      1 READ(IUNIT,2)IBUFFR
	      2 FORMAT(100A1)
	        LOWBFR=1
	      3 CALL DAHEFT(7,1,0,IBUFFR,100,LOWBFR,KIND,ISHIFT,
	       1JSHIFT,KSHIFT,LSHIFT,IVALUE,VALUE(IHAVE))
	        IF(KIND.EQ.1)GO TO 1
	        IF(KIND.EQ.2)LOWBFR=LOWBFR+1
	        IF(KIND.EQ.3)IHAVE=IHAVE+1
	        IF(IHAVE.LE.IWANT)GO TO 3
	      4 RETURN
	        END



	  Recognition of Leading Exponents and Changing Default Values
	  ----------- -- ------- --------- --- -------- ------- ------

	  In addition to its function of  selecting  whether  trailing
	  percent  signs  and  the  letters  K,  M  and  E  are  to be
	  recognized, ITRAIL can enable the recognition  of  exponents
	  which  are  not  preceded  by  value specifications, and can
	  change the default value used when no value is specified  to
	  be  one rather than zero.  ITRAIL values of -1, 0 and 1 have
	  been described previously, and  enable  the  recognition  of
	  trailing  E's,  of  no  exponents  whatever, and of trailing
	  exponents of all sorts, respectively.  ITRAIL values of  -3,
	  -2,  2  and  3  as  described  below  allow  exponents to be
	  recognized even if not preceded by a sign, decimal point  or
	  digit.  The value zero is always returned by this routine if
	  no value digits are encountered and ITRAIL is in  the  range
	  FASP, FORTRAN Alphameric Subroutine Package         Page 114
	  DAHEFT, Free Format Numeric Input Routine


	  -3  through 3 (or in the range 7 through 13).  ITRAIL values
	  of -2 and 2 will allow the evaluation  of  either  a  number
	  possibly  containing  a trailing exponent, or of an exponent
	  appearing by itself without a leading value  representation.
	  ITRAIL  values  -3  and  3  accept  only an exponent without
	  leading value representation.  If ITRAIL has either  of  the
	  values  -3 or 3 and a leading sign or digit or decimal point
	  is encountered,  then  KIND  is  returned  containing  2  to
	  indicate an unknown character.

	  ITRAIL = -3,  only  exponents  specified  as  the  letter  E
	           followed  by  a  possibly  signed  number are to be
	           recognized.  Leading sign, digits or decimal  point
	           are   not   allowed.   The  value  zero  is  always
	           returned.
	         = -2, same as ITRAIL=-1,  except  that  in  addition,
	           leading   exponents   specified  as  the  letter  E
	           followed by possible signed  numbers  are  allowed.
	           The value zero is returned if the letter E is found
	           not preceded by any value digits.
	         = 2,  same  as  ITRAIL=1,  except  that  in  addition
	           leading exponents specified by percent signs or the
	           letters K or M, and leading exponents specified  as
	           the  letter  E followed by a possibly signed number
	           are allowed.  The value zero  is  returned  if  the
	           percent  sign  or  the  letters  K,  M or E are not
	           preceded by any value digits.
	         = 3, only exponents specified as the percent sign  or
	           the  letters  K  or M, or specified as the letter E
	           followed by a possible  signed  number  are  to  be
	           recognized.   Leading sign, digits or decimal point
	           are  not  allowed.   The  value  zero   is   always
	           returned.

	  ITRAIL values of -13 through -7 evaluate the same  sequences
	  of characters as ITRAIL values of -3 through 3 respectively,
	  except that if no value digits are found for  ITRAIL  values
	  of  -13  through  -7,  then  the  value is assumed to be one
	  rather than zero before this value is negated and/or shifted
	  by  the  amount  indicated by the exponent if necessary, and
	  except that if the letter E is found but not followed by any
	  digits,  then  the  single  exponent  digit  1  is similarly
	  assumed.  For ITRAIL values of -9, -8 or -7 (1-10, 2-10  and
	  3-10  respectively),  the  number representation -K would be
	  equivalent to -1K having the value -1000, and  -E  would  be
	  the same as -1E1 having the value -10.

	  ITRAIL values of 7 through 13 evaluate the same sequences of
	  characters  as  ITRAIL  values of -3 through 3 respectively,
	  except that the ITRAIL values of 7  through  13  return  the
	  evaluated  number  as  though  neither  an  exponent nor the
	  decimal point had been included, although  the  location  of
	  the  decimal  point  and  the  value  of  the  exponent  are
	  identified to the calling program.  The returned value  will
	  FASP, FORTRAN Alphameric Subroutine Package         Page 115
	  DAHEFT, Free Format Numeric Input Routine


	  have  been  multiplied  by  the  radix  raised  to the power
	  indicated by IEXTRA.  ITRAIL being set to 9  (-1+10)  would,
	  for  example,  allow  an E exponent in the number, but would
	  return the value as  though  neither  exponent  nor  decimal
	  point had been found.  Since neither ITRAIL values of -3 nor
	  3 allow a leading number anyway, ITRAIL=-3 is equivalent  to
	  ITRAIL=7,  and  ITRAIL=3 is equivalent to ITRAIL=13.  If any
	  of the values of 7 through 13 are used for ITRAIL, then  the
	  value  indicated  by  the  full combination of value digits,
	  decimal point and/or exponent  can  be  obtained  as  either
	  VALUE*radix**KSHIFT or IVALUE*radix**KSHIFT (where the radix
	  is 8 if  KONTRL  is  -1  and  10  otherwise,  and  where  **
	  indicates  exponentiation),  whichever  is appropriate.  The
	  value indicated by  the  digits  and/or  decimal  point  but
	  ignoring  the  exponent  can similarly be obtained as either
	  VALUE*radix**(KSHIFT-JSHIFT)                              or
	  IVALUE*radix**(KSHIFT-JSHIFT).

	  The table below presents the values which would be  returned
	  when  the  number  representations  shown  along the top are
	  evaluated using the ITRAIL values appearing along  the  left
	  edge.  Blank entries in the table indicate that some portion
	  of the representation  could  not  be  evaluated  using  the
	  corresponding  value  of ITRAIL.  For example, ITRAIL=0 does
	  not allow the recognition of any exponents so, although  the
	  number  representation 1.23K would be evaluated for ITRAIL=0
	  as the number 1.23 followed by the unknown character K,  the
	  entry for this is left out of the table.

	       1.23 12.3 1.23K 1.23E3 1.23E 1.23E-  E2   E  E-  -E -E-
	       -------------------------------------------------------
	  -13                                      100  10  .1
	  -12  1.23 12.3         1230  12.3   .123 100  10  .1 -10 -.1
	  -11  1.23 12.3         1230  12.3   .123             -10 -.1
	  -10  1.23 12.3
	   -9  1.23 12.3  1230   1230  12.3   .123             -10 -.1
	   -8  1.23 12.3  1230   1230  12.3   .123 100  10  .1 -10 -.1
	   -7                                      100  10  .1
	       -------------------------------------------------------
	   -3                                        0   0   0
	   -2  1.23 12.3         1230  1.23   1.23   0   0   0   0   0
	   -1  1.23 12.3         1230  1.23   1.23               0   0
	    0  1.23 12.3
	    1  1.23 12.3  1230   1230  1.23   1.23               0   0
	    2  1.23 12.3  1230   1230  1.23   1.23   0   0   0   0   0
	    3                                        0   0   0
	       -------------------------------------------------------
	    7                                        0   0   0
	    8   123  123          123   123    123   0   0   0   0   0
	    9   123  123          123   123    123               0   0
	   10   123  123
	   11   123  123   123    123   123    123               0   0
	   12   123  123   123    123   123    123   0   0   0   0   0
	   13                                        0   0   0
	  FASP, FORTRAN Alphameric Subroutine Package         Page 116
	  DAHEFT, Free Format Numeric Input Routine


	  DAMISS, Extends DAHEFT to Allow Comments and Missing Numbers
	  ------  ------- ------ -- ----- -------- --- ------- -------

	  If the first printing character found by DAHEFT in the  line
	  of  input  text  is  not  a  digit, minus sign, plus sign or
	  period  (and  cannot  begin  an  exponent  specification  if
	  ITRAIL= has a value other than -11, -10, -9, -1, 0, 1, 9, 10
	  or 11), then the  character  is  considered  to  be  unknown
	  causing DAHEFT to return control to the calling program.  In
	  particular,  DAHEFT  does  not  recognize  the   punctuation
	  characters  allowed  by  many  of  the other routines in the
	  FORTRAN Alphameric  Subroutine  Package.   DAMISS,  a  short
	  subroutine  which  calls upon DAHEFT for numeric evaluation,
	  allows commas  between  numbers,  identifies  missing  items
	  indicated  by  extra commas, skips over any text which is to
	  the right of either an exclamation point  or  an  ampersand,
	  and   reports   any  semicolons  found  in  the  text  being
	  evaluated.  Although DAMISS  checks  the  character  to  the
	  right  of the number to insure that this character is one of
	  the allowed punctuation marks or else is either a space or a
	  tab  character,  the  finding of some other character to the
	  right of the number might not actually be an error since the
	  number  might be evaluated again by a routine such as DASPAN
	  or DATREK which allow additional characters to continue  the
	  representation.

	  The argument list of routine DAMISS is

	        SUBROUTINE DAMISS(KONTRL,ITRAIL,IEXTRA,IBUFFR,MAXBFR,
	       1    LOWBFR,KIND  ,ISHIFT,JSHIFT,KSHIFT,LSHIFT,IVALUE,
	       2    VALUE ,MANY  ,LCNBFR,LCNERR)

	  with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR)

	  The argument lists of DAMISS and DAHEFT are identical except
	  for  the  DAMISS  arguments MANY, LCNBFR and LCNERR which do
	  not appear in the DAHEFT  argument  list,  and  except  that
	  DAMISS  can  return  the  argument named KIND containing the
	  additional values 4, 5, 6 and 7.  The  argument  named  MANY
	  must  be  set  to zero by the calling program before calling
	  either this routine or any of the other routines in the FASP
	  package  (such  as  DANEXT,  DASPAN and DALOSS) which define
	  this argument in a  similar  manner.   The  arguments  named
	  KIND,  LCNBFR  and  LCNERR  are  used only for output to the
	  calling program and their input values are  ignored.   These
	  arguments  are described below.  The documentation of DAHEFT
	  should  be  consulted  for  descriptions  of  the  remaining
	  arguments.

	  KIND   = 1, nothing, except perhaps a comment indicated by a
	           leading  exclamation  point, was found at or to the
	           right  of  IBUFFR(LOWBFR).   The  calling   program
	  FASP, FORTRAN Alphameric Subroutine Package         Page 117
	  DAHEFT, Free Format Numeric Input Routine


	           should read a new line into the IBUFFR array before
	           again calling this routine if additional values are
	           required.   LOWBFR  is returned pointing beyond the
	           end of the buffer.  MANY is returned set  to  zero.
	           IVALUE and VALUE are returned undefined.
	         = 2, the  first  printing  character  (other  than  a
	           possible comma if MANY was input greater than zero)
	           in  or  to  right  of  IBUFFR(LOWBFR)  was  not   a
	           character which could begin the representation of a
	           number and was not a comma, semicolon, ampersand or
	           exclamation  point.  LOWBFR is returned pointing to
	           this printing character.  It is expected  that  the
	           calling   program   will   otherwise  process  this
	           printing character since DAMISS  would  return  the
	           same results if called again with the same value of
	           LOWBFR and with the same buffer contents.  MANY  is
	           returned  containing  one  plus  its input absolute
	           value.  IVALUE and VALUE are returned undefined.
	         = 3, a number was found which  extended  through  the
	           end of the buffer or which was followed by a space,
	           a tab character, a semicolon, an exclamation  point
	           or  an  ampersand.   The  value  of  the  number is
	           returned in either VALUE or  IVALUE,  whichever  is
	           appropriate,  and ISHIFT, JSHIFT, KSHIFT and LSHIFT
	           are returned describing the representation  of  the
	           number.   MANY  is returned containing one plus its
	           input absolute value.  LOWBFR is returned  pointing
	           to  the  character  to  the  right  of  the  number
	           representation.
	         = 4, a number was followed by  a  printing  character
	           other  than  a  comma,  a semicolon, an exclamation
	           point or an ampersand.  The value of the number  is
	           returned  in  either  VALUE or IVALUE, whichever is
	           appropriate, and ISHIFT, JSHIFT, KSHIFT and  LSHIFT
	           are  returned  describing the representation of the
	           number.  LCNBFR is returned pointing in the  buffer
	           to  the  first  character of the number.  LOWBFR is
	           returned pointing in the buffer to the character to
	           the  right  of  the  number.   LCNERR  is  returned
	           pointing in the  buffer  to  the  next  space,  tab
	           character,  comma,  semicolon, exclamation point or
	           ampersand  to  the  right  of  the  number,  or  is
	           returned  pointing  beyond the end of the buffer if
	           no  space,   tab   character,   comma,   semicolon,
	           exclamation  point  or  ampersand  is  found to the
	           right of the number.  MANY is  returned  containing
	           one plus its input absolute value.

	           KIND will be  returned  set  to  4  if  one  number
	           immediately   follows   another  as  in  18-36  (18
	           followed by -36) or in  12.34.56  (which  might  be
	           interpreted   as   12.34   followed  by  .56).   If
	           immediately adjacent numbers  are  to  be  allowed,
	           then  KIND=4  should be considered to be equivalent
	  FASP, FORTRAN Alphameric Subroutine Package         Page 118
	  DAHEFT, Free Format Numeric Input Routine


	           to KIND=3.  If  the  character  in  IBUFFR(LOWBFR),
	           where  LOWBFR is the returned not input value, does
	           not itself start a number, then the subsequent call
	           to DAMISS will return KIND=2.
	         = 5, a semicolon was  found  as  the  first  printing
	           character  at  or  to  the right of IBUFFR(LOWBFR).
	           LOWBFR is returned pointing to the  next  character
	           beyond  the  semicolon.   It  is  assumed  that the
	           calling program will treat the  appearance  of  the
	           semicolon  as marking the end of a statement.  MANY
	           is returned set to  zero.   IVALUE  and  VALUE  are
	           returned undefined.
	         = 6, an ampersand was found  as  the  first  printing
	           character  at  or to the right of LOWBFR.  The text
	           to the right of the ampersand is taken as a comment
	           so LOWBFR is returned pointing beyond the right end
	           of the buffer.  It  is  assumed  that  the  calling
	           program  will read in the contents of a new buffer,
	           then again request a  new  number  evaluation  from
	           this  routine.   The  value  of  MANY  must  not be
	           changed  by  the  calling  program  prior  to  this
	           following  call.   The effect is not quite the same
	           as if the user had typed  all  of  the  text  on  a
	           single  line  since a single number cannot be split
	           across a  line  boundary.   IVALUE  and  VALUE  are
	           returned undefined.
	         = 7, a number was not found, but an extra  comma  was
	           found   indicating   a  missing  number.   MANY  is
	           returned containing one  plus  its  input  absolute
	           value.   IVALUE or VALUE, whichever is appropriate,
	           is returned set to zero.   ISHIFT,  JSHIFT,  KSHIFT
	           and LSHIFT are returned undefined.

	  MANY   = should be input  containing  zero  each  time  this
	           routine  is  called  to  begin  processing of a new
	           logical  section  of  text,  as  for  example  when
	           beginning  processing of a line of text not tied to
	           the previous line by an ampersand at the end of the
	           previous  line,  or when processing the text to the
	           right of a semicolon.  The initial zeroing of  this
	           argument  must  be done by the calling program, but
	           thereafter the value returned by the previous  call
	           to  this  routine  can  usually  be  used.  MANY is
	           returned set to zero each time a semicolon (KIND=5)
	           is  found, and each time an end of line not tied to
	           the following line  by  an  ampersand  (KIND=1)  is
	           found.   MANY  is  returned containing one plus its
	           input absolute value each time a number  is  found,
	           each  time  an  unknown character is found, or each
	           time an indication of a missing  number  is  found.
	           KIND is returned containing the value 6 and MANY is
	           returned containing the negative of the  number  of
	           items   found   if   the  next  printing  character
	           following a comma is an ampersand.  MANY should not
	  FASP, FORTRAN Alphameric Subroutine Package         Page 119
	  DAHEFT, Free Format Numeric Input Routine


	           be  changed  by the calling program if an ampersand
	           (KIND being returned=6) is  found  indicating  that
	           the  subsequent  call to this routine is to process
	           text which is to be treated as though  it  appeared
	           in place of the ampersand and the characters to its
	           right.  The effect is not quite the same as if  the
	           user  had  typed  all  of the text on a single line
	           since a single number cannot be  split  across  the
	           line boundary.

	           If MANY is input containing zero, then  an  initial
	           comma in the input text buffer is taken to indicate
	           an initial missing item, and MANY is then  returned
	           containing  1.  If MANY is input greater than zero,
	           then an initial comma is ignored if followed  by  a
	           number.   If  MANY is input greater than zero, then
	           an initial comma  followed  by  no  other  printing
	           characters,  by  a  semicolon, or by an exclamation
	           point indicates a missing item.  If MANY  is  input
	           greater  than  zero, then an initial comma followed
	           by an ampersand will cause the remaining characters
	           in  the  buffer  to  be  ignored,  and MANY will be
	           returned  containing  the  negative  of  its  input
	           value.   If  MANY  is  input  negative,  then it is
	           assumed that the contents  of  the  current  buffer
	           continue  a  previous  line which terminated with a
	           comma  followed  by  an  ampersand,  and  MANY   is
	           returned greater than zero.

	  LCNBFR = if a number representation  is  found,  KIND  being
	           returned  containing  either 3 or 4, then LCNBFR is
	           returned containing the  subscript  of  the  IBUFFR
	           array  location which contains the first (leftmost)
	           character of the number representation.

	           If the first printing character at or to the  right
	           of  IBUFFR(LOWBFR) cannot begin a number and is not
	           one of the allowed punctuation marks so  that  KIND
	           is  returned  containing  2, then LCNBFR and LOWBFR
	           are  both  returned  pointing  to  the   unexpected
	           character  and  LCNERR  is returned pointing to the
	           following space, tab character,  comma,  semicolon,
	           exclamation point or ampersand.

	  LCNERR = if a number representation  is  found,  KIND  being
	           returned  containing  either 3 or 4, then LCNERR is
	           returned containing the  subscript  of  the  IBUFFR
	           array  location  which contains the next space, tab
	           character, comma, semicolon, exclamation  point  or
	           ampersand to the right of the number representation
	           or else LCNERR is returned containing  MAXBFR+1  if
	           none  of  these  characters  appear anywhere to the
	           right of the number  representation.   If  KIND  is
	           returned  containing  3, then LCNERR and LOWBFR are
	  FASP, FORTRAN Alphameric Subroutine Package         Page 120
	  DAHEFT, Free Format Numeric Input Routine


	           both returned pointing  to  the  character  to  the
	           immediate  right  of the number representation.  If
	           KIND is  returned  containing  4,  then  LOWBFR  is
	           returned   pointing   to  the  unexpected  printing
	           character to the  immediate  right  of  the  number
	           representation.

	           If KIND is returned containing 2, indicating that a
	           printing  character  which could not begin a number
	           and which was not one of  the  allowed  punctuation
	           marks  was  found, then LCNERR is returned pointing
	           to the next space, tab character, comma, semicolon,
	           exclamation  point  or ampersand, or else LCNERR is
	           returned  containing  MAXBFR+1  if  none  of  these
	           characters  appear  anywhere  to  the  right of the
	           initial unexpected character.


	       Demonstration Program to Interactively Test DAHEFT
	       ------------- ------- -- ------------- ---- ------

	  The program listed on the following pages accepts a line  of
	  text  from  the user, then reports each value encountered in
	  the text for all requested values of ITRAIL,  together  with
	  the  portion of the text which has just been evaluated.  The
	  values of ITRAIL which give  identical  results  are  listed
	  together  in  parentheses to the right of the returned value
	  or to the right of the EMPTY (KIND=1)  or  UNKNOWN  (KIND=2)
	  condition  descriptions.   If  a  number  has been evaluated
	  (KIND=3), then the values  of  ISHIFT,  JSHIFT,  KSHIFT  and
	  LSHIFT  are also reported to the right of the ITRAIL values.
	  The typing  of  a  completely  empty  line  allows  the  the
	  respecification of whether DAHEFT or DAIHFT is being tested,
	  of the values of the arguments KONTRL  and  IEXTRA,  and  of
	  another group of values of ITRAIL to be tested.

	  C     PROGRAM TO DEMONSTRATE DAHEFT AND DAIHFT ROUTINES
	        DIMENSION IBUFFR(58),JBUFFR(72),LOCATE(20),NEEDED(20),
	       1          KNDSAV(20),ISHSAV(20),JSHSAV(20),KSHSAV(20),
	       2          LSHSAV(20),VALSAV(20),IVASAV(20), IDENT(20),
	       3           ITEST(20),IEMPTY( 5),IUNKNO( 8)
	        DATA ILEFT,IRIGHT,ILESS,IGREAT,IYES,IBLANK/
	       11H(,1H),1H<,1H>,1HY,1H /
	        DATA IEMPTY/1HE,1HM,1HP,1HT,1HY/
	        DATA IUNKNO/1HU,1HN,1HK,1HN,1HO,1HW,1HN,1H /
	        DATA ITTY,JTTY/5,5/
	  C
	  C     MAXBFR = NUMBER OF LOCATIONS IN IBUFFR
	  C     MAXSHO = NUMBER OF LOCATIONS IN JBUFFR
	  C     LIMIT  = MAXIMUM NUMBER OF ITRAIL VALUES TO TEST
	        DATA MAXBFR,MAXSHO,LIMIT/58,72,20/
	  C
	  C     GET VALUES OF KONTRL AND IEXTRA
	      1 WRITE(JTTY,2)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 121
	  DAHEFT, Free Format Numeric Input Routine


	      2 FORMAT(22H TEST DAIHFT (Y OR N) ,$)
	        READ(ITTY,3)IANS
	      3 FORMAT(1A1)
	        WRITE(JTTY,4)
	      4 FORMAT(15H KONTRL,IEXTRA ,$)
	        READ(ITTY,5)KONTRL,IEXTRA
	      5 FORMAT(3I)
	        IWHICH=KONTRL
	        IF(IANS.EQ.IYES)IWHICH=0
	        WRITE(JTTY,6)
	      6 FORMAT(26H TEST WHICH ITRAIL VALUES ,$)
	        READ(ITTY,7)ITEST
	      7 FORMAT(20I)
	        MAXTRL=LIMIT
	      8 IF(ITEST(MAXTRL).NE.0)GO TO 10
	        MAXTRL=MAXTRL-1
	        IF(MAXTRL.GT.0)GO TO 8
	        GO TO 1
	  C
	  C     GET NEXT TEXT BUFFER TO BE EVALUATED
	      9 IF(INITAL.EQ.1)GO TO 1
	     10 WRITE(JTTY,11)
	     11 FORMAT(2H *,$)
	        READ(ITTY,12)IBUFFR
	     12 FORMAT(72A1)
	        DO 13 I=1,MAXTRL
	     13 LOCATE(I)=1
	        INITAL=1
	        GO TO 19
	  C
	  C     GET NEXT ITEM IN TEXT BUFFER AND STORE DESCRIPTION
	     14 IF(LOWBFR.GT.MAXBFR)GO TO 9
	        INITAL=LOWBFR
	     15 ITRAIL=ITEST(JTRAIL)
	        IF(IANS.EQ.IYES)GO TO 16
	        CALL DAHEFT(KONTRL,ITRAIL,IEXTRA,IBUFFR,MAXBFR,
	       1LOWBFR,KIND,ISHIFT,JSHIFT,KSHIFT,LSHIFT,IVALUE,
	       2VALUE)
	        GO TO 17
	     16 CALL DAIHFT(KONTRL,ITRAIL,IEXTRA,IBUFFR,MAXBFR,
	       1LOWBFR,KIND,ISHIFT,JSHIFT,KSHIFT,LSHIFT,IVALUE)
	     17 IF(KIND.EQ.2)LOWBFR=LOWBFR+1
	        LOCATE(JTRAIL)=LOWBFR
	        NEEDED(JTRAIL)=1
	        KNDSAV(JTRAIL)=KIND
	        IF(KIND.NE.3)GO TO 19
	        ISHSAV(JTRAIL)=ISHIFT
	        JSHSAV(JTRAIL)=JSHIFT
	        KSHSAV(JTRAIL)=KSHIFT
	        LSHSAV(JTRAIL)=LSHIFT
	        IF(IWHICH.LE.0)GO TO 18
	        VALSAV(JTRAIL)=VALUE
	        GO TO 19
	     18 IVASAV(JTRAIL)=IVALUE
	  FASP, FORTRAN Alphameric Subroutine Package         Page 122
	  DAHEFT, Free Format Numeric Input Routine


	  C
	  C     SEARCH FOR NEXT VALUE OF ITRAIL TO BE USED
	     19 LOWBFR=MAXBFR+1
	        DO 20 I=1,MAXTRL
	        IF(LOWBFR.LE.LOCATE(I))GO TO 20
	        LOWBFR=LOCATE(I)
	        JTRAIL=I
	     20 CONTINUE
	        IF(INITAL.EQ.LOWBFR)GO TO 15
	  C
	  C     REPORT RESULTS IF ALL VALUES OF ITRAIL DONE
	        ISEEN=INITAL-1
	     21 LEAST=MAXBFR+1
	        DO 22 I=1,MAXTRL
	        IF(NEEDED(I).EQ.0)GO TO 22
	        IF(LEAST.LT.LOCATE(I))GO TO 22
	        LEAST=LOCATE(I)-1
	        INDEX=I
	     22 CONTINUE
	        IF(LEAST.GT.MAXBFR)GO TO 14
	        NEEDED(INDEX)=0
	        ISAME=1
	        IDENT(1)=ITEST(INDEX)
	        DO 25 I=INDEX,MAXTRL
	        IF(NEEDED(I).EQ.0)GO TO 25
	        IF(KNDSAV(INDEX).NE.KNDSAV(I))GO TO 25
	        IF(KNDSAV(INDEX).NE.3)GO TO 24
	        IF(ISHSAV(INDEX).NE.ISHSAV(I))GO TO 25
	        IF(JSHSAV(INDEX).NE.JSHSAV(I))GO TO 25
	        IF(KSHSAV(INDEX).NE.KSHSAV(I))GO TO 25
	        IF(LSHSAV(INDEX).NE.LSHSAV(I))GO TO 25
	        IF(IWHICH.LE.0)GO TO 23
	        IF(VALSAV(INDEX).NE.VALSAV(I))GO TO 25
	        GO TO 24
	     23 IF(IVASAV(INDEX).NE.IVASAV(I))GO TO 25
	     24 ISAME=ISAME+1
	        IDENT(ISAME)=ITEST(I)
	        NEEDED(I)=0
	     25 CONTINUE
	  C
	  C     DISPLAY EVALUATED TEXT
	        IF(ISEEN.EQ.LEAST)GO TO 30
	        NOWSHO=0
	     26 NOWSHO=NOWSHO+1
	        IF(NOWSHO.GE.INITAL)GO TO 27
	        JBUFFR(NOWSHO)=IBLANK
	        GO TO 26
	     27 JBUFFR(NOWSHO)=ILESS
	        DO 28 I=INITAL,LEAST
	        NOWSHO=NOWSHO+1
	     28 JBUFFR(NOWSHO)=IBUFFR(I)
	        NOWSHO=NOWSHO+1
	        JBUFFR(NOWSHO)=IGREAT
	        WRITE(JTTY,29)(JBUFFR(I),I=1,NOWSHO)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 123
	  DAHEFT, Free Format Numeric Input Routine


	     29 FORMAT(1X,100A1)
	        ISEEN=LEAST
	  C
	  C     REPORT ALL VALUES OF ITRAIL WHICH GIVE SAME RESULTS
	     30 NOWSHO=0
	        KIND=KNDSAV(INDEX)
	        GO TO(31,33,35),KIND
	     31 DO 32 I=1,5
	        NOWSHO=NOWSHO+1
	     32 JBUFFR(NOWSHO)=IEMPTY(I)
	        GO TO 36
	     33 DO 34 I=1,8
	        NOWSHO=NOWSHO+1
	     34 JBUFFR(NOWSHO)=IUNKNO(I)
	        NOWSHO=NOWSHO+1
	        I=LOCATE(INDEX)-1
	        JBUFFR(NOWSHO)=IBUFFR(I)
	        GO TO 36
	     35 CALL DASHOW(IWHICH,0,6,6,6,5,
	       1IVASAV(INDEX),VALSAV(INDEX),MAXSHO,NOWSHO,JBUFFR,IERR)
	     36 NOWSHO=NOWSHO+1
	        IF(NOWSHO.GE.12)GO TO 37
	        JBUFFR(NOWSHO)=IBLANK
	        GO TO 36
	     37 JBUFFR(NOWSHO)=ILEFT
	        J=NOWSHO
	        DO 38 I=1,ISAME
	        CALL DANUMB(0,IDENT(I),10,JBUFFR,NOWSHO,J,MAXSHO)
	     38 CONTINUE
	        NOWSHO=NOWSHO+1
	        JBUFFR(NOWSHO)=IRIGHT
	        IF(KIND.NE.3)GO TO 39
	        CALL DANUMB(0,ISHSAV(INDEX),10,JBUFFR,NOWSHO,0,MAXSHO)
	        CALL DANUMB(0,JSHSAV(INDEX),10,JBUFFR,NOWSHO,0,MAXSHO)
	        CALL DANUMB(0,KSHSAV(INDEX),10,JBUFFR,NOWSHO,0,MAXSHO)
	        CALL DANUMB(0,LSHSAV(INDEX),10,JBUFFR,NOWSHO,0,MAXSHO)
	     39 WRITE(JTTY,40)(JBUFFR(I),I=1,NOWSHO)
	     40 FORMAT(2X,72A1)
	        GO TO 21
	        END


	  Typical Dialog Between DAHEFT Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  TEST DAIHFT (Y OR N) N
	  KONTRL,IEXTRA 1
	  TEST WHICH ITRAIL VALUES -11 -10 -9 -2 -1 0 1 2 9 10 11
	  *12.34E-4 .1234 12.34 1234 12.34E4
	  <12.34>
	   12.34      (-10 0) 0 0 -2 4
	   1234       (10) 0 0 -2 4
	  <12.34E-4>
	   1.234E-3   (-11 -9 -2 -1 1 2) -1 -4 -6 4
	  FASP, FORTRAN Alphameric Subroutine Package         Page 124
	  DAHEFT, Free Format Numeric Input Routine


	   1234       (9 11) -1 -4 -6 4
	       <E>
	   UNKNOWN E  (-10 0 10)
	        <-4>
	   -4         (-10 0 10) 0 0 0 1
	          < .1234>
	   .1234      (-11 -10 -9 -2 -1 0 1 2) 0 0 -4 4
	   1234       (9 10 11) 0 0 -4 4
	                < 12.34>
	   12.34      (-11 -10 -9 -2 -1 0 1 2) 0 0 -2 4
	   1234       (9 10 11) 0 0 -2 4
	                      < 1234>
	   1234       (-11 -10 -9 -2 -1 0 1 2 9 10 11) 0 0 0 4
	                           < 12.34>
	   12.34      (-10 0) 0 0 -2 4
	   1234       (10) 0 0 -2 4
	                           < 12.34E4>
	   123400     (-11 -9 -2 -1 1 2) -1 4 2 4
	   1234       (9 11) -1 4 2 4
	                                 <E>
	   UNKNOWN E  (-10 0 10)
	                                  <4>
	   4          (-10 0 10) 0 0 0 1
	                                   <                         >
	   EMPTY      (-11 -10 -9 -2 -1 0 1 2 9 10 11)
	  *-18.3K -18.3M -18.3%
	  <-18.3>
	   -18.3      (-11 -10 -2 -1 0) 0 0 -1 3
	   -183       (9 10) 0 0 -1 3
	  <-18.3K>
	   -18300     (-9 1 2) 2 3 2 3
	   -183       (11) 2 3 2 3
	       <K>
	   UNKNOWN K  (-11 -10 -2 -1 0 9 10)
	        < -18.3>
	   -18.3      (-11 -10 -2 -1 0) 0 0 -1 3
	   -183       (9 10) 0 0 -1 3
	        < -18.3M>
	   -1.83E7    (-9 1 2) 3 6 5 3
	   -183       (11) 3 6 5 3
	              <M>
	   UNKNOWN M  (-11 -10 -2 -1 0 9 10)
	               < -18.3>
	   -18.3      (-11 -10 -2 -1 0) 0 0 -1 3
	   -183       (9 10) 0 0 -1 3
	               < -18.3%>
	   -.183      (-9 1 2) 1 -2 -3 3
	   -183       (11) 1 -2 -3 3
	                     <%>
	   UNKNOWN %  (-11 -10 -2 -1 0 9 10)
	                      <                                      >
	   EMPTY      (-11 -10 -9 -2 -1 0 1 2 9 10 11)
	  *
	  <                                                          >
	  FASP, FORTRAN Alphameric Subroutine Package         Page 125
	  DAHEFT, Free Format Numeric Input Routine


	   EMPTY      (-11 -10 -9 -2 -1 0 1 2 9 10 11)
	  TEST DAIHFT (Y OR N) N
	  KONTRL,IEXTRA 6
	  TEST WHICH ITRAIL VALUES -11 -10 -9 -2 -1 0 1 2 9 10 11
	  *12.34E-4 .1234 12.34 1234 12.34E4
	  <12.34>
	   12.34      (-10 0) 0 0 -2 4
	   1234       (10) 0 0 -2 4
	  <12.34E-4>
	   1.234E-3   (-11 -9 -2 -1 1 2) -1 -4 -6 4
	   1234       (9 11) -1 -4 -6 4
	       <E>
	   UNKNOWN E  (-10 0 10)
	        <-4>
	   -4         (-10 0 10) 0 0 0 1
	          < .1234>
	   .1234      (-11 -10 -9 -2 -1 0 1 2) 0 0 -4 4
	   1234       (9 10 11) 0 0 -4 4
	                < 12.34>
	   12.34      (-11 -10 -9 -2 -1 0 1 2) 0 0 -2 4
	   1234       (9 10 11) 0 0 -2 4
	                      < 1234>
	   1234       (-11 -10 -9 -2 -1 0 1 2 9 10 11) 0 0 0 4
	                           < 12.34>
	   12.34      (-10 0) 0 0 -2 4
	   1234       (10) 0 0 -2 4
	                           < 12.34E4>
	   123400     (-11 -9 -2 -1 1 2) -1 4 2 4
	   1234       (9 11) -1 4 2 4
	                                 <E>
	   UNKNOWN E  (-10 0 10)
	                                  <4>
	   4          (-10 0 10) 0 0 0 1
	                                   <                         >
	   EMPTY      (-11 -10 -9 -2 -1 0 1 2 9 10 11)
	  *-18.3K -18.3M -18.3%
	  <-18.3>
	   -18.3      (-11 -10 -2 -1 0) 0 0 -1 3
	   -183       (9 10) 0 0 -1 3
	  <-18.3K>
	   -18300     (-9 1 2) 2 3 2 3
	   -183       (11) 2 3 2 3
	       <K>
	   UNKNOWN K  (-11 -10 -2 -1 0 9 10)
	        < -18.3>
	   -18.3      (-11 -10 -2 -1 0) 0 0 -1 3
	   -183       (9 10) 0 0 -1 3
	        < -18.3M>
	   -1.83E7    (-9 1 2) 3 6 5 3
	   -183       (11) 3 6 5 3
	              <M>
	   UNKNOWN M  (-11 -10 -2 -1 0 9 10)
	               < -18.3>
	   -18.3      (-11 -10 -2 -1 0) 0 0 -1 3
	  FASP, FORTRAN Alphameric Subroutine Package         Page 126
	  DAHEFT, Free Format Numeric Input Routine


	   -183       (9 10) 0 0 -1 3
	               < -18.3%>
	   -.183      (-9 1 2) 1 -2 -3 3
	   -183       (11) 1 -2 -3 3
	                     <%>
	   UNKNOWN %  (-11 -10 -2 -1 0 9 10)
	                      <                                      >
	   EMPTY      (-11 -10 -9 -2 -1 0 1 2 9 10 11)
	  *
	  <                                                          >
	   EMPTY      (-11 -10 -9 -2 -1 0 1 2 9 10 11)
	  TEST DAIHFT (Y OR N) N
	  KONTRL,IEXTRA 0
	  TEST WHICH ITRAIL VALUES -11 -10 -9 -2 -1 0 1 2 9 10 11
	  *12.34E-4 .1234 12.34 1234 12.34E4
	  <12.34>
	   12         (-10 0) 0 0 -2 4
	   1234       (10) 0 0 -2 4
	  <12.34E-4>
	   0          (-11 -9 -2 -1 1 2) -1 -4 -6 4
	   1234       (9 11) -1 -4 -6 4
	       <E>
	   UNKNOWN E  (-10 0 10)
	        <-4>
	   -4         (-10 0 10) 0 0 0 1
	          < .1234>
	   0          (-11 -10 -9 -2 -1 0 1 2) 0 0 -4 4
	   1234       (9 10 11) 0 0 -4 4
	                < 12.34>
	   12         (-11 -10 -9 -2 -1 0 1 2) 0 0 -2 4
	   1234       (9 10 11) 0 0 -2 4
	                      < 1234>
	   1234       (-11 -10 -9 -2 -1 0 1 2 9 10 11) 0 0 0 4
	                           < 12.34>
	   12         (-10 0) 0 0 -2 4
	   1234       (10) 0 0 -2 4
	                           < 12.34E4>
	   123400     (-11 -9 -2 -1 1 2) -1 4 2 4
	   1234       (9 11) -1 4 2 4
	                                 <E>
	   UNKNOWN E  (-10 0 10)
	                                  <4>
	   4          (-10 0 10) 0 0 0 1
	                                   <                         >
	   EMPTY      (-11 -10 -9 -2 -1 0 1 2 9 10 11)
	  *-18.3K -18.3M -18.3%
	  <-18.3>
	   -18        (-11 -10 -2 -1 0) 0 0 -1 3
	   -183       (9 10) 0 0 -1 3
	  <-18.3K>
	   -18300     (-9 1 2) 2 3 2 3
	   -183       (11) 2 3 2 3
	       <K>
	   UNKNOWN K  (-11 -10 -2 -1 0 9 10)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 127
	  DAHEFT, Free Format Numeric Input Routine


	        < -18.3>
	   -18        (-11 -10 -2 -1 0) 0 0 -1 3
	   -183       (9 10) 0 0 -1 3
	        < -18.3M>
	   -18300000  (-9 1 2) 3 6 5 3
	   -183       (11) 3 6 5 3
	              <M>
	   UNKNOWN M  (-11 -10 -2 -1 0 9 10)
	               < -18.3>
	   -18        (-11 -10 -2 -1 0) 0 0 -1 3
	   -183       (9 10) 0 0 -1 3
	               < -18.3%>
	   0          (-9 1 2) 1 -2 -3 3
	   -183       (11) 1 -2 -3 3
	                     <%>
	   UNKNOWN %  (-11 -10 -2 -1 0 9 10)
	                      <                                      >
	   EMPTY      (-11 -10 -9 -2 -1 0 1 2 9 10 11)
	  *
	  <                                                          >
	   EMPTY      (-11 -10 -9 -2 -1 0 1 2 9 10 11)
	  TEST DAIHFT (Y OR N) N
	  KONTRL,IEXTRA 1
	  TEST WHICH ITRAIL VALUES -8 2 12
	  *3.2 3.2E 3.2E+ 3.2E-
	  <3.2>
	   3.2        (-8 2) 0 0 -1 2
	   32         (12) 0 0 -1 2
	     < 3.2E>
	   32         (-8) -4 1 0 2
	   3.2        (2) -4 0 -1 2
	   32         (12) -4 0 -1 2
	          < 3.2E+>
	   32         (-8) -2 1 0 2
	   3.2        (2) -2 0 -1 2
	   32         (12) -2 0 -1 2
	                < 3.2E->
	   .32        (-8) -3 -1 -2 2
	   3.2        (2) -3 0 -1 2
	   32         (12) -3 0 -1 2
	                      <                                      >
	   EMPTY      (-8 2 12)
	  *E3 -E3 +E3 .E3 -.E3 +.E3 K -K +K .K -.K +.K
	  <E3>
	   1000       (-8) -1 3 3 -4
	   0          (2 12) -1 3 3 -4
	    < -E3>
	   -1000      (-8) -1 3 3 -3
	   0          (2 12) -1 3 3 -3
	        < +E3>
	   1000       (-8) -1 3 3 -2
	   0          (2 12) -1 3 3 -2
	            < .E3>
	   1000       (-8) -1 3 3 -1
	  FASP, FORTRAN Alphameric Subroutine Package         Page 128
	  DAHEFT, Free Format Numeric Input Routine


	   0          (2 12) -1 3 3 -1
	                < -.E3>
	   -1000      (-8) -1 3 3 -3
	   0          (2 12) -1 3 3 -3
	                     < +.E3>
	   1000       (-8) -1 3 3 -2
	   0          (2 12) -1 3 3 -2
	                          < K>
	   1000       (-8) 2 3 3 -4
	   0          (2 12) 2 3 3 -4
	                            < -K>
	   -1000      (-8) 2 3 3 -3
	   0          (2 12) 2 3 3 -3
	                               < +K>
	   1000       (-8) 2 3 3 -2
	   0          (2 12) 2 3 3 -2
	                                  < .K>
	   1000       (-8) 2 3 3 -1
	   0          (2 12) 2 3 3 -1
	                                     < -.K>
	   -1000      (-8) 2 3 3 -3
	   0          (2 12) 2 3 3 -3
	                                         < +.K>
	   1000       (-8) 2 3 3 -2
	   0          (2 12) 2 3 3 -2
	                                             <               >
	   EMPTY      (-8 2 12)
	  *- + . -. +. 0 -0 +0 0. .0 0.00 0.00E-4 0.00E4
	  <->
	   -1         (-8) 0 0 0 -3
	   0          (2 12) 0 0 0 -3
	   < +>
	   1          (-8) 0 0 0 -2
	   0          (2 12) 0 0 0 -2
	     < .>
	   1          (-8) 0 0 0 -1
	   0          (2 12) 0 0 0 -1
	       < -.>
	   -1         (-8) 0 0 0 -3
	   0          (2 12) 0 0 0 -3
	          < +.>
	   1          (-8) 0 0 0 -2
	   0          (2 12) 0 0 0 -2
	             < 0>
	   0          (-8 2 12) 0 0 0 0
	               < -0>
	   0          (-8 2 12) 0 0 0 0
	                  < +0>
	   0          (-8 2 12) 0 0 0 0
	                     < 0.>
	   0          (-8 2 12) 0 0 0 0
	                        < .0>
	   0          (-8 2 12) 0 0 -1 0
	                           < 0.00>
	  FASP, FORTRAN Alphameric Subroutine Package         Page 129
	  DAHEFT, Free Format Numeric Input Routine


	   0          (-8 2 12) 0 0 -2 0
	                                < 0.00E-4>
	   0          (-8 2 12) -1 -4 -6 0
	                                        < 0.00E4>
	   0          (-8 2 12) -1 4 2 0
	                                               <             >
	   EMPTY      (-8 2 12)
	  * E -E +E E- E+ -E- -E+ +E- +E+
	  < E>
	   10         (-8) -4 1 1 -4
	   0          (2 12) -4 0 0 -4
	    < -E>
	   -10        (-8) -4 1 1 -3
	   0          (2 12) -4 0 0 -3
	       < +E>
	   10         (-8) -4 1 1 -2
	   0          (2 12) -4 0 0 -2
	          < E->
	   .1         (-8) -3 -1 -1 -4
	   0          (2 12) -3 0 0 -4
	             < E+>
	   10         (-8) -2 1 1 -4
	   0          (2 12) -2 0 0 -4
	                < -E->
	   -.1        (-8) -3 -1 -1 -3
	   0          (2 12) -3 0 0 -3
	                    < -E+>
	   -10        (-8) -2 1 1 -3
	   0          (2 12) -2 0 0 -3
	                        < +E->
	   .1         (-8) -3 -1 -1 -2
	   0          (2 12) -3 0 0 -2
	                            < +E+>
	   10         (-8) -2 1 1 -2
	   0          (2 12) -2 0 0 -2
	                                <                            >
	   EMPTY      (-8 2 12)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 130
	  DAHELP, Determines Number of Leading Question Marks


	   DDDDD          AAA  HH    HH  EEEEEEEE  LL        PPPPPP
	   DD   DD       AAAA  HH    HH  EE        LL        PP    PP
	   DD    DD     AA AA  HH    HH  EE        LL        PP    PP
	   DD    DD    AA  AA  HHHHHHHH  EEEEE     LL        PPPPPP
	   DD    DD   AAAAAAA  HH    HH  EE        LL        PP
	   DD   DD   AA    AA  HH    HH  EE        LL        PP
	   DDDDD    AA     AA  HH    HH  EEEEEEEE  LLLLLLLL  PP


	      DAHELP, Determines Number of Leading Question Marks
	      ------  ---------- ------ -- ------- -------- -----

	  Many interactive programs  interpret  the  appearance  of  a
	  question  mark at the start of the text typed by the user to
	  be a request  by  the  user  for  information.   However,  a
	  question  mark  appearing  within  or  to  the  right  of an
	  intelligible user response should probably  be  treated  the
	  same  as  any  other unknown character.  The routines within
	  the  FASP  package  do  not  have  available  to  them   any
	  information  regarding  the  location  of the text currently
	  being processed  relative  to  the  total  text  within  the
	  buffer.   These  routines  do  not  treat  the question mark
	  differently than any other unknown or  alphabetic  character
	  since  the  interpretation of the question mark depends upon
	  its location relative to the total text  within  the  buffer
	  rather  than upon the location of the question mark relative
	  to the text forming a particular statement  which  might  be
	  delimited by semicolons.

	  Initial question marks can, however, be  identified  by  the
	  DAHELP routine immediately after a new line of text has been
	  read by  the  calling  program.   DAHELP  reports  how  many
	  question  marks  were  found at the start of the buffer, and
	  specifies the  buffer  location  which  contains  the  first
	  printing  character which is not itself a question mark.  If
	  a question mark in not found, then the location of the first
	  printing  character can be supplied to the other routines in
	  the FASP package as the location  in  the  buffer  at  which
	  these  routines  are  to  begin interpretation.  The calling
	  program should issue the appropriate informative message  if
	  the first printing character is found to be a question mark,
	  and then, ignoring the remainder of the current contents  of
	  the  buffer,  should  ask for and accept a new response from
	  the user, again assuring that  this  new  message  does  not
	  itself  begin  with  a  question mark before resuming normal
	  processing.  Either the number of question marks found on  a
	  single  line,  or else the number of consecutive lines found
	  to start with question marks might be  used  to  select  the
	  length of the informative message.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 131
	  DAHELP, Determines Number of Leading Question Marks


	                    The DAHELP Argument List
	                    --- ------ -------- ----

	  The argument list of routine DAHELP is

	        SUBROUTINE DAHELP(IBUFFR,MAXBFR,LOWBFR,IQUERY)

	  with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR)

	  The following arguments are used for input and are  returned
	  unchanged.

	  IBUFFR = input buffer array containing characters  typed  by
	           the user, read by a multiple of an A1 format, which
	           is to  be  searched  for  initial  question  marks.
	           IBUFFR  then  contains  1  character  per  computer
	           storage location.

	  MAXBFR = subscript of the final (rightmost) location in  the
	           IBUFFR  array  which  can  be  searched for initial
	           question marks.

	  The following argument must be set by  the  calling  program
	  before  this routine is called, and then is returned by this
	  routine  describing  the  location  of  the  first  printing
	  character which is not itself a question mark.

	  LOWBFR = input containing the subscript of the IBUFFR  array
	           location   which   contains  the  first  (leftmost)
	           character which must be tested to determine whether
	           it is a question mark.
	         = returned containing the  subscript  of  the  IBUFFR
	           array location which contains the leftmost printing
	           character which is not itself a question  mark,  or
	           returned pointing beyond the end of the buffer (set
	           to MAXBFR+1) if no printing characters  other  than
	           question marks were found in the buffer.

	  The following argument is used for returning the  number  of
	  question  marks  found  to  the  calling program.  Its input
	  value is ignored.

	  IQUERY = 0,  returned  if  the  input  buffer  contained  no
	           printing  characters,  or if no question marks were
	           found before the first printing character which  is
	           not itself a question mark.
	         = greater than zero, IQUERY  is  returned  containing
	           the  number  of  question  marks  which  were found
	           before any other printing characters in the buffer.
	           These   question  marks  can  be  preceded  by,  be
	           separated by, or be followed by  spaces  and/or  by
	           tab characters.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 132
	  DAHEST, Parser for Simple Commands to Interactive Programs


	   DDDDD          AAA  HH    HH  EEEEEEEE    SSSSSS  TTTTTTTT
	   DD   DD       AAAA  HH    HH  EE        SS           TT
	   DD    DD     AA AA  HH    HH  EE        SS           TT
	   DD    DD    AA  AA  HHHHHHHH  EEEEE       SSSS       TT
	   DD    DD   AAAAAAA  HH    HH  EE              SS     TT
	   DD   DD   AA    AA  HH    HH  EE              SS     TT
	   DDDDD    AA     AA  HH    HH  EEEEEEEE  SSSSSS       TT


	   DAHEST, Parser for Simple Commands to Interactive Programs
	   ------  ------ --- ------ -------- -- ----------- --------

	  The main routine of  an  interactive  program  often  merely
	  interrogates  the  user  concerning  the  sequence  in which
	  subroutines  are  to  be  executed.   Providing   that   any
	  subroutine  will  request  relatively few items of data from
	  the  user,  and  that  the  requests  for  this   data   are
	  predictable by the user, then the commands typed by the user
	  can be statements containing command  words  which  identify
	  the subroutines and containing numeric or textual arguments.
	  DAHEST is a FORTRAN subroutine which can be  called  by  the
	  main  program  to identify the command words and to evaluate
	  the arguments in such statements.

	  The following statements are typical of those which  can  be
	  interpreted  by  the  DAHEST routine.  The comments shown to
	  the right of the  statements  are  optional  and  would  not
	  normally  be used unless DAHEST is processing commands which
	  have been read from a file, rather than typed by the user.

	     OPAQUE '=',,'*'   !USE = FOR OUTLINE, * FOR ORIGIN
	     INVISIBLE ,'$'    !REST OF OBJECT WILL SHOW
	     WINDOW 10/30,5/25 !WINDOW COLUMN 10 TO 30, LINE 5 TO 25
	     EXAMINE           !LOOK AT CONTENTS OF WINDOW
	     GROUP 25,12       !GROUP CONTIGUOUS TO COLUMN 25, LINE 12
	     EXAMINE           !LOOK AT WINDOW OUTLINING GROUP
	     MOVE +5,-3        !MOVE GROUP +5 COLUMNS, -3 LINES
	     EXAMINE           !LOOK AT GROUP IN NEW LOCATION

	  If the possible command words have been chosen to start with
	  different  letters  of  the alphabet, then the above example
	  could be reduced to the following single line.

	     O'=',,'*';I,'$';W 10/30,5/25;E;G 25,12;E;M+5,-3;E

	  or, if unnecessary commas are removed or replaced by spaces

	     O'=',,'*';I,'$';W 10/30 5/25;E;G 25 12;E;M+5-3;E

	  Of course, the user probably would not combine statements to
	  the  extent  shown above, since the results of one statement
	  would not be available before the next  is  issued,  causing
	  the interactive nature of the program to be lost.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 133
	  DAHEST, Parser for Simple Commands to Interactive Programs


	  DAHEST interprets an array read by the calling program  with
	  a  multiple  of an A1 format.  The calling program indicates
	  to DAHEST the position in the buffer array of  the  leftmost
	  character  which  has  not yet been evaluated.  DAHEST moves
	  this pointer through  the  buffer  and  returns  it  to  the
	  calling  program  specifying  the  leftmost  character to be
	  evaluated by the next call  to  DAHEST.   After  DAHEST  has
	  finally  indicated that nothing more remains to be processed
	  in the line of text which is contained in the  buffer,  then
	  the calling program must read another line of text, and must
	  reset the pointer to indicate the start of the new  line  of
	  text before DAHEST is called again.

	  The line of  text  which  is  being  evaluated  can  contain
	  several  statements  if  these  statements  are separated by
	  semicolons.  Extra semicolons can be used to indicate  empty
	  statements.   The  text can also contain a comment indicated
	  by an exclamation point to the left of  the  comment.   When
	  DAHEST encounters an exclamation point which is not within a
	  quoted text string (one of the  argument  types),  then  the
	  contents of the buffer to the right of the exclamation point
	  are not evaluated and the pointer is returned indicating the
	  character  beyond  the right end of the buffer.  A statement
	  which is processed by DAHEST cannot be continued across  the
	  end  of a line.  Although many other routines in FASP take a
	  rightmost ampersand to indicate that the  current  statement
	  is  being  continued  on the following line, DAHEST provides
	  not special treatment of the ampersand.

	  A  statement  starts  with  a  command  word  which  can  be
	  abbreviated   providing   that   the   abbreviation  is  not
	  ambiguous.  If the command word typed  by  the  user  is  an
	  exact  match  of  a  word  in the dictionary supplied by the
	  calling program, but is also an  abbreviation  of  a  longer
	  word,  then the shorter word is assumed to be the word which
	  was desired.  For example, if the dictionary  contains  both
	  of  the  words  NO  and NONE, then the single letter N is an
	  ambiguous abbreviation, the letter sequence NO  selects  the
	  word  NO,  and the letter sequence NON is an abbreviation of
	  the word NONE.

	  If the word in the dictionary does not contain a space, then
	  a  space  or  tab  character  typed  by the user following a
	  command word will be assumed to mark the end of the  command
	  word.   If  the word in the dictionary does contain a space,
	  then the portions of the command word to either side of  the
	  space can be abbreviated by the user whether or not the user
	  has typed one or more spaces and/or tab characters  at  this
	  location.   For example, if the dictionary contains the word
	  specification

	     1HN,1HO,1H ,1HL,1HI,1HM,1HI,1HT

	  then this word could be selected by  any  of  the  following
	  FASP, FORTRAN Alphameric Subroutine Package         Page 134
	  DAHEST, Parser for Simple Commands to Interactive Programs


	  letter sequences
	     N, NL, N L, NLI, N LI, NO, NOL, NO L or NO LI
	  in the  input  buffer,  providing  in  each  case  that  the
	  sequence is not ambiguous.

	  The arguments which appear to the right of the command  word
	  can  be  possibly  signed numbers, or alphabetic words to be
	  evaluated by the calling program, or (quoted)  text  strings
	  begun  and  terminated either by the apostrophe character or
	  else by matched parentheses.

	  The signed value of a numeric argument and an indication  of
	  its  sign,  if any, are both returned to the calling program
	  so that the appearance of a plus sign can, if necessary,  be
	  treated  differently  than  the  absence  of  any sign.  For
	  example, an unsigned number might indicate a location upon a
	  positive  coordinate  scale, but a number preceded by a sign
	  might indicate a relative shift or vector.  Numbers  can  be
	  separated  by  slashes  or  by  colons (the 2 characters are
	  equivalent) if they are to be  associated  in  some  manner.
	  Two  such possibly signed numbers separated only by a single
	  slash or by a single colon might indicate  a  range.   Three
	  possibly  signed  numbers  separated  only  by slashes or by
	  colons might be used to indicate the start of a  range,  the
	  increment, and the end of the range.

	  A word appearing as an argument of a command must begin with
	  a character which cannot start a number and which is not one
	  of  the  delimiter  characters  such  as  the   space,   tab
	  character,   slash,  colon,  semicolon,  exclamation  point,
	  comma,  apostrophe  or  parentheses.   Digits   can   appear
	  anywhere  to the right of the leading character of the word,
	  but the other prohibited characters  will,  if  encountered,
	  terminate the word.  DAHEST indicates to the calling program
	  the character locations at which the word begins and ends.

	  Text strings  delimited  by  the  apostrophe  character  can
	  contain  any legal FORTRAN readable characters.  If the text
	  string is to contain the apostrophe  itself,  then  this  is
	  indicated  by  2  successive  appearances  of the apostrophe
	  neither of which is  taken  to  be  the  string  terminator.
	  DAHEST  indicates  to  the  calling  program  the  character
	  locations  at  which  the   text   inside   the   delimiting
	  apostrophes  begins  and  ends.  If the text string contains
	  apostrophes indicated by 2 appearances  of  the  apostrophe,
	  then DAHEST removes the extra apostrophe from the string and
	  moves the position of the rightmost pointer 1  character  to
	  the  left.   If the apostrophe which indicates the right end
	  of the string is missing, then the text string is assumed to
	  extend through the rightmost printing character on the line.

	  The start of a text  string  can  also  be  indicated  by  a
	  leading  left  or  right  parenthesis.   Starting  with  the
	  leading parenthesis, a level count is obtained by  adding  1
	  FASP, FORTRAN Alphameric Subroutine Package         Page 135
	  DAHEST, Parser for Simple Commands to Interactive Programs


	  for  each  left  parenthesis  which  is  not  preceded by an
	  apostrophe, and by subtracting 1 for each right  parenthesis
	  which  is  not  preceded  by an apostrophe.  The text string
	  then continues to the next  parenthesis  which  returns  the
	  parenthetical  level count to zero, or through the rightmost
	  printing character on the line if a closing  parenthesis  is
	  not found.  The text string includes embedded parentheses if
	  these do not return the parenthetical level count  to  zero.
	  If an apostrophe is encountered within the text string, then
	  the apostrophe is retained and both the apostrophe  and  the
	  character to its right are included in the text string.

	  Although DAHEST does  not  reveal  to  the  calling  program
	  whether  the  text  string started to the right of a leading
	  apostrophe or of a left or a right parenthesis, the  calling
	  program can easily determine which of these three characters
	  appears to the immediate left of the contents  of  the  text
	  string.   In  the  application for which DAHEST was written,
	  text strings begun by apostrophes contain characters  to  be
	  handled  in  the  order  encountered,  strings begun by left
	  parentheses contain characters to be included  in  a  class,
	  and strings begun by right parentheses contain characters to
	  be excluded from a class.

	  One, but only one, of the three types of arguments, words or
	  numbers  or  text  strings, can be used more than once as an
	  argument.  If the type of argument which can be repeated  is
	  specified  before  the first argument is found, either being
	  the  same  for  all  commands,  or  else   being   specified
	  separately   in   the  dictionary  for  each  command,  then
	  arguments of the other two types can appear at most once  in
	  the  argument  list.  If the repeatable type is word or text
	  string, then a set of numbers indicating a range  can  still
	  be  supplied.   If the repeatable type is numeric, then more
	  than one set of numbers indicating ranges will be  accepted.
	  Alternatively,  the  type  of argument which can be repeated
	  can be the type of the first argument encountered, in  which
	  case arguments of the other two types are not allowed in the
	  argument list.

	  Any number of spaces and/or tab characters can appear before
	  the  command word and between the command word and its first
	  argument.  Successive arguments can be separated by a single
	  comma  and/or by any number of spaces and/or tab characters.
	  No  separating  characters  are  necessary  if  the  leading
	  character  of  an argument indicates that it cannot continue
	  the preceding command word or preceding argument.  A  single
	  comma appearing between 2 arguments of either the same or of
	  different types merely indicates the separation between  the
	  arguments,  and is entirely equivalent to one or more spaces
	  and/or tab characters.  Two commas,  possibly  separated  by
	  spaces and/or by tab characters, indicate a missing argument
	  of the  repeatable  type.   A  comma  appearing  immediately
	  (except  for  optional spaces and/or tabs) after the command
	  FASP, FORTRAN Alphameric Subroutine Package         Page 136
	  DAHEST, Parser for Simple Commands to Interactive Programs


	  word is taken to indicate that the  first  argument  of  the
	  repeatable type is missing.  For example, in the statements

	     OPAQUE'=',,'*';INVISIBLE,'$'

	  the quoted text character * is the  third  argument  of  the
	  command  word OPAQUE, the second argument being missing, and
	  the quoted text character $ is the second  argument  of  the
	  command word INVISIBLE, the first argument being missing.

	  The arguments of the repeatable type  are  returned  to  the
	  calling  program  in  the  order in which they appear in the
	  statement, and, in particular, the calling program  is  able
	  to  determine  whether  any  are  missing.   No  information
	  regarding ordering between arguments of different  types  is
	  returned  to the calling program.  If the command word FETCH
	  takes both an object name  and  a  pair  of  coordinates  as
	  arguments,  then  the  following  statements  would  all  be
	  equivalent.

	       FETCH HEXAGON,20,44
	       FETCH HEXAGON,20 44
	       FETCH HEXAGON 20,44
	       FETCH HEXAGON 20 44
	       FETCH 20,HEXAGON,44
	       FETCH 20,HEXAGON 44
	       FETCH 20 HEXAGON,44
	       FETCH 20 HEXAGON 44
	       FETCH 20,44,HEXAGON
	       FETCH 20,44 HEXAGON
	       FETCH 20 44,HEXAGON
	       FETCH 20 44 HEXAGON

	  DAHEST can evaluate numeric arguments either as integers  or
	  as real numbers.  The type of numeric evaluation which is to
	  be performed is associated with  the  command  word  at  the
	  start  of  the statement, and is specified by the dictionary
	  containing the descriptions of the possible  command  words.
	  DAHEST  calls  the routine DAHEFT to perform the evaluation,
	  and all numeric variations which are permitted by DAHEFT are
	  recognized  by  DAHEST.  Any number, whether being evaluated
	  as an integer or as a  real  number,  can  be  specified  in
	  floating  point form or in exponent form.  The characters %,
	  K and M are accepted in place of the exponents E-2,  E3  and
	  E6 respectively.

	  If the program which  calls  DAHEST  does  not  require  the
	  evaluation  of  real  numbers  and  does  not otherwise call
	  DAHEFT, and if the specification  of  integers  in  exponent
	  form  is  not  necessary,  then the routine DAIHST should be
	  called  instead  of  DAHEST.   The   2   routines   are   of
	  approximately  the  same  length,  but  DAIHST does not call
	  DAHEFT for numeric evaluation.  Numbers evaluated by  DAIHST
	  must  consist  only  of  digits following the optional sign.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 137
	  DAHEST, Parser for Simple Commands to Interactive Programs


	  DAIHST treats the characters ., %, E, K and M  the  same  as
	  any alphabetic letter.

	  DAIHST was developed as the command scanner for  the  MIRAGE
	  printable  image  sketchpad  program (not yet completed when
	  this  documentation  was  written).   Most  of  the  command
	  statements  shown  above are written in the command language
	  designed for MIRAGE.  DAHEST uses the same logic  as  DAIHST
	  and  was  developed from DAIHST since it was felt that other
	  users would reject the  command  scanner  if  it  could  not
	  evaluate real numbers.


	              the DAHEST and DAIHST Argument Lists
	              --- ------ --- ------ -------- -----

	  The argument lists of routines DAHEST and DAIHST are

	        SUBROUTINE DAHEST(KMDTYP,LSTTYP,NAMLOW,NAMMAX,MRKLOW,
	       1    MRKMAX,NUMLOW,NUMMAX,INTRVL,LOWWRD,MAXWRD,IWORD ,
	       2    LOWKNT,MAXKNT,KNTLTR,LEGAL ,MAXBFR,IBUFFR,LOWBFR,
	       3    KIND  ,KOMAND,LCNWRD,LCNKNT,INIPRT,MIDPRT,LMTPRT,
	       4    NAMKNT,NAMLFT,NAMRIT,MRKKNT,MRKLFT,MRKRIT,NUMKNT,
	       5    NUMSIN,NUMVAL,VALNUM,IFLOAT)

	  with the associated DIMENSION statement

	        DIMENSION      IWORD (MAXWRD),KNTLTR(MAXKNT),
	       1LEGAL (MAXKNT),IBUFFR(MAXBFR),NAMLFT(NAMMAX),
	       2NAMRIT(NAMMAX),MRKLFT(MRKMAX),MRKRIT(MRKMAX),
	       3NUMSIN(NUMMAX),NUMVAL(NUMMAX),VALNUM(NUMMAX)

	  and

	        SUBROUTINE DAIHST(KMDTYP,LSTTYP,NAMLOW,NAMMAX,MRKLOW,
	       1    MRKMAX,NUMLOW,NUMMAX,INTRVL,LOWWRD,MAXWRD,IWORD ,
	       2    LOWKNT,MAXKNT,KNTLTR,LEGAL ,MAXBFR,IBUFFR,LOWBFR,
	       3    KIND  ,KOMAND,LCNWRD,LCNKNT,INIPRT,MIDPRT,LMTPRT,
	       4    NAMKNT,NAMLFT,NAMRIT,MRKKNT,MRKLFT,MRKRIT,NUMKNT,
	       5    NUMSIN,NUMVAL)

	  with the associated DIMENSION statement

	        DIMENSION      IWORD (MAXWRD),KNTLTR(MAXKNT),
	       1LEGAL (MAXKNT),IBUFFR(MAXBFR),NAMLFT(NAMMAX),
	       2NAMRIT(NAMMAX),MRKLFT(MRKMAX),MRKRIT(MRKMAX),
	       3NUMSIN(NUMMAX),NUMVAL(NUMMAX)

	  The ordering of the arguments is the same for both routines,
	  but  the  last 2 arguments of DAHEST are not included in the
	  DAIHST argument list.  The  argument  definitions  are  also
	  identical,  with  the  exception  that those argument values
	  which request evaluation of  numbers  as  real  numbers  for
	  DAHEST instead produce evaluation as integers for DAIHST.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 138
	  DAHEST, Parser for Simple Commands to Interactive Programs


	  The following arguments are used for  input  only,  and  are
	  returned unchanged.

	  KMDTYP = specifies  whether  a  command  word   is   to   be
	           recognized  at  the start of the statement.  KMDTYP
	           equal to 1 or 2 specifies  that  a  leading  number
	           encountered  in  place  of  a command word is to be
	           treated specially.  KMDTYP  equal  to  2  indicates
	           that  such a leading number is to be evaluated as a
	           real number, and for routine DAIHST this  value  of
	           KMDTYP is exactly equivalent to the value 1.
	         = -1, a command word is not to be recognized  at  the
	           start  of  the  statement.   The  contents  of  the
	           statement are to be evaluated as an  argument  list
	           of  the  type indicated by the value of LSTTYP.  If
	           LSTTYP also has the value -1 and if an argument  is
	           found, then KIND will be returned containing one of
	           the values 7, 8, 9 or 10, depending upon  the  type
	           of argument.
	         = 0, the statement must start with  a  known  command
	           word.   If  a  known  command  word  does begin the
	           statement, then KIND  will  be  returned  with  the
	           value  3 if there is no error in the argument list,
	           or with one of the values 7, 8, 9 or 10 if an error
	           is found in the argument list.

	           If the line of text contains no printing characters
	           or contains merely an exclamation point followed by
	           a comment, or if the line of text contains an extra
	           semicolon,  then  KIND  will  be  returned with the
	           value 2 indicating an empty statement.

	           If the statement  starts  with  a  number,  a  text
	           string, a comma, a slash or a colon, then KIND will
	           be returned containing the value 5  to  indicate  a
	           missing command word.

	           If the  statement  does  not  start  with  a  known
	           command  word,  and if the first printing character
	           in the statement  is  not  one  of  the  characters
	           exclamation  point,  semicolon,  apostrophe, comma,
	           slash, colon or  either  parenthesis,  and  if  the
	           first  printing  character  in the statement is not
	           one of the characters which  can  start  a  number,
	           then  KIND  will  be  returned  with  the  value  6
	           indicating  an  unknown  command  word,   and   the
	           arguments   INIPRT  and  MIDPRT  will  be  returned
	           pointing to the leftmost and  rightmost  characters
	           in this unknown command word.
	         = 1, same as KMDTYP=0,  except  that  if  an  initial
	           number is found in the statement, then the value of
	           the number  is  evaluated  as  an  integer  and  is
	           returned  in  NUMVAL(NUMLOW),  an indication of the
	           sign if any is returned in NUMSIN(NUMLOW), KIND  is
	  FASP, FORTRAN Alphameric Subroutine Package         Page 139
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           returned  with  the  value 4, and MIDPRT and LMTPRT
	           are returned pointing to the character to the right
	           of  the  number,  and  to  the  rightmost  printing
	           character in the IBUFFR array respectively.  If the
	           first  printing character on the line is a slash or
	           a colon, then KIND is returned with the value 5  to
	           indicate a missing command word, since the slash or
	           colon is not considered to be part of a number.
	         = 2, same as KMDTYP=1,  except  that  if  an  initial
	           number is found in the statement, then the value of
	           the number is evaluated as a  real  number  and  is
	           returned in VALNUM(NUMLOW).

	  LSTTYP = specifies the type of numeric  arguments,  real  or
	           integer,  which  can  be evaluated, and the type of
	           argument, word or set of numbers  or  text  string,
	           which can be present more than once in the argument
	           list.  The values  5,  6,  7  and  8  specify  that
	           numeric  arguments  are  to  be  evaluated  as real
	           numbers, and for the routine DAIHST these values of
	           LSTTYP are exactly equivalent to the values 1, 2, 3
	           and 4 respectively.

	         = -1, the type of argument list is specified for each
	           possible  command  word  by  the value in the LEGAL
	           array parallel to the character count in the KNTLTR
	           array.
	         = 0, no descriptions of arguments are to be  returned
	           to   the   calling  program.   The  arguments  are,
	           however, interpreted to find the right end  of  the
	           statement.  If an argument is found, then KIND will
	           be returned with one of the value 7, 8,  9  or  10,
	           depending upon the type of the argument, instead of
	           being returned with the value 3.
	         = 1, the type of argument which can  be  repeated  is
	           the type of the first argument encountered, whether
	           or not this is preceded by commas.  The commas  do,
	           however,  indicate  missing  arguments  of the same
	           type  as   that   eventually   found.    Additional
	           arguments  of  types  other  than that of the first
	           argument  encountered  are  not  allowed.   If   an
	           additional  argument of another type is found, then
	           evaluation of the argument list will be  terminated
	           except insofar as is necessary to detect the end of
	           the statement, and KIND will be returned containing
	           one of the values 8, 9 or 10 indicating the type of
	           the illegal argument.   If  a  set  of  numbers  is
	           found, it is evaluated as a set of integers.
	         = 2, allow a series of words.  A single  text  string
	           and/or  a  single set of numbers can also appear in
	           the argument list.  If a set of numbers  is  found,
	           it is evaluated as a set of integers.
	         = 3, allow a series of sets of  integers.   A  single
	           word and/or a single text string can also appear in
	  FASP, FORTRAN Alphameric Subroutine Package         Page 140
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           the argument list.
	         = 4, allow a series of text strings.  A  single  word
	           and/or  a  single set of numbers can also appear in
	           the argument list.  If a set of numbers  is  found,
	           it is evaluated as a set of integers.
	         = 5, 6, 7 and 8, same as the LSTTYP values of 1, 2, 3
	           and  4 respectively, except that if a number or set
	           of  numbers  or  series  of  sets  of  numbers  are
	           encountered,  these  numbers  are evaluated as real
	           numbers and returned in  the  VALNUM  array  rather
	           than  in the NUMVAL array.  For the routine DAIHST,
	           the LSTTYP values of 5, 6,  7  and  8  are  exactly
	           equivalent  to  the  LSTTYP values of 1, 2, 3 and 4
	           respectively.
	         = 9, all arguments will be text strings delimited  by
	           parentheses,  not by apostrophes.  Each text string
	           begins  with  the  first  printing  character   and
	           extends to the next punctuation character or space,
	           or if a parenthesis is encountered within the  text
	           string,   to  the  parenthesis  which  returns  the
	           parenthetical level count to zero.   An  apostrophe
	           can  be included anywhere within the text string to
	           indicate that the  following  character  is  to  be
	           included  within  the  text  string  and  is not to
	           change the  parenthetical  level  count.   Since  a
	           leading   parenthesis   is  not  necessary,  it  is
	           included within the  text  string  if  found.   The
	           closing  parenthesis  is  never included within the
	           contents of the text string.  For example

	                ABC DEF,GHI(JKL)MNO)PQR((STU))VWX(' '(')

	           would include the following text strings

	                ABC
	                DEF
	                GHI(JKL
	                MNO)PQR
	                (STU
	                )VWX
	                ' '(')

	           It must be noted that in order for this  particular
	           type  of  parenthetical expression to be recognized
	           either LSTTYP=9 or else LSTTYP=-1 while  the  value
	           in  the LEGAL array corresponding to the command is
	           9.  Under all other conditions, quoted text strings
	           begin   either   with   an  apostrophe  or  with  a
	           parenthesis and this initial  delimiting  character
	           is not then included within the text string.

	  NAMLOW = subscript of the NAMLFT and NAMRIT array  locations
	           into  which  can  be  placed the description of the
	           first  word  encountered  in  the  argument   list.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 141
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           NAMLOW would normally have the value 1 to allow the
	           description of the first word argument to be placed
	           into  the  first locations in the NAMLFT and NAMRIT
	           arrays.

	  NAMMAX = highest subscript of the NAMLFT  and  NAMRIT  array
	           locations  into which can be placed the description
	           of a word  in  the  argument  list.   NAMMAX  would
	           normally  be the dimension of the NAMLFT and NAMRIT
	           arrays.  If NAMMAX equals NAMLOW, then  at  most  a
	           single  word  can be evaluated in the argument list
	           even if a series of words is enabled by  either  of
	           the  arguments  LSTTYP or LEGAL.  If NAMMAX is less
	           than NAMLOW, then no words can be evaluated in  the
	           argument list.

	  MRKLOW = subscript of the MRKLFT and MRKRIT array  locations
	           into  which  can  be  placed the description of the
	           first text string encountered in the argument list.
	           MRKLOW would normally have the value 1 to allow the
	           description of the first text string argument to be
	           placed  into  the first locations in the MRKLFT and
	           MRKRIT arrays.

	  MRKMAX = highest subscript of the MRKLFT  and  MRKRIT  array
	           locations  into which can be placed the description
	           of a text string  in  the  argument  list.   MRKMAX
	           would  normally  be the dimension of the MRKLFT and
	           MRKRIT arrays.  If MRKMAX equals  MRKLOW,  then  at
	           most  a  single text string can be evaluated in the
	           argument list even if a series of text  strings  is
	           enabled by either of the arguments LSTTYP or LEGAL.
	           If MRKMAX is less than MRKLOW, then no text strings
	           can be evaluated in the argument list.

	  NUMLOW = subscript of the NUMSIN, NUMVAL  and  VALNUM  array
	           locations  into which can be placed the description
	           of the first number  encountered  in  the  argument
	           list.   NUMLOW  would  normally have the value 1 to
	           allow the description of  the  sign  of  the  first
	           numeric  argument  to  be  placed  into  the  first
	           location in the NUMSIN array and the value  of  the
	           argument  to  be placed, depending upon whether the
	           number is evaluated as integer or  real,  into  the
	           first  location  in  either  the  NUMVAL  or VALNUM
	           arrays.

	  NUMMAX = highest subscript of the NUMSIN, NUMVAL and  VALNUM
	           array  locations  into  which  can  be  placed  the
	           description of  a  number  in  the  argument  list.
	           NUMMAX  would  normally  be  the  dimension  of the
	           NUMSIN, NUMVAL and VALNUM arrays.  If NUMMAX equals
	           NUMLOW,  then  at  most  a  single  number  can  be
	           evaluated in the argument list even if a series  of
	  FASP, FORTRAN Alphameric Subroutine Package         Page 142
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           sets  of  numbers  is  enabled  by  either  of  the
	           arguments LSTTYP or LEGAL.  If NUMMAX is less  than
	           NUMLOW,  then  no  numbers  can be evaluated in the
	           argument list.

	  INTRVL = the maximum number of numeric arguments  which  can
	           be  separated by slashes and/or by colons to form a
	           set of numeric  arguments.   Each  slash  or  colon
	           causes the description of the immediately following
	           numeric argument to be placed into the next  higher
	           location  in  the NUMSIN, NUMVAL and VALNUM arrays.
	           If 2 numeric arguments are separated  by  something
	           other  than  a slash or colon, then these arguments
	           are taken to  be  part  of  a  series  of  sets  of
	           numbers,  and  the description of the second number
	           is placed into the locations in the NUMSIN,  NUMVAL
	           and  VALNUM arrays having subscripts greater by the
	           value  of  INTRVL  than  the  subscripts   of   the
	           locations  into which was placed the description of
	           the first number of the previous set.  For example,
	           if

	                NUMLOW=1, NUMMAX=36 (or greater) and INTRVL=5,

	           then the argument list

	                1/2//4 //+8/,11+16WORD+21'TEXT STRING'26,31 36

	           would consist of the word  WORD,  the  text  string
	           TEXT  STRING,  and  the numbers 1, 2, 4, 8, 11, 16,
	           21, 26, 31 and 36 which were chosen for the example
	           so  as  to  be  stored at subscripts equal to their
	           values.   The   NUMSIN   array   locations   having
	           subscripts  3,  6, 7 and 9 would be returned set to
	           -1 to show  that  the  corresponding  numbers  were
	           indicated by slashes or colons to be missing.

	  LOWWRD = subscript of the location in the IWORD array  which
	           contains  the  first character of the first word in
	           the dictionary.  Note  that  if  KNTLTR(LOWKNT)  is
	           less   than  or  equal  to  zero,  then  the  first
	           character of the first word is instead contained in
	           IWORD(LOWWRD-KNTLTR(LOWKNT)).

	  MAXWRD = maximum dimension of the IWORD array.

	  IWORD  = dictionary array containing the characters  of  the
	           command   words  which  are  to  be  recognized,  1
	           character per array  location  as  read  by  an  A1
	           format or else defined by 1H field.  All alphabetic
	           letters within the IWORD array must be supplied  in
	           upper case.  The command word typed by the user and
	           read into the input  buffer  array  IBUFFR  can  be
	           split  into  2 or more portions any of which can be
	  FASP, FORTRAN Alphameric Subroutine Package         Page 143
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           abbreviated and/or separated by spaces or  tabs  if
	           the word in the IWORD array contains a single space
	           at the location at which the split is allowed,  and
	           if  the  length  stored  in the KNTLTR array is 100
	           more than the number of  characters  including  the
	           space  or  spaces  which form the word in the IWORD
	           array.  For example, if the IWORD array contains

	                1HN,1HO,1H ,1HL,1HI,1HM,1HI,1HT

	           and if the KNTLTR array contains the  corresponding
	           length  of 108, then this word could be selected by
	           any of the letter sequences

	                N, NO, N L, NL, NO L, NOL, N LI or NLI

	           providing in each case that  the  sequence  is  not
	           ambiguous.

	  LOWKNT = subscript of the KNTLTR array  location  containing
	           the  length  of the first word which can be matched
	           in the IWORD array.  This first word will start  at
	           IWORD(LOWWRD).    If   LSTTYP  is  less  than  zero
	           indicating that the argument list type is specified
	           in  the LEGAL array for each possible command word,
	           then LOWKNT is also  the  subscript  of  the  LEGAL
	           array  location  containing  the argument list type
	           associated  with  the  command  word   having   its
	           character count in KNTLTR(LOWKNT).

	  MAXKNT = subscript of the KNTLTR array  location  containing
	           the  length  of the final word which can be matched
	           in the IWORD array.  If LSTTYP is  less  than  zero
	           indicating that the argument list type is specified
	           in the LEGAL array for each possible command  word,
	           then  MAXKNT  is  also  the  subscript of the LEGAL
	           array location containing the  argument  list  type
	           associated   with   the  command  word  having  its
	           character count in KNTLTR(MAXKNT).

	  KNTLTR = array containing the numbers of characters  in  the
	           words in the IWORD array.  A zero or negative value
	           in the KNTLTR array offsets the next possible  word
	           which  can  be  matched  in  the IWORD array by the
	           number of letters given by the  absolute  value  of
	           the  negative  number  in  the  KNTLTR  array.  The
	           dimension of KNTLTR must be at least  MAXKNT.   For
	           example to recognize the words

	                YES, NO, MAYBE

	           the contents of the IWORD array would be

	                1HY,1HE,1HS,1HN,1HO,1HM,1HA,1HY,1HB,1HE
	  FASP, FORTRAN Alphameric Subroutine Package         Page 144
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           and the contents of the KNTLTR array would be

	                3,2,5

	  LEGAL  = if LSTTYP has the value -1, then LEGAL is an  array
	           which  specifies for each possible command word the
	           type of numeric arguments, real or  integer,  which
	           can be evaluated, and the type of argument, word or
	           set of numbers or text string, which can be present
	           more   than   once   in  the  argument  list.   The
	           specification  of  the  allowable   argument   list
	           construction for a particular command word is found
	           at the same subscript in the  LEGAL  array  as  the
	           character  count in the KNTLTR array.  If LSTTYP is
	           greater than or equal to zero, then the contents of
	           the LEGAL array are ignored.

	           The values 0 through 8 in the LEGAL  array  specify
	           the     following     allowable    argument    list
	           constructions.  The values 5, 6, 7  and  8  specify
	           that  numeric arguments are to be evaluated as real
	           numbers, and for the routine DAIHST these values in
	           the  LEGAL  array  are  exactly  equivalent  to the
	           values 1, 2, 3 and 4 respectively.
	         = 0 (or -1), no descriptions of arguments are  to  be
	           returned  to  the  calling  program.  The arguments
	           are, however, interpreted to find the right end  of
	           the  statement.  If an argument is found, then KIND
	           will be returned with one of the value 7, 8,  9  or
	           10,  depending  upon  the  type  of  the  argument,
	           instead of being returned with the value 3.
	         = 1, the type of argument which can  be  repeated  is
	           the type of the first argument encountered, whether
	           or not this is preceded by commas.  The commas  do,
	           however,  indicate  missing  arguments  of the same
	           type  as   that   eventually   found.    Additional
	           arguments  of  types  other  than that of the first
	           argument  encountered  are  not  allowed.   If   an
	           additional  argument of another type is found, then
	           evaluation of the argument list will be  terminated
	           except insofar as is necessary to detect the end of
	           the statement, and KIND will be returned containing
	           one of the values 8, 9 or 10 indicating the type of
	           the illegal argument.   If  a  set  of  numbers  is
	           found, it is evaluated as a set of integers.
	         = 2, allow a series of words.  A single  text  string
	           and/or  a  single set of numbers can also appear in
	           the argument list.  If a set of numbers  is  found,
	           it is evaluated as a set of integers.
	         = 3, allow a series of sets of  integers.   A  single
	           word and/or a single text string can also appear in
	           the argument list.
	         = 4, allow a series of text strings.  A  single  word
	           and/or  a  single set of numbers can also appear in
	  FASP, FORTRAN Alphameric Subroutine Package         Page 145
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           the argument list.  If a set of numbers  is  found,
	           it is evaluated as a set of integers.
	         = 5, 6, 7 and 8, same as the LEGAL array values of 1,
	           2, 3 and 4 respectively, except that if a number or
	           set of numbers or series of  sets  of  numbers  are
	           encountered,  these  numbers  are evaluated as real
	           numbers and returned in  the  VALNUM  array  rather
	           than  in the NUMVAL array.  For the routine DAIHST,
	           the LEGAL array values of 5, 6, 7 and 8 are exactly
	           equivalent to the LEGAL array values of 1, 2, 3 and
	           4 respectively.
	         = 9, all arguments will be text strings delimited  by
	           parentheses,  not by apostrophes.  Each text string
	           begins  with  the  first  printing  character   and
	           extends to the next punctuation character or space,
	           or if a parenthesis is encountered within the  text
	           string,   to  the  parenthesis  which  returns  the
	           parenthetical level count to zero.   An  apostrophe
	           can  be included anywhere within the text string to
	           indicate that the  following  character  is  to  be
	           included  within  the  text  string  and  is not to
	           change the  parenthetical  level  count.   Since  a
	           leading   parenthesis   is  not  necessary,  it  is
	           included within the  text  string  if  found.   The
	           closing  parenthesis  is  never included within the
	           contents of the text string.

	  MAXBFR = subscript of the IBUFFR array  location  containing
	           the  rightmost (highest subscript) character in the
	           line being interpreted.  MAXBFR would  normally  be
	           the dimension of the IBUFFR array.

	  The following arguments are used for both input and output.

	  IBUFFR = the input buffer array containing the characters of
	           the line being interpreted, one character per array
	           location, as read by a multiple of  an  A1  format.
	           Such  a  line  can  contain one or more statements.
	           The alphabetic letters forming  the  command  words
	           and  the  numeric  exponents  which  appear  in the
	           IBUFFR array can be either upper or lower case.

	           If  a  quoted   text   string   itself   containing
	           apostrophes  is found in the contents of the IBUFFR
	           array, then the extra apostrophes  needed  to  mark
	           the  apostrophes  which  are  to remain in the text
	           string are removed from the text string.

	  LOWBFR = subscript within the IBUFFR array of  the  location
	           which  contains  the  first (leftmost) character of
	           the line of text to be interpreted.  LOWBFR will be
	           returned pointing to the first character beyond (to
	           the right of)  the  interpreted  statement.   If  a
	           semicolon appears at the end of the statement, then
	  FASP, FORTRAN Alphameric Subroutine Package         Page 146
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           LOWBFR is returned pointing to  the  semicolon  and
	           will  be  advanced  beyond  the  semicolon  by  the
	           subsequent call to this routine.  If an exclamation
	           point  appears  at  the end of the statement, or if
	           there are no more printing characters to the  right
	           of  the  statement,  then  LOWBFR  will be returned
	           containing MAXBFR+1, but the calling program should
	           not read in a new line of text and should not reset
	           LOWBFR to the start of  the  new  contents  of  the
	           buffer  until  after  DAHEST  has  returned  KIND=1
	           indicating that the evaluation of the line of  text
	           has been completed.

	  KIND   = must be set to zero by the calling  program  before
	           this  routine is first called to evaluate a line of
	           text.  KIND is then returned describing the type of
	           statement which was evaluated.  The calling program
	           should reset KIND to have the  value  zero  if  the
	           evaluation  of  the contents of the line of text is
	           being abandoned by the calling program before  this
	           routine  has  indicated by returning KIND=1 that it
	           has completed the evaluation of the line  of  text.
	           Except    for    this   instance   in   which   the
	           interpretation is being abandoned  by  the  calling
	           program,  the  value  of  KIND  is otherwise passed
	           unchanged to the subsequent call to this routine.
	         = 1, (processing completed) returned if the  previous
	           calls to this routine have completed the evaluation
	           of the contents  of  the  line  of  text.   If  the
	           original   line   of  text  contained  no  printing
	           characters or contained a leading exclamation point
	           indicating  that the characters to its right formed
	           a comment, then the previous call to  this  routine
	           returned  KIND=2  to  indicate  an empty statement.
	           The calling program should read a new line of  text
	           and reset LOWBFR to point to the first character in
	           the new text.
	         = 2, (empty statement) returned if the original  line
	           of   text   contained  no  printing  characters  or
	           contained a leading  exclamation  point  indicating
	           that  the characters to its right formed a comment.
	           KIND  is  also  returned  set  to  2  if  an  extra
	           semicolon indicates a missing statement.  A leading
	           semicolon  would  indicate   an   initial   missing
	           statement.  A final semicolon, possibly followed by
	           an exclamation point and comment, would indicate  a
	           final  missing  statement.  Two adjacent semicolons
	           would indicate a missing statement between them.  A
	           line  of text in which the only printing characters
	           are  2  semicolons,  and   possibly   a   following
	           exclamation  point  and  comment,  would  specify 3
	           missing statements.
	         = 3, (correct statement) returned  if  the  statement
	           was not empty and was evaluated without errors.  If
	  FASP, FORTRAN Alphameric Subroutine Package         Page 147
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           KMDTYP is greater than or equal  to  zero,  then  a
	           known   command   word,   or  else  a  nonambiguous
	           abbreviation thereof, was found  and  the  sequence
	           number  of  this command word within the dictionary
	           is returned as the value of KOMAND.  If  KMDTYP  is
	           less  than  zero,  then KOMAND is returned with the
	           value zero, and the statement contained at least  a
	           comma, a slash, a colon or an argument.
	         = 4, (initial number) returned if KMDTYP  is  greater
	           than  zero,  and if a number was found at the start
	           of the statement.  MIDPRT  is  returned  containing
	           the  subscript  within  the  IBUFFR  array  of  the
	           character to the immediate  right  of  the  number.
	           LMTPRT  is returned containing the subscript within
	           the  IBUFFR  array  of   the   rightmost   printing
	           character  within the IBUFFR array.  If no printing
	           characters appear to the right of the number,  then
	           LMTPRT  will  be returned pointing to the rightmost
	           character of the number,  and  will  be  less  than
	           MIDPRT.   Other  than  to  determine  the rightmost
	           printing character, the characters to the right  of
	           the  number  are not interpreted, and in particular
	           are not tested to find apostrophes, semicolons  and
	           exclamation points.
	         = 5, (missing command) returned if a command word  or
	           else  a  leading number was required but not found,
	           but  the  statement  is  not  empty.   No  argument
	           descriptions  are  returned to the calling program.
	           This value of KIND is never returned if  KMDTYP  is
	           less  than  zero.   If  KMDTYP  is  zero,  then the
	           statement starts with a number, a  text  string,  a
	           comma,  a  slash or a colon since any other initial
	           printing characters which do not match  a  word  in
	           the  dictionary would be assumed to form an unknown
	           or misspelled command word.  If KMDTYP  is  greater
	           than  zero,  then  the statement starts with a text
	           string, a comma, a slash or a colon.
	         = 6, (unknown command) returned if an initial command
	           word  was required, but the statement starts with a
	           sequence of printing characters which could form  a
	           command  word, but which do not match a word in the
	           dictionary, or which form an ambiguous abbreviation
	           of  2  or more words in the dictionary, or which do
	           match a single  word  in  the  dictionary  but  are
	           followed   immediately   by  additional  alphabetic
	           characters  or  digits.   INIPRT  and  MIDPRT   are
	           returned  pointing  to  the  leftmost and rightmost
	           characters  in  this  unknown  command  word.    No
	           argument  descriptions  are returned to the calling
	           program.  This value of KIND is never  returned  if
	           KMDTYP  is  less  than  zero.  If KMDTYP is greater
	           than or equal to  zero,  then  the  first  printing
	           character  in  the  statement  is  not  one  of the
	           characters    exclamation     point,     semicolon,
	  FASP, FORTRAN Alphameric Subroutine Package         Page 148
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           apostrophe,  comma,  slash or colon, and is not one
	           of the characters which can start a number.
	         = 7, 8, 9 or 10, (too many arguments)  same  as  when
	           KIND  is  returned  containing  3,  except that the
	           maximum number of arguments of a  single  type  was
	           exceeded  during  the  evaluation  of  the argument
	           list.   The  description  of  the  argument   which
	           exceeded  the limit, as well as the descriptions of
	           any arguments to its right, are not returned to the
	           calling  program,  although  the  scanning  of  the
	           statement continues to determine the right  end  of
	           the statement.
	         = 7, returned if too many  slashes  and/or  too  many
	           colons were encountered in a set of numbers.
	         = 8, returned if too many words were found.
	         = 9, returned if too many sets of numbers were found.
	         = 10, returned if too many text strings were found.

	  The following arguments are used  only  for  output.   Their
	  input values are ignored.

	  KOMAND = if a command word is  recognized,  then  KOMAND  is
	           returned   containing  the  sequence  number  of  a
	           command word  matched  in  the  IWORD  array.   For
	           example,  if  the  second  command word is matched,
	           then KOMAND would be returned  containing  2.   The
	           sequence  number  of  the command word in the IWORD
	           array does not include the letters skipped over  by
	           the  value of LOWWRD being greater than 1, and does
	           not include the letters skipped  over  by  negative
	           values  encountered  in  the  KNTLTR  array.   If a
	           command word in the IWORD array is matched,  KMDTYP
	           being  greater than or equal to zero and KIND being
	           returned containing 3 or containing 7  or  greater,
	           then  KOMAND  is the number of values in the KNTLTR
	           array which  are  greater  than  zero  starting  at
	           KNTLTR(LOWKNT)  up  to  and  including  the  KNTLTR
	           location which contains the number  of  letters  in
	           the command word which is successfully matched.

	           KOMAND is returned containing  zero  if  a  command
	           word  could  not  be matched, regardless of whether
	           this was due to KMDTYP being less than zero, or  to
	           a  command  word being missing or misspelled, or to
	           the statement starting with a number.

	  LCNWRD = if  a  command  word  was  recognized,  KIND  being
	           returned  containing  3 or containing 7 or greater,
	           and KOMAND being returned greater than  zero,  then
	           LCNWRD  is returned containing the subscript of the
	           IWORD  array  location  which  contains  the  first
	           character  of  the  command  word  matched  in  the
	           dictionary.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 149
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           LCNWRD is returned undefined if KOMAND is  returned
	           set  to  zero  indicating  that no command word was
	           recognized.

	  LCNKNT = if  a  command  word  was  recognized,  KIND  being
	           returned  containing  3 or containing 7 or greater,
	           and KOMAND being returned greater than  zero,  then
	           LCNKNT  is returned containing the subscript of the
	           KNTLTR array location which contains the number  of
	           characters  in  the  command  word  matched  in the
	           dictionary.  If  there  are  no  zero  or  negative
	           entries   in  the  KNTLTR  array,  then  LCNKNT  is
	           returned equal to LOWKNT+KOMAND-1.

	           LCNKNT is returned undefined if KOMAND is  returned
	           set  to  zero  indicating  that no command word was
	           recognized.

	  INIPRT = returned containing the  subscript  of  the  IBUFFR
	           array  location  containing  the  leftmost printing
	           character in the  statement  if  KIND  is  returned
	           containing  3  or greater.  If an error is found in
	           the text  being  interpreted,  then  IBUFFR(INIPRT)
	           through   and   including   IBUFFR(LMTPRT)  can  be
	           displayed by the calling program as  the  statement
	           containing the error, although this text may not be
	           exactly what was input by the  user  since  when  2
	           adjacent  apostrophes  appear  within  text strings
	           which are delimited by apostrophes, one  of  the  2
	           adjacent   apostrophes   will   already  have  been
	           removed.  INIPRT is returned undefined if  KIND  is
	           returned set to either 1 or 2.
	         = if KIND is returned containing 6 indicating that an
	           unknown  command word was found at the start of the
	           statement, then INIPRT is returned pointing to  the
	           left character of the unknown command word.  MIDPRT
	           will  then  be  returned  pointing  to  the   right
	           character of the unknown command word.

	  MIDPRT = returned undefined if KIND is  returned  containing
	           any value other than 4 or 6.
	         = if KMDTYP was input greater than zero  allowing  an
	           initial number in place of an initial command word,
	           and if such an initial number  was  found  so  that
	           KIND  is  returned  containing  4,  then  MIDPRT is
	           returned pointing to the character to the immediate
	           right  of the number.  LMTPRT will then be returned
	           pointing to the rightmost printing character on the
	           line.   If  no  printing  characters  appear to the
	           right of the number, then LMTPRT will  be  returned
	           pointing  to  the rightmost character of the number
	           and will be less than the returned value of MIDPRT.
	         = if KIND is returned containing 6 indicating that an
	           unknown  command word was found at the start of the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 150
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           statement, then MIDPRT is returned pointing to  the
	           right character of the unknown command word.

	  LMTPRT = returned containing the  subscript  of  the  IBUFFR
	           array  location  containing  the rightmost printing
	           character in the  statement  if  KIND  is  returned
	           containing  3  or  greater.   If  the  statement is
	           followed by either a semicolon  or  an  exclamation
	           point,  then  LMTPRT  is  returned  pointing to the
	           rightmost printing character to  the  left  of  the
	           semicolon or exclamation point.  LMTPRT is returned
	           undefined if KIND is returned set to either 1 or 2.
	         = if KMDTYP was input greater than zero  allowing  an
	           initial number in place of an initial command word,
	           and if such an initial number  was  found  so  that
	           KIND  is  returned  containing  4,  then  LMTPRT is
	           returned  pointing  to   the   rightmost   printing
	           character in the buffer.  If no printing characters
	           appear to the right of the number, then LMTPRT will
	           be  returned pointing to the rightmost character of
	           the number and will be less than the returned value
	           of MIDPRT.

	  NAMKNT = returned containing the highest subscript  used  in
	           the NAMLFT and NAMRIT arrays to store the locations
	           within the buffer of the ends of words found in the
	           argument  list.   If  no  words  were  found in the
	           argument  list,  then  NAMKNT  will   be   returned
	           containing  NAMLOW-1.   NAMKNT  cannot  be returned
	           greater than NAMLOW  unless  the  evaluation  of  a
	           series of words is enabled.

	  NAMLFT = array returned containing the subscripts within the
	           IBUFFR  array  of  the  locations which contain the
	           left characters of the words in the argument  list.
	           If  the evaluation of a series of words is enabled,
	           but  some  intermediate  words  are  indicated   as
	           missing  by  the  appearance of extra commas in the
	           argument list, then for  these  missing  words  the
	           NAMRIT  array  will  contain  values which are less
	           than those in the NAMLFT array.  Missing  words  at
	           the  right  end of the statement indicated by extra
	           commas at the right end of the  statement  are  not
	           included  in  the  value  of  NAMKNT  and  are  not
	           indicated as being missing by  the  values  in  the
	           NAMLFT and NAMRIT arrays.

	  NAMRIT = array returned containing the subscripts within the
	           IBUFFR  array  of  the  locations which contain the
	           right characters of the words in the argument list.
	           If  the evaluation of a series of words is enabled,
	           but  some  intermediate  words  are  indicated   as
	           missing  by  the  appearance of extra commas in the
	           argument list, then for  these  missing  words  the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 151
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           NAMRIT  array  will  contain  values which are less
	           than those in the NAMLFT array.  Missing  words  at
	           the  right  end of the statement indicated by extra
	           commas at the right end of the  statement  are  not
	           included  in  the  value  of  NAMKNT  and  are  not
	           indicated as being missing by  the  values  in  the
	           NAMLFT and NAMRIT arrays.

	  MRKKNT = returned containing the highest subscript  used  in
	           the MRKLFT and MRKRIT arrays to store the locations
	           within the IBUFFR array of the ends of quoted  text
	           strings  found  in the argument list.  If no quoted
	           text strings were found in the argument list,  then
	           MRKKNT   will   be  returned  containing  MRKLOW-1.
	           MRKKNT  cannot  be  returned  greater  than  MRKLOW
	           unless  the  evaluation  of a series of quoted text
	           strings is enabled.

	  MRKLFT = array returned containing the subscripts within the
	           IBUFFR  array  of  the  locations which contain the
	           left characters of the quoted text strings  in  the
	           argument list.  The character pointed to by a value
	           in  the  MRKLFT  array  is  the  character  to  the
	           immediate right of the initial apostrophe or of the
	           initial parenthesis at the left end of  the  quoted
	           text  string.  If LSTTYP=9, or if LSTTYP=-1 and the
	           value in  the  LEGAL  array  corresponding  to  the
	           command  is  9,  then the character pointed to by a
	           value in the  MRKLFT  array  is  either  a  leading
	           parenthesis,  or is the leftmost printing character
	           which is neither  a  punctuation  character  nor  a
	           parenthesis.

	           The  character  to  the  left  of  the   delimiting
	           character  at  the  right  end  of  the quoted text
	           string is pointed to by the location in the  MRKRIT
	           array having the same subscript as the MRKLFT array
	           location pointing to the character at the left  end
	           of the quoted text string.  If a leading apostrophe
	           is followed immediately by another apostrophe which
	           is  not  itself  followed by an apostrophe, or if a
	           leading left parenthesis is followed immediately by
	           a  closing right parenthesis, or if a leading right
	           parenthesis is followed immediately  by  a  closing
	           left  parenthesis,  then  the quoted text string is
	           considered to be empty  and  the  location  in  the
	           MRKLFT  array  will point to the closing delimiting
	           character while the location in  the  MRKRIT  array
	           points  to the leading delimiting character so that
	           the value in the MRKRIT array is 1 less  than  that
	           of  the corresponding location in the MRKLFT array.
	           If the closing delimiting character is  not  found,
	           then  the  location  in  the  MRKRIT  array will be
	           returned  pointing  to   the   rightmost   printing
	  FASP, FORTRAN Alphameric Subroutine Package         Page 152
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           character  in  the  IBUFFR array, or to the leading
	           delimiting  character  if  no  printing  characters
	           appear  to  the  right  of  the  leading delimiting
	           character.

	           If the  evaluation  of  a  series  of  quoted  text
	           strings  is  enabled,  but some intermediate quoted
	           text  strings  are  indicated  as  missing  by  the
	           appearance  of  extra  commas in the argument list,
	           then for these  missing  quoted  text  strings  the
	           MRKRIT  array  will contain values which are 2 less
	           than those in the  MRKLFT  array.   Missing  quoted
	           text  strings  at  the  right  end of the statement
	           indicated by extra commas at the right end  of  the
	           statement  are  not included in the value of MRKKNT
	           and are not  indicated  as  being  missing  by  the
	           values in the MRKLFT and MRKRIT arrays.

	  MRKRIT = array returned containing the subscripts within the
	           IBUFFR  array  of  the  locations which contain the
	           right characters of the quoted text strings in  the
	           argument  list.   The  character  pointed to by the
	           value in the MRKRIT array is the character  to  the
	           immediate left of the final apostrophe at the right
	           end of a quoted text string which is  begun  by  an
	           apostrophe,  or  is  the character to the immediate
	           left of the final parenthesis at the right end of a
	           quoted text string which is begun by a parenthesis,
	           or is the rightmost printing character on the  line
	           if  no  final  delimiting character is found.  If a
	           quoted text string is begun by  an  apostrophe  and
	           contains  2 adjacent apostrophes marking the single
	           appearance of an apostrophe as part of  the  quoted
	           text  string,  then the extra apostrophe is removed
	           from the quoted text string and the portion of  the
	           quoted  text  string  to its right is moved left an
	           extra character position, and the  pointer  in  the
	           MRKRIT array then marks the right end of the quoted
	           text string after the shift is completed.

	           If the  evaluation  of  a  series  of  quoted  text
	           strings  is  enabled,  but some intermediate quoted
	           text  strings  are  indicated  as  missing  by  the
	           appearance  of  extra  commas in the argument list,
	           then for these  missing  quoted  text  strings  the
	           MRKRIT  array  will contain values which are 2 less
	           than those in the  MRKLFT  array.   Missing  quoted
	           text  strings  at  the  right  end of the statement
	           indicated by extra commas at the right end  of  the
	           statement  are  not included in the value of MRKKNT
	           and are not  indicated  as  being  missing  by  the
	           values in the MRKLFT and MRKRIT arrays.

	  NUMKNT = returned containing the highest subscript  used  in
	  FASP, FORTRAN Alphameric Subroutine Package         Page 153
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           the  NUMSIN,  NUMVAL and VALNUM arrays to store the
	           sign and value of numeric arguments  found  in  the
	           argument  list.  If no numeric arguments were found
	           in the argument list, then NUMKNT will be  returned
	           containing  NUMLOW-1.   NUMKNT  cannot  be returned
	           greater than NUMLOW+INTRVL-1 unless the  evaluation
	           of  a  series  of  sets  of numbers is enabled.  If
	           KMDTYP is input greater than zero and if an initial
	           number  is found in the statement, then NUMKNT will
	           be returned equal to NUMLOW and the description  of
	           the    initial   number   will   be   returned   in
	           NUMSIN(NUMLOW)  and  in  either  NUMVAL(NUMLOW)  or
	           VALNUM(NUMLOW).

	  NUMSIN = array returned indicating the sign, if  any,  which
	           preceded  each  numeric argument.  The value of the
	           argument is returned in the NUMVAL or VALNUM  array
	           location  having  the  same subscript as the NUMSIN
	           array location describing the sign.  Each  location
	           from   NUMSIN(NUMLOW)   through  NUMSIN(NUMKNT)  is
	           returned containing one of the following values.
	         = -1, returned if the corresponding numeric  argument
	           was indicated as missing either by the absence of a
	           number before a slash or a colon, by the absence of
	           a  number  after  a  slash  or  a  colon, or by the
	           absence of a number between two adjacent slashes or
	           colons.   The  corresponding location in either the
	           NUMVAL or VALNUM arrays, whichever is  appropriate,
	           is also set to zero.
	         = 0, returned if subsequent numeric arguments  (which
	           are  returned  in  NUMSIN,  NUMVAL  or VALNUM array
	           locations having higher subscripts) appear  in  the
	           argument list, but the current numeric argument was
	           indicated as missing by less  than  INTRVL  numbers
	           being  included  in  a  set  of  numbers  or,  by 2
	           adjacent  commas  in  the   argument   list.    The
	           corresponding  location  in  either  the  NUMVAL or
	           VALNUM arrays, whichever is  appropriate,  is  also
	           set  to  zero.  Missing numeric arguments indicated
	           by extra commas at the right end of  the  statement
	           are not included in the value of NUMKNT and are not
	           represented  in  the  NUMSIN,  NUMVAL  and   VALNUM
	           arrays.
	         = 1, returned if a numeric  argument  was  evaluated,
	           but no sign appeared to its left.
	         = 2, returned if a minus sign appeared to the left of
	           the numeric argument.
	         = 3, returned if a plus sign appeared to the left  of
	           the numeric argument.

	  NUMVAL = array returned containing  the  values  of  numeric
	           arguments  evaluated  as  integers.  If the numeric
	           argument was preceded by a  minus  sign,  then  the
	           value   will   be   returned   negative   and   the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 154
	  DAHEST, Parser for Simple Commands to Interactive Programs


	           corresponding location in  the  NUMSIN  array  will
	           contain 2.

	  The following arguments are used only for output, and appear
	  only in the argument list of routine DAHEST.

	  VALNUM = array returned containing  the  values  of  numeric
	           arguments   evaluated  as  real  numbers.   If  the
	           numeric argument was preceded by a minus sign, then
	           the   value  will  be  returned  negative  and  the
	           corresponding location in  the  NUMSIN  array  will
	           contain 2.

	  IFLOAT = returned describing whether numeric arguments  were
	           evaluated as integers or as real numbers.
	         = 0, returned if numeric arguments were evaluated  as
	           integers.   The  values  of these numeric arguments
	           are then returned in the NUMVAL array.
	         = 1, returned if numeric arguments were evaluated  as
	           real   numbers.    The   values  of  these  numeric
	           arguments are then returned in the VALNUM array.


	                an Example of the Use of DAHEST
	                -- ------- -- --- --- -- ------

	  The following sample program demonstrates how  most  of  the
	  DAHEST  arguments  are  used.  The program accepts a line of
	  text from the user, evaluates the contents of the  line  and
	  reports the results.  This reading, evaluation and reporting
	  sequence is repeated until the user terminates execution  of
	  the  program.   Typical  output  is  shown after the program
	  listing.  Argument types  associated  with  the  11  command
	  words are described in comments at the start of the program.

	  C     RENBR(TSTHST/TEST DAHEST ROUTINE FROM FASP PACKAGE)
	        DIMENSION IBUFFR(72),IWORD(148),KNTLTR(21),ISIGN(3),
	       1NAMLFT(100),NAMRIT(100),MRKLFT(100),MRKRIT(100),
	       2NUMSIN(100),NUMVAL(100),VALNUM(100),LEGAL(21)
	  C     FOLLOWING WORDS ARE IN DICTIONARY
	  C     REAL NUMBERS               TAKES SERIES OF REAL SETS
	  C     INTEGER NUMBERS         TAKES SERIES OF INTEGER SETS
	  C     NUMBERS                 TAKES SERIES OF INTEGER SETS
	  C     STRINGS         TAKES INTEGERS AND SERIES OF STRINGS
	  C     WORDS             TAKES INTEGERS AND SERIES OF WORDS
	  C     TEXT STRINGS    TAKES INTEGERS AND SERIES OF STRINGS
	  C     NO ARGUMENTS                    NO ARGUMENTS ALLOWED
	  C     NUMERIC SERIES          TAKES SERIES OF INTEGER SETS
	  C     NUMERAL SETS               TAKES SERIES OF REAL SETS
	  C     GENERAL REAL          SERIES OF 1ST FOUND TYPE, REAL
	  C     GENERAL INTEGER    SERIES OF 1ST FOUND TYPE, INTEGER
	  C     PARENTHESES       LEADING CHARACTERS AND PARENTHESES
	        DATA IWORD/ 1HI,1HG,1HN,1HO,1HR,1HE,1H*,1HR,1HE,1HA,
	       11HL,1H ,1HN,1HU,1HM,1HB,1HE,1HR,1HS,1HI,1HN,1HT,1HE,
	  FASP, FORTRAN Alphameric Subroutine Package         Page 155
	  DAHEST, Parser for Simple Commands to Interactive Programs


	       21HG,1HE,1HR,1H ,1HN,1HU,1HM,1HB,1HE,1HR,1HS,1H*,1H*,
	       31H*,1H*,1HN,1HU,1HM,1HB,1HE,1HR,1HS,1HS,1HT,1HR,1HI,
	       41HN,1HG,1HS,1H*,1HW,1HO,1HR,1HD,1HS,1H*,1HT,1HE,1HX,
	       51HT,1H ,1HS,1HT,1HR,1HI,1HN,1HG,1HS,1H*,1HN,1HO,1H ,
	       61HA,1HR,1HG,1HU,1HM,1HE,1HN,1HT,1HS,1HN,1HU,1HM,1HE,
	       71HR,1HI,1HC,1H ,1HS,1HE,1HR,1HI,1HE,1HS,1HN,1HU,1HM,
	       81HE,1HR,1HA,1HL,1H ,1HS,1HE,1HT,1HS,1HG,1HE,1HN,1HE,
	       91HR,1HA,1HL,1H ,1HR,1HE,1HA,1HL,1HG,1HE,1HN,1HE,1HR,
	       11HA,1HL,1H ,1HI,1HN,1HT,1HE,1HG,1HE,1HR,1HP,1HA,1HR,
	       21HE,1HN,1HT,1HH,1HE,1HS,1HE,1HS/
	        DATA KNTLTR/ 99, 99, 99, -1,112,115, -4,  7,  7, -1,
	       1              5, -1,112, -1,112,114,  0,112,112,115,
	       2             11/
	        DATA LEGAL / 0, 0, 0, 9, 7, 3, 9, 3, 4, 9,
	       1             2, 9, 4, 9, 0, 3, 9, 7, 5, 1,
	       2             9/
	        DATA KMDTYP,LSTTYP,NAMLOW,NAMMAX,MRKLOW,MRKMAX,
	       1NUMLOW,NUMMAX,INTRVL,LOWWRD,MAXWRD,LOWKNT,MAXKNT,
	       2MAXBFR/1,-1,21,25,76,80,15,39,5,7,148,4,21,72/
	        DATA ISIGN/1H ,1H-,1H+/
	        DATA IGREAT,IYES/1H>,1HY/
	        DATA ITTY,JTTY/5,5/
	        WRITE(JTTY,1)
	      1 FORMAT(13H TEST DAIHST ,$)
	        READ(ITTY,7)IANS
	        KIND=0
	      2 WRITE(JTTY,3)KMDTYP,LSTTYP
	      3 FORMAT(8H KMDTYP(,I2,10H), LSTTYP(,I2,2H) ,$)
	        READ(ITTY,4)KMDTYP,LSTTYP
	      4 FORMAT(2I)
	      5 WRITE(JTTY,6)
	      6 FORMAT(1X,1H*,$)
	        READ(ITTY,7)IBUFFR
	      7 FORMAT(100A1)
	        LOWBFR=1
	  C
	  C     FIND NEXT STATEMENT IN BUFFER
	        IFANY=0
	      8 IF(IANS.EQ.IYES)GO TO 9
	        CALL DAHEST(KMDTYP,LSTTYP,NAMLOW,NAMMAX,MRKLOW,
	       1MRKMAX,NUMLOW,NUMMAX,INTRVL,LOWWRD,MAXWRD,IWORD,
	       2LOWKNT,MAXKNT,KNTLTR,LEGAL,MAXBFR,IBUFFR,LOWBFR,
	       3KIND,KOMAND,LCNWRD,LCNKNT,INIPRT,MIDPRT,LMTPRT,
	       4NAMKNT,NAMLFT,NAMRIT,MRKKNT,MRKLFT,MRKRIT,NUMKNT,
	       5NUMSIN,NUMVAL,VALNUM,IFLOAT)
	        GO TO 10
	      9 CALL DAIHST(KMDTYP,LSTTYP,NAMLOW,NAMMAX,MRKLOW,
	       1MRKMAX,NUMLOW,NUMMAX,INTRVL,LOWWRD,MAXWRD,IWORD,
	       2LOWKNT,MAXKNT,KNTLTR,LEGAL,MAXBFR,IBUFFR,LOWBFR,
	       3KIND,KOMAND,LCNWRD,LCNKNT,INIPRT,MIDPRT,LMTPRT,
	       4NAMKNT,NAMLFT,NAMRIT,MRKKNT,MRKLFT,MRKRIT,NUMKNT,
	       5NUMSIN,NUMVAL)
	        IFLOAT=0
	     10 IF(KIND.LE.2)GO TO 12
	  FASP, FORTRAN Alphameric Subroutine Package         Page 156
	  DAHEST, Parser for Simple Commands to Interactive Programs


	        IFANY=1
	        WRITE(JTTY,11)(IBUFFR(I),I=INIPRT,LMTPRT),IGREAT
	     11 FORMAT(10X,1H<,100A1)
	     12 IF(KOMAND.LE.0)GO TO 14
	        IEND=KNTLTR(LCNKNT)
	        IF(IEND.GE.100)IEND=IEND-100
	        IEND=LCNWRD+IEND-1
	        WRITE(JTTY,13)(IWORD(I),I=LCNWRD,IEND),IGREAT
	     13 FORMAT(11H COMMAND =<,100A1)
	     14 GO TO(15,16,25,18,21,23,25,25,25,25),KIND
	  C
	  C     CONDITIONS FOR WHICH NO ARGUMENTS ARE REPORTED
	     15 IF(IFANY.LE.0)GO TO 2
	        GO TO 5
	     16 WRITE(JTTY,17)
	     17 FORMAT(16H EMPTY STATEMENT)
	        GO TO 8
	     18 J=NUMSIN(NUMLOW)
	        WRITE(JTTY,19)NUMVAL(NUMLOW),ISIGN(J)
	     19 FORMAT(10H NUMBER  =,1I12,1A1)
	        IF(MIDPRT.LE.LMTPRT)WRITE(JTTY,20)
	       1(IBUFFR(I),I=MIDPRT,LMTPRT),IGREAT
	     20 FORMAT(11H TEXT    =<,100A1)
	        GO TO 8
	     21 WRITE(JTTY,22)
	     22 FORMAT(16H MISSING COMMAND)
	        GO TO 8
	     23 WRITE(JTTY,24)(IBUFFR(I),I=INIPRT,MIDPRT),IGREAT
	     24 FORMAT(11H UNKNOWN =<,100A1)
	        GO TO 8
	  C
	  C     REPORT WORD ARGUMENTS
	     25 I=NAMLOW-1
	        N=0
	     26 IF(I.GE.NAMKNT)GO TO 28
	        I=I+1
	        N=N+1
	        J=NAMLFT(I)
	        K=NAMRIT(I)
	        IF(K.GE.J)WRITE(JTTY,27)N,(IBUFFR(L),L=J,K),IGREAT
	     27 FORMAT(6H WORD(,I2,3H)=<,100A1)
	        GO TO 26
	     28 IF(KIND.EQ.8)WRITE(JTTY,29)
	     29 FORMAT(15H TOO MANY WORDS)
	  C
	  C     REPORT QUOTED TEXT STRING ARGUMENTS
	        I=MRKLOW-1
	        N=0
	     30 IF(I.GE.MRKKNT)GO TO 32
	        I=I+1
	        N=N+1
	        J=MRKLFT(I)
	        K=MRKRIT(I)
	        IF(K.EQ.(J-1))WRITE(JTTY,31)N,IGREAT
	  FASP, FORTRAN Alphameric Subroutine Package         Page 157
	  DAHEST, Parser for Simple Commands to Interactive Programs


	        IF(K.GE.J)WRITE(JTTY,31)N,(IBUFFR(L),L=J,K),IGREAT
	     31 FORMAT(6H TEXT(,I2,3H)=<,100A1)
	        GO TO 30
	     32 IF(KIND.EQ.10)WRITE(JTTY,33)
	     33 FORMAT(22H TOO MANY TEXT STRINGS)
	  C
	  C     REPORT NUMERIC ARGUMENTS
	        I=NUMLOW-1
	        N=0
	     34 IF(I.GE.NUMKNT)GO TO 39
	        I=I+1
	        N=N+1
	        J=NUMSIN(I)
	        IF(J.EQ.0)GO TO 34
	        IF(J.LT.0)GO TO 37
	        IF(IFLOAT.EQ.0)WRITE(JTTY,35)N,NUMVAL(I),ISIGN(J)
	     35 FORMAT(6H NMBR(,I2,2H)=,1I12,1A1)
	        IF(IFLOAT.NE.0)WRITE(JTTY,36)N,VALNUM(I),ISIGN(J)
	     36 FORMAT(6H NMBR(,I2,2H)=,1E12.4,1A1)
	        GO TO 34
	     37 WRITE(JTTY,38)N
	     38 FORMAT(6H NMBR(,I2,9H) MISSING)
	        GO TO 34
	     39 IF(KIND.EQ.7)WRITE(JTTY,40)
	     40 FORMAT(27H TOO MANY SLASHES OR COLONS)
	        IF(KIND.EQ.9)WRITE(JTTY,41)
	     41 FORMAT(17H TOO MANY NUMBERS)
	        GO TO 8
	        END


	   Sample Dialog Between a User and the Demonstration Program
	   ------ ------ ------- - ---- --- --- ------------- -------

	  In the following dialog between a user and the demonstration
	  program  listed  on  the  previous  pages, the lines of text
	  typed by the user appear right  of  asterisks  in  the  left
	  column.   The program types the characters found in the each
	  statement and a summary of the contents  of  the  statement.
	  The  demonstration  program  defines  the  maximum number of
	  numbers which can appear in each numeric set to be 5 so that
	  the  first  number  of  each numeric set is at a subscript 5
	  greater than the first number  of  the  previous  set  if  a
	  series of numeric sets is both enabled and found.

	  FASP, FORTRAN Alphameric Subroutine Package         Page 158
	  DAHEST, Parser for Simple Commands to Interactive Programs


	  TEST DAIHST N
	  KMDTYP( 1), LSTTYP(-1) 1 -1

	  *R ONE;R N TWO;R NUM THREE;REA FOUR;REALN FIVE;REA NUM
	           <R ONE>
	  COMMAND =<REAL NUMBERS>
	  WORD( 1)=<ONE>
	           <R N TWO>
	  COMMAND =<REAL NUMBERS>
	  WORD( 1)=<TWO>
	           <R NUM THREE>
	  COMMAND =<REAL NUMBERS>
	  WORD( 1)=<THREE>
	           <REA FOUR>
	  COMMAND =<REAL NUMBERS>
	  WORD( 1)=<FOUR>
	           <REALN FIVE>
	  COMMAND =<REAL NUMBERS>
	  WORD( 1)=<FIVE>
	           <REA NUM>
	  COMMAND =<REAL NUMBERS>

	  *S'A STRING';STRINGSGARBAGE'A STRING';STRINGS'A STRING'
	           <S'A STRING'>
	  COMMAND =<STRINGS>
	  TEXT( 1)=<A STRING>
	           <STRINGSGARBAGE'A STRING'>
	  UNKNOWN =<STRINGSGARBAGE>
	           <STRINGS'A STRING'>
	  COMMAND =<STRINGS>
	  TEXT( 1)=<A STRING>

	  *WORD ONE,,'FIRST',1/2/,,FOUR;WORD,,THREE/2/3'FIRST'FOUR
	           <WORD ONE,,'FIRST',1/2/,,FOUR>
	  COMMAND =<WORDS>
	  WORD( 1)=<ONE>
	  WORD( 4)=<FOUR>
	  TEXT( 1)=<FIRST>
	  NMBR( 1)=           1
	  NMBR( 2)=           2
	  NMBR( 3) MISSING

	           <WORD,,THREE/2/3'FIRST'FOUR>
	  COMMAND =<WORDS>
	  WORD( 3)=<THREE>
	  WORD( 4)=<FOUR>
	  TEXT( 1)=<FIRST>
	  NMBR( 1) MISSING
	  NMBR( 2)=           2
	  NMBR( 3)=           3

	  FASP, FORTRAN Alphameric Subroutine Package         Page 159
	  DAHEST, Parser for Simple Commands to Interactive Programs


	  *TEXT,1//3'TWO' 'THREE'FIRST'FOUR';TEXT/2,,'TWO'FIRST,,'FOUR
	           <TEXT,1//3'TWO' 'THREE'FIRST'FOUR'>
	  COMMAND =<TEXT STRINGS>
	  WORD( 1)=<FIRST>
	  TEXT( 2)=<TWO>
	  TEXT( 3)=<THREE>
	  TEXT( 4)=<FOUR>
	  NMBR( 1)=           1
	  NMBR( 2) MISSING
	  NMBR( 3)=           3
	           <TEXT/2,,'TWO'FIRST,,'FOUR>
	  COMMAND =<TEXT STRINGS>
	  WORD( 1)=<FIRST>
	  TEXT( 2)=<TWO>
	  TEXT( 4)=<FOUR>
	  NMBR( 1) MISSING
	  NMBR( 2)=           2

	  *I 1//3 6FIRST//13'ONE',,21;I+1//+3+6,FIRST,//+13,'ONE',,+21
	           <I 1//3 6FIRST//13'ONE',,21>
	  COMMAND =<INTEGER NUMBERS>
	  WORD( 1)=<FIRST>
	  TEXT( 1)=<ONE>
	  NMBR( 1)=           1
	  NMBR( 2) MISSING
	  NMBR( 3)=           3
	  NMBR( 6)=           6
	  NMBR(11) MISSING
	  NMBR(12) MISSING
	  NMBR(13)=          13
	  NMBR(21)=          21
	           <I+1//+3+6,FIRST,//+13,'ONE',,+21>
	  COMMAND =<INTEGER NUMBERS>
	  WORD( 1)=<FIRST>
	  TEXT( 1)=<ONE>
	  NMBR( 1)=           1+
	  NMBR( 2) MISSING
	  NMBR( 3)=           3+
	  NMBR( 6)=           6+
	  NMBR(11) MISSING
	  NMBR(12) MISSING
	  NMBR(13)=          13+
	  NMBR(21)=          21+

	  *TEXT'APOSTROPHES''IN''TEXT'(APOSTROPHES''IN''TEXT'
	           <TEXT'APOSTROPHES'IN'TEXT'(APOSTROPHES''IN''TEXT' >
	  COMMAND =<TEXT STRINGS>
	  TEXT( 1)=<APOSTROPHES'IN'TEXT>
	  TEXT( 2)=<APOSTROPHES''IN''TEXT' >

	  FASP, FORTRAN Alphameric Subroutine Package         Page 160
	  DAHEST, Parser for Simple Commands to Interactive Programs


	  *TEXT '' 'TWO' '''' 'FOUR' '''''';TEXT'ONE',,'
	           <TEXT '' 'TWO' ''' 'FOUR' ''''>
	  COMMAND =<TEXT STRINGS>
	  TEXT( 1)=<>
	  TEXT( 2)=<TWO>
	  TEXT( 3)=<'>
	  TEXT( 4)=<FOUR>
	  TEXT( 5)=<''>
	           <TEXT'ONE',,'>
	  COMMAND =<TEXT STRINGS>
	  TEXT( 1)=<ONE>
	  TEXT( 3)=<>

	  *N A;NOA;NO A;N A-12;N A'STRING';N A WORD!ALLOWS NO ARGUMENT
	           <N A>
	  COMMAND =<NO ARGUMENTS>
	           <NOA>
	  COMMAND =<NO ARGUMENTS>
	           <NO A>
	  COMMAND =<NO ARGUMENTS>
	           <N A-12>
	  COMMAND =<NO ARGUMENTS>
	  TOO MANY NUMBERS
	           <N A'STRING'>
	  COMMAND =<NO ARGUMENTS>
	  TOO MANY TEXT STRINGS
	           <N A WORD>
	  COMMAND =<NO ARGUMENTS>
	  TOO MANY WORDS

	  *'MISSING COMMANDS'; ; /55 ;; ,SAME;  -123LEADING NUMBER
	           <'MISSING COMMANDS'>
	  MISSING COMMAND
	  EMPTY STATEMENT
	           </55>
	  MISSING COMMAND
	  EMPTY STATEMENT
	           <,SAME>
	  MISSING COMMAND
	           <-123LEADING NUMBER>
	  NUMBER  =        -123-
	  TEXT    =<LEADING NUMBER>

	  *PARENTH ONE TWO(')TWO),THREE)THREE''((FOUR))FIVE(
	           <PARENTH ONE TWO(')TWO),THREE)THREE''((FOUR))FIVE(>
	  COMMAND =<PARENTHESES>
	  TEXT( 1)=<ONE>
	  TEXT( 2)=<TWO(')TWO>
	  TEXT( 3)=<THREE)THREE''>
	  TEXT( 4)=<(FOUR>
	  TEXT( 5)=<)FIVE>

	  FASP, FORTRAN Alphameric Subroutine Package         Page 161
	  DAHEST, Parser for Simple Commands to Interactive Programs


	  *;N;NUM;NUMER;NUMERA;NUMERI;N SE;N SET;N SER;
	  EMPTY STATEMENT
	           <N>
	  UNKNOWN =<N>
	           <NUM>
	  UNKNOWN =<NUM>
	           <NUMER>
	  UNKNOWN =<NUMER>
	           <NUMERA>
	  COMMAND =<NUMERAL SETS>
	           <NUMERI>
	  COMMAND =<NUMERIC SERIES>
	           <N SE>
	  UNKNOWN =<N SE>
	           <N SET>
	  COMMAND =<NUMERAL SETS>
	           <N SER>
	  COMMAND =<NUMERIC SERIES>
	  EMPTY STATEMENT

	  *INT-12//6.3K/+1.33E+2-123.45E-1/88E2WORD/36
	           <INT-12//6.3K/+1.33E+2-123.45E-1/88E2WORD/36>
	  COMMAND =<INTEGER NUMBERS>
	  WORD( 1)=<WORD>
	  NMBR( 1)=         -12-
	  NMBR( 2) MISSING
	  NMBR( 3)=        6300
	  NMBR( 4)=         133+
	  NMBR( 6)=         -12-
	  NMBR( 7)=        8800
	  NMBR(11) MISSING
	  NMBR(12)=          36

	  *REAL 12.34E+6 -945.12;REAL +44E2,16K;REAL,-22M,,0.002
	           <REAL 12.34E+6 -945.12>
	  COMMAND =<REAL NUMBERS>
	  NMBR( 1)=  0.1234E+08
	  NMBR( 6)= -0.9451E+03-
	           <REAL +44E2,16K>
	  COMMAND =<REAL NUMBERS>
	  NMBR( 1)=  0.4400E+04+
	  NMBR( 6)=  0.1600E+05
	           <REAL,-22M,,0.002>
	  COMMAND =<REAL NUMBERS>
	  NMBR( 6)= -0.2200E+08-
	  NMBR(16)=  0.2000E-02
	  FASP, FORTRAN Alphameric Subroutine Package         Page 162
	  DAHEST, Parser for Simple Commands to Interactive Programs


	    A Program to Maintain the DAHEST or DAVERB Dictionaries
	    - ------- -- -------- --- ------ -- ------ ------------

	  DAMENU is a program which  constructs  the  DATA  statements
	  defining  the  dictionary  required by FASP routines such as
	  DAVERB and DAHEST for word  identification.   The  first  80
	  characters  are  read from each line of the input file.  The
	  first line read from the  input  file  is  copied  into  the
	  output  file  as  a  FORTRAN comment line beginning with the
	  letter C in column 1, but is otherwise ignored.  The  second
	  line  of the input file must contain separated by spaces (or
	  commas) the names by which the following 6 items are  to  be
	  represented in the DATA statements generated by this program

	    1  the  variable  which  contains  the  total  number   of
	       characters  in all words in the dictionary.  This would
	       correspond to the variable named MAXWRD in  the  DAHEST
	       argument list.

	    2  the variable which contains the total number  of  words
	       in  the  dictionary.   This  would  correspond  to  the
	       variable named MAXKNT in the DAHEST argument list.

	    3  the array which contains  identical  values  for  words
	       which  are synonyms.  This array does not appear in the
	       DAHEST argument list.   Once  all  6  names  have  been
	       specified, then a number at the left end of each of the
	       subsequent lines specifies the value to be placed  into
	       this  array  for  each  of  the  words appearing to its
	       right.   DATA  statements  defining  this   array   are
	       generated  only if at least one value within this array
	       is specified, but the name of the array must  still  be
	       supplied.

	    4  the array which contains  the  characters  forming  the
	       words  in the dictionary.  This would correspond to the
	       array named IWORD in the DAHEST argument list.

	    5  the array which contains the length of each word in the
	       dictionary.   This  would correspond to the array named
	       KNTLTR in the DAHEST argument list.

	    6  the array which contains the argument  type  associated
	       with   each   word   in  the  dictionary.   This  would
	       correspond to the  array  named  LEGAL  in  the  DAHEST
	       argument  list.   Once all 6 names have been specified,
	       then a single digit at the right end  of  each  of  the
	       subsequent  lines specifies the value to be placed into
	       this array for each of the words appearing to its left.
	       DATA  statements defining this array are generated only
	       if at least one value within this array  is  specified,
	       but the name of the array must still be supplied.

	  If the second line does not contain at  least  6  groups  of
	  FASP, FORTRAN Alphameric Subroutine Package         Page 163
	  DAHEST, Parser for Simple Commands to Interactive Programs


	  characters,   then   additional  names  will  be  read  from
	  subsequent lines until 6 have been specified.

	  Once all 6 names have been established, then each subsequent
	  line  contains  a  word  identification number (which can be
	  expressed in E, K or M notation), followed by  one  or  more
	  spaces  and  then  by  the  spelling  of the word.  The FASP
	  routines return to the calling program the  sequence  number
	  of the word within the dictionary counting as separate words
	  all character sequences even  though  some  of  these  might
	  logically  be  synonyms  or allowed ambiguous abbreviations.
	  The word identification numbers are not needed by  the  FASP
	  routines,  but  are  instead meant to be used by the calling
	  program to identify the operation to be performed  when  the
	  word  or  any  of  its  synonyms  is  encountered.  The word
	  identification number is assumed to be zero if no number  is
	  found  at  the start of the line.  The line can begin with a
	  comma if a word identification number is not  required,  but
	  the  leftmost word on the line itself begins with a digit or
	  a sign or a decimal point.  The DATA statements representing
	  the  word  identification  numbers  are generated only if at
	  least one word identification number is found.

	  If abbreviations of a word are to be recognized even  though
	  they are not unique across the entire dictionary, then these
	  abbreviations should follow the complete spelling  separated
	  from   it  and  each  other  by  commas,  with  the  longest
	  abbreviations coming first.  Spaces are ignored at the start
	  or  at  the  end  of the spelling of a word.  If two or more
	  words appear on a single  line  but  are  not  separated  by
	  commas,  then  the  resulting  dictionary will include these
	  words as a single entry in which these words  are  separated
	  by  single  spaces.   For example, if the first 3 letters of
	  the word duplicate those of some other word,  but  the  word
	  being described on the current line is to be selected by its
	  1, 2 or 3 letter abbreviations, then the full spelling would
	  be  followed  by a comma and the 3 letter abbreviation, then
	  by a comma and the 2 letter abbreviation and  finally  by  a
	  comma  and  the  single letter abbreviation.  Alternatively,
	  the abbreviations can be entered in  subsequent  lines,  but
	  again  the full spelling should appear first and be followed
	  by its longest abbreviation.

	  A single digit can appear at the right end of each  line  to
	  indicate  the  type  of argument list which the words in the
	  line are to accept if recognized by  DAHEST.   The  argument
	  description digit is assumed to be zero if no digit is found
	  at the right end of the line.  The line can end with a comma
	  if  the  argument description digit is not required, but the
	  rightmost character of the rightmost word on the line  is  a
	  digit.   The  DATA  statements describing the argument types
	  are generated only if  at  least  one  argument  description
	  digit  is  found.   The  values 0 through 9 specified by the
	  digits 0 through 9 appearing at the right end of a  line  in
	  FASP, FORTRAN Alphameric Subroutine Package         Page 164
	  DAHEST, Parser for Simple Commands to Interactive Programs


	  the input file, if used in the LEGAL array for either DAHEST
	  or DAIHST, would select  the  following  variations  in  the
	  argument lists accepted by the corresponding words

	    0  (or absent number) will not allow the  word  to  accept
	       any arguments.

	    1  allows the word to accept  multiple  arguments  of  the
	       same type as its first argument.

	    2  allows the word to accept multiple word arguments.

	    3  allows the word to accept multiple numeric arguments.

	    4  allows  the  word  to  accept  multiple   text   string
	       arguments.

	    5, 6, 7 or 8, same as  1, 2, 3 or 4  respectively,  except
	       that numbers if found are returned as reals.

	    9  allows the word to accept multiple text  strings  which
	       begin   with  any  characters  which  cannot  serve  as
	       punctuation, but not  to  accept  any  other  types  of
	       arguments.

	  The input file is terminated by a line which either is empty
	  or contains only a leading number.

	  For example, if  the  dictionary  is  to  contain  the  word
	  EXAMINE which is to

	       be identified by the number 135
	       be abbreviated as either EX or E
	       take multiple arguments of the same type as  its  first
	       argument

	  and the word EXCHANGE which is to

	       be identified by the number -8
	       not be abbreviated as either EX or E
	       take multiple numeric arguments

	  and if  the  names  of  the  variables  and  arrays  in  the
	  generated  DATA statements are to be MAXWRD, MAXKNT, IDNTFY,
	  IWORD, KNTLTR and LEGAL

	  then the input file would contain

	  THIS IS A COMMENT LINE
	  MAXWRD MAXKNT,IDNTFY IWORD KNTLTR LEGAL
	  135 EXAMINE,EX,E 1
	  -8,EXCHANGE,3
	  0
	  FASP, FORTRAN Alphameric Subroutine Package         Page 165
	  DAHEST, Parser for Simple Commands to Interactive Programs


	  or

	  THIS IS A COMMENT LINE
	  MAXWRD MAXKNT IDNTFY IWORD KNTLTR LEGAL
	  135 EXAMINE 1
	  135 EX 1
	  135 E 1
	  -8 EXCHANGE 3
	  0

	  The following  FORTRAN  comments  and  statements  would  be
	  generated  when  either of the above forms of the input file
	  are read.  The initial comment lines  stating  the  argument
	  types  are  generated  only  if at least one line contains a
	  rightmost non-zero digit.  Although  not  necessary  in  the
	  example, the extra arrays and the EQUIVALENCE statements are
	  generated to allow large arrays to be represented by several
	  DATA statements each of which defines a portion of the large
	  array.

	  CTHIS IS A COMMENT LINE
	  C
	  C     MULTIPLE  NUMERIC  LENGTH
	  C
	  C    135 DYNAMIC INTEGER  7 EXAMINE
	  C                         2 EX(AMINE)
	  C                         1 E(XAMINE)
	  C     -8 NUMBER  INTEGER  8 EXCHANGE
	  C
	        DIMENSION IDNTFY(4),IDNTF1(4)
	        DIMENSION IWORD (18),IWORD1(18)
	        DIMENSION KNTLTR(4),KNTLT1(4)
	        DIMENSION LEGAL (4),LEGAL1(4)
	  C
	        EQUIVALENCE (IDNTF1(1),IDNTFY(1))
	        EQUIVALENCE (IWORD1(1),IWORD(1))
	        EQUIVALENCE (KNTLT1(1),KNTLTR(1))
	        EQUIVALENCE (LEGAL1(1),LEGAL(1))
	  C
	  C     NUMBER OF CHARACTERS AND WORDS
	        DATA MAXWRD,MAXKNT/  18,   4/
	  C
	  C     NUMBER IDENTIFYING EACH COMMAND
	        DATA IDNTF1/135,135,135, -8/
	  C
	  C     LETTERS FORMING EACH COMMAND
	        DATA IWORD1/1HE,1HX,1HA,1HM,1HI,1HN,1HE,1HE,1HX,1HE,
	       1            1HE,1HX,1HC,1HH,1HA,1HN,1HG,1HE/
	  C
	  C     LENGTH OF EACH COMMAND
	        DATA KNTLT1/  7,  2,  1,  8/
	  C
	  C     TYPE OF ARGUMENT LIST
	        DATA LEGAL1/  1,  1,  1,  3/
	  FASP, FORTRAN Alphameric Subroutine Package         Page 166
	  DAJOIN, Free Format Fraction Evaluation Routine


	    DDDDD          AAA        JJ    OOOOO   IIIIII  NN    NN
	    DD   DD       AAAA        JJ   OO   OO    II    NNN   NN
	    DD    DD     AA AA        JJ  OO     OO   II    NNNN  NN
	    DD    DD    AA  AA        JJ  OO     OO   II    NN NN NN
	    DD    DD   AAAAAAA  JJ    JJ  OO     OO   II    NN  NNNN
	    DD   DD   AA    AA   JJ  JJ    OO   OO    II    NN   NNN
	    DDDDD    AA     AA    JJJJ      OOOOO   IIIIII  NN    NN

	        DAJOIN, Free Format Fraction Evaluation Routine
	        ------  ---- ------ -------- ---------- -------

	  DAJOIN interprets an array read by the calling program  with
	  a  multiple  of  an  A1 format and returns the values of the
	  possibly  signed  whole  numbers,  of  the  possibly  signed
	  fractions  and  of  the  mixed  numbers  represented  by the
	  characters in the array.   A  mixed  number  consists  of  a
	  possibly  signed whole number followed by one or more spaces
	  and/or tab characters and then by an unsigned fraction.  The
	  numbers forming the numerators and denominators of fractions
	  can contain decimal  points.   The  value  12.475  could  be
	  represented  as  12.1  1.5/4 since DAJOIN sums the values of
	  the leading number  and  the  following  unsigned  fraction.
	  However,  the representation 12.1+1.5/4 would be interpreted
	  as the value 12.1 followed by the value 0.375 which would be
	  returned by the next call to this routine.

	  A number can be followed  immediately  with  no  intervening
	  spaces  or  tabs  by  the  letter  E  and  a possibly signed
	  exponent.  A percent sign following the number implies  E-2,
	  trailing  letter  K implies E3 and trailing letter M implies
	  E6.  If an exponent is used with  either  a  fraction  or  a
	  mixed number, then the exponent must appear to the immediate
	  right  of  the  denominator  of  the  fraction  without  any
	  intervening spaces or tab characters.  The value -1500 could
	  be represented in any of the following forms

	  -1500   -1.5K   -1 1/2K   -3/2K   -1.5E3   -1 1/2E3   -3/2E3

	  Evaluation of a number is terminated whenever an exponent is
	  found.   The buffer contents -1K 1/2 would be interpreted as
	  the number -1000 followed by the fraction +1/2  which  would
	  be  returned  by  the next call to this routine.  The buffer
	  contents -1 1K/2 would be treated as containing  the  number
	  -1  followed  by the numbers +1000 and 0 (evaluated as +0/2)
	  which would be returned by the next 2 calls to this routine.

	  Fractions can have more than a single  denominator.   If  an
	  exponent  is included with a fraction containing more than a
	  single slash, then the exponent must appear to the immediate
	  right  of  the  rightmost  denominator.  For example, 1/2/3K
	  would have the value 166.666....   A  denominator  having  a
	  zero value is assumed instead to have the value 1 to prevent
	  division by zero.  Therefore, 2///3, 2/  and  -3/  would  be
	  evaluated as 0.66666...., 2 and -3 respectively.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 167
	  DAJOIN, Free Format Fraction Evaluation Routine


	                    The DAJOIN Argument List
	                    --- ------ -------- ----

	  The argument list of routine DAJOIN is

	        SUBROUTINE DAJOIN(ITRAIL,IBUFFR,MAXBFR,LOWBFR,KIND  ,
	       1    VALUE ,DIVISR,ISHIFT,JSHIFT)

	  with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR)

	  The following arguments are used for input and are  returned
	  unchanged.

	  ITRAIL = selects whether exponents are to be recognized.  If
	           not,  then  each number will terminate prior to the
	           exponent, and LOWBFR will be returned  pointing  to
	           the  letter  starting the exponent.  The subsequent
	           call to this routine will return KIND=2  indicating
	           that  an  illegal  character  has been found if the
	           calling program does not first increment the  value
	           of LOWBFR.

	         = -1, only exponents expressed in E notation  are  to
	           be  recognized.   The  returned  value will already
	           have  been  multiplied  by  10.0  raised   to   the
	           indicated  power.  The percent sign and the letters
	           K and M are to be treated the  same  as  any  other
	           alphabetic character.
	         = 0, no exponents are to be recognized.  Numbers will
	           be  terminated  prior  to  percent  signs or to the
	           letters E or K or M.
	         = 1,  percent  signs,  the  letters  K  and  M,   and
	           exponents  expressed  in  E notation, are all to be
	           recognized.  The returned value will  already  have
	           been  multiplied  by  10.0  raised to the indicated
	           power.

	  IBUFFR = input buffer array containing characters  typed  by
	           user,  read by a multiple of an A1 format, which is
	           to be searched for numbers.  IBUFFR then contains 1
	           character per computer storage location.

	  MAXBFR = subscript of the final (rightmost) location in  the
	           IBUFFR array which can be searched for a number.

	  The following argument must be set by  the  calling  program
	  before this routine is first called, and then is returned by
	  this routine describing the location of the first  character
	  in the input buffer not yet processed.

	  LOWBFR = subscript within the  IBUFFR  array  of  the  first
	           (leftmost)  character  which can be scanned for the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 168
	  DAJOIN, Free Format Fraction Evaluation Routine


	           representation of numbers.  If a number  is  found,
	           then  LOWBFR will be returned pointing to the first
	           character beyond the number which could not be part
	           of  the  number.   If  a  number is not found, then
	           LOWBFR will  be  returned  pointing  to  the  first
	           printing  character  (which  would  have  to  be  a
	           character other than a plus sign or a minus sign or
	           a  decimal  point or a slash or a digit), or beyond
	           the end of  the  buffer  if  the  buffer  does  not
	           contain  any printing characters at or to the right
	           of IBUFFR(LOWBFR).   LOWBFR  must  be  set  by  the
	           calling program before this routine is first called
	           to process the contents of the buffer,  and  should
	           not  be  changed  by  the  calling  program if this
	           routine locates a number.  If a printing  character
	           is  found  which  cannot  start  a number, then the
	           contents of the buffer should be processed by  some
	           other FASP routine, or at least the calling program
	           should increment the value of LOWBFR  by  1  before
	           again calling this routine.

	  The following arguments are used for  returning  information
	  to the calling program.  Their input values are ignored.

	  KIND   = returned describing the kind of item located in the
	           IBUFFR array.
	         = 1, no printing character was found  at  or  to  the
	           right   of   IBUFFR(LOWBFR).   LOWBFR  is  returned
	           pointing beyond the end of the IBUFFR  array.   The
	           calling  program  should  read  a new line into the
	           IBUFFR array and reset LOWBFR to point to the first
	           character  in  this array before again calling this
	           routine.
	         = 2, a number was not found, but a printing character
	           which  cannot start a number was found at or to the
	           right of IBUFFR(LOWBFR).  LOWBFR will  be  returned
	           pointing  to  the  printing character.  The calling
	           program must increment the value of  LOWBFR  before
	           again calling this routine since supplying the same
	           initial character would produce identical  results.
	           DIVISR  is  returned containing 1 and VALUE, ISHIFT
	           and JSHIFT are set to zero if a number is not found
	           so  that  KIND  equal  1  or  2  can  be considered
	           equivalent to KIND=3 if such is appropriate to  the
	           application  for  which  DAJOIN  is being used.  It
	           should be noted that an exponent must  be  preceded
	           by  either  a digit or a sign or a decimal point if
	           it is to be  recognized.   KIND  will  be  returned
	           containing  2 if the first printing character at or
	           to the right of IBUFFR(LOWBFR) is a percent sign or
	           one of the letters E, K or M.
	         = 3 or 4 or 5, a number was found.   If  this  number
	           included a fraction, then the rightmost denominator
	           was present.  LOWBFR is returned  pointing  to  the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 169
	  DAJOIN, Free Format Fraction Evaluation Routine


	           character to the right of the representation of the
	           number.  If ITRAIL=0 and the number is followed  by
	           a  percent  sign  or  the  letters K, M or E, or if
	           ITRAIL is equal to -1 and the number is followed by
	           a  percent  sign or the letters K or M, then LOWBFR
	           will  be  returned  pointing   to   this   printing
	           character and no exponent will be evaluated.
	         = 3, a possibly signed whole number was  found  which
	           was not followed by a fraction.  DIVISR is returned
	           containing one.  LOWBFR is returned pointing to the
	           character to the immediate right of the number.
	         = 4, a mixed number consisting of a  possibly  signed
	           whole  number  followed by an unsigned fraction was
	           found.   LOWBFR  is  returned   pointing   to   the
	           character to the immediate right of the fraction.
	         = 5, a possibly signed fraction was found  which  was
	           not preceded by a whole number.  LOWBFR is returned
	           pointing to the character to the immediate right of
	           the fraction.
	         = 6, a mixed number or fraction was  found  in  which
	           the  rightmost  denominator was missing.  LOWBFR is
	           returned pointing to the character to the immediate
	           right  of the rightmost slash in the fraction.  The
	           fraction representation 1/2/3/ would return KIND=6,
	           VALUE=0.16666.... and DIVISR=3.

	  VALUE  = returned containing the value of the number if KIND
	           is  returned  containing  3 or greater.  This value
	           has been multiplied by 10.0  raised  to  the  power
	           indicated   by  the  exponent  if  any.   VALUE  is
	           returned set to zero if a number is not found.

	  DIVISR = returned containing  the  value  of  the  rightmost
	           denominator  which  is specified in a fraction or a
	           mixed number.  The returned value of DIVISR has not
	           been  multiplied  by the power of 10.0 indicated by
	           the exponent if any.  DIVISR is returned set to one
	           if  a  number is not found, or if a number is found
	           which does not contain a fraction, or if a fraction
	           is  found  in which a denominator is not specified.
	           The value 0.666666.... represented  as  2/3/  would
	           return  DIVISR  containing  3,  while  the  value 2
	           represented as 2/ would return DIVISR containing 1.

	  ISHIFT = if a number  is  found,  then  ISHIFT  is  returned
	           describing which of the characters E, %, K or M, if
	           any, appeared in the number specification.   ISHIFT
	           is returned set to zero if a number is not found.
	         = -4, the number was followed by the  letter  E,  but
	           neither  sign  nor digits appeared in the exponent.
	           JSHIFT is returned zeroed.  No  exponent  has  been
	           applied to the returned value.
	         = -3, the number was followed by  the  letter  E  and
	           then by a minus sign, but no digits appeared in the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 170
	  DAJOIN, Free Format Fraction Evaluation Routine


	           exponent.  JSHIFT is returned zeroed.  No  exponent
	           has been applied to the returned value.
	         = -2, the number was followed by  the  letter  E  and
	           then  by a plus sign, but no digits appeared in the
	           exponent.  JSHIFT is returned zeroed.  No  exponent
	           has been applied to the returned value.
	         = -1, the number was followed by  the  letter  E  and
	           then  by  the number which is returned as the value
	           of JSHIFT.
	         = 0, returned if none of the characters E, %, K or  M
	           follow  the  number.  JSHIFT is returned containing
	           0.
	         = 1, the number  was  followed  by  a  percent  sign.
	           JSHIFT is returned containing -2.
	         = 2, the number was followed by the letter K.  JSHIFT
	           is returned containing 3.
	         = 3, the number was followed by the letter M.  JSHIFT
	           is returned containing 6.

	  JSHIFT = if a number  is  found,  then  JSHIFT  is  returned
	           containing  the  value of the exponent evaluated at
	           the right end of the  number  representation.   The
	           returned  value  will  have been multiplied by 10.0
	           raised to the power returned  in  JSHIFT.   If  the
	           letter  E  follows  the  number, then JSHIFT is the
	           number appearing to the right of the letter  E,  or
	           is returned containing zero if no digits were found
	           to the right of  the  letter  E.   If  one  of  the
	           characters %, K or M follow the number, then JSHIFT
	           is returned containing -2, 3  and  6  respectively.
	           JSHIFT  is  returned set to zero if a number is not
	           found.


	                An Example of the Use of DAJOIN
	                -- ------- -- --- --- -- ------

	  The  sample  program  listed  below  displays   the   values
	  represented by a line of text typed by the user.  Each value
	  is displayed to  the  right  of  the  original  fraction  as
	  reconstructed from the denominator and the exponent if any.

	        DIMENSION IBUFFR(72),JBUFFR(50)
	        DATA ISLASH,IEXPNT,IGREAT,IEQUAL,ISPACE/
	       11H/,1HE,1H>,1H=,1H /
	        DATA ITTY,JTTY/5,5/
	        WRITE(JTTY,1)
	      1 FORMAT(8H ITRAIL ,$)
	        READ(ITTY,2)ITRAIL
	      2 FORMAT(I)
	      3 WRITE(JTTY,4)
	      4 FORMAT(2H *,$)
	        READ(ITTY,5)IBUFFR
	      5 FORMAT(72A1)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 171
	  DAJOIN, Free Format Fraction Evaluation Routine


	        LOWBFR=1
	  C
	  C     EVALUATE NEXT NUMBER IN TEXT
	      6 INIBFR=LOWBFR
	        CALL DAJOIN(ITRAIL,IBUFFR,72,LOWBFR,KIND,
	       1VALUE,DIVISR,ISHIFT,JSHIFT)
	        IF(KIND.EQ.1)GO TO 3
	        IF(KIND.EQ.2)GO TO 9
	        J=LOWBFR-1
	        IF(J.GE.INIBFR)WRITE(JTTY,7)(IBUFFR(I),I=INIBFR,J),
	       1IGREAT
	      7 FORMAT(2H <,132A1)
	  C
	  C     CONSTRUCT DESCRIPTION OF DENOMINATOR AND OF EXPONENT
	        KOUNT=0
	        FRCTN=(VALUE*DIVISR)/(10.0**JSHIFT)
	        CALL DASHOW(1,0,6,1,6,
	       15,IVALUE,FRCTN,50,KOUNT,JBUFFR,IERR)
	        KOUNT=KOUNT+1
	        JBUFFR(KOUNT)=ISLASH
	        CALL DASHOW(1,0,6,1,6,
	       15,IVALUE,DIVISR,50,KOUNT,JBUFFR,IERR)
	        IF(JSHIFT.EQ.0)GO TO 8
	        KOUNT=KOUNT+1
	        JBUFFR(KOUNT)=IEXPNT
	        CALL DASHOW(0,0,6,0,6,
	       15,JSHIFT,VALUE,50,KOUNT,JBUFFR,IERR)
	      8 KOUNT=KOUNT+3
	        JBUFFR(KOUNT-2)=ISPACE
	        JBUFFR(KOUNT-1)=IEQUAL
	        JBUFFR(KOUNT)=ISPACE
	        CALL DASHOW(1,0,6,1,6,
	       15,IVALUE,VALUE,50,KOUNT,JBUFFR,IERR)
	  C
	  C     DESCRIBE THE RESULT, DENOMINATOR AND EXPONENT
	        GO TO(3,9,11,13,15,17),KIND
	      9 WRITE(JTTY,10)IBUFFR(LOWBFR)
	     10 FORMAT(10H  UNKNOWN ,1A1)
	        LOWBFR=LOWBFR+1
	        GO TO 6
	     11 WRITE(JTTY,12)(JBUFFR(I),I=1,KOUNT)
	     12 FORMAT(8H  WHOLE ,50A1)
	        GO TO 6
	     13 WRITE(JTTY,14)(JBUFFR(I),I=1,KOUNT)
	     14 FORMAT(8H  MIXED ,50A1)
	        GO TO 6
	     15 WRITE(JTTY,16)(JBUFFR(I),I=1,KOUNT)
	     16 FORMAT(8H  FRCTN ,50A1)
	        GO TO 6
	     17 WRITE(JTTY,18)(JBUFFR(I),I=1,KOUNT)
	     18 FORMAT(8H  ABSNT ,50A1)
	        GO TO 6
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 172
	  DAJOIN, Free Format Fraction Evaluation Routine


	  Typical Dialog Between DAJOIN Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  ITRAIL 1
	  *1 2 3     1 2/3     1/2/3
	  <1>
	   WHOLE 1/1 = 1
	  < 2>
	   WHOLE 2/1 = 2
	  < 3>
	   WHOLE 3/1 = 3
	  <     1 2/3>
	   MIXED 5/3 = 1.66667
	  <     1/2/3>
	   FRCTN .5/3 = .166667
	  *1K 2/3    1 2K/3    1 2/3K
	  <1K>
	   WHOLE 1/1E3 = 1000
	  < 2/3>
	   FRCTN 2/3 = .666667
	  <    1>
	   WHOLE 1/1 = 1
	  < 2K>
	   WHOLE 2/1E3 = 2000
	  </3>
	   FRCTN 0/3 = 0
	  <    1 2/3K>
	   MIXED 5/3E3 = 1666.67
	  *-12 3/4   -12-3/4   -12 3/-4
	  <-12 3/4>
	   MIXED -51/4 = -12.75
	  <   -12>
	   WHOLE -12/1 = -12
	  <-3/4>
	   FRCTN -3/4 = -.75
	  <   -12 3/>
	   ABSNT -15/1 = -15
	  <-4>
	   WHOLE -4/1 = -4
	  *12.4,     12.4//    43.4//3.5//
	  <12.4>
	   WHOLE 12.4/1 = 12.4
	   UNKNOWN ,
	  <     12.4//>
	   ABSNT 12.4/1 = 12.4
	  <    43.4//3.5//>
	   ABSNT 43.4/3.5 = 12.4
	  FASP, FORTRAN Alphameric Subroutine Package         Page 173
	  DALEAD, Identify Command and Trailing Word, Number or String


	  DDDDD         AAA   LL        EEEEEEEE        AAA   DDDDD
	  DD   DD      AAAA   LL        EE             AAAA   DD   DD
	  DD    DD    AA AA   LL        EE            AA AA   DD    DD
	  DD    DD   AA  AA   LL        EEEEE        AA  AA   DD    DD
	  DD    DD  AAAAAAA   LL        EE          AAAAAAA   DD    DD
	  DD   DD  AA    AA   LL        EE         AA    AA   DD   DD
	  DDDDD   AA     AA   LLLLLLLL  EEEEEEEE  AA     AA   DDDDD



	  DALEAD, Identify Command and Trailing Word, Number or String
	  ------  -------- ------- --- -------- ----  ------ -- ------

	  DALEAD identifies to the calling program a command word  and
	  an   associated   word  or  number  or  quoted  text  string
	  represented by the characters in an input buffer read by the
	  calling  program  with  a  multiple  of  an  A1 format.  The
	  calling program supplies to DALEAD two separate dictionaries
	  which  identify  all possible command words and all possible
	  associated words.  Any abbreviation which is  unique  across
	  both  dictionaries  is allowed.  A word or word abbreviation
	  must be followed by a known delimiter character such as  the
	  blank,  tab, comma, apostrophe, semicolon, exclamation point
	  or ampersand, or by an end of line.  The appearance  of  any
	  other  character  following  a  word or word abbreviation is
	  considered to be an  error  and  causes  the  word  or  word
	  abbreviation  and  the following characters to be identified
	  as an unknown sequence of characters.  A quoted text  string
	  includes   the   characters  to  the  right  of  an  initial
	  apostrophe and extends to the second unpaired apostrophe  or
	  through  the  rightmost  printing character in the line if a
	  second  unpaired  apostrophe  is  not  found.   A  pair   of
	  apostrophes  within  the string indicates the inclusion of a
	  single apostrophe and the extra apostrophe is removed.   Any
	  character  (except  of course another apostrophe) can follow
	  the second unpaired apostrophe which marks the right end  of
	  a quoted text string.  A number is terminated to the left of
	  any character which could not logically extend the number.

	  If the leftmost printing characters in the buffer  (ignoring
	  leading  commas) form an associated word or its abbreviation
	  or form a number or quoted text  string,  then  the  command
	  word identified by the previous call to this routine and the
	  new associated word or number  or  quoted  text  string  are
	  identified   to   the  calling  program.   If  the  printing
	  characters  in  the  buffer  form  a  command  word  or  its
	  abbreviation  followed  to  its  right by spaces and/or tabs
	  and/or  commas  and  then  by  an  associated  word  or  its
	  abbreviation or by a number or by a quoted text string, then
	  the new command word and the new associated word  or  number
	  or quoted text string are identified to the calling program.
	  If a command word or its abbreviation is followed by  spaces
	  and/or  tabs and/or commas and then by a second command word
	  or its abbreviation, then the first command is identified by
	  FASP, FORTRAN Alphameric Subroutine Package         Page 174
	  DALEAD, Identify Command and Trailing Word, Number or String


	  the  current call to this routine, and the second command is
	  identified by the subsequent call.

	  The range of a command is the sequence of  associated  words
	  and/or  numbers  and/or  quoted  text  strings for which the
	  command continues to be identified by this routine if a  new
	  command  is not encountered.  The range of a command extends
	  to the next appearance  of  another  command,  to  the  next
	  appearance  of  a  semicolon or exclamation point, or to the
	  end of a line not preceded by an ampersand.  An  exclamation
	  point  and  any  characters  to  its right are taken to be a
	  comment and are ignored.  An ampersand and any characters to
	  its  right  are  similarly ignored, but the associated words
	  and/or numbers and/or quoted text strings at  the  start  of
	  the  next  text  read  into  the  buffer  and interpreted by
	  subsequent calls to this routine are within the range of the
	  command in effect when the ampersand was encountered.  Words
	  and numbers cannot extend  across  commas,  but  commas  are
	  otherwise  ignored.   Semicolons are reported to the calling
	  program.



	                    The DALEAD Argument List
	                    --- ------ -------- ----

	  The argument list of routine DALEAD is

	        SUBROUTINE DALEAD(INITYP,NXTTYP,ITRAIL,KWRDLO,KWRDHI,
	       1    KWORD ,KCNTLO,KCNTHI,KCOUNT,NUMTYP,LWRDLO,LWRDHI,
	       2    LWORD ,LCNTLO,LCNTHI,LCOUNT,IBUFFR,MAXBFR,LOWBFR,
	       3    KIND  ,KOMAND,KWRDID,KCNTID,LOCAL ,LWRDID,LCNTID,
	       4    INITAL,IVALUE,VALUE ,IFLOAT)

	  with the associated DIMENSION statement

	        DIMENSION KWORD(KWRDHI),KCOUNT(KCNTHI),
	       1NUMTYP(KCNTHI),LWORD(LWRDHI),LCOUNT(LCNTHI),
	       2IBUFFR(MAXBFR)

	  The following arguments are used for  input  only,  and  are
	  returned  unchanged.   ITRAIL  is  identical  to  the DAHEFT
	  argument having the same name.  The  dictionary  of  command
	  words  is  defined  by KWRDLO, KWRDHI, KWORD, KCNTLO, KCNTHI
	  and KCOUNT which  are  identical  to  the  DAVERB  arguments
	  LOWWRD,   MAXWRD,   IWORD,   LOWKNT,   MAXKNT   and   KNTLTR
	  respectively.   The  dictionary  of  associated   words   is
	  similarly  defined  by LWRDLO, LWRDHI, LWORD, LCNTLO, LCNTHI
	  and LCOUNT.

	  INITYP = if the representation of a number is found  outside
	           the  range  of  a  command,  then  INITYP specifies
	           whether the value is to be returned as the  integer
	           argument IVALUE or as the real argument VALUE.  The
	  FASP, FORTRAN Alphameric Subroutine Package         Page 175
	  DALEAD, Identify Command and Trailing Word, Number or String


	           number can be typed with a decimal point and/or  an
	           exponent regardless of the value of INITYP.
	         = -2, if the representation  of  a  number  is  found
	           outside  the range of a command, then it is treated
	           as an unknown sequence of characters, and  KIND  is
	           returned containing the value 7.
	         = -1, the value is calculated as an octal integer and
	           returned  as  the  argument  IVALUE.   However, the
	           number following the letter E  of  an  exponent  is
	           evaluated in decimal.
	         = 0, the value is calculated as a decimal integer and
	           is returned as the argument IVALUE.
	         = 1 or greater, the value is  returned  as  the  real
	           argument  VALUE.  If possible, the real number will
	           be accumulated as an integer, then be converted  to
	           real  and  shifted  as  necessary.   INITYP  is the
	           maximum number of digits in the integer.

	  NXTTYP = if the representation of a number is  found  within
	           the  range  of  a  command,  then  NXTTYP specifies
	           whether the value is to be returned as the  integer
	           argument IVALUE or as the real argument VALUE.  The
	           number can be typed with a decimal point and/or  an
	           exponent regardless of the value of NXTTYP.
	         = -3, whether the number is interpreted as  an  octal
	           integer  or  as  a  decimal integer or as a decimal
	           real, and whether the  value  is  returned  in  the
	           argument IVALUE or VALUE is specified by the NUMTYP
	           array entry having the same subscript as the KCOUNT
	           array  entry containing the number of characters in
	           the command.  The calling program must  not  change
	           the  value  of KCNTID returned by the previous call
	           to this routine if NXTTYP is set to -3.
	         = -2, if the representation  of  a  number  is  found
	           within  the  range of a command, then it is treated
	           as an unknown sequence of characters, and  KIND  is
	           returned  containing  the  value  7 or 14 depending
	           upon whether  a  command  word  was  found  by  the
	           current call to this routine.
	         = -1, the value is calculated as an octal integer and
	           returned  as  the  argument  IVALUE.   However, the
	           number following the letter E  of  an  exponent  is
	           evaluated in decimal.
	         = 0, the value is calculated as a decimal integer and
	           is returned as the argument IVALUE.
	         = 1 or greater, the value is  returned  as  the  real
	           argument  VALUE.  If possible, the real number will
	           be accumulated as an integer, then be converted  to
	           real  and  shifted  as  necessary.   NXTTYP  is the
	           maximum number of digits in the integer.

	  ITRAIL = selects whether exponents are to be recognized.  If
	           not,  then  each number will terminate prior to the
	           exponent, and LOWBFR will be returned  pointing  to
	  FASP, FORTRAN Alphameric Subroutine Package         Page 176
	  DALEAD, Identify Command and Trailing Word, Number or String


	           the letter starting the exponent.
	         = -1, exponents expressed in E  notation  are  to  be
	           recognized,  but the percent sign and the letters K
	           and M are to be  treated  the  same  as  any  other
	           alphabetic characters.
	         = 0, no exponents are to be recognized.  Numbers will
	           be  terminated  prior  to  percent  signs or to the
	           letters E or K or M.
	         = 1,  percent  signs,  the  letters  K  and  M,   and
	           exponents  expressed  in  E  notation are all to be
	           recognized.

	  KWRDLO = subscript  of  the  location  in  the  KWORD  array
	           containing the first character of the first command
	           word which can be recognized.

	  KWRDHI = subscript  of  the  location  in  the  KWORD  array
	           containing the final character of the final command
	           word which can be recognized.

	  KWORD  = array containing  the  characters  of  the  command
	           words  which  can  be  recognized,  1 character per
	           array location as though read by a multiple  of  an
	           A1  format  or  defined  by several 1H fields.  All
	           alphabetic letters within the KWORD array  must  be
	           supplied in upper case.

	  KCNTLO = subscript of  the  location  in  the  KCOUNT  array
	           containing  the  number  of characters in the first
	           command word which can be recognized.  If KCNTLO is
	           greater  than  KCNTHI, then no command words can be
	           recognized, causing  KIND  to  always  be  returned
	           containing 7 or less.

	  KCNTHI = subscript of  the  location  in  the  KCOUNT  array
	           containing  the  number  of characters in the final
	           command word which can be recognized.

	  KCOUNT = array  containing   in   locations   KCOUNT(KCNTLO)
	           through and including KCOUNT(KCNTHI) the numbers of
	           characters in each of  the  several  command  words
	           which  can  be recognized.  A negative entry in the
	           KCOUNT  array  causes  the  number  of   characters
	           indicated  by  the  absolute  value of the negative
	           number to  be  skipped  over  in  the  KWORD  array
	           without   forming  a  recognizable  word.   If  the
	           command word is formed  of  two  or  more  sections
	           which  can  be matched when separated by any number
	           of spaces or tab characters, then the  word  stored
	           in  the  KWORD array must contain a single space at
	           each of the locations in the word at which a  split
	           is  allowed,  and  the  length stored in the KCOUNT
	           array must be 100 more than the  actual  number  of
	           characters including the spaces which are stored in
	  FASP, FORTRAN Alphameric Subroutine Package         Page 177
	  DALEAD, Identify Command and Trailing Word, Number or String


	           the KWORD array.

	  NUMTYP = specifies the manner in which a number is evaluated
	           if  the number is within the range of a command and
	           if NXTTYP=-3.  Whether the number is interpreted as
	           an  octal  integer  or as a decimal integer or as a
	           decimal real, and whether the value is returned  in
	           the  argument  IVALUE  or VALUE is specified by the
	           NUMTYP array entry having the same subscript as the
	           KCOUNT   array   entry  containing  the  number  of
	           characters in the command.  If  NXTTYP  is  greater
	           than  -3,  then  the  NUMTYP array is ignored.  The
	           values of the individual entries within the  NUMTYP
	           array   are  defined  similarly  to  those  of  the
	           nondimensioned   argument   NXTTYP   (other    than
	           NXTTYP=-3) and are as follow
	         = -2, if the representation  of  a  number  is  found
	           within  the  range of a command, then it is treated
	           as an unknown sequence of characters, and  KIND  is
	           returned  containing  the  value  7 or 14 depending
	           upon whether  a  command  word  was  found  by  the
	           current call to this routine.
	         = -1, the value is calculated as an octal integer and
	           returned  as  the  argument  IVALUE.   However, the
	           number following the letter E  of  an  exponent  is
	           evaluated in decimal.
	         = 0, the value is calculated as a decimal integer and
	           is returned as the argument IVALUE.
	         = 1 or greater, the value is  returned  as  the  real
	           argument  VALUE.  If possible, the real number will
	           be accumulated as an integer, then be converted  to
	           real  and  shifted as necessary.  NUMTYP(KCNTID) is
	           the maximum number of digits in the integer.

	  LWRDLO = subscript  of  the  location  in  the  LWORD  array
	           containing   the   first  character  of  the  first
	           associated word which can be recognized.

	  LWRDHI = subscript  of  the  location  in  the  LWORD  array
	           containing   the   final  character  of  the  final
	           associated word which can be recognized.

	  LWORD  = array containing the characters of  the  associated
	           words  which  can  be  recognized,  1 character per
	           array location as though read by a multiple  of  an
	           A1  format  or  defined  by several 1H fields.  All
	           alphabetic letters within the LWORD array  must  be
	           supplied in upper case.

	  LCNTLO = subscript of  the  location  in  the  LCOUNT  array
	           containing  the  number  of characters in the first
	           associated word which can be recognized.  If LCNTLO
	           is  greater  than  LCNTHI, then no associated words
	           can be recognized so that KIND cannot  be  returned
	  FASP, FORTRAN Alphameric Subroutine Package         Page 178
	  DALEAD, Identify Command and Trailing Word, Number or String


	           with either of the values 4 or 11.

	  LCNTHI = subscript of  the  location  in  the  LCOUNT  array
	           containing  the  number  of characters in the final
	           associated word which can be recognized.

	  LCOUNT = array  containing   in   locations   LCOUNT(LCNTLO)
	           through and including LCOUNT(LCNTHI) the numbers of
	           characters in each of the several associated  words
	           which  can  be recognized.  A negative entry in the
	           LCOUNT  array  causes  the  number  of   characters
	           indicated  by  the  absolute  value of the negative
	           number to  be  skipped  over  in  the  LWORD  array
	           without   forming  a  recognizable  word.   If  the
	           associated word is formed of two or  more  sections
	           which  can  be matched when separated by any number
	           of spaces or tab characters, then the  word  stored
	           in  the  LWORD array must contain a single space at
	           each of the locations in the word at which a  split
	           is  allowed,  and  the  length stored in the LCOUNT
	           array must be 100 more than the  actual  number  of
	           characters including the spaces which are stored in
	           the LWORD array.

	  IBUFFR = input buffer array, containing characters typed  by
	           the  user  and  read by a multiple of an A1 format,
	           which is to be searched for  known  command  words,
	           known  associated  words,  numbers  and quoted text
	           strings.  IBUFFR  then  contains  1  character  per
	           computer  storage location.  The alphabetic letters
	           forming the command  words,  associated  words  and
	           numeric  exponents  which  appear within the IBUFFR
	           array can be either upper or lower case.  IBUFFR is
	           returned  modified if a quoted text string is found
	           which contains a pair of apostrophes  indicating  a
	           single  apostrophe within the string or if a quoted
	           text string is  found  which  is  terminated  by  a
	           second unpaired apostrophe.

	  MAXBFR = subscript of the final (rightmost) location in  the
	           IBUFFR array which can be searched for known words,
	           numbers and quoted text strings.

	  The following arguments must be set by the  calling  program
	  before  this  routine  is first called, then are returned by
	  this routine  containing  information  to  be  used  by  the
	  calling  program and, usually, to be passed unchanged to the
	  subsequent call to this routine.

	  LOWBFR = should be input containing the subscript within the
	           IBUFFR  array  of  the  first  (leftmost) character
	           which can be scanned for known  words  and  numbers
	           and   quoted  text  strings.   LOWBFR  is  returned
	           containing  the  subscript  of  the  IBUFFR   array
	  FASP, FORTRAN Alphameric Subroutine Package         Page 179
	  DALEAD, Identify Command and Trailing Word, Number or String


	           location to the right of the rightmost character of
	           the rightmost identified item.  If  a  quoted  text
	           string  is  found, then LOWBFR is returned pointing
	           to the character to  the  right  of  the  rightmost
	           character  within  the  string,  rather than to the
	           character to  the  right  of  the  second  unpaired
	           apostrophe.   If  the  quoted  text  string was not
	           terminated by a second  unpaired  apostrophe,  then
	           LOWBFR is returned pointing to the character to the
	           right of the rightmost printing  character  in  the
	           buffer.   If  the quoted text string was terminated
	           with  a  second  unpaired  apostrophe,  then   this
	           apostrophe  is  changed to a space which is pointed
	           to by the returned value of LOWBFR.  If an  unknown
	           sequence of printing characters, or a known word or
	           abbreviation followed by  an  unknown  sequence  of
	           printing  characters,  is  found,  then  LOWBFR  is
	           returned pointing to the character to the right  of
	           the  unknown  sequence.   If  a new command word is
	           followed by spaces and/or tabs  and/or  commas  and
	           then  by  a second new command word, then LOWBFR is
	           returned containing the  subscript  of  the  IBUFFR
	           array  location  which contains the first character
	           of the second  command  word  which  will  then  be
	           identified  by the subsequent call to this routine.
	           If an exclamation point or ampersand is found, then
	           LOWBFR  is  returned  containing  MAXBFR+1.  LOWBFR
	           must be reset by the calling program  to  point  to
	           the  leftmost  character  in  the IBUFFR array each
	           time new text is read into this array.

	  KIND   = input containing 0, this routine has not  yet  been
	           called  during the execution of the current logical
	           section of the calling program.  This routine is to
	           begin  evaluation of the contents of the input text
	           buffer, not continue the range of  a  command  word
	           identified by a previous call to this routine.  The
	           following  values  of  KIND  are  returned  to  the
	           calling  program  describing  the  type  of item or
	           items located in the IBUFFR  array.   Except  where
	           mentioned  below,  these  values are usually passed
	           unchanged to the subsequent call to this routine.
	         = 1, either the input buffer was empty, or  else  the
	           next  printing  character  at  or  to  the right of
	           IBUFFR(LOWBFR), ignoring commas, was an exclamation
	           point.   LOWBFR is returned pointing beyond the end
	           of the buffer.  It is  expected  that  the  calling
	           program  will  read  new text into the input buffer
	           and reset LOWBFR to point to the first character in
	           the  buffer  before  again  calling  this  routine.
	           Unless KIND is changed to 3 by the calling program,
	           the  subsequent  call  to  this routine will return
	           KOMAND  zeroed  if  a  new  command  word  is   not
	           identified.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 180
	  DALEAD, Identify Command and Trailing Word, Number or String


	         = 2, the next printing character at or to  the  right
	           of   IBUFFR(LOWBFR),   ignoring   commas,   was   a
	           semicolon.  LOWBFR  is  returned  pointing  to  the
	           character  to  the  right  of  the  semicolon.  The
	           subsequent call to this routine will return  KOMAND
	           zeroed if a new command word is not identified.
	         = 3, the next printing character at or to  the  right
	           of   IBUFFR(LOWBFR),   ignoring   commas,   was  an
	           ampersand.  LOWBFR is returned containing MAXBFR+1.
	           It  is  expected that the calling program will read
	           new text into the input buffer and reset LOWBFR  to
	           point  to  the first character in the buffer before
	           again calling this routine.  Unless KIND is changed
	           to 1 by the calling program, the subsequent call to
	           this routine will  return  the  values  of  KOMAND,
	           KWRDID  and  KCNTID unchanged if a new command word
	           is not identified.
	         = 4, the next printing characters at or to the  right
	           of IBUFFR(LOWBFR), ignoring commas except for their
	           use as  word  separators,  uniquely  identified  an
	           associated  word in the dictionary contained in the
	           LWORD and LCOUNT arrays.  The  sequence  number  of
	           the  identified  word among all possible associated
	           words is returned as the argument LOCAL.  LWRDID is
	           returned  containing  the  subscript  of  the LWORD
	           array location containing the  first  character  of
	           the  word,  and  LCNTID  is returned containing the
	           subscript of the LCOUNT array  location  containing
	           the  number  of characters within the word.  INITAL
	           is returned containing the subscript of the  IBUFFR
	           array  location  which contains the first character
	           of  the  associated  word  or  abbreviation  of  an
	           associated  word.   LOWBFR  is returned pointing to
	           the character to the right  of  the  word  or  word
	           abbreviation.   The subsequent call to this routine
	           will return the values of KOMAND, KWRDID and KCNTID
	           unchanged if a new command word is not identified.
	         = 5, the next printing characters at or to the  right
	           of IBUFFR(LOWBFR), ignoring commas except for their
	           use as number separators,  formed  a  number.   The
	           value  of  the  number  is returned in the argument
	           IVALUE if evaluated as an octal  integer  or  as  a
	           decimal  integer,  or  in  the  argument  VALUE  if
	           evaluated as a decimal real.   INITAL  is  returned
	           containing   the  subscript  of  the  IBUFFR  array
	           location which contains the first character of  the
	           number.    LOWBFR   is  returned  pointing  to  the
	           character  to  the  right  of  the   number.    The
	           subsequent  call  to  this  routine will return the
	           values of KOMAND, KWRDID and KCNTID unchanged if  a
	           new command word is not identified.
	         = 6, the next printing character at or to  the  right
	           of  IBUFFR(LOWBFR), ignoring leading commas, was an
	           apostrophe which is  pointed  to  by  the  returned
	  FASP, FORTRAN Alphameric Subroutine Package         Page 181
	  DALEAD, Identify Command and Trailing Word, Number or String


	           value  of  INITAL.   LOWBFR is returned pointing to
	           the  character  to  the  right  of  the   rightmost
	           character  within  the  quoted text string.  If the
	           quoted text string is not terminated by an unpaired
	           apostrophe, then LOWBFR is returned pointing to the
	           character to the right of  the  rightmost  printing
	           character in the buffer.  If the quoted text string
	           is terminated by an unpaired apostrophe, then  this
	           apostrophe  is changed to a space pointed to by the
	           returned value of LOWBFR.  If a  pair  of  adjacent
	           apostrophes is found within the quoted text string,
	           then the portion of the quoted text string  to  the
	           right  of  the  pair of apostrophes is moved to the
	           left overwriting the second apostrophe of the pair,
	           and LOWBFR is returned pointing to the character to
	           the right of the rightmost character of the  quoted
	           text  string  in  its  new  location.  The location
	           vacated by the rightmost character is filled with a
	           space after the shift is complete.
	         = 7, the next printing characters at or to the  right
	           of IBUFFR(LOWBFR), ignoring commas except for their
	           use as character  sequence  separators,  formed  an
	           unknown  sequence.   This value of KIND is returned
	           also if a word or word abbreviation is  not  unique
	           across  both  dictionaries, or if a command word or
	           its abbreviation  or  an  associated  word  or  its
	           abbreviation  is  followed  by  any character other
	           than a space, tab,  comma,  apostrophe,  semicolon,
	           exclamation point or ampersand.  INITAL is returned
	           containing  the  subscript  of  the  IBUFFR   array
	           location  which contains the first character of the
	           unknown sequence or of  the  word  or  abbreviation
	           which  is  followed by an unknown sequence.  LOWBFR
	           is returned pointing to the following  space,  tab,
	           comma,  apostrophe, semicolon, exclamation point or
	           ampersand or beyond the end  of  the  line  if  the
	           unknown  printing characters extend through the end
	           of the line.  The subsequent call to  this  routine
	           will return the values of KOMAND, KWRDID and KCNTID
	           unchanged if a new command word is not identified.
	         = 8 through 14, same  as  KIND  values  1  through  7
	           respectively   except   that   a  command  word  or
	           abbreviation was recognized prior  to  the  end  of
	           line (8), semicolon (9), ampersand (10), associated
	           word (11), number (12), quoted text string (13)  or
	           unknown  sequence (14).  The sequence number of the
	           identified command among all possible  commands  is
	           returned   as   the  argument  KOMAND.   KWRDID  is
	           returned containing  the  subscript  of  the  KWORD
	           array  location  containing  the first character of
	           the command, and KCNTID is returned containing  the
	           subscript  of  the KCOUNT array location containing
	           the number of characters within the  command.   The
	           following additional information should be noted.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 182
	  DALEAD, Identify Command and Trailing Word, Number or String


	         = 8, a command word extended  through  the  rightmost
	           printing  characters  in the line, or else the next
	           printing character to the right of a command  word,
	           ignoring  commas  except  for  their  use  as  word
	           separators, was an exclamation point.  Unless  KIND
	           is  changed  to  10  by  the  calling  program, the
	           subsequent call to this routine will return  KOMAND
	           zeroed unless a new command is found.
	         = 10, the next printing character to the right  of  a
	           command  word, ignoring commas except for their use
	           as word separators, was an ampersand.  The  calling
	           program  should read new text into the input buffer
	           and the subsequent call to this routine is then  to
	           continue  the  interpretation  of  the  new text as
	           though this command word appeared at the  start  of
	           the  new  contents  of  the buffer.  Unless KIND is
	           changed to 8 by the calling program, the subsequent
	           call to this routine will return KOMAND, KWRDID and
	           KCNTID unchanged and will return KIND greater  than
	           7.
	         = 15, ignoring commas except for their  use  as  word
	           terminators, a command word or its abbreviation was
	           followed by spaces and/or tabs  and/or  commas  and
	           then  by a second command word or its abbreviation.
	           The first command is  identified  by  the  returned
	           values  of  KOMAND,  KWRDID  and KCNTID.  LOWBFR is
	           returned pointing to the  first  character  of  the
	           second   command   word   which  will  in  turn  be
	           identified by the subsequent call to this  routine.
	           If KIND was input containing the value 10, then the
	           second command word is of course actually the first
	           to appear in the current contents of the buffer.

	  The following arguments are returned to the calling  program
	  identifying  the command word found by this routine or which
	  is still in effect from the previous call to  this  routine.
	  The previous command is still in effect and the input values
	  of these arguments are returned unchanged if KIND  is  input
	  with  a  value  other  than  0, 1, 2, 8 or 9, and if KIND is
	  returned with a value less than or equal to 7.

	  KOMAND = returned containing  the  sequence  number  of  the
	           current  command  word  among  all possible command
	           words.  The sequence number does  not  include  the
	           letters  skipped  over by the value of KWRDLO being
	           greater than 1, and does not  include  the  letters
	           skipped  over by negative values encountered in the
	           KCOUNT array.  KOMAND is the number  of  values  in
	           the  KCOUNT  array  which  are  greater  than  zero
	           starting at KCOUNT(KCNTLO) up to and including  the
	           KCOUNT  array location which contains the number of
	           letters in the command word which  is  successfully
	           matched.   KOMAND  is  returned  containing zero if
	           KIND is input containing 0, 1, 2, 8 or 9 indicating
	  FASP, FORTRAN Alphameric Subroutine Package         Page 183
	  DALEAD, Identify Command and Trailing Word, Number or String


	           that  the  range  of  the previous command is being
	           terminated, and if KIND is returned  less  than  or
	           equal  to  7  indicating  that  no  new command was
	           found.  KOMAND is returned  unchanged  if  KIND  is
	           input  containing  a value other than 0, 1, 2, 8 or
	           9, and if KIND is returned less than or equal to 7.

	  KWRDID = returned containing  the  subscript  of  the  KWORD
	           array  location  which contains the first character
	           of the matched command word.   KWRDID  is  returned
	           unchanged  if  the command identified by a previous
	           call to this routine is still in effect.

	  KCNTID = returned containing the  subscript  of  the  KCOUNT
	           array   location   which  contains  the  number  of
	           characters in the matched command word.  KCNTID  is
	           returned  unchanged  if the command identified by a
	           previous call to this routine is still in effect.

	  The following arguments are returned to the calling  program
	  identifying  the  associated  word found if KIND is returned
	  containing either 4 or 11.   These  arguments  are  returned
	  unchanged if KIND is returned with any value other than 4 or
	  11.

	  LOCAL  = returned containing  the  sequence  number  of  the
	           associated   word  among  all  possible  associated
	           words.  The sequence number does  not  include  the
	           letters  skipped  over by the value of LWRDLO being
	           greater than 1, and does not  include  the  letters
	           skipped  over by negative values encountered in the
	           LCOUNT array.  LOCAL is the number of values in the
	           LCOUNT  array  which are greater than zero starting
	           at LCOUNT(LCNTLO) up to and  including  the  LCOUNT
	           array location which contains the number of letters
	           in  the  associated  word  which  is   successfully
	           matched.

	  LWRDID = returned containing  the  subscript  of  the  LWORD
	           array  location  which contains the first character
	           of the matched associated word.

	  LCNTID = returned containing the  subscript  of  the  LCOUNT
	           array   location   which  contains  the  number  of
	           characters in the matched associated word.

	  The following arguments are used  only  for  output.   Their
	  input values are ignored.

	  INITAL = returned containing the  subscript  of  the  IBUFFR
	           array  location  which contains the first character
	           of an associated word (KIND returned as 4  or  11),
	           of  a  number  (KIND returned as 5 or 12), or of an
	           unknown sequence of characters (KIND returned as  7
	  FASP, FORTRAN Alphameric Subroutine Package         Page 184
	  DALEAD, Identify Command and Trailing Word, Number or String


	           or  14).   If  a  quoted text string is found (KIND
	           returned  containing  6  or  13),  then  INITAL  is
	           returned pointing to the apostrophe at the left end
	           of the string.

	  IVALUE = returned containing the value if a number is  found
	           (KIND  being  returned  containing  5 or 12) and is
	           evaluated as an  octal  integer  or  as  a  decimal
	           integer.

	  VALUE  = returned containing the value if a number is  found
	           (KIND  being  returned  containing  5 or 12) and is
	           evaluated as a decimal real.

	  IFLOAT = specifies how a number was  evaluated.   IFLOAT  is
	           returned  set  equal  to  INITYP  if  the number is
	           outside the range of a command,  or  set  equal  to
	           NXTTYP  if  the  number  is  within  the range of a
	           command and NXTTYP has a value greater than -3,  or
	           set  equal  to the entry in the NUMTYP array having
	           the same subscript as the KCOUNT array entry  which
	           specifies  the  number of characters in the command
	           if NXTTYP=-3.  IFLOAT is  returned  undefined,  but
	           probably  changed, if KIND is returned with a value
	           other than 5 or 12.
	         = -1, the number was evaluated as  an  octal  integer
	           and its value is returned in IVALUE.
	         = 0, the number was evaluated as  a  decimal  integer
	           and its value is returned in IVALUE.
	         = 1 or greater, the number was evaluated as a decimal
	           real  and  its  value  is  returned in the argument
	           named VALUE.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 185
	  DALEAD, Identify Command and Trailing Word, Number or String


	                An Example of the Use of DALEAD
	                -- ------- -- --- --- -- ------

	  The program  listed  on  the  following  pages  reports  the
	  results  of  the  interpretation by DALEAD of a line of text
	  typed by the user.  The user can type the commands  LEADING,
	  TRAILING  or  BOTH  followed  by  the associated words NONE,
	  OCTAL, DECIMAL or  REAL  to  modify  the  interpretation  of
	  numbers  in  the  indicated  positions.  For example, if the
	  command TRAILING has been issued with  the  associated  word
	  DECIMAL,  then  numbers  associated with any command will be
	  evaluated as decimal integers.   The  command  TRAILING  can
	  also  be  followed by the associated word DEPENDENT to cause
	  the subsequent commands TEST NONE, TEST OCTAL, TEST DECIMAL,
	  and  TEST  REAL  to  take  associated  numbers  of the types
	  indicated by the command names.  For example, if the command
	  TRAILING has been issued with the associated word DEPENDENT,
	  then the command TEST NONE will  not  allow  any  associated
	  numbers,  TEST  OCTAL  will  accept  only  octal  associated
	  numbers, and so forth.  The demonstration program  does  not
	  take  special  action  for  the  other  words  which  it can
	  recognize.  A typical dialog between  the  program  and  the
	  user is presented following the listing of the program.

	  C     PROGRAM TO DEMONSTRATE DALEAD ROUTINE
	  C
	        DIMENSION KCOUNT(18),NUMTYP(18),KWORD(109)
	        DIMENSION LCOUNT(21),LWORD(85)
	        DIMENSION JAND(5),LGND1(11),LGND7(8),LGND15(7)
	        DIMENSION IBUFFR(60),JBUFFR(60)
	  C
	  C     ARRAYS DEFINING DICTIONARY OF COMMANDS
	  C     1 LEADING     6 EXAMINE    11 EDIT
	  C     2 BOTH        7 LIST       12 TEST NONE
	  C     3 TRAILING    8 REMOVE     13 TEST OCTAL
	  C     4 CHANGE      9 RESTORE    14 TEST DECIMAL
	  C     5 MODIFY     10 NOTE       15 TEST REAL
	  C
	        DATA KCNTLO,KCNTHI,KWRDLO,KWRDHI/4,18,7,109/
	        DATA KCOUNT/ 99, 99, 99,  7,  4,  8,  6,  6,  7,  4,
	       1              6,  7,  4,  4,109,110,112,109/
	        DATA NUMTYP/ 0, 0, 0,-2,-2,-2, 0, 0, 0, 0,
	       1 0, 0, 0, 0,-2,-1, 0, 1/
	        DATA KWORD /1HI,1HG,1HN,1HO,1HR,1HE,1HL,1HE,1HA,1HD,
	       11HI,1HN,1HG,1HB,1HO,1HT,1HH,1HT,1HR,1HA,1HI,1HL,1HI,
	       21HN,1HG,1HC,1HH,1HA,1HN,1HG,1HE,1HM,1HO,1HD,1HI,1HF,
	       31HY,1HE,1HX,1HA,1HM,1HI,1HN,1HE,1HL,1HI,1HS,1HT,1HR,
	       41HE,1HM,1HO,1HV,1HE,1HR,1HE,1HS,1HT,1HO,1HR,1HE,1HN,
	       51HO,1HT,1HE,1HE,1HD,1HI,1HT,1HT,1HE,1HS,1HT,1H ,1HN,
	       61HO,1HN,1HE,1HT,1HE,1HS,1HT,1H ,1HO,1HC,1HT,1HA,1HL,
	       71HT,1HE,1HS,1HT,1H ,1HD,1HE,1HC,1HI,1HM,1HA,1HL,1HT,
	       81HE,1HS,1HT,1H ,1HR,1HE,1HA,1HL/
	  C
	  C     ARRAYS DEFINING DICTIONARY OF ASSOCIATED WORDS
	  FASP, FORTRAN Alphameric Subroutine Package         Page 186
	  DALEAD, Identify Command and Trailing Word, Number or String


	  C     1 DEPENDENT   6 SOME       11 TELL NOTHING
	  C     2 NONE        7 ALL        12 TRY NUMBER
	  C     3 OCTAL       8 FEW        13 NOT ALL
	  C     4 DECIMAL     9 MANY       14 TEST
	  C     5 REAL       10 MORE
	  C
	        DATA LCNTLO,LCNTHI,LWRDLO,LWRDHI/8,21,6,85/
	        DATA LCOUNT/ 99, 99, 99, 99, 99, 99, 99,  9,  4,  5,
	       1              7,  4,  4,  3,  3,  4,  4,112,110,107,
	       2              4/
	        DATA LWORD /1HD,1HU,1HM,1HM,1HY,1HD,1HE,1HP,1HE,1HN,
	       11HD,1HE,1HN,1HT,1HN,1HO,1HN,1HE,1HO,1HC,1HT,1HA,1HL,
	       21HD,1HE,1HC,1HI,1HM,1HA,1HL,1HR,1HE,1HA,1HL,1HS,1HO,
	       31HM,1HE,1HA,1HL,1HL,1HF,1HE,1HW,1HM,1HA,1HN,1HY,1HM,
	       41HO,1HR,1HE,1HT,1HE,1HL,1HL,1H ,1HN,1HO,1HT,1HH,1HI,
	       51HN,1HG,1HT,1HR,1HY,1H ,1HN,1HU,1HM,1HB,1HE,1HR,1HN,
	       61HO,1HT,1H ,1HA,1HL,1HL,1HT,1HE,1HS,1HT/
	  C
	  C     ARRAYS USED TO GENERATE TEXT DESCRIPTIONS
	        DATA JAND/1H ,1HA,1HN,1HD,1H /
	        DATA LGND1/1HE,1HN,1HD,1H ,1HO,1HF,1H ,1HL,1HI,1HN,
	       11HE/
	        DATA LGND7/1HU,1HN,1HK,1HN,1HO,1HW,1HN,1H /
	        DATA LGND15/1HC,1HO,1HM,1HM,1HA,1HN,1HD/
	        DATA ILEFT,IRIGHT,IAND,IEND,IQUOTE/
	       11H(,1H),1H&,1H;,1H'/
	  C
	  C     INITIAL VALUES
	        DATA ITTY,JTTY,MAXBFR,IFRCTN,INITYP,NXTTYP,ITRAIL,
	       1KIND/5,5,60,0,0,0,0,0/
	  C
	  C     ASK USER FOR TEXT TO BE PROCESSED
	      1 WRITE(JTTY,2)
	      2 FORMAT(2H *,$)
	        READ(ITTY,3)IBUFFR
	      3 FORMAT(72A1)
	        LOWBFR=1
	  C
	  C     FIND NEXT COMMAND AND ASSOCIATED WORD OR NUMBER
	      4 CALL DALEAD(INITYP,NXTTYP,ITRAIL,KWRDLO,KWRDHI,
	       1KWORD ,KCNTLO,KCNTHI,KCOUNT,NUMTYP,LWRDLO,LWRDHI,
	       2LWORD ,LCNTLO,LCNTHI,LCOUNT,IBUFFR,MAXBFR,LOWBFR,
	       3KIND  ,KOMAND,KWRDID,KCNTID,LOCAL ,LWRDID,LCNTID,
	       4INITAL,IVALUE,VALUE ,IFLOAT)
	  C
	  C     INSERT COMMAND WORD INTO TEXT TO BE PRINTED
	        INDEX=0
	        IF(KOMAND.EQ.0)GO TO 7
	        JBUFFR(INDEX+1)=ILEFT
	        IF(KIND.LE.7)INDEX=INDEX+1
	        J=KCOUNT(KCNTID)
	        IF(J.GE.100)J=J-100
	        J=KWRDID+J-1
	        DO 5 I=KWRDID,J
	  FASP, FORTRAN Alphameric Subroutine Package         Page 187
	  DALEAD, Identify Command and Trailing Word, Number or String


	        INDEX=INDEX+1
	      5 JBUFFR(INDEX)=KWORD(I)
	        JBUFFR(INDEX+1)=IRIGHT
	        IF(KIND.LE.7)INDEX=INDEX+1
	        DO 6 I=1,5
	        INDEX=INDEX+1
	      6 JBUFFR(INDEX)=JAND(I)
	  C
	  C     BRANCH TO CODE TO REPRESENT ASSOCIATED WORD OR NUMBER
	      7 NEW=KIND
	        IF(NEW.GT.7)NEW=NEW-7
	        GO TO(8,10,11,12,14,17,15,19),NEW
	  C
	  C     END OF LINE
	      8 DO 9 I=1,11
	        INDEX=INDEX+1
	      9 JBUFFR(INDEX)=LGND1(I)
	        GO TO 21
	  C
	  C     SEMICOLON
	     10 INDEX=INDEX+1
	        JBUFFR(INDEX)=IEND
	        GO TO 21
	  C
	  C     AMPERSAND
	     11 INDEX=INDEX+1
	        JBUFFR(INDEX)=IAND
	        GO TO 21
	  C
	  C     ASSOCIATED WORD
	     12 J=LCOUNT(LCNTID)
	        IF(J.GE.100)J=J-100
	        J=LWRDID+J-1
	        DO 13 I=LWRDID,J
	        INDEX=INDEX+1
	     13 JBUFFR(INDEX)=LWORD(I)
	  C
	  C     CHECK IF DALEAD ARGUMENTS ARE TO BE CHANGED
	        IF(LOCAL.GT.5)GO TO 21
	        IF((KOMAND.EQ.1).OR.(KOMAND.EQ.2))INITYP=LOCAL-4
	        IF((KOMAND.EQ.2).OR.(KOMAND.EQ.3))NXTTYP=LOCAL-4
	        GO TO 21
	  C
	  C     NUMBER
	     14 CALL DASHOW(IFLOAT,0,6,4,6,
	       13,IVALUE,VALUE,MAXBFR,INDEX,JBUFFR,IERR)
	        GO TO 21
	  C
	  C     QUOTED TEXT STRING OR UNKNOWN CHARACTER SEQUENCE
	     15 DO 16 I=1,8
	        INDEX=INDEX+1
	     16 JBUFFR(INDEX)=LGND7(I)
	     17 J=LOWBFR-1
	        DO 18 I=INITAL,J
	  FASP, FORTRAN Alphameric Subroutine Package         Page 188
	  DALEAD, Identify Command and Trailing Word, Number or String


	        INDEX=INDEX+1
	     18 JBUFFR(INDEX)=IBUFFR(I)
	        JBUFFR(INDEX+1)=IQUOTE
	        IF(NEW.EQ.6)INDEX=INDEX+1
	        GO TO 21
	  C
	  C     FOLLOWING COMMAND
	     19 DO 20 I=1,7
	        INDEX=INDEX+1
	     20 JBUFFR(INDEX)=LGND15(I)
	  C
	  C     REPORT RESULTS TO USER
	     21 WRITE(JTTY,22)(JBUFFR(I),I=1,INDEX)
	     22 FORMAT(2X,100A1)
	        IF(NEW.EQ.1)GO TO 1
	        IF(NEW.EQ.3)GO TO 1
	        GO TO 4
	        END



	  Typical Dialog Between DALEAD Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  *EXAM ALL!SIMPLE COMMAND AND ARGUMENT
	   EXAMINE AND ALL
	   (EXAMINE) AND END OF LINE
	  *EXAM ALL;!SEMICOLON
	   EXAMINE AND ALL
	   (EXAMINE) AND ;
	   END OF LINE
	  *EXAM ALL&AMPERSAND
	   EXAMINE AND ALL
	   (EXAMINE) AND &
	  *NONE LISTING SOMETHING UNKNOWN;;&UNKNOWN WORDS
	   (EXAMINE) AND NONE
	   (EXAMINE) AND UNKNOWN LISTING
	   (EXAMINE) AND UNKNOWN SOMETHING
	   (EXAMINE) AND UNKNOWN UNKNOWN
	   (EXAMINE) AND ;
	   ;
	   &
	  *T N TE N T NO TEST TEL N TE NOT!AMBIGUOUS AND UNIQUE
	   UNKNOWN T N
	   UNKNOWN TE N
	   UNKNOWN T NO
	   TEST
	   TELL NOTHING
	   TELL NOTHING
	   END OF LINE
	  FASP, FORTRAN Alphameric Subroutine Package         Page 189
	  DALEAD, Identify Command and Trailing Word, Number or String


	  *NOTE NOTA NON 12.34 ;ALL REAL 12.34 CHANGE SOM&CONTINUE
	   NOTE AND NOT ALL
	   (NOTE) AND NONE
	   (NOTE) AND 12
	   (NOTE) AND ;
	   ALL
	   REAL
	   12
	   CHANGE AND SOME
	   (CHANGE) AND &
	  *MORE 12.3 MANNY EXAMINE&CONTINUE WHEN NO ARGUMENT YET FOUND
	   (CHANGE) AND MORE
	   (CHANGE) AND 12
	   (CHANGE) AND UNKNOWN MANNY
	   EXAMINE AND &
	  *LIST,,MANY EDIT MODIFY!COMMAND AFTER COMMAND
	   EXAMINE AND COMMAND
	   LIST AND MANY
	   EDIT AND COMMAND
	   MODIFY AND END OF LINE
	  *0169.20 NOTE 0169.20 LEAD REAL;0169.20 NOTE 0169.20
	   169
	   NOTE AND 169
	   LEADING AND REAL
	   (LEADING) AND ;
	   169.2
	   NOTE AND 169
	   (NOTE) AND END OF LINE
	  *LEAD DEC TRAI REAL;0169.20 NOTE 0169.20 TRAIL DEPENDENT
	   LEADING AND DECIMAL
	   TRAILING AND REAL
	   (TRAILING) AND ;
	   169
	   NOTE AND 169.2
	   TRAILING AND DEPENDENT
	   (TRAILING) AND END OF LINE
	  *TEST NONE 0169.20 TEST OCTAL 0169.20
	   TEST NONE AND UNKNOWN 0169.20
	   TEST OCTAL AND 16
	   (TEST OCTAL) AND UNKNOWN 9.20
	   (TEST OCTAL) AND END OF LINE
	  *TEST DECIMAL 0169.20 TEST REAL 0169.20
	   TEST DECIMAL AND 169
	   TEST REAL AND 169.2
	   (TEST REAL) AND END OF LINE
	  FASP, FORTRAN Alphameric Subroutine Package         Page 190
	  DALINE, Bar Chart Plotter for Printer


	  DDDDD          AAA   LL         IIIIII   NN    NN   EEEEEEEE
	  DD   DD       AAAA   LL           II     NNN   NN   EE
	  DD    DD     AA AA   LL           II     NNNN  NN   EE
	  DD    DD    AA  AA   LL           II     NN NN NN   EEEEE
	  DD    DD   AAAAAAA   LL           II     NN  NNNN   EE
	  DD   DD   AA    AA   LL           II     NN   NNN   EE
	  DDDDD    AA     AA   LLLLLLLL   IIIIII   NN    NN   EEEEEEEE


	             DALINE, Bar Chart Plotter for Printer
	             ------  --- ----- ------- --- -------

	  DALINE is a FORTRAN subroutine  which  constructs  printable
	  plots  containing  horizontal  bars  formed  of segments the
	  lengths  of  which   represent   the   magnitudes   of   the
	  corresponding  values.  The segments can each be represented
	  with a different character.  Either the  entire  lengths  of
	  the segments, or merely their tips, can be represented.  The
	  bars can be superimposed upon  a  background  grid  and  can
	  extend  to  either side of a central column corresponding to
	  zero.  Negative segments (debits)  are  accumulated  to  one
	  side  of the zero column, and positive segments (credits) to
	  the other, although the user has the option  of  suppressing
	  the  display  of  either  portion.  DALINE is called as many
	  times as there are lines in the plot, each  subsequent  call
	  generating the next lower line of the plot.  Either a number
	  or an alphabetic label can be printed to the  left  of  each
	  line  of  the  plot.   Tick  marks  and scale numbers can be
	  generated below the plot when the final bar is  plotted,  or
	  can be added afterwards.

	                    The DALINE Argument List
	                    --- ------ -------- ----

	  The argument list of routine DALINE is

	        SUBROUTINE DALINE(IGRID ,KNDBAR,LSTLIN,MARGIN,MSHLFT,
	       1    MSHRIT,LNGLFT,LNGRIT,XLEFT ,XRIGHT,SEGMNT,MINSEG,
	       2    MAXSEG,LETTER,MINLTR,MAXLTR,YVALUE,LABEL ,MINLBL,
	       3    MAXLBL,LINPRT,IDISK )

	  with the associated DIMENSION statement

	        DIMENSION SEGMNT(MAXSEG),LETTER(MAXLTR),LABEL(MAXLBL)

	  All of the arguments of this routine are used only for input
	  and are returned unchanged.

	  IGRID  = selects the background characters to be shown where
	           not  hidden by the characters used to represent the
	           bar segments, selects the  character,  if  any,  to
	           appear  in the central zero column, and selects the
	           type of caption, either numeric or  alphabetic,  to
	           be  shown  to  the  left of the currently generated
	  FASP, FORTRAN Alphameric Subroutine Package         Page 191
	  DALINE, Bar Chart Plotter for Printer


	           panel of the bar chart.  These options are selected
	           by  the  digits  in  the  ones,  tens, and hundreds
	           positions respectively in the decimal integer value
	           of IGRID.

	           If the bar chart  is  to  be  superimposed  upon  a
	           rectangular   grid   formed   of  horizontal  lines
	           represented by minus signs and  of  vertical  lines
	           represented by exclamation points, then IGRID would
	           be assigned 2 different  values,  the  first  value
	           selecting  exclamation  points in the columns which
	           are  to  ruled  with  vertical  lines  and   spaces
	           elsewhere  in  each  panel which is not to be ruled
	           with a horizontal grid line,  and  a  second  value
	           selecting plus signs at the grid line intersections
	           and minus signs elsewhere in each panel which is to
	           be  ruled  with  a  horizontal  grid  line.   If  a
	           rectangular grid is not to be included in the  plot
	           but border lines are desired, then IGRID would have
	           a value selecting horizontal grid lines in the  top
	           and bottom panels, and another value selecting only
	           the left and right grid lines  in  the  intervening
	           panels.

	           The meanings assigned to each position in the value
	           of IGRID are as follow

	         ONES DIGIT

	           selects the characters to be  included  across  the
	           width  of  the  plot in columns not occupied by the
	           characters used to represent the bar segments,  but
	           does not dictate the characters appearing in either
	           the left margin or in the column representing zero.

	             0  spaces will be shown where not hidden  by  the
	                characters used to represent the bar segments.
	             1  minus signs will be shown where not hidden  by
	                the  characters  used  to  represent  the  bar
	                segments.
	             2  if  not  hidden  by  the  characters  used  to
	                represent  the  bar segments, then exclamation
	                points will be shown in  the  leftmost  column
	                which  could  bear a lower scale number to the
	                left of the zero column, and in the  rightmost
	                column  which  could bear a lower scale number
	                to the right of the zero column.  Spaces  will
	                be  shown  in  the remaining columns where not
	                hidden by the characters used to represent the
	                bar segments.
	             3  same as IGRID=2, except that minus  signs  are
	                included  instead  of  spaces  in  the columns
	                which contain neither exclamation  points  nor
	                the   characters   which   represent  the  bar
	  FASP, FORTRAN Alphameric Subroutine Package         Page 192
	  DALINE, Bar Chart Plotter for Printer


	                segments.
	             4  same as IGRID=2, except that if not hidden  by
	                the  characters  used  to  represent  the  bar
	                segments, then plus signs will be shown in the
	                leftmost column which could bear a lower scale
	                number to the left of the zero column, and  in
	                the  rightmost column which could bear a lower
	                scale number to the right of the zero column.
	             5  same as IGRID=4, except that minus  signs  are
	                included  instead  of  spaces  in  the columns
	                which  contain  neither  plus  signs  nor  the
	                characters which represent the bar segments.
	             6  if  not  hidden  by  the  characters  used  to
	                represent  the  bar segments, then exclamation
	                points will be  shown  in  each  column  which
	                could  bear a lower scale number.  Spaces will
	                be shown in the remaining  columns  where  not
	                hidden by the characters used to represent the
	                bar segments.
	             7  same as IGRID=6, except that minus  signs  are
	                included  instead  of  spaces  in  the columns
	                which contain neither exclamation  points  nor
	                the   characters   which   represent  the  bar
	                segments.
	             8  same as IGRID=6, except that if not hidden  by
	                the  characters  used  to  represent  the  bar
	                segments, then plus signs  will  be  shown  in
	                each  column  which  could  bear a lower scale
	                number.
	             9  same as IGRID=8, except that minus  signs  are
	                included  instead  of  spaces  in  the columns
	                which  contain  neither  plus  signs  nor  the
	                characters which represent the bar segments.

	           The  following  examples  demonstrate  the  results
	           produced by the various values of the ones digit.

	           ones digit = 0
	                      = 1    --------------- ---------------
	                      = 2    !                             !
	                      = 3    !-------------- --------------!
	                      = 4    +                             +
	                      = 5    +-------------- --------------+
	                      = 6    !    !    !         !    !    !
	                      = 7    !----!----!---- ----!----!----!
	                      = 8    +    +    +         +    +    +
	                      = 9    +----+----+---- ----+----+----+
	               tick marks    !    !    !    !    !    !    !
	            scale numbers   -15  -10  -5    0    5   10   15

	         TENS DIGIT

	           selects the character, if any, to be shown  in  the
	           zero  column,  and whether the lower scale numbers,
	  FASP, FORTRAN Alphameric Subroutine Package         Page 193
	  DALINE, Bar Chart Plotter for Printer


	           if generated by the current call to  this  routine,
	           are  to  include  the  identification  of  the zero
	           column.

	             0  the zero column is not to be  included  within
	                the  representation  of the current panel.  If
	                the tens digit has  the  value  zero  for  any
	                panel of the plot, then it must have the value
	                zero for all panels of the plot  or  else  the
	                bar  segments  to the right of the zero column
	                will be improperly aligned.
	             1  the zero column is to be  represented  by  the
	                space  character,  but is not to be identified
	                in the lower  scale  numbers  which  might  be
	                generated by the current call to this routine.
	             2  the zero column is to be  represented  by  the
	                minus sign, but is not to be identified in the
	                lower scale numbers which might  be  generated
	                by the current call to this routine.
	             3  the zero column is to be  represented  by  the
	                exclamation point, but is not to be identified
	                in the lower  scale  numbers  which  might  be
	                generated by the current call to this routine.
	             4  the zero column is to be  represented  by  the
	                plus  sign, but is not to be identified in the
	                lower scale numbers which might  be  generated
	                by the current call to this routine.
	             5  the zero column is to be  represented  by  the
	                space  character.  If the current call to this
	                routine  also  generates   the   lower   scale
	                numbers,   then   the   zero  column  will  be
	                identified by a scale number having the  value
	                zero.
	             6  the zero column is to be  represented  by  the
	                minus  sign.   If  the  current  call  to this
	                routine  also  generates   the   lower   scale
	                numbers,   then   the   zero  column  will  be
	                identified by a scale number having the  value
	                zero.
	             7  the zero column is to be  represented  by  the
	                exclamation  point.   If  the  current call to
	                this routine also generates  the  lower  scale
	                numbers,   then   the   zero  column  will  be
	                identified by a scale number having the  value
	                zero.
	             8  the zero column is to be  represented  by  the
	                plus  sign.   If  the  current  call  to  this
	                routine  also  generates   the   lower   scale
	                numbers,   then   the   zero  column  will  be
	                identified by a scale number having the  value
	                zero.

	           The  following  examples  demonstrate  the  results
	           produced by the various values of the tens digit.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 194
	  DALINE, Bar Chart Plotter for Printer


	           tens digit = 0

	                    +-+--+-+
	                    ! !  ! !
	                   -4-2  2 4

	           tens digit = 1          2          3          4

	                    +-+- -+-+  +-+---+-+  +-+-!-+-+  +-+-+-+-+
	                    ! !   ! !  ! !   ! !  ! !   ! !  ! !   ! !
	                   -4-2   2 4 -4-2   2 4 -4-2   2 4 -4-2   2 4

	           tens digit = 5          6          7          8

	                    +-+- -+-+  +-+---+-+  +-+-!-+-+  +-+-+-+-+
	                    ! ! ! ! !  ! ! ! ! !  ! ! ! ! !  ! ! ! ! !
	                   -4-2 0 2 4 -4-2 0 2 4 -4-2 0 2 4 -4-2 0 2 4

	         HUNDREDS DIGIT

	           selects the type  of  caption,  either  numeric  or
	           alphabetic,   to  be  shown  to  the  left  of  the
	           currently generated panel of the bar chart.

	             0  the left margin is to contain spaces.
	             1  the representation of the value input  as  the
	                argument named YVALUE is to be right justified
	                in the margin to the left of the  left  border
	                of the bar chart.
	             2  the characters input in LABEL(MINLBL)  through
	                and  including  LABEL(MAXLBL)  are to be right
	                justified in the margin to  the  left  of  the
	                left border of the bar chart.
	             3  a space character is to  be  placed  into  the
	                column  to  the  immediate  left  of  the left
	                border   of   the   bar   chart,    and    the
	                representation  of  the  value  input  as  the
	                argument named YVALUE is to be right justified
	                in the remaining portion of the left margin.
	             4  a space character is to  be  placed  into  the
	                column  to  the  immediate  left  of  the left
	                border of the bar chart,  and  the  characters
	                input  in  LABEL(MINLBL) through and including
	                LABEL(MAXLBL) are to be right justified in the
	                remaining portion of the left margin.
	             5  a minus sign is to be placed into  the  column
	                to  the  immediate  left of the left border of
	                the bar chart, and the representation  of  the
	                value input as the argument named YVALUE is to
	                be right justified in the remaining portion of
	                the left margin.
	             6  a minus sign is to be placed into  the  column
	                to  the  immediate  left of the left border of
	                the bar chart, and  the  characters  input  in
	  FASP, FORTRAN Alphameric Subroutine Package         Page 195
	  DALINE, Bar Chart Plotter for Printer


	                LABEL(MINLBL)     through     and    including
	                LABEL(MAXLBL) are to be right justified in the
	                remaining portion of the left margin.

	           The  following  examples  demonstrate  the  results
	           produced  by  the  various  values  of the hundreds
	           digit.

	           hundreds digit = 0          +----+---- ----+----+
	                          = 1     12.34+----+---- ----+----+
	                          = 2     LABEL+----+---- ----+----+
	                          = 3    12.34 +----+---- ----+----+
	                          = 4    LABEL +----+---- ----+----+
	                          = 5    12.34-+----+---- ----+----+
	                          = 6    LABEL-+----+---- ----+----+
	                   tick marks          !    !         !    !
	                scale numbers         -10  -5         5   10

	  KNDBAR = specifies which bar segment is to be represented if
	           more  than  one  bar  segment  appears  in a single
	           column of  the  plot,  and  which  columns  are  to
	           represent any bar segment which extends across more
	           than a single column.
	         = -1, no bar  segments  are  to  be  plotted  in  the
	           current panel.  The resulting panel is identical to
	           that which would  be  produced  if  MINSEG  is  set
	           greater than MAXSEG.
	         = 0, each bar segment is to be  represented  only  in
	           the  final  column  (that  furthest  from  the zero
	           column) in  which  it  is  the  largest  component.
	           Spaces are inserted into any other columns in which
	           the bar segment is dominant.
	         = 1, each bar segment is to be  represented  only  in
	           the  final  column  (that  furthest  from  the zero
	           column) in which it is the largest component.   The
	           grid  characters  selected by the ones digit of the
	           decimal integer value of IGRID  are  inserted  into
	           any  other  columns  in  which  the  bar segment is
	           dominant.
	         = 2, each bar segment is to  be  represented  in  all
	           columns in which it is the largest component.
	         = 3, 4 or 5, same as KIND=0,  1  or  2  respectively,
	           except  that  the  final columns (those furthest to
	           the left and to the right of the zero column) which
	           contain  the  final negative and the final positive
	           values  specified  by  the  SEGMNT  array   instead
	           contain  the  grid  characters selected by the ones
	           digit of the decimal integer value of IGRID if  the
	           largest components within these columns are smaller
	           than the space remaining in these columns.
	         = 6, each bar segment is to be  represented  only  in
	           the  final  column  (that  furthest  from  the zero
	           column) in which the bar segment appears.   If  two
	           or  more bar segments terminate in the same column,
	  FASP, FORTRAN Alphameric Subroutine Package         Page 196
	  DALINE, Bar Chart Plotter for Printer


	           then the bar segment specified by the SEGMNT  array
	           location    having    the   higher   subscript   is
	           represented, and the bar segment specified  by  the
	           the   SEGMENT   array  location  having  the  lower
	           subscript is instead represented  in  the  adjacent
	           column next closer to the zero column if this lower
	           bar segment is the only bar segment  which  appears
	           in  this adjacent column.  Spaces are inserted into
	           any  other  columns  across  which  a  bar  segment
	           extends.
	         = 7, each bar segment is to be  represented  only  in
	           the  final  column  (that  furthest  from  the zero
	           column) in which the bar segment appears.   If  two
	           or  more bar segments terminate in the same column,
	           then the bar segment specified by the SEGMNT  array
	           location    having    the   higher   subscript   is
	           represented, and the bar segment specified  by  the
	           the   SEGMENT   array  location  having  the  lower
	           subscript is instead represented  in  the  adjacent
	           column next closer to the zero column if this lower
	           bar segment is the only bar segment  which  appears
	           in  this  adjacent  column.   The  grid  characters
	           selected by the ones digit of the  decimal  integer
	           value  of IGRID are inserted into any other columns
	           which do not  contain  the  termination  of  a  bar
	           segment.
	         = 8, each bar segment is  represented  in  the  final
	           column  (that  furthest  from  the  zero column) in
	           which the bar segment appears, and in  each  column
	           in which the bar segment is the only component.

	           As a demonstration of  the  plotting  modifications
	           caused by the various values of KNDBAR, the numbers

	            .3  .4  .2  3.5  .1  .3  3.5  .2  .1  3.5  .3  .2

	           and

	           -.3 -.4 -.2 -3.5 -.1 -.3 -3.5 -.2 -.1 -3.5 -.3 -.2

	           are plotted below  represented  by  the  letters  A
	           through   X   respectively  with  LNGLFT=LNGRIT=15,
	           XLEFT=-15 and XRIGHT=15 for all possible values  of
	           KNDBAR

	  FASP, FORTRAN Alphameric Subroutine Package         Page 197
	  DALINE, Bar Chart Plotter for Printer


	              KNDBAR =-1   +----+----+----+----+----+----+
	                     = 0   +-WV   S  P   N+B   D  G   JK-+
	                     = 1   +-WV-+-S--P---N+B---D--G-+-JK-+
	                     = 2   +-WVVVVSSSPPPPN+BDDDDGGGJJJJK-+
	                     = 3   +--V   S  P   N+B   D  G   J--+
	                     = 4   +--V-+-S--P---N+B---D--G-+-J--+
	                     = 5   +--VVVVSSSPPPPN+BDDDDGGGJJJJ--+
	                     = 6   +-XV  US  RP  O+C  DF  GI  JL-+
	                     = 7   +-XV-+US--RP--O+C--DF--GI+-JL-+
	                     = 8   +-XVVVUSSSRPPPO+CDDDFGGGIJJJL-+
	              tick marks   !    !    !    !    !    !    !
	           scale numbers  -15  -10  -5    0    5   10   15

	           The letters which appear in columns 1, 5, 9 and  13
	           when  KNDBAR  is  less  than  or  equal  to  5  are
	           different than whose which appear  when  KNDBAR  is
	           greater  than or equal to 6.  The correspondence of
	           the letters to the columns is shown  in  the  chart
	           below.

	                            columns                   columns
	               column 1    ! 2 - 4 !     column 5    ! 6 - 8 !
	                           !       !                 !       !
	           .3A .4B .2C .1D !  3.D  ! .4D .1E .3F .2G !  3.G  !

	                            columns
	               column 9    !10 - 12!     column 13
	                           !       !
	           .3G .2H .1I .4J !  3.J  ! .1J .3K .2L and .4 space

	           For example, when KNDBAR is less than or  equal  to
	           5,  column 5 contains the letter D which represents
	           the largest component in column 5.  When KNDBAR  is
	           greater  than  or  equal  to  6,  column  5 instead
	           contains the letter F which represents the  highest
	           subscripted  component  which  terminates  in  this
	           column, and, since the component represented by the
	           letter  F does not appear in column 4, the letter D
	           is forced to appear in column 4.

	  LSTLIN = -1, only tick marks and lower scale numbers are  to
	           be generated, but a panel of the bar chart will not
	           be generated.  This option might  be  used  to  add
	           tick  marks  and scale numbers to a bar chart after
	           it has been completed if  it  is  not  possible  to
	           determine whether a particular panel will terminate
	           the bar chart before the panel is to be generated.
	         = 0, the current panel finishes the bar chart.  Scale
	           numbers  ranging  in  value  from that of XLEFT (if
	           LNGLFT is greater than zero) through that of XRIGHT
	           (if  LNGRIT is greater than zero) are to be written
	           below the current panel of the bar chart.
	         = greater than  zero,  the  current  panel  does  not
	           finish  the bar chart.  Scale numbers are not to be
	  FASP, FORTRAN Alphameric Subroutine Package         Page 198
	  DALINE, Bar Chart Plotter for Printer


	           written below the current panel of the  bar  chart.
	           Subsequent  calls  to  DALINE  will  add additional
	           panels to the bar chart.  The value  of  LSTLIN  is
	           ignored  other  than  to  determine  whether  it is
	           greater than zero.  If the main program  knows  the
	           total  number  of time periods, it can count LSTLIN
	           down to zero.  If the main program  does  not  know
	           the  total number of time periods, it is sufficient
	           to set LSTLIN to 1 until the final panel.

	  MARGIN = number of  characters  which  must  appear  in  the
	           output  between  the  carriage control character in
	           column 1 and the left edge of the current panel  of
	           the  bar  chart.   The width of this margin must be
	           the same for all panels forming the bar chart.  The
	           margin  must  include  sufficient room for the left
	           scale number  or  for  the  left  alphameric  label
	           requested  by a nonzero value of the hundreds digit
	           of the decimal integer value of IGRID, and for  the
	           extra  space  or  for  the  extra minus sign if the
	           hundreds digit of IGRID is greater than or equal to
	           3.   If  scale  numbers are to be written below the
	           bar chart, and if LNGLFT is greater than zero, then
	           MARGIN  should have a value of at least 5 (or of at
	           least half of MSHLFT if MSHLFT is less than 10)  to
	           allow a number to be centered below the left border
	           line.  If LNGLFT is not  greater  than  zero,  then
	           room does not need to be allowed in the left margin
	           for the lower scale numbers.

	  MSHLFT = width of the grid  divisions  indicated  either  by
	           exclamation  points or plus signs in the portion of
	           the bar chart to the left of the zero  column.   If
	           MSHLFT is equal to zero, then a grid division width
	           of 10 is assumed.  MSHLFT is equal to one more than
	           the  number  of  columns  of  characters  appearing
	           between the exclamation points or plus  signs.   If
	           LSTLIN  is  less  than or equal to zero, then scale
	           numbers are  written  below  the  bar  chart  every
	           MSHLFT columns to the left of the zero column.

	  MSHRIT = width of the grid  divisions  indicated  either  by
	           exclamation  points or plus signs in the portion of
	           the bar chart to the right of the zero column.   If
	           MSHRIT is equal to zero, then a grid division width
	           of 10 is assumed.  MSHRIT is equal to one more than
	           the  number  of  columns  of  characters  appearing
	           between the exclamation points or plus  signs.   If
	           LSTLIN  is  less  than or equal to zero, then scale
	           numbers are  written  below  the  bar  chart  every
	           MSHRIT columns to the right of the zero column.

	  LNGLFT = 0, the bar chart is not to include any  columns  to
	           the  left of the zero column.  This does not change
	  FASP, FORTRAN Alphameric Subroutine Package         Page 199
	  DALINE, Bar Chart Plotter for Printer


	           the width of the left margin specified by the value
	           of MARGIN.  The value of XLEFT is ignored.
	         = greater than zero, LNGLFT is the number of  columns
	           of  characters  to  be included in the bar chart to
	           the left of the zero column.  The  portion  of  the
	           bar  chart  to  the  left  of  the zero column will
	           represent negative segments if XLEFT is  less  than
	           zero, or positive segments if XLEFT is greater than
	           zero.  The  left  border  of  the  bar  chart  will
	           represent  an  accumulated  bar length equal to the
	           value of XLEFT.  If requested by the ones digit  of
	           the decimal integer value of IGRID, a vertical grid
	           line will be indicated every MSHLFT columns to  the
	           left of the zero column.

	  LNGRIT = 0, the bar chart is not to include any  columns  to
	           the  right of the zero column.  The value of XRIGHT
	           is ignored.
	         = greater than zero, LNGRIT is the number of  columns
	           of  characters  to  be included in the bar chart to
	           the right of the zero column.  The portion  of  the
	           bar  chart  to  the  right  of the zero column will
	           represent negative segments if XRIGHT is less  than
	           zero,  or  positive  segments  if XRIGHT is greater
	           than zero.  The right border of the bar chart  will
	           represent  an  accumulated  bar length equal to the
	           value of XRIGHT.  If requested by the ones digit of
	           the decimal integer value of IGRID, a vertical grid
	           line will be indicated every MSHRIT columns to  the
	           right of the zero column.

	  XLEFT  = the accumulated total of SEGMNT values  having  the
	           same  sign  as  XLEFT which is to be represented by
	           the left border of the portion of the bar chart  to
	           the  left  of  the zero column if LNGLFT is greater
	           than  zero.   If  XLEFT  is  negative,  then   only
	           negative  values are represented to the left of the
	           zero column.   IF  XLEFT  is  positive,  then  only
	           positive  values are represented to the left of the
	           zero column.  The magnitude of XLEFT should  depend
	           upon  the  magnitudes  of  the values in the SEGMNT
	           array.  If XLEFT has a value equal  to  -100  times
	           the number of columns specified by LNGLFT, then the
	           first column to the left of the zero  column  would
	           represent an accumulated total in the range -100 to
	           0, the second column to the left of the zero column
	           would  represent  an accumulated total in the range
	           -200 to -100 and so on.

	  XRIGHT = the accumulated total of SEGMNT values  having  the
	           same  sign  as XRIGHT which is to be represented by
	           the right border of the portion of the bar chart to
	           the  right  of the zero column if LNGRIT is greater
	           than  zero.   If  XRIGHT  is  negative,  then  only
	  FASP, FORTRAN Alphameric Subroutine Package         Page 200
	  DALINE, Bar Chart Plotter for Printer


	           negative values are represented to the right of the
	           zero column.  IF  XRIGHT  is  positive,  then  only
	           positive values are represented to the right of the
	           zero column.  The magnitude of XRIGHT should depend
	           upon  the  magnitudes  of  the values in the SEGMNT
	           array.  If XRIGHT has a value equal  to  100  times
	           the number of columns specified by LNGRIT, then the
	           first column to the right of the zero column  would
	           represent  an  accumulated  total greater than zero
	           but not greater than 100, the second column to  the
	           right   of  the  zero  column  would  represent  an
	           accumulated total greater than 100 but not  greater
	           than 200 and so on.

	  SEGMNT = array   containing   in   the    array    locations
	           SEGMNT(MINSEG) through and including SEGMNT(MAXSEG)
	           the lengths of the bar segments  specified  in  the
	           same coordinate systems as used for the definitions
	           of XLEFT and XRIGHT.  Zero  values  in  the  SEGMNT
	           array are ignored.

	  MINSEG = subscript of the first location in the SEGMNT array
	           which  can specify the length of a bar segment.  If
	           MINSEG is greater than MAXSEG, then no bar segments
	           will be represented.

	  MAXSEG = subscript of the final location in the SEGMNT array
	           which can specify the length of a bar segment.

	  LETTER = array   containing   in   the    array    locations
	           LETTER(MINLTR) through and including LETTER(MAXLTR)
	           the characters by which the bar segments are to  be
	           represented,   one   character   per  LETTER  array
	           location as though read by  a  multiple  of  an  A1
	           format  or  defined  by several 1H fields in a DATA
	           statement.  The segment having its length specified
	           by   SEGMNT(MINSEG)  will  be  represented  by  the
	           character found in LETTER(MINLTR), that having  its
	           length  in  SEGMNT(MINSEG+1)  by  the  character in
	           LETTER(MINLTR+1), and so on.  If  MAXLTR-MINLTR  is
	           less  than  MAXSEG-MINSEG,  then  the assignment of
	           characters recycles through  the  LETTER  array  as
	           many times as are necessary to represent all of the
	           bar segments so that the segment having its  length
	           specified   by   SEGMNT(MINSEG+MAXLTR-MINLTR+1)  is
	           represented by  the  character  in  LETTER(MINLTR),
	           that        having        its       length       in
	           SEGMNT(MINSEG+MAXLTR-MINLTR+2) by the character  in
	           LETTER(MINLTR+1), and so on.

	  MINLTR = subscript  of  the  LETTER  array  location   which
	           specifies   the   character  to  be  used  for  the
	           representation of the bar segment having its length
	           in SEGMNT(MINSEG).
	  FASP, FORTRAN Alphameric Subroutine Package         Page 201
	  DALINE, Bar Chart Plotter for Printer


	  MAXLTR = subscript  of  the  LETTER  array  location   which
	           specifies   the   character  to  be  used  for  the
	           representation of the bar segment having its length
	           in SEGMNT(MINSEG+MAXLTR-MINLTR).

	  YVALUE = number to be placed to the left of the bar chart if
	           the  hundreds digit of the decimal integer value of
	           IGRID has the value 1, 3 or 5.

	  LABEL  = array   containing   in   the    array    locations
	           LABEL(MINLBL)  through  and including LABEL(MAXLBL)
	           the characters to be shown to the left of  the  bar
	           chart  if the hundreds digit of the decimal integer
	           value of IGRID has  the  value  2,  4  or  6.   The
	           characters  in  the  LABEL  array  are  stored  one
	           character per array location as though  read  by  a
	           multiple  of  an A1 format or defined by several 1H
	           fields in a DATA statement.  If more characters are
	           specified  in  the LABEL array than can be shown in
	           the  left  margin,  then   the   rightmost   excess
	           characters are not shown.

	  MINLBL = subscript of the LABEL  array  location  containing
	           the  leftmost  character to be shown to the left of
	           the bar chart if the hundreds digit of the  decimal
	           integer value of IGRID has the value 2, 4 or 6.

	  MAXLBL = subscript of the LABEL  array  location  containing
	           the  rightmost character to be shown to the left of
	           the bar chart if the hundreds digit of the  decimal
	           integer value of IGRID has the value 2, 4 or 6.

	  LINPRT = -1, do not include a carriage control character  to
	           the left of each line of the plot.  Since the minus
	           sign  of  a  negative  scale  number  or  the  left
	           character  of  a label can then appear in column 1,
	           the resulting output must not be treated as  though
	           the   left   column   contains   carriage   control
	           characters.
	         = 0, the plot  will  be  viewed  by  the  user  on  a
	           terminal,  either  typed  directly with IDISK being
	           given the terminal unit number,  or  typed  by  the
	           user after this routine has written the plot into a
	           file on the unit the number of which  is  contained
	           in  IDISK.   A  blank  or  space  will  be  used as
	           carriage control character to give single spacing.
	         = 1, the plot will be printed on the line printer  by
	           the  user  after  the  program has written the plot
	           into a file.  An asterisk will be used as  carriage
	           control  character  to  give  single  spacing  with
	           suppression of skipping extra  lines  at  the  page
	           boundaries.   On  the  PDP-10,  an  asterisk as the
	           carriage control character  gives  overprinting  on
	           the terminal as opposed to single spacing.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 202
	  DALINE, Bar Chart Plotter for Printer


	  IDISK  = the unit number of the device onto which the  plots
	           are to be written.  This routine will only generate
	           the plot.  It is the responsibility of the  calling
	           program  to  open  the output file and to write the
	           captions, the  form  feeds  and/or  the  separating
	           lines.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 203
	  DALINE, Bar Chart Plotter for Printer


	   Examples of Grid Rulings Selected by Various IGRID Values
	   -------- -- ---- ------- -------- -- ------- ----- ------

	  In each illustration, a positive segment is  represented  by
	  the character P and a negative segment by the character N.

	  IGRID=500         501         502         503         504

	   1-   NP     1----NP---  1-!  NP  !  1-!--NP--!  1-+  NP  +
	     ! !  ! !    ! !  ! !    ! !  ! !    ! !  ! !    ! !  ! !
	    -4-2  2 4   -4-2  2 4   -4-2  2 4   -4-2  2 4   -4-2  2 4

	  IGRID=505         506         507         508         509

	   1-+--NP--+  1-! !NP! !  1-!-!NP!-!  1-+ +NP+ +  1-+-+NP+-+
	     ! !  ! !    ! !  ! !    ! !  ! !    ! !  ! !    ! !  ! !
	    -4-2  2 4   -4-2  2 4   -4-2  2 4   -4-2  2 4   -4-2  2 4

	  IGRID=510         511         512         513         514

	   1-   N P    1----N P--- 1-!  N P  ! 1-!--N P--! 1-+  N P  +
	     ! !   ! !   ! !   ! !   ! !   ! !   ! !   ! !   ! !   ! !
	    -4-2   2 4  -4-2   2 4  -4-2   2 4  -4-2   2 4  -4-2   2 4

	  IGRID=515         516         517         518         519

	   1-+--N P--+ 1-! !N P! ! 1-!-!N P!-! 1-+ +N P+ + 1-+-+N P+-+
	     ! !   ! !   ! !   ! !   ! !   ! !   ! !   ! !   ! !   ! !
	    -4-2   2 4  -4-2   2 4  -4-2   2 4  -4-2   2 4  -4-2   2 4

	  IGRID=540         541         542         543         544

	   1-   N+P    1----N+P--- 1-!  N+P  ! 1-!--N+P--! 1-+  N+P  +
	     ! !   ! !   ! !   ! !   ! !   ! !   ! !   ! !   ! !   ! !
	    -4-2   2 4  -4-2   2 4  -4-2   2 4  -4-2   2 4  -4-2   2 4

	  IGRID=545         546         547         548         549

	   1-+--N+P--+ 1-! !N+P! ! 1-!-!N+P!-! 1-+ +N+P+ + 1-+-+N+P+-+
	     ! !   ! !   ! !   ! !   ! !   ! !   ! !   ! !   ! !   ! !
	    -4-2   2 4  -4-2   2 4  -4-2   2 4  -4-2   2 4  -4-2   2 4

	  IGRID=580         581         582         583         584

	   1-   N+P    1----N+P--- 1-!  N+P  ! 1-!--N+P--! 1-+  N+P  +
	     ! ! ! ! !   ! ! ! ! !   ! ! ! ! !   ! ! ! ! !   ! ! ! ! !
	    -4-2 0 2 4  -4-2 0 2 4  -4-2 0 2 4  -4-2 0 2 4  -4-2 0 2 4

	  IGRID=585         586         587         588         589

	   1-+--N+P--+ 1-! !N+P! ! 1-!-!N+P!-! 1-+ +N+P+ + 1-+-+N+P+-+
	     ! ! ! ! !   ! ! ! ! !   ! ! ! ! !   ! ! ! ! !   ! ! ! ! !
	    -4-2 0 2 4  -4-2 0 2 4  -4-2 0 2 4  -4-2 0 2 4  -4-2 0 2 4
	  FASP, FORTRAN Alphameric Subroutine Package         Page 204
	  DALINE, Bar Chart Plotter for Printer


	                An Example of the Use of DALINE
	                -- ------- -- --- --- -- ------

	  The following program was used to generate the 3 plots shown
	  on  the next page.  The major portion of the program defines
	  the values of IGRID and KNDBAR needed for the production  in
	  the first plot of the hollow bars separated by blank lines.

	        DIMENSION SEGMNT(7),LETTER(7),VALUES(7,6),LABEL(1)
	        DATA ((VALUES(I,J),I=1,7),J=1,6)/
	       1-2.,-4.,-2., 3., 8., 2., 1.,
	       2-2.,-3.,-3., 4., 7., 2., 3.,
	       3-1.,-2.,-4., 9., 6., 2., 7.,
	       4 0.,-2.,-1., 6., 5., 3., 5.,
	       5 0.,-2.,-6., 5., 5., 4., 3.,
	       6 0.,-2.,-8., 4., 9.,10., 5./
	        DATA LETTER/1HA,1HB,1HC,1HD,1HE,1HF,1HG/
	        DATA IDISK/1/
	        LSTLIN=1
	        DO 9 LINE=1,6
	        YVALUE=LINE
	        DO 1 I=1,7
	      1 SEGMNT(I)=VALUES(I,LINE)
	        DO 9 INNER=1,7
	        GO TO(2,3,4,5,4,6,7),INNER
	      2 IF(LINE.NE.1)GO TO 9
	        KNDBAR=-1
	        IGRID=49
	        GO TO 8
	      3 IF(LINE.NE.1)GO TO 9
	        IGRID=36
	        GO TO 8
	      4 IGRID=36
	        KNDBAR=2
	        GO TO 8
	      5 IGRID=549
	        KNDBAR=0
	        GO TO 8
	      6 KNDBAR=-1
	        IGRID=36
	        GO TO 8
	      7 IF(LINE.NE.6)GO TO 9
	        LSTLIN=0
	        IGRID=49
	      8 CALL DALINE(IGRID,KNDBAR,LSTLIN,10,10,
	       110,10,30,-10.,30.,SEGMNT,1,
	       27,LETTER,1,7,YVALUE,LABEL,2,
	       31,0,IDISK)
	      9 CONTINUE
	        DO 12 KNDBAR=1,2
	        WRITE(IDISK,10)
	     10 FORMAT(1X)
	        DO 12 LINE=1,6
	        DO 11 I=1,7
	  FASP, FORTRAN Alphameric Subroutine Package         Page 205
	  DALINE, Bar Chart Plotter for Printer


	     11 SEGMNT(I)=VALUES(I,LINE)
	     12 CALL DALINE(176,KNDBAR,6-LINE,10,10,
	       110,10,30,-10.,30.,SEGMNT,1,
	       27,LETTER,1,7,FLOAT(LINE),LABEL,2,
	       31,0,IDISK)
	        STOP
	        END
	             +---------+---------+---------+---------+
	             !         !         !         !         !
	             ! CCBBBBAA!DDDEEEEEEEEFFG     !         !
	           1-+-C B   A +  D       E FG-----+---------+
	             ! CCBBBBAA!DDDEEEEEEEEFFG     !         !
	             !         !         !         !         !
	             ! CCCBBBAA!DDDDEEEEEEEFFGGG   !         !
	           2-+-C  B  A +   D      E F  G---+---------+
	             ! CCCBBBAA!DDDDEEEEEEEFFGGG   !         !
	             !         !         !         !         !
	             !  CCCCBBA!DDDDDDDDDEEEEEEFFGGGGGGG     !
	           3-+--C   B A+        D     E F      G-----+
	             !  CCCCBBA!DDDDDDDDDEEEEEEFFGGGGGGG     !
	             !         !         !         !         !
	             !      CBB!DDDDDDEEEEEFFFGGGGG!         !
	           4-+------CB +     D    E  F    G+---------+
	             !      CBB!DDDDDDEEEEEFFFGGGGG!         !
	             !         !         !         !         !
	             ! CCCCCCBB!DDDDDEEEEEFFFFGGG  !         !
	           5-+-C     B +    D    E   F  G--+---------+
	             ! CCCCCCBB!DDDDDEEEEEFFFFGGG  !         !
	             !         !         !         !         !
	             CCCCCCCCBB!DDDDEEEEEEEEEFFFFFFFFFFGGGGG !
	           6-C       B +   D        E         F    G-+
	             CCCCCCCCBB!DDDDEEEEEEEEEFFFFFFFFFFGGGGG !
	             !         !         !         !         !
	             +---------+---------+---------+---------+
	             !                   !         !         !
	            -10                 10        20        30

	            1! C B   A !  D      !E FG     !         !
	            2! C  B  A !   D     !E F  G   !         !
	            3!  C   B A!        D!    E F  !   G     !
	            4!      CB !     D   !E  F    G!         !
	            5! C     B !    D    E   F  G  !         !
	            6C       B !   D     !  E      !  F    G !
	             !         !         !         !         !
	            -10        0        10        20        30

	            1! CCBBBBAA!DDDEEEEEEEEFFG     !         !
	            2! CCCBBBAA!DDDDEEEEEEEFFGGG   !         !
	            3!  CCCCBBA!DDDDDDDDDEEEEEEFFGGGGGGG     !
	            4!      CBB!DDDDDDEEEEEFFFGGGGG!         !
	            5! CCCCCCBB!DDDDDEEEEEFFFFGGG  !         !
	            6CCCCCCCCBB!DDDDEEEEEEEEEFFFFFFFFFFGGGGG !
	             !         !         !         !         !
	            -10        0        10        20        30
	  FASP, FORTRAN Alphameric Subroutine Package         Page 206
	  DALIST, Routine to List Dictionary Constructed by DALOAD


	    DDDDD          AAA  LL        IIIIII    SSSSSS  TTTTTTTT
	    DD   DD       AAAA  LL          II    SS           TT
	    DD    DD     AA AA  LL          II    SS           TT
	    DD    DD    AA  AA  LL          II      SSSS       TT
	    DD    DD   AAAAAAA  LL          II          SS     TT
	    DD   DD   AA    AA  LL          II          SS     TT
	    DDDDD    AA     AA  LLLLLLLL  IIIIII  SSSSSS       TT



	    DALIST, Routine to List Dictionary Constructed by DALOAD
	    ------  ------- -- ---- ---------- ----------- -- ------

	  DALIST summarizes  the  array  names  and  subscript  ranges
	  specified  in  the  dictionary  constructed  by  the  DALOAD
	  routine.  DALIST is used along with several  other  routines
	  in  the  FASP package for the purpose of specifying by name,
	  examining and modifying the values of  multiply  subscripted
	  arrays  equivalenced  with or otherwise loaded into a singly
	  subscripted buffer.  The interaction between these  routines
	  is  described at the start of the DALOAD documentation.  The
	  sample program  at  the  end  of  the  DALOAD  documentation
	  illustrates the use of most of these routines.



	                    The DALIST Argument List
	                    --- ------ -------- ----

	  The argument list of routine DALIST is

	        SUBROUTINE DALIST(JTTY  ,LTRLOW,LTRUSD,LTRSTR,NUMLOW,
	       1NUMUSD,NUMSTR,NAMMAX,NAME)

	  with the associated DIMENSION statement

	        DIMENSION LTRSTR(LTRUSD),NUMSTR(NUMUSD),NAME(NAMMAX)

	  The following arguments are used  for  input  only  and  are
	  returned unchanged.

	  JTTY   = number of the unit onto which  the  description  of
	           the  contents  of  the dictionary is to be written.
	           This could be the number associated with a terminal
	           or  be the number of the unit to which a file is to
	           be written.  If the number is that of the  unit  to
	           which  a  file  is  to be written, then the calling
	           program must open  the  file  before  calling  this
	           routine, and close it, if necessary, afterwards.

	  LTRLOW = lowest subscript of the  locations  in  the  LTRSTR
	           array containing the characters of the names in the
	           dictionary as originally read  by  DALOAD  using  a
	           multiple  of an A1 format.  LTRSTR(LTRLOW) contains
	  FASP, FORTRAN Alphameric Subroutine Package         Page 207
	  DALIST, Routine to List Dictionary Constructed by DALOAD


	           either the first letter of the name  of  the  first
	           logical  group  of  names in the dictionary or else
	           (if the first group itself isn't named)  the  first
	           letter  of  the first name within the first logical
	           group in the dictionary.

	  LTRUSD = highest subscript of the locations  in  the  LTRSTR
	           array containing the characters of the names in the
	           dictionary as originally read  by  DALOAD  using  a
	           multiple  of an A1 format.  LTRSTR(LTRUSD) contains
	           the  last  character  of  the  last  name  in   the
	           dictionary.

	  LTRSTR = array containing the characters forming  the  names
	           in  the  dictionary, 1 character per array location
	           as originally read by DALOAD using a multiple of an
	           A1 format.

	  NUMLOW = lowest subscript of the  locations  in  the  NUMSTR
	           array    containing    the    numeric   information
	           corresponding to the names  stored  in  the  LTRSTR
	           array.   NUMSTR(NUMLOW)  must  contain the start of
	           the description of a logical group  of  names,  not
	           the start of the description of an individual name.

	  NUMUSD = highest subscript of the locations  in  the  NUMSTR
	           array    containing    the    numeric   information
	           corresponding to the names  stored  in  the  LTRSTR
	           array.

	  NUMSTR = array   containing    the    numeric    information
	           corresponding  to  the  names  stored in the LTRSTR
	           array.  The construction of  the  NUMSTR  array  is
	           described  in  detail  in the DALOAD documentation.
	           For each name in the dictionary, the  NUMSTR  array
	           contains

	             a. the number of characters in the name

	             b. an indication of the associated data type

	             c. the number of subscript ranges

	             d. pairs of starting and ending values  of  these
	                ranges.

	           If the number of  characters  is  instead  zero  or
	           negative,  then its absolute value is the number of
	           characters in the name of a logical group of names,
	           and  the  next location, rather than indicating the
	           data type, contains the number of locations  within
	           a  singly  subscripted buffer which would be needed
	           to store the values  of  the  multiply  subscripted
	           arrays  which  are  within  the  logical  group and
	  FASP, FORTRAN Alphameric Subroutine Package         Page 208
	  DALIST, Routine to List Dictionary Constructed by DALOAD


	           equivalenced with or otherwise loaded into  such  a
	           singly subscripted buffer.

	  NAMMAX = highest subscript of any location in the NAME array
	           which can be used by this routine for the temporary
	           storage of characters which are to be  included  in
	           the  summary of the dictionary contents.  NAMMAX is
	           the maximum width of any line which can be included
	           in  the  summary.   The contents of NAME(1) through
	           NAME(NAMMAX) will be destroyed by this routine.

	  The following argument is used internally by  this  routine.
	  Its original contents are destroyed.

	  NAME   = array used  internally  by  this  routine  for  the
	           construction  of  the  lines  of  text  forming the
	           summary of the contents of the dictionary.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 209
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	   DDDDD          AAA  LL         OOOOO         AAA  DDDDD
	   DD   DD       AAAA  LL        OO   OO       AAAA  DD   DD
	   DD    DD     AA AA  LL       OO     OO     AA AA  DD    DD
	   DD    DD    AA  AA  LL       OO     OO    AA  AA  DD    DD
	   DD    DD   AAAAAAA  LL       OO     OO   AAAAAAA  DD    DD
	   DD   DD   AA    AA  LL        OO   OO   AA    AA  DD   DD
	   DDDDD    AA     AA  LLLLLLLL   OOOOO   AA     AA  DDDDD


	   DALOAD, Routine to Make Dictionary Describing Named Arrays
	   ------  ------- -- ---- ---------- ---------- ----- ------

	  DALOAD  reads  the  DIMENSION,  COMMON,  INTEGER,  REAL  and
	  IMPLICIT   statements   which   could  be  used  to  declare
	  subscripted arrays  in  a  FORTRAN  program,  and  from  the
	  information  in  these  statements  constructs  a dictionary
	  containing the names, data types, and  subscript  limits  of
	  the  arrays.   The  calling program must open the input file
	  containing the FORTRAN statements.  DALOAD is then called to
	  read  the statements from this input file, returning control
	  only after an END statement or an end-of-file is read or  if
	  the  space  allocated  for  the  dictionary fills before the
	  dictionary is complete.

	  The dictionary constructed by DALOAD can be used by  several
	  other  routines  in  the  FASP  package  for  the purpose of
	  specifying by name, examining and modifying  the  values  of
	  multiply  subscripted  arrays equivalenced with or otherwise
	  loaded into a singly subscripted buffer.  The sample program
	  at  the  end of the DALOAD documentation illustrates the use
	  of most of these routines.  A summary of the dictionary  can
	  be  typed  by  the DALIST routine.  Array names typed by the
	  user and read by the calling program into  an  input  buffer
	  with  a  multiple  of  an  A1  format can be matched against
	  entries in the dictionary by the DAPICK routine.  The DASITE
	  routine  uses the dictionary and the subscripts typed by the
	  user as evaluated by DAPICK to locate the desired  value  of
	  the  multiply  subscripted  array  which  is being simulated
	  within the singly subscripted buffer.   The  DALONE  routine
	  constructs in a third buffer (the first two being the buffer
	  containing the  text  typed  by  the  user  and  the  buffer
	  containing  the array values being manipulated) the name and
	  alphameric representation of the current subscripts even  if
	  the  user  has  typed  a  range  or ranges through which the
	  subscripts are to be varied.  The  DAVARY  routine  displays
	  the  name  and  current subscripts as represented by DALONE,
	  displays the value contained in the indicated location,  and
	  accepts  a  new value for the array location if the user has
	  typed the character = to the right of the  subscript  range.
	  DAVARY will ask the user to supply a new value if he did not
	  type such a value to the right of the =  character.   Either
	  of  the  routines  DAROLL or DALOOP are then used to advance
	  the subscripts through the ranges typed  by  the  user,  the
	  main  program calling DALONE, DASITE and DAVARY for each new
	  FASP, FORTRAN Alphameric Subroutine Package         Page 210
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  set of subscripts until the ranges have been completed.

	  The FORTRAN statements read as data by  DALOAD  are  written
	  either  in  conventional  card format, or with a leading tab
	  character.  In card  format,  the  statement  begins  in  or
	  continues  with  the text starting in column 7.  If the card
	  format is chosen, a space or zero in column 6 indicates  the
	  start of a new statement, while any other printing character
	  indicates the continuation of the current statement.  In tab
	  format,  any  printing  character  other  than  the digits 0
	  through  9  to  the  immediate  right  of  the  initial  tab
	  character  starts  the  text  of  a  new  statement.  If the
	  character right of the tab character is  a  zero,  then  the
	  statement  starts  with  the  character  to the right of the
	  zero.  A digit other than zero to the immediate right of the
	  tab  character  indicates  that the text to the right of the
	  digit continues the previously begun statement.  The left 72
	  characters,   counting   the   tab  character  as  a  single
	  character, are usually read from  each  line  of  the  input
	  file,  but  the  calling program can specify that some other
	  number of characters is to be read.

	  Unrecognizable  statements  and  lines  beginning  with  the
	  letter  C in column 1 are ignored.  Statements recognized by
	  DALOAD cannot begin with statement numbers.   Command  words
	  such  as  COMMON, DIMENSION, IMPLICIT, REAL, INTEGER and END
	  must not be split across a continuation.   Array  names  and
	  the  parenthetical  expressions  used  to  define  subscript
	  limits and the letters to be associated  with  various  data
	  types  can,  however,  be  split across continuations.  Such
	  array names and numbers will be handled  correctly  even  if
	  comment  lines  indicated by the letter C in column 1 appear
	  before the name or  number  is  completed  by  a  subsequent
	  continuation  line.   Spaces and/or tabs can appear anywhere
	  within statements but are ignored.

	  Each array name in the dictionary constructed by DALOAD  has
	  stored with it a specification of the type of data which the
	  array is expected to contain.  Array names appearing  in  an
	  INTEGER  or  REAL statement are added to the dictionary with
	  the specification of their data type matching that indicated
	  by  the statement in which they are declared.  An additional
	  statement OCTAL can be used  to  declare  arrays  containing
	  octal   information.   The  array  names  appearing  on  the
	  INTEGER,  OCTAL  and  REAL  statements  are  added  to   the
	  dictionary  in the order in which they are found.  The array
	  names are not searched  for  within  the  dictionary  before
	  being  added, so it is not possible to declare an array in a
	  DIMENSION or COMMON statement, then later change its type.

	  Within a COMMON or DIMENSION statement, the data type to  be
	  associated with the name is indicated by the first character
	  of the array name.  The default association of the letters I
	  through N with integer, and A through H and O through Z with
	  FASP, FORTRAN Alphameric Subroutine Package         Page 211
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  real  is  restored  each  time  DALOAD  is  called.    These
	  associations  of characters with data types can, however, be
	  changed for the duration of a particular execution of DALOAD
	  by  the use of the IMPLICIT statement.  Although there is no
	  default association of the octal data type with any  initial
	  letters,  the words INTEGER, OCTAL and REAL are all accepted
	  in IMPLICIT statements as data type names.

	  The  IMPLICIT  statement  consists  of  the  word   IMPLICIT
	  followed by a data type name and enclosed in parentheses the
	  letters to be associated with that data  type.   Within  the
	  parentheses,  single  letters  separated  by commas indicate
	  that these letters are to begin array names associated  with
	  the  data  type.   Two  (or  more)  letters not separated by
	  commas but the first being lower in the  alphabet  than  the
	  second  indicate  that all letters within the range from the
	  first through the last are to begin array  names  associated
	  with  the  data  type.   Minus  signs can appear between the
	  letters indicating ranges,  but  are  not  required.   If  a
	  second  (or additional) parenthetical expression follows the
	  first without the declaration of another data type and  with
	  no  printing  character other than an optional comma between
	  the pair  of  expressions,  then  the  second  parenthetical
	  expression  will  be  assumed to continue the declaration of
	  the letters to  be  associated  with  the  same  data  type.
	  Another  data  type  name  and  its associated parenthetical
	  expressions can follow directly or with intervening  spaces,
	  tabs  and/or commas.  The association of data types with the
	  initial letters of the array names applies  only  to  arrays
	  declared by the following COMMON or DIMENSION statements and
	  only until the particular letters  involved  are  associated
	  with  another  data type by a subsequent IMPLICIT statement.
	  The statement

	        IMPLICIT REAL(A-G,R-Z),OCTAL(W-Z,C),INTEGER(P,H,O)

	  would associate the initial letters A, B, D, E, F, G, R,  S,
	  T,  U  and  V  with the real data type.  The letters C and W
	  through Z are temporarily  associated  with  the  real  data
	  type, but then are associated with the octal data type.  The
	  sample statement also associates the letters H, O and P with
	  the  integer  data  type.   The  letters not assigned by the
	  current statement  will  retain  their  previous  data  type
	  associations.

	  The formats of COMMON, DIMENSION, INTEGER,  OCTAL  and  REAL
	  statements  are  identical.   The  initial  command  word is
	  followed by the array names each of which can be followed in
	  turn by its subscript limits enclosed in parentheses.  Array
	  names  can  be  of  any  length,  but  must  start  with  an
	  alphabetic  letter  and  can contain only alphabetic letters
	  and digits.  Commas are required between array names only if
	  subscripts  are not specified.  Following an array name, the
	  subscripts enclosed in parentheses are separated  by  commas
	  FASP, FORTRAN Alphameric Subroutine Package         Page 212
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  and  are  specified  as  ranges  consisting  of the starting
	  value, a slash character or a colon (the  2  characters  are
	  equivalent),  and  the ending value.  The numbers indicating
	  the subscript ranges can be signed, but  cannot  contain  an
	  exponent,  neither  the E of scientific notation nor K nor M
	  being accepted.  If a slash or a colon is present but either
	  number  is missing, then the missing number is assumed to be
	  1.  If a single number appears without a slash and without a
	  colon,  then  the  range is assumed to start at 1 and extend
	  through the indicated number.  If nothing or just a slash or
	  just  a colon appears between the parentheses and/or commas,
	  then the range is assumed  to  be  1/1.   For  example,  the
	  statement

	        DIMENSION ABC,DEF(-123),GHI(20/4,,4/20)

	  would declare a nonsubscripted variable named ABC, an  array
	  named  DEF  with  dimensions  starting  at  1  and extending
	  through -123, and a triply subscripted array named GHI  with
	  first dimension starting at 20 and extending through 4, with
	  second dimension having the single value  1,  and  with  the
	  third dimension starting at 4 and extending through 20.

	  The appearance outside of a parenthetical expression of  two
	  slashes  in  an  array declaration statement (colons are not
	  recognized in this context) indicates that the arrays  which
	  follow  it in the current statement or which are declared by
	  the following statements  are  to  be  considered  to  be  a
	  logical  group (perhaps the contents of a single record of a
	  file).  The appearance of the two slashes causes a specially
	  marked  entry  to  be  added  to the dictionary.  If nothing
	  appears  between  the  slashes,  then  this  entry  has   no
	  associated  name  and  no  associated subscript limits.  The
	  entry does, however, specify  the  total  number  of  buffer
	  locations  which  would  be  necessary  to  store the values
	  associated with the names which follow it in the dictionary.
	  If  no  slashes  appear  at  the  start  of  the first array
	  declaration read by the current call to DALOAD, then such  a
	  zero  character  zero subscript entry is constructed anyway.
	  If the sample DIMENSION statement shown above was the  first
	  array  declaration  read  by  DALOAD, then an entry would be
	  created prior to the ABC entry stating that a total  of  415
	  buffer locations (1+125+17*1*17) would be necessary to store
	  the values associated with the  names.   If  a  name  and/or
	  subscript information appears between the slashes, then this
	  information is stored along  with  the  number  of  required
	  buffer locations.  The name and/or subscript information, is
	  meant only to identify  to  the  user,  or  to  the  calling
	  program, the particular logical grouping involved.  Although
	  the  names  enclosed  within  slashes  are  stored  in   the
	  dictionary,  the DAPICK routine cannot match such names with
	  the text typed by the user.  DAPICK will, however,  identify
	  to the calling program the location within the dictionary of
	  the  entry  which  specifies  the  length  of  the  grouping
	  FASP, FORTRAN Alphameric Subroutine Package         Page 213
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  containing the user selected name.

	  The dictionary is stored in two  arrays,  LTRSTR  containing
	  the  characters  of  the  names,  and  NUMSTR containing the
	  numeric information.  The numeric  information  consists  of
	  the following

	    a. the number of characters in the array name.  This  must
	       be  1  or greater since zero length array names are not
	       allowed.

	    b. the associated data type.  The coding is as follows

	       -1 = octal.  This  is  an  integer  type.   The  DAVARY
	            routine will use a radix value of 8 to display the
	            values to the user and to accept new  values  from
	            the  user.   It must be noted that it is the value
	            that  is  displayed  by  DAVARY,  not   an   octal
	            representation  of the bit pattern.  If the number
	            would be displayed as the radix  10  integer  -10,
	            then  it  is  displayed as the radix 8 integer -12
	            regardless of whether these octal numerals can  be
	            directly  mapped  to the binary bits used to store
	            the number in the computer.

	        0 = standard FORTRAN integer.  The DAVARY routine uses
	            radix 10 to display such values to the user and to
	            accept new values from the user.

	        1 = standard FORTRAN real.  The  DAVARY  routine  will
	            display  such values to the precision specified by
	            the calling program.

	    c. the number of subscripts.  If this is  zero,  then  the
	       name  is  nonsubscripted, but DAPICK will accept either
	       the nonsubscripted name or  the  name  and  the  single
	       subscript 1.

	    d. If the number of subscripts is greater than zero,  then
	       the  following  pairs  of numbers specify the beginning
	       and ending values of each subscript range.

	  The buffer size needed for  a  logical  grouping  is  stored
	  instead  of  an  associated  data type in an entry the first
	  number of which is the negative of the number of  characters
	  in  the name found between the two slashes.  Since a name is
	  not required between the two slashes, the  first  number  of
	  such an entry can be zero.

	  The characters of each name are merely appended to  the  end
	  of  the  LTRSTR array 1 character per array location as read
	  by a multiple of an A1 format.

	  The DIMENSION statement used earlier  as  an  example  would
	  FASP, FORTRAN Alphameric Subroutine Package         Page 214
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  generate the following dictionary information if read as the
	  first array declaration.

	       contents of the LTRSTR array

	            1HA,1HB,1HC,1HD,1HE,1HF,1HG,1HH,1HI

	       contents of the NUMSTR array (shown with each entry  on
	       a separate line)

	            0, 415,   0,
	            3,   1,   0,
	            3,   1,   1,   1,-123,
	            3,   1,   3,  20,   4,   1,   1,   4,  20


	                    The DALOAD Argument List
	                    --- ------ -------- ----

	  The argument list of routine DALOAD is

	        SUBROUTINE DALOAD(IDSK  ,LTRMAX,NUMMAX,MAXBFR,LTRUSD,
	       1NUMUSD,LTRSTR,NUMSTR,IBUFFR,IFULL )

	  with the associated DIMENSION statement

	        DIMENSION LTRSTR(LTRMAX),NUMSTR(NUMMAX),IBUFFR(MAXBFR)

	  The following are input arguments left unchanged.

	  IDSK   = number of the input unit  from  which  the  FORTRAN
	           statements  are to be read as data.  The file being
	           read from  this  unit  must  previously  have  been
	           opened  by the calling program.  If several sets of
	           array specifications appear in the  file  separated
	           by  END statements, then subsequent calls to DALOAD
	           might read from the same file.

	  LTRMAX = maximum subscript of the locations  in  the  LTRSTR
	           array  which can be used to store the characters of
	           names in the dictionary.

	  NUMMAX = maximum subscript of the locations  in  the  NUMSTR
	           array  which  can  be  used  to  store  the numeric
	           information associated with the names in the LTRSTR
	           array.

	  MAXBFR = maximum subscript of the locations  in  the  IBUFFR
	           array  which  can  be used for temporary storage of
	           each line of the  input  file,  the  characters  of
	           which    are    read    into    IBUFFR(1)   through
	           IBUFFR(MAXBFR).  MAXBFR is the number of characters
	           to be read from each line of the input file.  It is
	           suggested that IBUFFR be dimensioned  to  at  least
	  FASP, FORTRAN Alphameric Subroutine Package         Page 215
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	           72,  and  that  MAXBFR  be input with the value 72.
	           The format used in DALOAD to read the input file is
	           100A1  so  MAXBFR should not exceed 100 unless this
	           format is increased.

	  The following arguments are  used  both  for  input  to  the
	  DALOAD routine, and for output to the calling program.

	  LTRUSD = input containing the number  of  locations  in  the
	           LTRSTR  array already in use and which must be left
	           intact.  If the LTRSTR array is empty, then  LTRUSD
	           would be input containing the value 0.
	         = returned specifying the number of locations in  the
	           LTRSTR  array  in  use  after  the  current call to
	           DALOAD has appended new names  to  the  dictionary.
	           If  LTRSTR  is  returned  equal to its input value,
	           then no names were added, but it is possible that a
	           slash  or slashes in an array declaration statement
	           has caused some numeric information to be added  to
	           the NUMSTR array.

	  NUMUSD = input containing the number  of  locations  in  the
	           NUMSTR  array already in use and which must be left
	           intact.  If the NUMSTR array is empty, then  NUMUSD
	           would be input containing the value 0.
	         = returned specifying the number of locations in  the
	           NUMSTR  array  in  use  after  the  current call to
	           DALOAD has appended new array specifications to the
	           dictionary.   If NUMUSD is returned unchanged, then
	           nothing was appended to  the  dictionary.   If  the
	           computer   system   being  used  does  not  support
	           end-of-file tests in READ statements, and  if  more
	           than  one  set  of  data  is contained in the input
	           file, then the end of the file might be  marked  by
	           an  additional  END statement which can be detected
	           by checking the returned values of both NUMUSD  and
	           IFULL.

	  The  following  arguments  are  used   to   accumulate   the
	  dictionary.   Depending  upon  the application, a previously
	  constructed dictionary at the start of these arrays  can  be
	  kept intact.

	  LTRSTR = array used to store the characters of the names,  1
	           character   per  storage  location  as  read  by  a
	           multiple  of  an  A1  format.    LTRSTR   must   be
	           dimensioned to at least the value of LTRMAX.

	  NUMSTR = array  used  to  store  the   numeric   information
	           associated   with  the  names  in  the  dictionary.
	           NUMSTR must be dimensioned to at least the value of
	           NUMMAX.

	  The following argument is  used  internally  by  the  DALOAD
	  FASP, FORTRAN Alphameric Subroutine Package         Page 216
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  routine.   The  input contents of this buffer are destroyed.
	  No attempt is made to supply any meaningful  information  to
	  the calling program through this argument.

	  IBUFFR = array used by the DALOAD routine to store each line
	           of the input file as it is being processed.  IBUFFR
	           must be  dimensioned  at  least  to  the  value  of
	           MAXBFR.

	  The following argument is used only for output.   Its  input
	  value is ignored.

	  IFULL  = returned  describing  the  reason  why  DALOAD  has
	           relinquished control back to the calling program.
	         = 1, returned if an END statement  was  read  in  the
	           input file.
	         = 2, returned if an end-of-file was sensed.
	         = 3, returned if adding a requested array declaration
	           to  the  dictionary  would  have  caused the NUMSTR
	           array to overflow.  NUMUSD is returned pointing  to
	           the  end  of the numeric information concerning the
	           last  successfully  appended  array  specification.
	           Since  reading  an  END  statement,  or  sensing an
	           end-of-file, can cause  the  used  portion  of  the
	           NUMSTR  array  (but  not  of  the  LTRSTR array) to
	           increase slightly, IFULL returned containing 3 does
	           not  assure that an END statement or an end-of-file
	           was not found.
	         = 4, returned if adding a requested array declaration
	           to  the  dictionary  would  have  caused the LTRSTR
	           array to overflow.  LTRUSD is returned pointing  to
	           the  end  of  the  name  of  the  last successfully
	           appended array specification.


	                An Example of the Use of DALOAD
	                -- ------- -- --- --- -- ------

	  The sample program listed on the following page calls DALOAD
	  to  read array specifications from the user's terminal.  The
	  contents of the dictionary are summarized after  DALOAD  has
	  returned  control  back to the calling program.  This report
	  consists first of the characters in the LTRSTR  array,  then
	  of  the  numbers in the NUMSTR array shown together with the
	  first 6 letters of each  of  the  associated  names  in  the
	  LTRSTR array.

	  A sample dialog between the program and  user  is  presented
	  following the listing of the program.

	  DABELT is called to prepare a buffer which can be  typed  to
	  identify the locations of the characters of the names within
	  the LTRSTR array.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 217
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  C     PROGRAM TO DEMONSTRATE DALOAD ROUTINE
	  C
	        DIMENSION IBUFFR(72),LTRSTR(1000),NUMSTR(1000)
	        DATA ITTY,MAXBFR,LTRMAX,NUMMAX/5,72,1000,1000/
	        DATA ISPACE/1H /
	        LTRUSD=0
	        NUMUSD=0
	      1 LTRBGN=LTRUSD
	        NUMBGN=NUMUSD
	        WRITE(ITTY,2)
	      2 FORMAT(' TYPE ARRAY SPECIFICATIONS'/)
	        CALL DALOAD(ITTY,LTRMAX,NUMMAX,MAXBFR,LTRUSD,
	       1NUMUSD,LTRSTR,NUMSTR,IBUFFR,IFULL)
	  C
	  C     REPORT CHARACTER INFORMATION IN LTRSTR ARRAY
	        LTRRIT=LTRBGN
	      3 IF(LTRRIT.GE.LTRUSD)GO TO 6
	        LTRLFT=LTRRIT+1
	        LTRRIT=LTRRIT+50
	        IF(LTRRIT.GT.LTRUSD)LTRRIT=LTRUSD
	        WRITE(ITTY,4)(LTRSTR(I),I=LTRLFT,LTRRIT)
	      4 FORMAT(1X,50A1)
	        LINE=0
	      5 LINE=LINE+1
	        CALL DABELT(1,1,1,LINE,LTRLFT,
	       1LTRRIT,0,MAXBFR,IBUFFR,MAXLIN,MAXPRT,MAXUSD)
	        WRITE(ITTY,4)(IBUFFR(I),I=1,MAXPRT)
	        IF(LINE.LT.MAXLIN)GO TO 5
	        WRITE(ITTY,4)
	        GO TO 3
	  C
	  C     REPORT NUMERIC INFORMATION IN NUMSTR ARRAY
	      6 IF(NUMBGN.GE.NUMUSD)GO TO 11
	        NUMLFT=NUMBGN+1
	        LTRLFT=LTRBGN+1
	        NUMBGN=NUMBGN+3+(2*NUMSTR(NUMLFT+2))
	        LTRBGN=LTRBGN+IABS(NUMSTR(NUMLFT))
	        DO 7 MAXPRT=1,6
	      7 IBUFFR(MAXPRT)=ISPACE
	        MAXPRT=0
	      8 IF(LTRLFT.GT.LTRBGN)GO TO 9
	        MAXPRT=MAXPRT+1
	        IBUFFR(MAXPRT)=LTRSTR(LTRLFT)
	        LTRLFT=LTRLFT+1
	        GO TO 8
	      9 WRITE(ITTY,10)NUMLFT,NUMBGN,(IBUFFR(I),I=1,6),
	       1(NUMSTR(I),I=NUMLFT,NUMBGN)
	     10 FORMAT(' NUMSTR(',I4,'/',1I4,') ',6A1,100I4)
	        GO TO 6
	     11 WRITE(ITTY,12)IFULL
	     12 FORMAT(/' IFULL=',1I2/)
	        IF(IFULL.LE.2)GO TO 1
	        STOP
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 218
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  Typical Dialog Between DALOAD Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  TYPE ARRAY SPECIFICATIONS
	        COMMON FIRST(10),SECOND,THIRD(-100/-91)
	       1IFOURTH(10,10/,11/20)
	        IMPLICIT INTEGER(O-V)OCTAL(A-H,W-Z)
	        COMMON/SLASHES/FIFTH,SIXTH(-5)
	        REAL SEVENTH(1),EIGHTH(3/3)
	        DIMENSION/(4)/NINTH,TENTH//ELEVENTH
	        END

	  FIRSTSECONDTHIRDIFOURTHSLASHESFIFTHSIXTHSEVENTHEIG
	  12345678911111111112222222222333333333344444444445
	           01234567890123456789012345678901234567890

	  HTHNINTHTENTHELEVENTH
	  555555555666666666677
	  123456789012345678901

	  NUMSTR(   1/   3)          01021   0
	  NUMSTR(   4/   8) FIRST    5   1   1   1  10
	  NUMSTR(   9/  11) SECOND   6   1   0
	  NUMSTR(  12/  16) THIRD    5   1   1-100 -91
	  NUMSTR(  17/  25) IFOURT   7   0   3   1  10  10   1  11  20
	  NUMSTR(  26/  28) SLASHE  -7  10   0
	  NUMSTR(  29/  31) FIFTH    5  -1   0
	  NUMSTR(  32/  36) SIXTH    5   0   1   1  -5
	  NUMSTR(  37/  41) SEVENT   7   1   1   1   1
	  NUMSTR(  42/  46) EIGHTH   6   1   1   3   3
	  NUMSTR(  47/  51)          0   2   1   1   4
	  NUMSTR(  52/  54) NINTH    5   0   0
	  NUMSTR(  55/  57) TENTH    5   0   0
	  NUMSTR(  58/  60)          0   1   0
	  NUMSTR(  61/  63) ELEVEN   8  -1   0

	  IFULL= 1

	  TYPE ARRAY SPECIFICATIONS
	  C     TEST DEFAULT ASSOCIATIONS OF LETTERS WITH TYPES
	        DIMENSION/PRESENT(22,55)/ABC,IJK,OPQ,WXY
	        END

	  PRESENTABCIJKOPQWXY
	  7777777788888888889
	  2345678901234567890

	  NUMSTR(  64/  70) PRESEN  -7   4   2   1  22   1  55
	  NUMSTR(  71/  73) ABC      3   1   0
	  NUMSTR(  74/  76) IJK      3   0   0
	  NUMSTR(  77/  79) OPQ      3   1   0
	  NUMSTR(  80/  82) WXY      3   1   0

	  IFULL= 1
	  FASP, FORTRAN Alphameric Subroutine Package         Page 219
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  Example of Use of Several Named Array Manipulation Routines
	  ------- -- --- -- ------- ----- ----- ------------ --------

	  An  interactive  program  which  was  used  to   prove   the
	  sufficiency  of  the named array manipulation routines for a
	  particular application is  listed  on  the  following  pages
	  together  with  a  dialog  between the user and the program.
	  Also listed is  a  shorter  noninteractive  support  program
	  which constructs a data base for the interactive program.

	  The interactive program  allows  the  user  to  examine  and
	  change the values in 6 different groups of simulated arrays.
	  Each data file read and written by the  program  stores  the
	  values  of  a  single  group  of simulated arrays.  In those
	  cases where different versions of the  values  of  a  single
	  group  are maintained, these versions are selected by GLOBAL
	  and LOCAL identification numbers typed  by  the  user.   The
	  GLOBAL  number selects the final character of the file name.
	  The LOCAL number selects a record within the file.   If  the
	  user  types  the  name  of  an  array  which  does  not vary
	  according to either GLOBAL  or  LOCAL  numbers,  then  these
	  numbers are ignored.  To select a new LOCAL number, the user
	  types an empty line in response to the request  for  another
	  array  name.   To select a new GLOBAL number, the user types
	  an empty line (or zero) in response to the request for a new
	  LOCAL  number.   When  the  contents of a new record must be
	  read, the contents of previous record are first written back
	  into the file if these values have been changed by the user.
	  The program reports to the user when files  are  opened  and
	  when records are read and written.

	  The values initially stored in the data files are merely the
	  sequence  numbers  of  the  locations  containing the values
	  relative to all locations storing values for that particular
	  group  of  simulated  arrays.   In  the  assignment of these
	  values, the LOCAL number is varied  more  rapidly  than  the
	  GLOBAL  numbers,  i.e.   where different versions are stored
	  for both LOCAL and GLOBAL numbers, the  counts  continue  in
	  the  record  selected  by  the next higher LOCAL number, and
	  when the end of the file has been reached, are continued  in
	  the  file selected by the next higher GLOBAL number.  To aid
	  the user in checking the operation of the program, the  name
	  of   each   simulated  array  is  constructed  of  a  single
	  alphabetic letter followed by the digits of the number which
	  is  the  subscript of the buffer location which contains the
	  start of the simulated array, and each  group  of  simulated
	  arrays  which  can  vary  by  either GLOBAL or LOCAL numbers
	  contains a multiple of 1000 locations.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 220
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	   Program Which Constructs Data Base for Interactive Program
	   ------- ----- ---------- ---- ---- --- ----------- -------

	  C     RENBR(MAKDAT/MAKE DATA FILES FOR NAMED ARRAY DEMO)
	  C
	        DIMENSION LTRSTR(1000),NUMSTR(1000),IARRAY(2000),
	       1AARRAY(2000),IBUFFR(72),ITWO(6),IFOUR(6)
	        EQUIVALENCE(IARRAY(1),AARRAY(1))
	  C
	  C     NAMES OF INPUT FILE CONTAINING VALUES TO MANIPULATE
	        DATA ITWO/
	       15HTWO1 ,5HTWO2 ,5HTWO3 ,5HTWO4 ,5HTWO5 ,5HTWO6 /
	        DATA IFOUR/
	       15HFOUR1,5HFOUR2,5HFOUR3,5HFOUR4,5HFOUR5,5HFOUR6/
	  C
	  C     SIZES OF VARIOUS ARRAYS
	  C     MAXBFR = DIMENSION OF IBUFFR ARRAY
	  C     LTRMAX = DIMENSION OF LTRSTR ARRAY
	  C     NUMMAX = DIMENSION OF NUMSTR ARRAY
	        DATA MAXBFR,LTRMAX,NUMMAX/72,1000,1000/
	  C
	  C     UNIT NUMBERS
	  C     ITTY   = UNIT NUMBER OF USER TERMINAL FOR INPUT
	  C     JTTY   = UNIT NUMBER OF USER TERMINAL FOR OUTPUT
	  C     IDSK   = UNIT NUMBER FOR READING ALL FILES
	        DATA ITTY,JTTY,IDSK/5,5,1/
	  C
	  C     ESTABLISH ARRAY MANIPULATION DICTIONARY
	        LTRUSD=0
	        NUMUSD=0
	        CALL IFILE(IDSK,5HARRAY)
	        CALL DALOAD(IDSK,LTRMAX,NUMMAX,MAXBFR,LTRUSD,
	       1NUMUSD,LTRSTR,NUMSTR,IBUFFR,IFULL)
	        CALL RELEAS(IDSK)
	        WRITE(JTTY,1)NUMUSD,NUMMAX,LTRUSD,LTRMAX
	      1 FORMAT(' USED STORAGE',1I5,1H/,1I5,' NUMERIC'/
	       113X,1I5,1H/,1I5,' CHARACTER')
	  C
	  C     OBTAIN DESCRIPTION OF NEXT FILE
	        KNDFIL=0
	      2 KNDFIL=KNDFIL+1
	        CALL DABASE(2,2,1,IBUFFR,KNDFIL,
	       11,LTRUSD,LTRSTR,1,NUMUSD,NUMSTR,LRGLTR,
	       2LRGNUM,LRGKNT)
	        IF(LRGKNT.LE.0)GO TO 19
	        NEWSIZ=NUMSTR(LRGNUM+1)
	        KNTLOC=0
	        NUMINI=LRGNUM+3+(2*NUMSTR(LRGNUM+2))
	        KONTRL=NUMSTR(NUMINI+1)
	        MAXFIL=1
	        MAXRCD=1
	        NEWFIL=1
	      3 GO TO(4,5,6,7,8,9),KNDFIL
	      4 NEWNAM=3HONE
	  FASP, FORTRAN Alphameric Subroutine Package         Page 221
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	        GO TO 10
	      5 MAXFIL=6
	        NEWNAM=ITWO(NEWFIL)
	        GO TO 10
	      6 NEWNAM=5HTHREE
	        GO TO 10
	      7 MAXFIL=6
	        MAXRCD=3
	        NEWNAM=IFOUR(NEWFIL)
	        GO TO 10
	      8 MAXRCD=3
	        NEWNAM=4HFIVE
	        GO TO 10
	      9 NEWNAM=3HSIX
	  C
	  C     WRITE THE FILE
	     10 CALL OFILE(IDSK,NEWNAM)
	        DO 18 NEWRCD=1,MAXRCD
	        IF(KONTRL.GT.0)GO TO 12
	        DO 11 I=1,NEWSIZ
	        KNTLOC=KNTLOC+1
	     11 IARRAY(I)=KNTLOC
	        WRITE(IDSK)(IARRAY(I),I=1,NEWSIZ)
	        GO TO 14
	     12 DO 13 I=1,NEWSIZ
	        KNTLOC=KNTLOC+1
	     13 AARRAY(I)=KNTLOC
	        WRITE(IDSK)(AARRAY(I),I=1,NEWSIZ)
	     14 IF((NEWRCD.EQ.1).AND.(NEWFIL.EQ.1))
	       1WRITE(JTTY,15)KNDFIL,NEWNAM,NEWRCD,KNTLOC
	     15 FORMAT(' TYPE =',1I2,', NAME = ',1A5,
	       1', RCRD =',1I2,', THRU =',1I6)
	        IF((NEWRCD.EQ.1).AND.(NEWFIL.GT.1))
	       1WRITE(JTTY,16)NEWNAM,NEWRCD,KNTLOC
	     16 FORMAT(11X,'NAME = ',1A5,
	       1', RCRD =',1I2,', THRU =',1I6)
	        IF(NEWRCD.GT.1)WRITE(JTTY,17)NEWRCD,KNTLOC
	     17 FORMAT(25X,'RCRD =',1I2,', THRU =',1I6)
	     18 CONTINUE
	        END FILE IDSK
	        NEWFIL=NEWFIL+1
	        IF(NEWFIL.LE.MAXFIL)GO TO 3
	        GO TO 2
	     19 STOP
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 222
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  Data File Read by DALOAD to Define Array Names in Dictionary
	  ---- ---- ---- -- ------ -- ------ ----- ----- -- ----------

	  C     FILE TO BE READ BY NAMED ARRAY DEMONSTRATION PROGRAM
	  C
	  C     SECOND FILE TYPE, VARIES BY GLOBAL NUMBER ONLY
	        COMMON/SECOND(2)/A1(24,4),A97(16,4),A161(16/1,4),A225(
	       116,4/1),A289(16/1,4/1),A353(-1/-100),A453(6,64),A837(4
	       2,4),A853(4,8),A885(4,4),A901(100/)
	  C
	  C     FOURTH FILE TYPE, VARIES BY GLOBAL AND LOCAL NUMBERS
	        COMMON/FOURTH(4)/B1,B2(6,6),B38(6,4),B62(8,6),B110(2,1
	       12,4),B206(3),B209(12,6),B281(3,2,6),B317(6,2),B329(6),
	       2B335(4,4),B351(8,4),B383(2,3,4),B407(2,4),B415(2,4,3,4
	       3),B511(2,3),B517(2,2,4)
	        COMMON B533(2,12,4),B629(2,15,4),B749(40,2),B829(2,12,
	       12),B877(12,4,2),B973(7,4,2),B1029(13,20),B1289(8,4),B1
	       2321(8,20),B1481(6),B1487(10),B1497(4,4),B1513(2,6),B15
	       325(4,4)
	        COMMONB1541(5,4,4),B1621(20),B1641(4,4),B1657(10,4),
	       1 B 1 6 9 7 ( 2 , 1 2 , 3 , 4 ) , B 1 9 8 5 ( 4 , 4 )
	  C
	  C     FIRST FILE TYPE, 1 COPY ONLY
	        COMMON/FIRST(1)/C1(10),C11(10),C21(30),C51(8),C59(2,4)
	       1,C67(3,3,2),C85(2,4),C93(3,3,3,2),C147(4,2,4),
	       2C179(3,2,4,2),C227(2,3,4)
	  C
	  C     FIFTH FILE TYPE, VARIES BY LOCAL NUMBER ONLY
	        COMMON/FIFTH(5)/D1(3,3),D10(14,4),D66(4,3),D78(4,22),
	       1D166(2,3,6),D202(2,4),D210(3,4),D222(4),D226(4,3),
	       2D238(5),D243(31,18),D801(2,2,4,8),D929(4,3,2,16),
	       3D1313(3,4,3,16),D1889(2,4,14)
	  C
	  C     THIRD FILE TYPE, 1 COPY ONLY
	        OCTAL/THIRD(3)/I1(4,2),I9(4),I13(25)
	        COMMON I38(2,4),I46,I47(5/5),I48(1),I49(2)
	  C
	  C     SIXTH FILE TYPE, 1 COPY ONLY
	        COMMON/SIXTH(6)/J1(4,4,2),J33(18)
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 223
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	   File Description Produced During Construction of Data Base
	   ---- ----------- -------- ------ ------------ -- ---- ----

	  USED STORAGE  632/ 1000 NUMERIC
	                348/ 1000 CHARACTER
	  TYPE = 1, NAME = ONE  , RCRD = 1, THRU =   250
	  TYPE = 2, NAME = TWO1 , RCRD = 1, THRU =  1000
	            NAME = TWO2 , RCRD = 1, THRU =  2000
	            NAME = TWO3 , RCRD = 1, THRU =  3000
	            NAME = TWO4 , RCRD = 1, THRU =  4000
	            NAME = TWO5 , RCRD = 1, THRU =  5000
	            NAME = TWO6 , RCRD = 1, THRU =  6000
	  TYPE = 3, NAME = THREE, RCRD = 1, THRU =    50
	  TYPE = 4, NAME = FOUR1, RCRD = 1, THRU =  2000
	                          RCRD = 2, THRU =  4000
	                          RCRD = 3, THRU =  6000
	            NAME = FOUR2, RCRD = 1, THRU =  8000
	                          RCRD = 2, THRU = 10000
	                          RCRD = 3, THRU = 12000
	            NAME = FOUR3, RCRD = 1, THRU = 14000
	                          RCRD = 2, THRU = 16000
	                          RCRD = 3, THRU = 18000
	            NAME = FOUR4, RCRD = 1, THRU = 20000
	                          RCRD = 2, THRU = 22000
	                          RCRD = 3, THRU = 24000
	            NAME = FOUR5, RCRD = 1, THRU = 26000
	                          RCRD = 2, THRU = 28000
	                          RCRD = 3, THRU = 30000
	            NAME = FOUR6, RCRD = 1, THRU = 32000
	                          RCRD = 2, THRU = 34000
	                          RCRD = 3, THRU = 36000
	  TYPE = 5, NAME = FIVE , RCRD = 1, THRU =  2000
	                          RCRD = 2, THRU =  4000
	                          RCRD = 3, THRU =  6000
	  TYPE = 6, NAME = SIX  , RCRD = 1, THRU =    50
	  FASP, FORTRAN Alphameric Subroutine Package         Page 224
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  Interactive Program Using Named Array Manipulation Routines
	  ----------- ------- ----- ----- ----- ------------ --------

	  C     RENBR(TSTNAM/TEST NAMED ARRAY MANIPULATION ROUTINES)
	  C
	        DIMENSION LTRSTR(1000),NUMSTR(1000),IARRAY(2000),
	       1AARRAY(2000),IBUFFR(72),INISUB(7),LMTSUB(7),
	       2NOWSUB(7),INCSUB(7),NAME(60),ITWO(6),IFOUR(6),
	       3IDOUBL(2)
	        EQUIVALENCE(IARRAY(1),AARRAY(1))
	  C
	  C     INITIAL VALUES FOR INCREMENT ARRAY
	        DATA INCSUB/7*0/
	  C
	  C     NAMES OF INPUT FILE CONTAINING VALUES TO MANIPULATE
	        DATA ITWO/
	       15HTWO1 ,5HTWO2 ,5HTWO3 ,5HTWO4 ,5HTWO5 ,5HTWO6 /
	        DATA IFOUR/
	       15HFOUR1,5HFOUR2,5HFOUR3,5HFOUR4,5HFOUR5,5HFOUR6/
	  C
	  C     SIZES OF VARIOUS ARRAYS
	  C     NAMMAX = DIMENSION OF NAME ARRAY
	  C     MAXBFR = DIMENSION OF IBUFFR ARRAY
	  C     LTRMAX = DIMENSION OF LTRSTR ARRAY
	  C     NUMMAX = DIMENSION OF NUMSTR ARRAY
	  C     MAXSUB = DIMENSIONS OF INISUB,LMTSUB,NOWSUB,INCSUB
	        DATA NAMMAX,MAXBFR,LTRMAX,NUMMAX,MAXSUB/
	       160,72,1000,1000,7/
	  C
	  C     UNIT NUMBERS
	  C     ITTY   = UNIT NUMBER OF USER TERMINAL FOR INPUT
	  C     JTTY   = UNIT NUMBER OF USER TERMINAL FOR OUTPUT
	  C     IDSK   = UNIT NUMBER FOR READING ALL FILES
	        DATA ITTY,JTTY,IDSK/5,5,1/
	  C
	  C     ESTABLISH ARRAY MANIPULATION DICTIONARY
	        LTRUSD=0
	        NUMUSD=0
	        CALL IFILE(IDSK,5HARRAY)
	        CALL DALOAD(IDSK,LTRMAX,NUMMAX,MAXBFR,LTRUSD,
	       1NUMUSD,LTRSTR,NUMSTR,IBUFFR,IFULL)
	        CALL RELEAS(IDSK)
	        IF(IFULL.EQ.1)WRITE(JTTY,1)
	      1 FORMAT(' DALOAD - END STATEMENT READ')
	        IF(IFULL.EQ.2)WRITE(JTTY,2)
	      2 FORMAT(' DALOAD - END-OF-FILE READ')
	        IF(IFULL.EQ.3)WRITE(JTTY,3)
	      3 FORMAT(' DALOAD - NUMSTR ARRAY OVERFLOW')
	        IF(IFULL.EQ.4)WRITE(JTTY,4)
	      4 FORMAT(' DALOAD - LTRSTR ARRAY OVERFLOW')
	        WRITE(JTTY,5)NUMUSD,NUMMAX,LTRUSD,LTRMAX
	      5 FORMAT(' USED STORAGE',1I5,1H/,1I5,' NUMERIC'/
	       113X,1I5,1H/,1I5,' CHARACTER')
	  C
	  FASP, FORTRAN Alphameric Subroutine Package         Page 225
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  C     TYPE DESCRIPTION OF DICTIONARY
	        WRITE(JTTY,6)
	      6 FORMAT(' TYPE ARRAY DESCRIPTION (Y OR N) ',$)
	        READ(ITTY,7)IFYES
	      7 FORMAT(1A1)
	        IF(IFYES.EQ.1HY)CALL DALIST(JTTY,1,LTRUSD,LTRSTR,1,
	       1NUMUSD,NUMSTR,NAMMAX,NAME)
	  C
	  C     ASK USER FOR WHAT RECORD HE WANTS
	        LSTRCD=0
	      8 WRITE(JTTY,9)
	      9 FORMAT(' GLOBAL NUMBER ',$)
	        READ(ITTY,10)MAJOR
	     10 FORMAT(1I)
	        IF(MAJOR.LE.0)GO TO 11
	        IF(MAJOR.LE.6)GO TO 13
	     11 WRITE(JTTY,12)
	     12 FORMAT(' EXIT (Y OR N) ',$)
	        READ(ITTY,7)IFYES
	        IF(IFYES.NE.1HY)GO TO 8
	        IF(LSTRCD.EQ.0)GO TO 43
	        MAJOR=0
	        GO TO 33
	     13 WRITE(JTTY,14)
	     14 FORMAT(' LOCAL NUMBER ',$)
	        READ(ITTY,10)MINOR
	        IF(MINOR.LE.0)GO TO 8
	        IF(MINOR.GT.3)GO TO 8
	  C
	  C     GET FIRST USER ARRAY SPECIFICATION
	     15 WRITE(JTTY,16)
	     16 FORMAT(' ARRAY NAME ',$)
	        READ(ITTY,17)IBUFFR
	     17 FORMAT(72A1)
	        LOWBFR=1
	        KIND=-1
	     18 CALL DAPICK(MAXBFR,IBUFFR,1,LTRUSD,LTRSTR,
	       11,NUMUSD,NUMSTR,MAXSUB,LOWBFR,KIND,LRGLTR,
	       2LRGNUM,LRGKNT,INITAL,KOUNT,LTRINI,NUMINI,KNTSUB,
	       3INISUB,LMTSUB)
	        GO TO(25,25,13,15,23,23,21,19),KIND
	  C
	  C     SEMICOLON REQUIRED IF TEXT PREVIOUSLY SPECIFIED
	     19 WRITE(JTTY,20)
	     20 FORMAT(' SEMICOLON REQUIRED')
	        GO TO 15
	  C
	  C     UNKNOWN NAME
	     21 WRITE(JTTY,22)
	     22 FORMAT(' UNKNOWN')
	        GO TO 15
	  C
	  C     REPORT CORRECT SUBSCRIPT LIMITS IF IN ERROR
	     23 NAMUSD=0
	  FASP, FORTRAN Alphameric Subroutine Package         Page 226
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	        CALL DALONE(-1,LTRINI,LTRUSD,LTRSTR,NUMINI,
	       1NUMUSD,NUMSTR,7,NOWSUB,NAMMAX,NAME,NAMUSD)
	        IF(NAMUSD.GT.0)WRITE(JTTY,24)(NAME(I),I=1,NAMUSD)
	     24 FORMAT(' CORRECT LIMITS ARE ',72A1)
	        GO TO 15
	  C
	  C     DETERMINE THE NEWLY SELECTED FILE AND RECORD
	     25 NEWSIZ=NUMSTR(LRGNUM+1)
	        NEWRCD=1
	        IDENT=NUMSTR(LRGNUM+4)
	        GO TO(26,27,28,29,30,31),IDENT
	     26 NEWNAM=3HONE
	        GO TO 32
	     27 NEWNAM=ITWO(MAJOR)
	        GO TO 32
	     28 NEWNAM=5HTHREE
	        GO TO 32
	     29 NEWNAM=IFOUR(MAJOR)
	        NEWRCD=MINOR
	        GO TO 32
	     30 NEWNAM=4HFIVE
	        NEWRCD=MINOR
	        GO TO 32
	     31 NEWNAM=3HSIX
	  C
	  C     TEST IF NEED TO WRITE OUT FORMER DATA
	     32 IF(LSTRCD.EQ.0)GO TO 36
	        IF(LSTRCD.NE.NEWRCD)GO TO 33
	        IF(LSTNAM.EQ.NEWNAM)GO TO 41
	     33 IF(MODIFY.LE.0)GO TO 35
	        WRITE(JTTY,34),LSTRCD
	     34 FORMAT(1X,'WRITING RECORD',1I3)
	        WRITE(IDSK#LSTRCD)(AARRAY(I),I=1,LSTSIZ)
	     35 IF(MAJOR.EQ.0)GO TO 43
	        IF(LSTNAM.EQ.NEWNAM)GO TO 39
	        CALL RELEAS(IDSK)
	  C
	  C     OPEN NEXT FILE
	     36 ENCODE(10,37,IDOUBL)NEWNAM
	     37 FORMAT(1A5,5H.DAT )
	        WRITE(JTTY,38)IDOUBL,NEWSIZ
	     38 FORMAT(1X,'OPENING ',2A5,'SIZE',1I5)
	        CALL DEFINE FILE(IDSK,NEWSIZ,IDUMMY,IDOUBL,0,0)
	  C
	  C     READ NEW INFORMATION
	     39 WRITE(JTTY,40)NEWRCD
	     40 FORMAT(1X,'READING RECORD',1I3)
	        READ(IDSK#NEWRCD)(AARRAY(I),I=1,NEWSIZ)
	        MODIFY=0
	        LSTNAM=NEWNAM
	        LSTRCD=NEWRCD
	        LSTSIZ=NEWSIZ
	  C
	  C     ADVANCE THE SUBSCRIPTS THROUGH THE RANGE
	  FASP, FORTRAN Alphameric Subroutine Package         Page 227
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	     41 INLOOP=0
	        KONTRL=NUMSTR(NUMINI+1)
	        LSTKNT=KOUNT
	     42 CALL DAROLL(0,1,KNTSUB,INISUB,LMTSUB,
	       1INCSUB,INLOOP,NOWSUB)
	        IF(INLOOP.EQ.0)GO TO 18
	  C
	  C     FIND THE NEWLY SELECTED ITEM IN THE BUFFER
	        CALL DASITE(0,KOUNT,1,KNTSUB,NOWSUB,
	       1-2,LRGNUM,NUMUSD,NUMSTR,LSTKNT,NUMINI,INITAL,
	       2LOCATN)
	  C
	  C     CONSTRUCT ALPHAMERIC REPRESENTATION OF ARRAY NAME
	        NAMUSD=0
	        CALL DALONE(0,LTRINI,LTRUSD,LTRSTR,NUMINI,
	       1NUMUSD,NUMSTR,KNTSUB,NOWSUB,NAMMAX,NAME,NAMUSD)
	  C
	  C     TYPE CURRENT VALUE AND MODIFY IF REQUESTED.
	        CALL DAVARY(KONTRL,ITTY,JTTY,LOCATN,NAMUSD,
	       1NAMMAX,MAXBFR,0,-1,8,6,6,
	       25,AARRAY,IARRAY,NAME,IBUFFR,LOWBFR,KIND,
	       3MODIFY)
	        IF(KIND.NE.0)GO TO 42
	        GO TO 18
	  C
	  C     USER HAS REQUESTED EXIT
	     43 STOP
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 228
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	   Portion of Dialog Text Shown Below Which Was Typed by User
	   ------- -- ------ ---- ----- ----- ----- --- ----- -- ----

	  The user typed the following text which is included  in  the
	  dialog.

	  Y
	  1
	  1
	  B1985(4,4)!END OF 1ST 2K RECORD OF 1ST FILE

	  3
	  B1985(4,4)!END OF 3RD 2K RECORD OF 1ST FILE


	  4
	  2
	  B1985(4,4)!END OF 2ND 2K RECORD OF 4TH 6K FILE
	  D1889(2,4,14!END OF 2ND 2K RECORD OF SINGLE FILE
	  &NEXT LINE TESTS ARRAYS WITH WEIRD DIMENSIONS
	  A901(100);A161(16,1);A161(1,4);A353(/-4)
	  &NEXT LINES TEST ABILITY TO CHANGE VALUES
	  I9()=100/100/400;I46(1)=
	  &NOTE THAT I9 IS OCTAL, I46 DECIMAL
	  100;I48()=200;I48(1)=

	  &BLANK RESPONSE KEPT THE ABOVE VALUE FOR I48
	  B407(,)=2*,2*.023,1K/1/2K;I9(4/1);I46;I48;B407(,)



	  Dialog With Program Using Named Array Manipulation Routines
	  ------ ---- ------- ----- ----- ----- ------------ --------

	  DALOAD - END STATEMENT READ
	  USED STORAGE  632/ 1000 NUMERIC
	                348/ 1000 CHARACTER
	  TYPE ARRAY DESCRIPTION (Y OR N) Y
	  1000 SECOND(2)
	  REAL A1(24,4) A97(16,4) A161(16/1,4) A225(16,4/1)
	  REAL A289(16/1,4/1) A353(-1/-100) A453(6,64) A837(4,4)
	  REAL A853(4,8) A885(4,4) A901(100/1)
	  2000 FOURTH(4)
	  REAL B1 B2(6,6) B38(6,4) B62(8,6) B110(2,12,4) B206(3)
	  REAL B209(12,6) B281(3,2,6) B317(6,2) B329(6) B335(4,4)
	  REAL B351(8,4) B383(2,3,4) B407(2,4) B415(2,4,3,4)
	  REAL B511(2,3) B517(2,2,4) B533(2,12,4) B629(2,15,4)
	  REAL B749(40,2) B829(2,12,2) B877(12,4,2) B973(7,4,2)
	  REAL B1029(13,20) B1289(8,4) B1321(8,20) B1481(6) B1487(10)
	  REAL B1497(4,4) B1513(2,6) B1525(4,4) B1541(5,4,4)
	  REAL B1621(20) B1641(4,4) B1657(10,4) B1697(2,12,3,4)
	  REAL B1985(4,4)
	  250 FIRST(1)
	  REAL C1(10) C11(10) C21(30) C51(8) C59(2,4) C67(3,3,2)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 229
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  REAL C85(2,4) C93(3,3,3,2) C147(4,2,4) C179(3,2,4,2)
	  REAL C227(2,3,4)
	  2000 FIFTH(5)
	  REAL D1(3,3) D10(14,4) D66(4,3) D78(4,22) D166(2,3,6)
	  REAL D202(2,4) D210(3,4) D222(4) D226(4,3) D238(5)
	  REAL D243(31,18) D801(2,2,4,8) D929(4,3,2,16)
	  REAL D1313(3,4,3,16) D1889(2,4,14)
	  50 THIRD(3)
	  OCTAL I1(4,2) I9(4) I13(25)
	  INTEGER I38(2,4) I46 I47(5/5) I48(1) I49(2)
	  50 SIXTH(6)
	  INTEGER J1(4,4,2) J33(18)
	  GLOBAL NUMBER 1
	  LOCAL NUMBER 1
	  ARRAY NAME B1985(4,4)!END OF 1ST 2K RECORD OF 1ST FILE
	  OPENING FOUR1.DAT SIZE 2000
	  READING RECORD  1
	  B1985(4,4) = 2000
	  ARRAY NAME
	  LOCAL NUMBER 3
	  ARRAY NAME B1985(4,4)!END OF 3RD 2K RECORD OF 1ST FILE
	  READING RECORD  3
	  B1985(4,4) = 6000
	  ARRAY NAME
	  LOCAL NUMBER
	  GLOBAL NUMBER 4
	  LOCAL NUMBER 2
	  ARRAY NAME B1985(4,4)!END OF 2ND 2K RECORD OF 4TH 6K FILE
	  OPENING FOUR4.DAT SIZE 2000
	  READING RECORD  2
	  B1985(4,4) = 22000
	  ARRAY NAME D1889(2,4,14!END OF 2ND 2K RECORD OF SINGLE FILE
	  OPENING FIVE .DAT SIZE 2000
	  READING RECORD  2
	  D1889(2,4,14) = 4000
	  ARRAY NAME &NEXT LINE TESTS ARRAYS WITH WEIRD DIMENSIONS
	  ARRAY NAME A901(100);A161(16,1);A161(1,4);A353(/-4)
	  OPENING TWO4 .DAT SIZE 1000
	  READING RECORD  1
	  A901(100) = 3901
	  A161(16,1) = 3161
	  A161(1,4) = 3224
	  A353(-1) = 3353
	  A353(-2) = 3354
	  A353(-3) = 3355
	  A353(-4) = 3356
	  ARRAY NAME &NEXT LINES TEST ABILITY TO CHANGE VALUES
	  ARRAY NAME I9()=100/100/400;I46(1)=
	  OPENING THREE.DAT SIZE   50
	  READING RECORD  1
	  I9(1) = 11 = 100
	  I9(2) = 12 = 200
	  I9(3) = 13 = 300
	  I9(4) = 14 = 400
	  FASP, FORTRAN Alphameric Subroutine Package         Page 230
	  DALOAD, Routine to Make Dictionary Describing Named Arrays


	  I46 = 46 = &NOTE THAT I9 IS OCTAL, I46 DECIMAL
	  I46 = 46 = 100;I48()=200;I48(1)=
	  I48(1) = 48 = 200
	  I48(1) = 200 =
	  ARRAY NAME &BLANK RESPONSE KEPT THE ABOVE VALUE FOR I48
	  ARRAY NAME B407(,)=2*,2*.023,1K/1/2K;I9(4/1);I46;I48;B407(,)
	  WRITING RECORD  1
	  OPENING FOUR4.DAT SIZE 2000
	  READING RECORD  2
	  B407(1,2) = 20409 = .023
	  B407(2,2) = 20410 = .023
	  B407(1,3) = 20411 = 1000
	  B407(2,3) = 20412 = 1001
	  B407(1,4) = 20413 = 1002
	  B407(2,4) = 20414 = 1003
	  WRITING RECORD  2
	  OPENING THREE.DAT SIZE   50
	  READING RECORD  1
	  I9(4) = 400
	  I9(3) = 300
	  I9(2) = 200
	  I9(1) = 100
	  I46 = 100
	  I48(1) = 200
	  OPENING FOUR4.DAT SIZE 2000
	  READING RECORD  2
	  B407(1,1) = 20407
	  B407(2,1) = 20408
	  B407(1,2) = .023
	  B407(2,2) = .023
	  B407(1,3) = 1000
	  B407(2,3) = 1001
	  B407(1,4) = 1002
	  B407(2,4) = 1003
	  FASP, FORTRAN Alphameric Subroutine Package         Page 231
	  DALONE, Routine to Represent Array Name and Subscript Limits


	   DDDDD          AAA  LL         OOOOO    NN    NN  EEEEEEEE
	   DD   DD       AAAA  LL        OO   OO   NNN   NN  EE
	   DD    DD     AA AA  LL       OO     OO  NNNN  NN  EE
	   DD    DD    AA  AA  LL       OO     OO  NN NN NN  EEEEE
	   DD    DD   AAAAAAA  LL       OO     OO  NN  NNNN  EE
	   DD   DD   AA    AA  LL        OO   OO   NN   NNN  EE
	   DDDDD    AA     AA  LLLLLLLL   OOOOO    NN    NN  EEEEEEEE



	  DALONE, Routine to Represent Array Name and Subscript Limits
	  ------  ------- -- --------- ----- ---- --- --------- ------

	  DALOAN represents the name of  an  array  contained  in  the
	  dictionary  constructed  by  the  DALOAD  routine  and  also
	  represents the subscripts of this array so that the name and
	  subscripts  can  be  written  by  the calling program with a
	  FORTRAN format statement containing  a  multiple  of  an  A1
	  alphameric specification.

	  DALONE is used along with several other routines in the FASP
	  package for the purpose of specifying by name, examining and
	  modifying  the  values  of   multiply   subscripted   arrays
	  equivalenced   with   or  otherwise  loaded  into  a  singly
	  subscripted buffer.  The interaction between these  routines
	  is  described at the start of the DALOAD documentation.  The
	  sample program  at  the  end  of  the  DALOAD  documentation
	  illustrates the use of most of these routines.



	                    The DALONE Argument List
	                    --- ------ -------- ----

	  The argument list of routine DALONE is

	        SUBROUTINE DALONE(LMTTYP,LTRINI,LTRUSD,LTRSTR,NUMINI,
	       1    NUMUSD,NUMSTR,KNTSUB,NOWSUB,NAMMAX,NAME  ,NAMUSD)

	  with the associated DIMENSION statement

	        DIMENSION LTRSTR(LTRUSD),NUMSTR(NUMUSD),
	       1NAME(NAMMAX),NOWSUB(KNTSUB)

	  The following arguments are used  only  for  input  and  are
	  returned unchanged.

	  LMTTYP = -2, the characters placed into the NAME  array  are
	           to include

	             a. an identification of the data type  associated
	                with  the name of the array.  This will be one
	                of the words OCTAL, INTEGER or REAL.   If  the
	                item  being  represented  is  instead the name
	  FASP, FORTRAN Alphameric Subroutine Package         Page 232
	  DALONE, Routine to Represent Array Name and Subscript Limits


	                and/or subscript  limits  associated  with  an
	                entire  logical group of array names, then the
	                number  of  locations  required  in  a  singly
	                subscripted buffer to contain the entire group
	                of arrays is represented rather than the  data
	                type.

	             b. the name of the array or of the logical  group
	                of arrays.

	             c. within  parentheses,  the   subscript   limits
	                stored  in  the dictionary for this particular
	                array or for this  logical  group  of  arrays.
	                When  such  information  is  included with the
	                name of a logical group of arrays, it is meant
	                to  be  searched  for  by  the DABASE routine,
	                rather than to indicate subscript limits.

	         = -1, same as LMTTYP=-2, except that  the  associated
	           data type or buffer size is not identified.
	         = 0, the representation is to include the name of the
	           array  and,  enclosed in parentheses, the values of
	           the current  subscripts  contained  in  the  NOWSUB
	           array.   If the dictionary indicates that the array
	           is not dimensioned, then no subscripts will  follow
	           the  name  even  if  one  or  more  subscripts  are
	           contained in the NOWSUB array.
	         = greater than zero, the value of  LMTTYP  is  to  be
	           enclosed  in  parentheses following the array name.
	           The subscript ranges indicated by  the  dictionary,
	           and  the values of the current subscripts contained
	           in the NOWSUB array, are  ignored.   The  value  of
	           LMTTYP   is  represented  even  if  the  dictionary
	           indicates that the name is not dimensioned.

	  LTRINI = subscript of the LTRSTR array  location  containing
	           the  first  character to be included in the name of
	           the array or in the name of the  logical  group  of
	           arrays.

	  LTRUSD = highest subscript of any  location  in  the  LTRSTR
	           array  used  for  the storage of a character of the
	           name of any array.

	  LTRSTR = array containing the characters of the array  names
	           in  the  dictionary, 1 character per array location
	           as read by a multiple of an A1 format or as defined
	           by several 1H fields.

	  NUMINI = subscript of the NUMSTR array  location  containing
	           the  first  of  the  numeric information associated
	           with the name of the array or with the name of  the
	           logical group of arrays.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 233
	  DALONE, Routine to Represent Array Name and Subscript Limits


	  NUMUSD = highest subscript  of  any  location  used  in  the
	           NUMSTR array to hold numeric information associated
	           with any name in the dictionary.

	  NUMSTR = array   containing    the    numeric    information
	           corresponding  to  the  names  stored in the LTRSTR
	           array.  The construction of  the  NUMSTR  array  is
	           described  in  detail  in the DALOAD documentation.
	           For each name in the dictionary, the  NUMSTR  array
	           contains

	             a. the number of characters in the name

	             b. an indication of the associated data type

	             c. the number of subscript ranges

	             d. pairs of starting and ending values  of  these
	                ranges.

	           If the number of  characters  is  instead  zero  or
	           negative,  then its absolute value is the number of
	           characters in the name of a logical group of names,
	           and  the  next location, rather than indicating the
	           data type, contains the number of locations  within
	           a  singly  subscripted buffer which would be needed
	           to store the values  of  the  multiply  subscripted
	           arrays  which  are  within  the  logical  group and
	           equivalenced with or otherwise loaded into  such  a
	           singly subscripted buffer.

	  KNTSUB = the number of current subscripts contained  in  the
	           NOWSUB array.

	  NOWSUB = array containing in locations NOWSUB(1) through and
	           including  NOWSUB(KNTSUB) the current values of the
	           subscripts of the array being represented.  This is
	           used only if LMTTYP=0.

	  NAMMAX = highest subscript of any location in the NAME array
	           which  can be used for the storage of characters by
	           this routine.

	  The following arguments are used  for  both  input  to  this
	  routine and for output to the calling program.

	  NAME   = the array into  which  the  representation  of  the
	           array  name  and  its subscripts is to be placed so
	           that it can be written by the calling program using
	           a  multiple  of  an A1 format.  The locations which
	           can be used for this purpose include NAME(NAMUSD+1)
	           through NAME(NAMMAX).

	  NAMUSD = input  containing  the  highest  subscript  of  any
	  FASP, FORTRAN Alphameric Subroutine Package         Page 234
	  DALONE, Routine to Represent Array Name and Subscript Limits


	           location in the NAME array which must be preserved.
	           The  representation  of  the  array  name  and  its
	           subscripts  is  placed  in the NAME array locations
	           having subscripts above the input value of NAMUSD.
	         = returned containing  the  highest  subscript  of  a
	           location  in the NAME array into which this routine
	           has placed a character of the representation of the
	           array  name  and  its subscripts.  If the number of
	           locations  remaining  in   the   NAME   array   was
	           insufficient  to  hold  the  representation  of the
	           array name and its subscripts, or if for any  other
	           reason  the  representation could not be generated,
	           then NAMUSD is returned unchanged.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 235
	  DALOOP, Variably Embedded DO Loop Simulator


	  DDDDDD         AAAA  LL        OOOOO      OOOOO    PPPPPP
	  DD    DD      AA AA  LL       OO   OO    OO   OO   PP    PP
	  DD     DD    AA  AA  LL      OO     OO  OO     OO  PP     PP
	  DD     DD   AA   AA  LL      OO     OO  OO     OO  PP    PP
	  DD     DD  AAAAAAAA  LL      OO     OO  OO     OO  PPPPPP
	  DD    DD  AA     AA  LL       OO   OO    OO   OO   PP
	  DDDDDD   AA      AA  LLLLLLLL  OOOOO      OOOOO    PP



	          DALOOP, Variably Embedded DO Loop Simulator
	          ------  -------- -------- -- ---- ---------

	  DALOOP simulates any number of variably  embedded  DO  loops
	  which  have  the  same  statements within their ranges.  The
	  order in which the loop indexes are varied is  specified  by
	  the  calling  program,  but  can  not  be  changed while the
	  statements within the range of the loops are being executed.
	  The index of each loop has its own initial and final values,
	  and its own increment  by  which  it  varies  between  these
	  limits.   The  final  value  can  be less than, equal to, or
	  greater than the initial value.

	  DALOOP is called at the  start  of  each  execution  of  the
	  statements  within  the  loop  structure to define the array
	  named NOWSUB which contains the current values of  the  loop
	  indexes.   The  argument named INLOOP must be set to zero by
	  the calling program before DALOOP is first  called.   DALOOP
	  returns  INLOOP  nonzero  until  the outermost loop has been
	  completed.  As an example of the use of DALOOP, if the order
	  specification array named NXTSUB contains the values 1, 2, 3
	  and 4 in locations having the subscripts 5 (LOWSUB)  through
	  8  (KNTSUB), and if the loop with the index varying the most
	  rapidly (the innermost loop)  is  selected  by  the  largest
	  value within the NXTSUB array, then the statements

	             INLOOP=0
	           1 CALL DALOOP(1,5,8,INISUB,LMTSUB,
	            1INCSUB,NXTSUB,INLOOP,NOWSUB)
	             IF(INLOOP.EQ.0)GO TO 2
	                  *
	                  *
	             text to be executed within the loop structure
	                  *
	                  *
	             GO TO 1
	           2 CONTINUE

	  would simulate the corresponding DO loop structure

	  FASP, FORTRAN Alphameric Subroutine Package         Page 236
	  DALOOP, Variably Embedded DO Loop Simulator


	             DO 2 NOWSUB(5)=INISUB(5),LMTSUB(5),INCSUB(5)
	             DO 2 NOWSUB(6)=INISUB(6),LMTSUB(6),INCSUB(6)
	             DO 2 NOWSUB(7)=INISUB(7),LMTSUB(7),INCSUB(7)
	             DO 2 NOWSUB(8)=INISUB(8),LMTSUB(8),INCSUB(8)
	                  *
	                  *
	             text to be executed within the loop structure
	                  *
	                  *
	           2 CONTINUE

	  However, merely by changing the contents of the NXTSUB array
	  to  3, 1, 4 and 2, the order of the simulated DO loops would
	  become

	             DO 2 NOWSUB(6)=INISUB(6),LMTSUB(6),INCSUB(6)
	             DO 2 NOWSUB(8)=INISUB(8),LMTSUB(8),INCSUB(8)
	             DO 2 NOWSUB(5)=INISUB(5),LMTSUB(5),INCSUB(5)
	             DO 2 NOWSUB(7)=INISUB(7),LMTSUB(7),INCSUB(7)
	                  *
	                  *
	             text to be executed within the loop structure
	                  *
	                  *
	           2 CONTINUE

	  A simpler version of DALOOP is also provided which bases the
	  order  of  the  embedded  loops  strictly  upon the relative
	  values of the subscripts of the array  locations  containing
	  the  loop descriptions.  This simpler version, named DAROLL,
	  is meant for use when the order of the embedded loops is not
	  subject to change during execution of the program.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 237
	  DALOOP, Variably Embedded DO Loop Simulator


	              The DALOOP and DAROLL Argument Lists
	              --- ------ --- ------ -------- -----

	  The argument lists of routines DALOOP and DAROLL are

	        SUBROUTINE DALOOP(IRAPID,LOWSUB,KNTSUB,INISUB,LMTSUB,
	       1    INCSUB,NXTSUB,INLOOP,NOWSUB)

	  with the associated DIMENSION statement

	        DIMENSION INISUB(KNTSUB),LMTSUB(KNTSUB),
	       1INCSUB(KNTSUB),NXTSUB(KNTSUB),NOWSUB(KNTSUB)

	  and

	        SUBROUTINE DAROLL(IRAPID,LOWSUB,KNTSUB,INISUB,LMTSUB,
	       1    INCSUB,INLOOP,NOWSUB)

	  with the associated DIMENSION statement

	        DIMENSION INISUB(KNTSUB),LMTSUB(KNTSUB),
	       1INCSUB(KNTSUB),NOWSUB(KNTSUB)

	  The argument lists of the 2 routines  are  identical  except
	  that  the  DALOOP  argument  NXTSUB  does  not appear in the
	  DAROLL argument list.  Since the NXTSUB array  dictates  the
	  order   of  the  embedded  loops  for  routine  DALOOP,  the
	  definition of the argument IRAPID is somewhat different  for
	  the  2 routines.  The definitions of the remaining arguments
	  are identical for the 2 routines.

	  The following arguments are used as input and  are  returned
	  unchanged.    (Under   circumstances  described  below,  the
	  contents  of  the  INCSUB  array  can  be  returned  changed
	  slightly.)  The  contents  of  these  arguments  must not be
	  changed by the calling program until the outermost loop  has
	  been completed.

	  IRAPID = 0 for routine DALOOP, the innermost loop (the  loop
	           having  the index which is varied the most rapidly)
	           is that with  the  smallest  value  in  the  NXTSUB
	           array.
	         = 1 for routine DALOOP, the innermost  loop  is  that
	           with the largest value in the NXTSUB array.

	         = 0 for routine DAROLL, the innermost  loop  is  that
	           represented  by  the  contents  of  INISUB(LOWSUB),
	           LMTSUB(LOWSUB), INCSUB(LOWSUB) and  NOWSUB(LOWSUB).
	           The  loops  represented  by the values in the array
	           locations having higher  subscripts  are  performed
	           less rapidly than those having lower subscripts.
	         = 1 for routine DAROLL, the innermost  loop  is  that
	           represented  by  the  contents  of  INISUB(KNTSUB),
	           LMTSUB(KNTSUB), INCSUB(KNTSUB) and  NOWSUB(KNTSUB).
	  FASP, FORTRAN Alphameric Subroutine Package         Page 238
	  DALOOP, Variably Embedded DO Loop Simulator


	           The  loops  represented  by the values in the array
	           locations having  lower  subscripts  are  performed
	           less rapidly than those having higher subscripts.

	  LOWSUB = the lowest subscript of the arrays which are to  be
	           used  as  the  loop  descriptors.  The portions, if
	           any, of the arrays below subscript LOWSUB and above
	           subscript  KNTSUB  are  ignored by this routine and
	           are returned unchanged.  A total of KNTSUB-LOWSUB+1
	           loops  will  be  simulated  by  this  routine.   If
	           I=LOWSUB+N-1, then the Nth loop is described by the
	           contents of INISUB(I), LMTSUB(I) and INCSUB(I), its
	           order  relative  to  the  rest  of  the  loops   is
	           specified  by  NXTSUB(I), and its current subscript
	           is returned by this routine in NOWSUB(I).

	  KNTSUB = the highest subscript of the arrays which are to be
	           used  as  the  loop  descriptors.   KNTSUB  must be
	           greater than or equal to LOWSUB.

	  INISUB = array  containing  the  starting  values   of   the
	           individual loop indexes.

	  LMTSUB = array containing ending values  of  the  individual
	           loop  indexes.   An  individual  item in the LMTSUB
	           array can be either less than, equal to, or greater
	           than the corresponding item in the INISUB array.

	  INCSUB = array  containing  the  increments  by  which   the
	           indexes  returned  in  the  NOWSUB array are varied
	           between the starting values in  the  INISUB  array,
	           and  the  ending values in the LMTSUB array.  If an
	           increment is  zero,  its  value  in  the  array  is
	           changed  to 1.  If an increment has the wrong sign,
	           its sign in the array is changed.

	  The following argument is used as an  input  to  the  DALOOP
	  routine,  then  is  returned  changed  for use by subsequent
	  DALOOP calls.  The contents of this  array  from  subscripts
	  LOWSUB  through  KNTSUB  must  not be changed by the calling
	  program until the outermost loop has been  completed.   This
	  argument does not appear in the DAROLL argument list.

	  NXTSUB = array set by the calling program before the initial
	           call to DALOOP to control the order of the embedded
	           loops.  DALOOP  will  return  NXTSUB  as  an  array
	           containing  pointers for use by subsequent calls to
	           DALOOP.  The original contents of the NXTSUB  array
	           are  sorted to determine the order of the pointers,
	           but the original contents are destroyed after being
	           used.   The  returned values must not be altered by
	           the calling program.

	           The original contents could, but  need  not,  equal
	  FASP, FORTRAN Alphameric Subroutine Package         Page 239
	  DALOOP, Variably Embedded DO Loop Simulator


	           the  subscripts  of  the  loops.  Only the relative
	           sizes of the original contents of the NXTSUB  array
	           are  used  and  all  of the numbers from largest to
	           smallest need not be represented (i.e.,  the  order
	           of  the  embedded  loops is not changed if the same
	           offset is added to each of the original  values  in
	           the  NXTSUB  array  and  the difference between the
	           largest and smallest numbers in  the  NXTSUB  array
	           can be greater than the number of embedded loops).

	           If IRAPID is zero, then the loops corresponding  to
	           the  smaller  original  values  in the NXTSUB array
	           will be done the most rapidly.   If  IRAPID  is  1,
	           then the loops corresponding to the larger original
	           values in the NXTSUB array will be  done  the  most
	           rapidly.    Loops  which  have  identical  original
	           values within the NXTSUB array are performed  as  a
	           single  unit, a single call to DALOOP advancing the
	           NOWSUB array values for all members  of  the  group
	           until  the  NOWSUB array value of any member of the
	           group exceeds its own  corresponding  LMTSUB  array
	           value.

	           When DALOOP finally signals  that  all  loops  have
	           been completed, by returning INLOOP=0, it will also
	           attempt to  restore  the  original  values  of  the
	           NXTSUB   array,  making  the  assumption  that  the
	           smallest value in the range NXTSUB(LOWSUB)  through
	           NXTSUB(KNTSUB)  has  the value LOWSUB, and that the
	           values are then incremented  by  1.   The  relative
	           order  within  the used portion of the NXTSUB array
	           will be returned correct, but  if  the  assumptions
	           are  not  correct, then the order will be incorrect
	           relative to that of the unused portion, if any,  of
	           the NXTSUB array.

	  The following argument is used as input,  then  is  returned
	  changed   for  use  by  both  the  calling  program  and  by
	  subsequent calls to this  routine.   The  contents  of  this
	  argument  must  not  be changed by the calling program until
	  the outermost loop has been completed.

	  INLOOP = must be set to zero before the initial call to this
	           routine.    This   initial  call  will  set  INLOOP
	           nonzero, and will copy the INISUB  array  into  the
	           NOWSUB  array  for use as the initial loop indexes.
	           Each subsequent call to this  routine  will  either
	           load the indexes for the next set of loops into the
	           NOWSUB array or will set  INLOOP  to  zero  if  the
	           outermost loop has been completed.

	  The following argument is returned changed for use  by  both
	  the calling program and by subsequent calls to this routine.
	  The original contents are ignored.   The  contents  of  this
	  FASP, FORTRAN Alphameric Subroutine Package         Page 240
	  DALOOP, Variably Embedded DO Loop Simulator


	  argument  must  not  be changed by the calling program until
	  the outermost loop has been completed.

	  NOWSUB = array  returned  containing  the  indexes  for  the
	           current    loop   structure.    The   contents   of
	           NOWSUB(LOWSUB) through NOWSUB(KNTSUB) are  used  in
	           the same manner as the indexes of FORTRAN DO loops.
	           The values upon input to the initial call  to  this
	           routine are ignored.



	     Contents of NXTSUB Array After First DALOOP EXECUTION
	     -------- -- ------ ----- ----- ----- ------ ---------

	  To prevent unnecessary  searching  by  subsequent  calls  to
	  DALOOP  of the NXTSUB array which originally contains values
	  indicating the loop order, the first call to DALOOP converts
	  the  values in this array into pointers.  The first location
	  in the used portion of the NXTSUB array after its conversion
	  to a pointer array contains the subscript of the index which
	  is being varied the most rapidly.  If additional indexes are
	  being  varied  at the same rate, then the second location in
	  the pointer array will contain the sum of the  subscript  of
	  the index being varied at the same rate and the total number
	  of all indexes so that the sum is greater than  the  maximum
	  possible  subscript.   Scanning from left to right, the next
	  location in the pointer array which contains  a  value  less
	  than  or  equal  to  the  maximum subscript of an index will
	  point to the index being varied the next most rapidly.

	  For example, if the initial contents of the NXTSUB array are

	       1, 2, 3, 2, 3, 4, 3, 4, 5

	  meaning (if smallest number indicates innermost  loop)  that
	  the  first  index  is  varied  most  rapidly, the second and
	  fourth are varied next most rapidly, and so on  through  the
	  ninth which is varied the least rapidly, and if LOWSUB is 1,
	  then the contents of the NXTSUB array  after  conversion  to
	  pointers are

	       1, 2, (4+9)=13, 3, (5+9)=14, (7+9)=16, 6, (8+9)=17, 9

	  FASP, FORTRAN Alphameric Subroutine Package         Page 241
	  DAMOVE, Justify Group of Characters within Field of Spaces


	  DDDDD         AAA  MM      MM    OOOOO    VV    VV  EEEEEEEE
	  DD   DD      AAAA  MMM    MMM   OO   OO   VV   VV   EE
	  DD    DD    AA AA  MMMM  MMMM  OO     OO  VV  VV    EE
	  DD    DD   AA  AA  MM MMMM MM  OO     OO  VV VV     EEEEE
	  DD    DD  AAAAAAA  MM  MM  MM  OO     OO  VVVV      EE
	  DD   DD  AA    AA  MM      MM   OO   OO   VVV       EE
	  DDDDD   AA     AA  MM      MM    OOOOO    VV        EEEEEEEE

	   DAMOVE, Justify Group of Characters within Field of Spaces
	   ------  ------- ----- -- ---------- ------ ----- -- ------

	  DAMOVE left justifies, centers or right justifies a group of
	  characters  within  a  larger  section of the array in which
	  these  characters  are  contained.   The  remainder  of  the
	  section  is  filled  with  spaces.   The characters are each
	  contained in separate array locations  as  though  they  had
	  been  read  using a multiple of an A1 format or defined with
	  several 1H fields.

	                    The DAMOVE Argument List
	                    --- ------ -------- ----

	  The argument list of routine DAMOVE is

	        SUBROUTINE DAMOVE(JSTIFY,IFILL ,LFTCOL,LTREND,IERR  ,
	       1    IBUFFR,KOUNT )

	  with the associated DIMENSION statement

	        DIMENSION IBUFFR(LTREND)

	  The following are input arguments returned unchanged

	  JSTIFY = -1, do not move the group of  characters  input  in
	           IBUFFR(LFTCOL+1) through IBUFFR(KOUNT).
	         = 0,   the   group    of    characters    input    in
	           IBUFFR(LFTCOL+1)  through  IBUFFR(KOUNT)  is  to be
	           centered in the field starting at  IBUFFR(LFTCOL+1)
	           and  extending  through IBUFFR(LTREND).  Spaces are
	           then  placed  into  the  IBUFFR   array   locations
	           starting  with IBUFFR(LFTCOL+1) and extending up to
	           but  not  including  the  IBUFFR   array   location
	           containing the leftmost character of the group.
	         = 1,   the   group    of    characters    input    in
	           IBUFFR(LFTCOL+1)  through  IBUFFR(KOUNT)  is  to be
	           moved to the right so that the character  input  in
	           IBUFFR(KOUNT)   is   placed   into  IBUFFR(LTREND).
	           Spaces  are  then  placed  into  the  IBUFFR  array
	           locations   starting   with   IBUFFR(LFTCOL+1)  and
	           extending up to but not including the IBUFFR  array
	           location  containing  the leftmost character of the
	           group.

	  IFILL  = 0, do  not  place  spaces  into  any  IBUFFR  array
	  FASP, FORTRAN Alphameric Subroutine Package         Page 242
	  DAMOVE, Justify Group of Characters within Field of Spaces


	           locations to the right of those returned containing
	           the characters of the group.  The  value  of  IFILL
	           has no effect on the placement of the characters of
	           the group.  KOUNT will be returned pointing to  the
	           rightmost character of the group.
	         = 1, place spaces into the IBUFFR array locations  to
	           the  right  of  those returned containing the group
	           and extending through IBUFFR(LTREND).   KOUNT  will
	           be returned returned pointing to IBUFFR(LTREND).

	  LFTCOL = subscript of  the  IBUFFR  array  location  to  the
	           immediate left of the first character in the group.

	  LTREND = subscript of the IBUFFR array location which  forms
	           the  right end of the field which is to be returned
	           containing  the  group.   If  JSTIFY=1,  then   the
	           rightmost  character  of  the  group will be placed
	           into IBUFFR(LTREND).

	  IERR   = -1, fill the IBUFFR array locations  starting  with
	           IBUFFR(LFTCOL+1)      and     extending     through
	           IBUFFR(LTREND)  with  asterisks  and  return  KOUNT
	           pointing  to  IBUFFR(LTREND).   The input values of
	           JSTIFY, IFILL and KOUNT are ignored.
	         = zero or greater, move the group of characters input
	           in  IBUFFR(LFTCOL+1) through IBUFFR(KOUNT) into the
	           position indicated by JSTIFY.

	  The following arguments are used  both  for  input  to  this
	  routine,  and  for  returning  information  to  the  calling
	  program.  The contents of the IBUFFR  array  locations  with
	  subscripts  which  are less than or equal to LFTCOL or which
	  are greater than LTREND are not changed.

	  IBUFFR = input containing the  group  of  characters  to  be
	           moved   in   locations   IBUFFR(LFTCOL+1)   through
	           IBUFFR(KOUNT).  Each IBUFFR array location contains
	           a  single  character as though read by an A1 format
	           or defined by a 1H field.
	         = returned containing this group of  characters  left
	           justified, centered or right justified (as directed
	           by  the  value  of   JSTIFY)   in   the   locations
	           IBUFFR(LFTCOL+1)  through  IBUFFR(LTREND).  If IERR
	           is  input  containing  -1,   then   the   locations
	           IBUFFR(LFTCOL+1) THROUGH IBUFFR(LTREND) are instead
	           returned containing asterisks.

	  KOUNT  = input containing the subscript of the IBUFFR  array
	           location  containing the rightmost character of the
	           group to be positioned as directed by JSTIFY.
	         = returned containing the  subscript  of  the  IBUFFR
	           array  location  containing the rightmost character
	           defined after the group has  been  moved,  and,  if
	           requested by IFILL, after spaces have been added.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 243
	  DANAME, Convert Buffer Location to Array Name and Subscripts


	  DDDDD         AAA  NN    NN       AAA  MM      MM  EEEEEEEE
	  DD   DD      AAAA  NNN   NN      AAAA  MMM    MMM  EE
	  DD    DD    AA AA  NNNN  NN     AA AA  MMMM  MMMM  EE
	  DD    DD   AA  AA  NN NN NN    AA  AA  MM MMMM MM  EEEEE
	  DD    DD  AAAAAAA  NN  NNNN   AAAAAAA  MM  MM  MM  EE
	  DD   DD  AA    AA  NN   NNN  AA    AA  MM      MM  EE
	  DDDDD   AA     AA  NN    NN AA     AA  MM      MM  EEEEEEEE



	  DANAME, Convert Buffer Location to Array Name and Subscripts
	  ------  ------- ------ -------- -- ----- ---- --- ----------

	  DANAME converts a subscript of a singly  subscripted  buffer
	  which  is  considered  to hold one or more possibly multiply
	  subscripted arrays into the array name and its subscripts as
	  defined by the dictionary constructed by the DALOAD routine.
	  This conversion is the opposite of  that  performed  by  the
	  DASITE routine.

	  For  example,  if  the  first  statement  read  during   the
	  construction of the dictionary by DALOAD was

	        DIMENSION FIRST(10),SECOND(10,10),THIRD(10,10,10)

	  and if it is assumed that the first (left) subscript of each
	  simulated  array  varies the most rapidly (the usual FORTRAN
	  convention for array names appearing without  subscripts  in
	  READ  and  WRITE  statements)  then  the  singly subscripted
	  buffer  location  having  123  as  its  subscript  would  be
	  equivalent  to  the  simulated  array location THIRD(3,2,1).
	  The buffer location subscript is converted by DANAME to  the
	  array  name  and  its  subscripts  by  determining  that the
	  locations below the desired location include

	    a. all 10 locations of the FIRST array

	    b. all 100 locations of the SECOND array

	    c. the 10 locations THIRD(1,1,1) through THIRD(10,1,1)

	    d. the 2 locations THIRD(1,2,1) and THIRD(2,2,1)

	  Since the dictionary constructed by DALOAD is  divided  into
	  logical groups of array names, the proper logical group must
	  be located by calling the DABASE routine prior to the  first
	  call  to DANAME, unless it is known that the desired logical
	  group is the first (or only) group in the dictionary.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 244
	  DANAME, Convert Buffer Location to Array Name and Subscripts


	                    The DANAME Argument List
	                    --- ------ -------- ----

	  The argument list of routine DANAME is

	        SUBROUTINE DANAME(IRAPID,LOCATN,LRGNUM,NUMUSD,NUMSTR,
	       1    LRGLTR,MAXSUB,INITAL,KOUNT ,LTRINI,NUMINI,KNTSUB,
	       2    NOWSUB)

	  with the associated DIMENSION statement

	        DIMENSION NUMSTR(NUMUSD),NOWSUB(MAXSUB)

	  The following arguments are used  for  input  only  and  are
	  returned unchanged.

	  IRAPID = 0, multiply  subscripted  arrays  have  their  left
	           subscripts vary the most rapidly
	         = 1, multiply subscripted  arrays  have  their  right
	           subscripts vary the most rapidly.

	  LOCATN = the  value  of  the   subscript   of   the   singly
	           subscripted  buffer which is to be converted to the
	           corresponding array name and its subscripts.

	  LRGNUM = subscript of the NUMSTR array  location  containing
	           the  start  of  the  numeric  portion  of the array
	           descriptions.

	           If NUMSTR(LRGNUM) is less than or  equal  to  zero,
	           then  NUMSTR(LRGNUM)  is  the first location in the
	           description of the  logical  group  of  arrays  the
	           values  of which are equivalenced with or otherwise
	           contained in the singly subscripted buffer, and the
	           subsequent  description is of the array which if it
	           contained the location corresponding to  the  input
	           value   of   LOCATN   would   return  KOUNT=1.   If
	           NUMSTR(LRGNUM) is less than or equal to zero,  then
	           its  absolute  value  is  the  number of characters
	           within the name of the group  of  arrays,  not  the
	           number  of  characters  in  the  name  of the first
	           array, and the dictionary is effectively terminated
	           prior  to the next array description which does not
	           start with a value greater than zero.

	           If NUMSTR(LRGNUM) is greater than  zero,  then  the
	           dictionary starts with the description of the array
	           which if it contained the location corresponding to
	           the input value of LOCATN would return KOUNT=1.  If
	           NUMSTR(LRGNUM)   is   greater   than   zero,   then
	           NUMSTR(LRGNUM) contains the number of characters in
	           the name of the  first  array  within  the  logical
	           group, and the dictionary is effectively terminated
	           prior to the first array description which does not
	  FASP, FORTRAN Alphameric Subroutine Package         Page 245
	  DANAME, Convert Buffer Location to Array Name and Subscripts


	           start with a value greater than zero.

	  NUMUSD = highest subscript of the locations  in  the  NUMSTR
	           array    containing    the    numeric   information
	           corresponding to the possibly multiply  subscripted
	           arrays the values of which are equivalenced with or
	           otherwise  contained  in  the  singly   subscripted
	           buffer.   NUMUSD  is  the highest subscript used in
	           the NUMSTR array for  the  storage  of  information
	           about  any  array  in any logical group, and is not
	           necessarily  the  highest  subscript  used  in  the
	           NUMSTR  array  for the storage of information about
	           an array in the current logical group.

	  NUMSTR = the  array  containing  the   numeric   information
	           corresponding  to the possibly multiply subscripted
	           arrays the values of which are equivalenced with or
	           otherwise   contained  in  the  singly  subscripted
	           buffer.  The construction of the  NUMSTR  array  is
	           described  in  detail  in the DALOAD documentation.
	           For each name in the dictionary, the  NUMSTR  array
	           contains

	             a. the number of characters in the name

	             b. an indication of the associated data type

	             c. the number of subscript ranges

	             d. pairs of starting and ending values  of  these
	                ranges.

	           If the number of  characters  is  instead  zero  or
	           negative,  then its absolute value is the number of
	           characters in the name of a logical group of names,
	           and  the  next location, rather than indicating the
	           data type, contains the number of locations  within
	           a  singly  subscripted buffer which would be needed
	           to store the values  of  the  multiply  subscripted
	           arrays  which  are  within  the  logical  group and
	           equivalenced with or otherwise loaded into  such  a
	           singly subscripted buffer.

	  LRGLTR = the subscript of the LTRSTR array (not an  argument
	           of  this  routine  but  constructed  by  DALOAD  in
	           parallel with NUMSTR) location which  contains  the
	           first  letter  of  the  name  associated  with  the
	           logical  group  of  names  in  the  dictionary   if
	           NUMSTR(LRGNUM)  is  negative, or which contains the
	           first letter of the first array name in the logical
	           group  of  names  if  NUMSTR(LRGNUM) is positive or
	           zero.

	  MAXSUB = highest subscript of the locations  in  the  NOWSUB
	  FASP, FORTRAN Alphameric Subroutine Package         Page 246
	  DANAME, Convert Buffer Location to Array Name and Subscripts


	           array  which  can  be used by this routine to store
	           the values of the  subscripts  of  the  array  name
	           corresponding  to the subscript (input as the value
	           of LOCATN) of the singly subscripted buffer.

	  The following arguments are used for both input and  output.
	  If  this routine is asked to convert a value of LOCATN which
	  is the subscript of a location  in  or  further  beyond  the
	  array  identified  by  the previous call to this routine but
	  which is still within the same logical group  of  arrays  as
	  dealt  with  by  the previous call, then the values of these
	  arguments as output by the previous call are used as the new
	  offsets  in the dictionary and buffer, rather than repeating
	  the calculations for the lower portion of the logical group.

	  INITAL = should be set to zero by the calling program before
	           this routine is first called, and again set to zero
	           whenever this routine  is  called  to  reference  a
	           different  logical  group  of  array  names  in the
	           dictionary.
	         = returned greater than zero if the subscript of  the
	           singly subscripted buffer input as the value of the
	           argument LOCATN could be converted  into  the  name
	           and  subscripts  of a possibly multiply subscripted
	           array equivalenced with or otherwise  contained  in
	           part  or  all  of  the  singly  subscripted buffer.
	           INITAL is returned containing the subscript of  the
	           singly  subscripted  buffer location which contains
	           the  start  of  (the  first  location  within)  the
	           possibly  multiply  subscripted array some location
	           within which corresponds to the singly  subscripted
	           buffer  location  having as its subscript the input
	           value of argument LOCATN.  If the possibly multiply
	           subscripted   array   identified  by  this  routine
	           consists of  a  single  location,  then  INITAL  is
	           returned containing the input value of LOCATN.
	         = 0,  returned  if  the  subscript  of   the   singly
	           subscripted  buffer  input  as  the  value  of  the
	           argument LOCATN could not be converted into a  name
	           and  subscripts  of  an  array equivalenced with or
	           otherwise contained in part or all  of  the  singly
	           subscripted  buffer.   In  other  words, LOCATN was
	           input containing  a  value  not  indicated  by  the
	           dictionary  as  being within the singly subscripted
	           buffer containing the arrays  forming  the  logical
	           group.
	         = -1, MAXSUB is less than the number of subscripts of
	           the  possibly multiply subscripted array identified
	           by this routine so that not all of  the  subscripts
	           could be represented in the NOWSUB array.

	  KOUNT  = input  value  is  ignored  if   INITAL   is   input
	           containing  zero or if INITAL is input greater than
	           the input value of LOCATN.  KOUNT is  set  by  each
	  FASP, FORTRAN Alphameric Subroutine Package         Page 247
	  DANAME, Convert Buffer Location to Array Name and Subscripts


	           call  to  this  routine, and should never be set by
	           the calling program.
	         = if INITAL is input greater than zero but less  than
	           or  equal to LOCATN, then KOUNT, as returned by the
	           previous call to  this  routine,  is  the  sequence
	           number  of  the possibly multiply subscripted array
	           corresponding to the input value of INITAL.
	         = returned containing  the  sequence  number  of  the
	           identified  array  relative  to  all  arrays in the
	           logical group of arrays.  If the third array in the
	           logical  group  contains the location corresponding
	           to  the  input  value  of  LOCATN,  then  KOUNT  is
	           returned containing the value 3.

	           If NUMSTR(LRGNUM) is less than or  equal  to  zero,
	           then  NUMSTR(LRGNUM)  is  the first location in the
	           description of the  logical  group  of  arrays  the
	           values  of which are equivalenced with or otherwise
	           contained in the singly subscripted buffer, and the
	           subsequent  description is of the array which if it
	           contained the location corresponding to  the  input
	           value   of   LOCATN   would   return  KOUNT=1.   If
	           NUMSTR(LRGNUM) is less than or equal to zero,  then
	           its  absolute  value  is  the  number of characters
	           within the name of the group  of  arrays,  not  the
	           number  of  characters  in  the  name  of the first
	           array, and the dictionary is effectively terminated
	           prior  to the next array description which does not
	           start with a value greater than zero.

	           If NUMSTR(LRGNUM) is greater than  zero,  then  the
	           dictionary starts with the description of the array
	           which if it contained the location corresponding to
	           the input value of LOCATN would return KOUNT=1.  If
	           NUMSTR(LRGNUM)   is   greater   than   zero,   then
	           NUMSTR(LRGNUM) contains the number of characters in
	           the name of the  first  array  within  the  logical
	           group, and the dictionary is effectively terminated
	           prior to the first array description which does not
	           start with a value greater than zero.

	  LTRINI = input  value  is  ignored  if   INITAL   is   input
	           containing  zero or if INITAL is input greater than
	           the input value of LOCATN.  LTRINI is set  by  each
	           call  to  this  routine, and should never be set by
	           the calling program.
	         = if INITAL is input greater than zero but less  than
	           or equal to LOCATN, then LTRINI, as returned by the
	           previous call to this routine, is the subscript  of
	           the  LTRSTR location containing the first character
	           of the name of the  possibly  multiply  subscripted
	           array corresponding to the input value of INITAL.
	         = returned containing the  subscript  of  the  LTRSTR
	           array  location  containing  the first character of
	  FASP, FORTRAN Alphameric Subroutine Package         Page 248
	  DANAME, Convert Buffer Location to Array Name and Subscripts


	           the name of the identified array.

	  NUMINI = input  value  is  ignored  if   INITAL   is   input
	           containing  zero or if INITAL is input greater than
	           the input value of LOCATN.  NUMINI is set  by  each
	           call  to  this  routine, and should never be set by
	           the calling program.
	         = if INITAL is input greater than zero but less  than
	           or equal to LOCATN, then NUMINI, as returned by the
	           previous call to this routine, is the subscript  of
	           the  NUMSTR  location  containing  the start of the
	           numeric  description  of  the   possibly   multiply
	           subscripted  array corresponding to the input value
	           of INITAL.
	         = returned containing the  subscript  of  the  NUMSTR
	           array  location containing the start of the numeric
	           description of the identified array.

	  The following arguments are used  only  for  output.   Their
	  input  values  are  ignored.   These  arguments are returned
	  undefined if INITAL is returned less than or equal to zero.

	  KNTSUB = returned containing the number of subscripts of the
	           identified  array.   If  the NUMSTR array indicates
	           that the identified array is  nondimensioned,  then
	           KNTSUB  is  returned containing 1, and NOWSUB(1) is
	           returned also containing  1.   This  precaution  is
	           performed  so that any subsequent FASP routine call
	           which includes KNTSUB in its argument list for  use
	           in  a  DIMENSION statement within the routine, will
	           not have that dimension input  as  the  value  zero
	           which  could be considered illegal during execution
	           of the program (depending upon whether the compiler
	           generates   code  to  check  for  this  condition).
	           Without  this  precaution,  a  subsequent  call  to
	           DALONE,  for  example,  could  cause  the DIMENSION
	           statement in that routine to effectively become

	                 DIMENSION NOWSUB(0)

	           Although such a statement  has  meaning  to  DALOAD
	           when  read as data (in particular, to DALOAD such a
	           statement  means  that  NOWSUB   includes   the   2
	           locations  NOWSUB(1)  and NOWSUB(0) with the higher
	           subscript value of 1 appearing first  in  storage),
	           it  probably  does  not have a valid meaning in the
	           code generated by the compiler.  Of  course,  under
	           these  circumstances,  the  logic in DALONE is such
	           that no location whatever is  used  in  the  NOWSUB
	           array  so  that probably no damage would be done if
	           the zero dimension is not detected as being illegal
	           by the entry code generated by the compiler.

	  NOWSUB = array returned containing  in  locations  NOWSUB(1)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 249
	  DANAME, Convert Buffer Location to Array Name and Subscripts


	           through  and including NOWSUB(KNTSUB) the values of
	           the subscripts of the possibly multiply subscripted
	           array  location  corresponding  to the subscript of
	           the singly subscripted buffer input as the argument
	           LOCATN.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 250
	  DANEXT, Returns Next Value Typed as Single Number or Series


	   DDDDD          AAA  NN    NN  EEEEEEEE  XX    XX  TTTTTTTT
	   DD   DD       AAAA  NNN   NN  EE         XX  XX      TT
	   DD    DD     AA AA  NNNN  NN  EE          XXXX       TT
	   DD    DD    AA  AA  NN NN NN  EEEEE        XX        TT
	   DD    DD   AAAAAAA  NN  NNNN  EE          XXXX       TT
	   DD   DD   AA    AA  NN   NNN  EE         XX  XX      TT
	   DDDDD    AA     AA  NN    NN  EEEEEEEE  XX    XX     TT


	  DANEXT, Returns Next Value Typed as Single Number or Series
	  ------  ------- ---- ----- ----- -- ------ ------ -- ------

	  DANEXT returns  to  the  calling  program  the  next  number
	  represented by the characters in an input buffer read by the
	  calling program with a multiple  of  an  A1  format.   If  a
	  series  specification  is  encountered  in the input buffer,
	  then the individual numbers of the series  are  returned  by
	  the  calls to this routine.  When all of the numbers forming
	  the series have been returned, then the subsequent number or
	  series  of  numbers  specified by the contents of the buffer
	  are evaluated.

	  A series evaluated by this routine can be written as a lower
	  bound,  increment and upper bound separated by slashes or by
	  colons (the 2 characters are equivalent).  If the  increment
	  is  to  be  one,  then  the  lower  and upper bounds need be
	  separated only by a single slash or by a single  colon.   If
	  either  bound  is  missing,  it  is assumed to be zero.  The
	  lower bound is the first number of the  series  reported  to
	  the calling program.  The series can then either increase or
	  decrease depending upon whether  the  upper  bound  is  less
	  than,  equal  to, or greater than the lower bound.  The sign
	  of the increment is changed if it does not  conform  to  the
	  relative values of the bounds.

	  If the series is to consist of several  repetitions  of  the
	  same value, then the series is instead written as the number
	  of times the value is to be used followed immediately by  an
	  asterisk  and the value itself.  The value to be repeated is
	  assumed to be null if it is missing.

	  The only printing delimiter character allowed between series
	  specifications  is  the  comma.   Two  commas  with no other
	  printing characters between them are  taken  to  indicate  a
	  missing   series  specification.   The  calling  program  is
	  informed if a semicolon is encountered  in  the  text  being
	  evaluated  by this routine.  The semicolon might be typed by
	  the user to signal that the calling program is to  terminate
	  its  requests  for data from the user.  An exclamation point
	  and any characters to its right are taken to  be  a  comment
	  and  are otherwise ignored.  An ampersand and the characters
	  to its right are similarly considered to form a comment, but
	  the calling program is informed that an ampersand was found.
	  An ampersand might be typed by the user to indicate that the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 251
	  DANEXT, Returns Next Value Typed as Single Number or Series


	  input text is to be continued on the following line.

	  Two versions  of  the  routine  are  supplied.   DANEXT  can
	  evaluate  real  numbers  as  well as either decimal or octal
	  integers including E,  K  and  M  notations  for  specifying
	  either  of these.  If the calling program does not otherwise
	  reference the free  format  input  routine  DAHEFT,  if  the
	  evaluation  of  either  real or octal numbers is not needed,
	  and if integers can be specified without resorting to the E,
	  K  and  M  notations, then the routine DAINXT should be used
	  instead of DANEXT.  Numbers evaluated by DAINXT must consist
	  only  of  digits following the optional sign.  DAINXT treats
	  the characters ., %, E, K and M as illegal characters.


	              The DANEXT and DAINXT Argument Lists
	              --- ------ --- ------ -------- -----

	  The argument lists of routines DANEXT and DAINXT are

	        SUBROUTINE DANEXT(KONTRL,SLACK ,IBUFFR,MAXBFR,LOWBFR,
	       1    MANY  ,KIND  ,NEWVAL,INCVAL,LMTVAL,VALNEW,VALINC,
	       2    VALLMT)

	  and

	        SUBROUTINE DAINXT              (IBUFFR,MAXBFR,LOWBFR,
	       1    MANY  ,KIND  ,NEWVAL,INCVAL,LMTVAL)

	  both with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR)

	  The ordering of the arguments is the same for both routines,
	  but  the  first  2  arguments  of  DANEXT,  and  the  last 3
	  arguments of DANEXT are not included in the DAINXT  argument
	  list.   The argument definitions for DAINXT are identical to
	  those of DANEXT with the exception that  the  new  value  is
	  always returned in integer form for DAINXT.

	  The following arguments are used  for  input  only  and  are
	  returned unchanged.

	  KONTRL = -1, the number (or series of numbers) in the IBUFFR
	           array  is  an  octal  integer (or a series of octal
	           integers).  The number can be typed with a  decimal
	           point and/or with an exponent.  However, the number
	           following the letter E of the exponent is evaluated
	           in  decimal.   The  value  of  the  octal number is
	           returned as the argument NEWVAL.  It must be  noted
	           that  numbers  evaluated as negative octal integers
	           have the negative octal integer as their value, not
	           as  their  bit  representation in computer storage.
	           For example, on a 36 bit twos complement  computer,
	  FASP, FORTRAN Alphameric Subroutine Package         Page 252
	  DANEXT, Returns Next Value Typed as Single Number or Series


	           the octal number -400000000000 (which could also be
	           typed as -4E11 or -4E+11 where the 11 after  the  E
	           is  in  decimal)  is represented as the bit pattern
	           having octal notation 400000000000  and  the  octal
	           number  -377777777777  is  represented  by  the bit
	           pattern 400000000001.
	         = 0, the number (or series of numbers) in the  IBUFFR
	           array  is a decimal integer (or a series of decimal
	           integers).  The number can be typed with a  decimal
	           point  (for  example  1.23K or 1.23E3 equals 1230),
	           but is stored as  an  integer,  and  is  output  as
	           argument  NEWVAL.   Any  decimal  integer which the
	           computer can  represent  can  be  evaluated.   This
	           includes, on twos complement computers, the largest
	           negative number the absolute value of which  cannot
	           be  stored.   On  the PDP10, a 36 bit computer with
	           twos complement  notation,  the  range  of  decimal
	           integers  is  -34359738368 through 34359738367 (the
	           octal  notation   of   the   bit   patterns   being
	           400000000000 through 377777777777).
	         = 1 or greater, the number (or series of numbers)  in
	           the  IBUFFR  array is a real number (or a series of
	           real numbers).  If possible, the real  number  will
	           be  accumulated as an integer, then be converted to
	           real and shifted if necessary.  KONTRL is then  the
	           maximum number of digits in the integer.  The value
	           is output as the argument VALNEW.  If the item  has
	           more than KONTRL digits, then the entire evaluation
	           is  done  as  a  real  number.   The  advantage  of
	           calculating  the  real values in integer as long as
	           the precision of the computer is not overflowed  is
	           that  the  calculation of the portion of the number
	           right of the decimal point is more  exact.   As  an
	           example,  if  KONTRL is greater than or equal to 4,
	           then the number 33.33 can be stored as the  integer
	           3333,  then  be  converted to the real value 3333.0
	           and divided by 100.0 to obtain  the  final  answer.
	           If  it makes no difference whether the number typed
	           as 33.33  has  value  33.33  or  33.32999...   then
	           KONTRL can be given the value 1.

	  SLACK  = the fraction of the increment of a series expressed
	           in  slash  or  colon notation, if KONTRL is greater
	           than zero, by  which  the  returned  value  of  the
	           argument  named  VALNEW  can exceed the upper bound
	           and still be considered to be  within  the  series.
	           SLACK  is  necessary  because of the imprecision of
	           calculations involving real numbers.  For  example,
	           if  the  user  wished  to  have  the  increment  be
	           0.666...  between a lower bound of 3.0 and an upper
	           bound  of  5.0,  he  might type 3/.667/5 and expect
	           that the numbers 3.000,  3.667,  4.333,  and  5.000
	           would   be   included  within  the  series,  while,
	           actually, the number near 5.00 would be  calculated
	  FASP, FORTRAN Alphameric Subroutine Package         Page 253
	  DANEXT, Returns Next Value Typed as Single Number or Series


	           to  be  5.001  and  would  therefore be outside the
	           series.  Although SLACK can be set to zero, a value
	           of   about  0.01  is  recommended.   In  the  above
	           example, SLACK=0.01 would cause  the  actual  upper
	           bound  to  be 5.00667 so that the number calculated
	           near the upper bound would be included  within  the
	           series.  SLACK should almost certainly never exceed
	           0.5 since larger values would  often  lead  to  the
	           inclusion  of  values not meant by the user.  SLACK
	           is ignored if KONTRL is less than or equal to zero.

	  IBUFFR = input buffer array containing characters  typed  by
	           user,  read by a multiple of an A1 format, which is
	           to be searched for series  specifications.   IBUFFR
	           then  contains  one  character per computer storage
	           location.

	  MAXBFR = maximum subscript of IBUFFR array to be searched

	  The following arguments are used both  for  input  to  these
	  routines, and for output to the calling program.

	  LOWBFR = input containing the subscript  within  the  IBUFFR
	           array  of  the first (leftmost) character which can
	           be scanned for a series specification.   LOWBFR  is
	           returned  unchanged  if  this  call to this routine
	           merely generates the next member of a series  begun
	           by  a previous call.  If a new series specification
	           is evaluated by this call  to  this  routine,  then
	           LOWBFR  will  be  returned  pointing  to  the  next
	           character beyond the series  specification.   If  a
	           second number immediately follows a first without a
	           separating slash or colon or asterisk, then  LOWBFR
	           will be returned pointing to the first character of
	           the second number.  If either  a  space  or  a  tab
	           character  follows  a  series  specification,  then
	           LOWBFR will be returned pointing to  the  space  or
	           tab  character.  If the first printing character at
	           or to right of  IBUFFR(LOWBFR)  is  an  exclamation
	           point, or if there are no printing characters at or
	           to the right of IBUFFR(LOWBFR), then LOWBFR will be
	           returned  containing  MAXBFR+1  and  KIND  will  be
	           returned containing one.   LOWBFR,  MANY  and  KIND
	           must  be set by the calling program before anything
	           is processed in the current contents of the  IBUFFR
	           array,  but  then  should  not  be  modified by the
	           calling program until the entire  contents  of  the
	           IBUFFR  array have been processed (except that KIND
	           can be returned to zero to abandon  the  generation
	           of a particular series).

	  MANY   = should be input  containing  zero  each  time  this
	           routine  is  called  to  begin  processing of a new
	           logical  section  of  text,  as  for  example  when
	  FASP, FORTRAN Alphameric Subroutine Package         Page 254
	  DANEXT, Returns Next Value Typed as Single Number or Series


	           beginning  processing of a line of text not tied to
	           the previous line by an ampersand at the end of the
	           previous  line,  or when processing the text to the
	           right of a semicolon.  The initial zeroing of  this
	           argument  must  be done by the calling program, but
	           thereafter the value returned by the previous  call
	           to  this  routine  can  usually  be  used.  MANY is
	           returned set to zero each time a semicolon (KIND=2)
	           is  found, and each time an end of line not tied to
	           the following line  by  an  ampersand  (KIND=1)  is
	           found.   MANY  is  returned containing one plus its
	           input absolute value each time a new  specification
	           of  either a single number or of a series is found,
	           each time  an  erroneous  series  specification  is
	           found,  each time an unknown character is found, or
	           each  time  an  indication  of  a  missing   series
	           specification is found.  MANY is returned unchanged
	           if this call to this routine merely  generates  the
	           next member of a series already begun by a previous
	           call to this routine.  KIND is returned  containing
	           the  value  3  and  MANY is returned containing the
	           negative of the number of items found if  the  next
	           printing   character   following   a  comma  is  an
	           ampersand.  MANY  should  not  be  changed  by  the
	           calling   program   if  an  ampersand  (KIND  being
	           returned=3) is found indicating that the subsequent
	           call to this routine is to process text which is to
	           be treated as though it appeared in  place  of  the
	           ampersand  and  the  characters  to its right.  The
	           effect is not quite the same as  if  the  user  had
	           typed  all  of  the  text  on a single line since a
	           single series specification cannot be split  across
	           the line boundary.

	           If MANY is input containing zero, then  an  initial
	           comma in the input text buffer is taken to indicate
	           an initial missing item, and MANY is then  returned
	           containing  1.  If MANY is input greater than zero,
	           then an initial comma is ignored if followed  by  a
	           series  specification.   If  MANY  is input greater
	           than zero, then an initial  comma  followed  by  no
	           other printing characters, by a semicolon, or by an
	           exclamation point indicates  a  missing  item.   If
	           MANY  is  input  greater than zero, then an initial
	           comma followed  by  an  ampersand  will  cause  the
	           remaining  characters  in the buffer to be ignored,
	           and MANY will be returned containing  the  negative
	           of  its  input  value.   If MANY is input negative,
	           then it is assumed that the contents of the current
	           buffer  continue  a  previous line which terminated
	           with a comma followed by an ampersand, and MANY  is
	           returned greater than zero.

	  KIND   = should be input containing zero the first time this
	  FASP, FORTRAN Alphameric Subroutine Package         Page 255
	  DANEXT, Returns Next Value Typed as Single Number or Series


	           routine  is  called,  or  to  abandon generation of
	           values  within  a  particular  series.    KIND   is
	           returned describing the kind of item located in the
	           IBUFFR array.  Except in  the  cases  of  when  the
	           buffer  is  found  to be empty, or when the calling
	           program  resets  KIND  to  zero  to  terminate  the
	           expansion of the current series, the returned value
	           of KIND should be used for the next  call  to  this
	           routine  to inform this routine whether a series is
	           being expanded.  KIND is returned containing one of
	           the following values.
	         = 1, nothing, except perhaps a comment indicated by a
	           leading  exclamation  point, was found at or to the
	           right  of  IBUFFR(LOWBFR).   The  calling   program
	           should read a new line into the IBUFFR array before
	           again calling this routine if additional values are
	           required.  MANY is returned set to zero.
	         = 2, a semicolon was  found  as  the  first  printing
	           character  at  or  to  the right of IBUFFR(LOWBFR).
	           LOWBFR is returned pointing to the  next  character
	           beyond  the  location  of  the  semicolon.   It  is
	           assumed  the  calling  program   will   treat   the
	           appearance of the semicolon as marking the end of a
	           statement.  MANY is returned set to zero.
	         = 3, an ampersand was found  as  the  first  printing
	           character  at  or to the right of LOWBFR.  The text
	           to the right of the ampersand is taken as a comment
	           so LOWBFR is returned pointing beyond the right end
	           of the buffer.  It  is  assumed  that  the  calling
	           program  will read in the contents of a new buffer,
	           then again request a  new  series  evaluation  from
	           this  routine.   The  value  of  MANY  must  not be
	           changed  by  the  calling  program  prior  to  this
	           following  call.   The effect is not quite the same
	           as if the user had typed  all  of  the  text  on  a
	           single  line since a series specification cannot be
	           split across a line boundary.
	         = 4, a number or series specification was not  found,
	           but  a  comma was found indicating a missing series
	           specification.  Either NEWVAL or VALNEW,  whichever
	           is  appropriate, is returned with the value zero so
	           KIND=4 can be considered equivalent  to  KIND=5  if
	           such  is  appropriate  to the application for which
	           this routine is being used.
	         = 5, the next number specified by the contents of the
	           input  buffer is being returned as the value of the
	           argument   NEWVAL   or   VALNEW,    whichever    is
	           appropriate.
	         = 6, a series was specified in asterisk notation, but
	           no  number  appeared  to  right  of  the  asterisk.
	           NEWVAL or  VALNEW,  whichever  is  appropriate,  is
	           returned with value zero.  Subsequent calls to this
	           routine will continue to return  KIND=6  until  the
	           specified  number  of null values has been returned
	  FASP, FORTRAN Alphameric Subroutine Package         Page 256
	  DANEXT, Returns Next Value Typed as Single Number or Series


	           to the calling program.  Note that if a number does
	           not  precede  the  asterisk,  then KIND is returned
	           with the value 7 whether or not  a  number  follows
	           the asterisk.
	         = 7, a series was specified in asterisk notation, but
	           no  number  appeared to the left of the asterisk or
	           the number to left of the asterisk was less than  1
	           (or  less than 0.5 if evaluated as a real number as
	           this number is rounded when used).   The  value  of
	           the  number  to  the  right of the asterisk will be
	           returned in either NEWVAL or VALNEW,  whichever  is
	           appropriate.   If no number appears to the right of
	           the  asterisk,  then  either  NEWVAL   or   VALNEW,
	           whichever   is   appropriate,   will   be  returned
	           containing zero.
	         = 8, a series specification was found which contained
	           too  many  numbers,  too  many  asterisks, too many
	           slashes or too many colons.
	         = 9, the  first  printing  character  (other  than  a
	           possible comma if MANY was input greater than zero)
	           in  or  to  right  of  IBUFFR(LOWBFR)  was  not   a
	           character  which could appear in a number or number
	           range, and was not a comma, semicolon, ampersand or
	           exclamation  point.  LOWBFR is returned pointing to
	           the next  character  beyond  this  character.   The
	           calling  program  must decrement LOWBFR by 1 if the
	           unknown character is  to  be  identified  by  other
	           routines in this package.

	  The following argument is used  to  return  the  next  value
	  represented  by  the  contents of the text buffer if this is
	  being evaluated as an integer.

	  NEWVAL = returned  containing   the   next   integer   value
	           evaluated  by  this  routine  (the  value of KONTRL
	           being less than or equal to zero).  The contents of
	           this  argument should not be changed by the calling
	           program.

	  The following 2 arguments are used, together with  KIND  and
	  NEWVAL,  by  the current call to this routine to specify the
	  characteristics of the currently generated integer series to
	  the  subsequent  call  to  this  routine.   Neither of these
	  arguments should be changed  by  the  calling  program,  and
	  their  returned  values can probably otherwise be ignored by
	  the calling program.

	  INCVAL = returned containing the  increment  if  an  integer
	           series  was  specified  in slash or colon notation.
	           INCVAL is used  by  the  subsequent  call  to  this
	           routine  even  if  the  series  is composed of real
	           numbers.  INCVAL is returned nonzero for use  as  a
	           simple  switch  by  the  subsequent  call  to  this
	           routine if a real number series  was  specified  in
	  FASP, FORTRAN Alphameric Subroutine Package         Page 257
	  DANEXT, Returns Next Value Typed as Single Number or Series


	           slash  or colon notation.  INCVAL is set to zero if
	           a series specified in asterisk notation was  found,
	           whether  or not the series was evaluated in integer
	           or real mode.

	  LMTVAL = returned containing the ending value if an  integer
	           series  was  specified  in slash or colon notation.
	           If the integer series  was  specified  in  asterisk
	           notation,  then  LMTVAL  is returned containing the
	           number of times that this routine must  return  the
	           same   value  of  argument  NEWVAL,  including  the
	           current return.  In other words, the first  time  a
	           new integer value expressed in asterisk notation is
	           returned, LMTVAL is equal to the number left of the
	           asterisk,  not  to one less than the number left of
	           the asterisk.

	  The following argument is used  to  return  the  next  value
	  represented  by  the  contents of the text buffer if this is
	  being evaluated as a real number.

	  VALNEW = returned containing the next real  value  evaluated
	           by  this routine (the value of KONTRL being greater
	           than zero).  The contents of this  argument  should
	           not be changed by the calling program.

	  The following 2 arguments are used, together with  KIND  and
	  VALNEW  (and INCVAL, see above), by the current call to this
	  routine to specify  the  characteristics  of  the  currently
	  generated  real number series to the subsequent call to this
	  routine.  Neither of these arguments should  be  changed  by
	  the  calling program, and their returned values can probably
	  otherwise be ignored by the calling program.

	  VALINC = returned containing the increment if a real  number
	           series was specified in slash or colon notation.

	  VALLMT = returned containing the  ending  value  if  a  real
	           number  series  was  specified  in  slash  or colon
	           notation.  If the real number series was  specified
	           in  asterisk  notation,  then  VALLMT  is  returned
	           containing the number of times  that  this  routine
	           must  return  the  same  value  of argument VALNEW,
	           including the current return.  In other words,  the
	           first  time  a  new  real number value expressed in
	           asterisk notation is returned, VALLMT is  equal  to
	           the  number  found left of the asterisk, not to one
	           less than the number left of the asterisk.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 258
	  DANEXT, Returns Next Value Typed as Single Number or Series


	       Demonstration Program to Interactively Test DANEXT
	       ------------- ------- -- ------------- ---- ------

	  The program listed on the following pages accepts a line  of
	  text from the user, then reports each punctuation mark, each
	  single value, and each of the values in the ranges  included
	  in  the  text.   A sample dialog between the program and the
	  user is presented following the listing of the program.


	  C     PROGRAM TO DEMONSTRATE DANEXT ROUTINE
	  C
	        DATA ITTY,JTTY,MAXBFR/5,5,58/
	        DIMENSION IBUFFR(58),JBUFFR(20)
	        DATA IGREAT/1H>/
	        WRITE(JTTY,1)
	      1 FORMAT(1X,37HPROGRAM TO DEMONSTRATE DANEXT ROUTINE/
	       124H TEST DAINXT (Y OR N) = ,$)
	        READ(ITTY,2)IANS
	      2 FORMAT(1A1)
	        KONTRL=0
	        IF(IANS.EQ.1HY)GO TO 7
	        WRITE(JTTY,3)
	      3 FORMAT(10H KONTRL = ,$)
	        READ(ITTY,4)KONTRL
	      4 FORMAT(I)
	        WRITE(JTTY,5)
	      5 FORMAT(10H SLACK  = ,$)
	        READ(ITTY,6)SLACK
	      6 FORMAT(F)
	      7 IRADIX=10
	        IF(KONTRL.LT.0)IRADIX=8
	        MANY=0
	  C
	  C     READ TEXT TYPED BY USER
	      8 WRITE(JTTY,9)
	      9 FORMAT(1X,1H*,$)
	        READ(ITTY,10)IBUFFR
	     10 FORMAT(100A1)
	        LOWBFR=1
	        KIND=0
	  C
	  C     GET NEXT NUMBER IN SERIES
	     11 INIBFR=LOWBFR
	        IF(IANS.NE.1HY)CALL DANEXT(KONTRL,SLACK,IBUFFR,MAXBFR,
	       1LOWBFR,MANY,KIND,NEWVAL,INCVAL,LMTVAL,VALNEW,
	       2VALINC,VALLMT)
	        IF(IANS.EQ.1HY)CALL DAINXT(IBUFFR,MAXBFR,
	       1LOWBFR,MANY,KIND,NEWVAL,INCVAL,LMTVAL)
	        IF(LOWBFR.LE.INIBFR)GO TO 13
	        J=LOWBFR-1
	        WRITE(JTTY,12)(IBUFFR(I),I=INIBFR,J),IGREAT
	     12 FORMAT(1X,1H<,100A1)
	     13 GO TO(14,16,18,20,22,27,22,29,31),KIND
	  FASP, FORTRAN Alphameric Subroutine Package         Page 259
	  DANEXT, Returns Next Value Typed as Single Number or Series


	  C
	  C     REPORT RESULT OF CURRENT CALL TO DANEXT
	     14 WRITE(JTTY,15)
	     15 FORMAT(6H EMPTY)
	        GO TO 8
	     16 WRITE(JTTY,17)
	     17 FORMAT(17H END OF STATEMENT)
	        GO TO 11
	     18 WRITE(JTTY,19)
	     19 FORMAT(10H AMPERSAND)
	        GO TO 8
	     20 WRITE(JTTY,21)
	     21 FORMAT(8H MISSING)
	        GO TO 11
	     22 KOUNT=0
	        IF(KONTRL.GT.0)GO TO 23
	        CALL DANUMB(0,NEWVAL,IRADIX,JBUFFR,KOUNT,0,20)
	        GO TO 24
	     23 CALL DARITE(VALNEW,-1,0,0,0,
	       1-3,0,20,-1,8,6,6,
	       2-1,0,5,0,0,0,0,
	       320,JBUFFR,KOUNT,IERR)
	     24 IF(KIND.EQ.5)WRITE(JTTY,25)(JBUFFR(I),I=1,KOUNT)
	     25 FORMAT(7H VALUE ,20A1)
	        IF(KIND.EQ.7)WRITE(JTTY,26)(JBUFFR(I),I=1,KOUNT)
	     26 FORMAT(21H ZERO DUPLICATION OF ,20A1)
	        GO TO 11
	     27 WRITE(JTTY,28)
	     28 FORMAT(32H ASTERISK NOT FOLLOWED BY NUMBER)
	        GO TO 11
	     29 WRITE(JTTY,30)
	     30 FORMAT(15H TOO MANY ITEMS)
	        GO TO 11
	     31 WRITE(JTTY,32)
	     32 FORMAT(27H SEPARATOR OTHER THAN COMMA)
	        GO TO 11
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 260
	  DANEXT, Returns Next Value Typed as Single Number or Series


	  Typical Dialog Between DANEXT Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  PROGRAM TO DEMONSTRATE DANEXT ROUTINE
	  TEST DAINXT (Y OR N) = N
	  KONTRL = 4
	  SLACK  = 0.01
	  *1.23K 0.012M 1.067E-8!TEST SIMPLE NUMBERS
	  <1.23K>
	  VALUE 1230
	  < 0.012M>
	  VALUE 12000
	  < 1.067E-8>
	  VALUE 1.067E-8
	  <!TEST SIMPLE NUMBERS                 >
	  EMPTY
	  *1E6/2E5/2E6,3*,,2*0.04618,,;0.0245/0.002/0.03
	  <1E6/2E5/2E6>
	  VALUE 1E6
	  VALUE 1.2E6
	  VALUE 1.4E6
	  VALUE 1.6E6
	  VALUE 1.8E6
	  VALUE 2E6
	  <,3*>
	  ASTERISK NOT FOLLOWED BY NUMBER
	  ASTERISK NOT FOLLOWED BY NUMBER
	  ASTERISK NOT FOLLOWED BY NUMBER
	  <,>
	  MISSING
	  <,2*0.04618>
	  VALUE .04618
	  VALUE .04618
	  <,>
	  MISSING
	  <,>
	  MISSING
	  <;>
	  END OF STATEMENT
	  <0.0245/0.002/0.03>
	  VALUE .0245
	  VALUE .0265
	  VALUE .0285
	  <             >
	  EMPTY
	  *  4*1352.01   ,   ,   2/5   ;   ,  -17/2/-25  &WITH SPACES
	  <  4*1352.01>
	  VALUE 1352.01
	  VALUE 1352.01
	  VALUE 1352.01
	  VALUE 1352.01
	  <   ,   >
	  MISSING
	  <,   2/5>
	  FASP, FORTRAN Alphameric Subroutine Package         Page 261
	  DANEXT, Returns Next Value Typed as Single Number or Series


	  VALUE 2
	  VALUE 3
	  VALUE 4
	  VALUE 5
	  <   ;>
	  END OF STATEMENT
	  <   >
	  MISSING
	  <,  -17/2/-25>
	  VALUE -17
	  VALUE -19
	  VALUE -21
	  VALUE -23
	  VALUE -25
	  <  &WITH SPACES>
	  AMPERSAND
	  *0/0.667/2      &TESTING SLACK
	  <0/0.667/2>
	  VALUE 0
	  VALUE .667
	  VALUE 1.334
	  VALUE 2.001
	  <      &TESTING SLACK                             >
	  AMPERSAND
	  FASP, FORTRAN Alphameric Subroutine Package         Page 262
	  DANUMB, Integer Number FORTRAN Output Routine


	  DDDDDDD      AAA    NNN   NNN UUU   UUU MMM    MMM BBBBBBBBB
	  DDD   DDD  AAA AAA  NNNN  NNN UUU   UUU MMMM  MMMM BBB   BBB
	  DDD   DDD AAA   AAA NNN N NNN UUU   UUU MMM MM MMM BBBBBBB
	  DDD   DDD AAAAAAAAA NNN  NNNN UUU   UUU MMM    MMM BBB   BBB
	  DDDDDDD   AAA   AAA NNN   NNN UUUUUUUUU MMM    MMM BBBBBBBBB



	         DANUMB, Integer Number FORTRAN Output Routine
	         ------  ------- ------ ------- ------ -------

	  DANUMB represents an integer value so that it can be written
	  with  a FORTRAN format statement containing a multiple of an
	  A1 alphameric specification.  DANUMB is  much  shorter  than
	  the  free  format floating point output routine DARITE, both
	  because fewer options are provided  by  DANUMB  and  because
	  integer numbers are easier to represent.

	  DANUMB can represent any integer which can be calculated  by
	  a  computer  which uses two's complement notation, including
	  the largest negative number which consists of the  sign  bit
	  on  and  all other bits off and for which the absolute value
	  cannot be stored.  If DANUMB is  used  to  generate  FORTRAN
	  source  code,  as  for example when used by the integer data
	  statement  generator,  it  is  possible  that  the   FORTRAN
	  compiler  will not accept this largest negative number since
	  the compiler may evaluate a negative number by negating  its
	  absolute value.  Similarly, on computers which take the sign
	  bit on and all other bits off to mean negative zero,  DANUMB
	  will  produce  the  representation  of positive zero for the
	  value negative zero.

	  DANUMB has no  output  argument  used  to  signal  an  error
	  condition.   Instead,  the character count KOUNT is returned
	  unchanged if the representation of the number will  not  fit
	  into the buffer provided.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 263
	  DANUMB, Integer Number FORTRAN Output Routine


	                    The DANUMB Argument List
	                    --- ------ -------- ----

	  The argument list of routine DANUMB is

	        SUBROUTINE DANUMB(KONTRL,NUMBER,IRADIX,LETTER,
	       1KOUNT,LFTCOL,MAX)

	  with the associated DIMENSION statement

	        DIMENSION LETTER(MAX)

	  The following are input arguments left unchanged

	  KONTRL = 0, left justify the representation of the number.

	           If KOUNT is  less  than  LFTCOL,  then  the  output
	           buffer  starting  at  LETTER(KOUNT+1) and extending
	           through LETTER(LFTCOL) will be filled with spaces.

	           If KOUNT is less than or equal to LFTCOL, then  the
	           leftmost  character,  which  will be either a minus
	           sign or the leftmost digit of the representation of
	           the number, will be placed in LETTER(LFTCOL+1).

	           If  KOUNT  is  greater  than  LFTCOL  meaning  that
	           characters  are  already  in  use  to  the right of
	           LFTCOL,  then   a   space   will   be   placed   in
	           LETTER(KOUNT+1),  and  the  leftmost  digit  of the
	           representation of the  number  will  be  placed  in
	           LETTER(KOUNT+2).

	           If the representation of the number will  fit  into
	           the  output  buffer, then the character count KOUNT
	           will be  left  pointing  to  the  location  of  the
	           rightmost   digit  of  the  representation  of  the
	           number.  If the representation of the number  would
	           extend  to  the  right  of  LETTER(MAX),  then  the
	           character count KOUNT is returned unchanged.

	         = 1, right justify the representation of  the  number
	           so   that   the   rightmost   digit  is  placed  in
	           LETTER(LFTCOL).

	           If the representation of the number  requires  less
	           than  LFTCOL-KOUNT characters, then fill the output
	           buffer with spaces starting at LETTER(KOUNT+1)  and
	           extending  up  to  the  leftmost  character  of the
	           representation of the number.

	           If the representation of the number will  fit  into
	           the  output  buffer, then the character count KOUNT
	           will be returned equal to  LFTCOL.   If  LFTCOL  is
	           greater than the dimension of the buffer, or if the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 264
	  DANUMB, Integer Number FORTRAN Output Routine


	           number is too large to be represented  starting  at
	           LETTER(KOUNT+1)  and ending at LETTER(LFTCOL), then
	           the character count KOUNT is returned unchanged.

	  NUMBER = the integer value to be represented.

	  IRADIX = the  radix  with  which  the   value   is   to   be
	           represented.   IRADIX  can  vary from 2 through 10,
	           but IRADIX values 2 for binary, 8 for octal, and 10
	           for    decimal   representations   are   the   most
	           reasonable.   It  must  be  remembered   that   for
	           negative  values  of the argument NUMBER, it is the
	           value of the argument NUMBER which is  represented,
	           not  the  particular  sequence of bits by which the
	           computer stores  this  argument.   Thus  the  value
	           decimal -8 would be represented as -10 for IRADIX=8
	           and as -1000 for IRADIX=2 even if the computer uses
	           two's complement notation to store negative values.

	  The  following  argument  is   an   array   to   which   the
	  representation of the value is appended.

	  LETTER = the output buffer into which DANUMB will place  the
	           representation  of  the  number  and  which  can be
	           written by a  multiple  of  an  A1  format  by  the
	           calling program.

	  The following argument is used for both input to, and output
	  from this routine.

	  KOUNT  = is  input  containing  the  number  of   characters
	           already in use in the output buffer LETTER array.

	           If the representation of the value  will  fit  into
	           the  letter  array,  then  KOUNT  will  be returned
	           containing the location within the LETTER array  of
	           the  rightmost  character  of the representation of
	           the value.  If the representation of the value will
	           not  fit  into  the  LETTER  array,  then  KOUNT is
	           returned unchanged.

	  The following are input arguments which describe the size of
	  the  output  text  buffer.   These  arguments  are  returned
	  unchanged.

	  LFTCOL = number of characters in the buffer which are to  be
	           to  the left of the representation of the number if
	           KONTRL equals 0.
	         = position in the buffer at which is to be placed the
	           right  digit of the representation of the number if
	           KONTRL equals 1.

	  MAX    = the dimension of the output  buffer  LETTER  array.
	           The   character   count   KOUNT  will  be  returned
	  FASP, FORTRAN Alphameric Subroutine Package         Page 265
	  DANUMB, Integer Number FORTRAN Output Routine


	           unchanged if the representation of the value  would
	           extend beyond LETTER(MAX).



	                An Example of the use of DANUMB
	                -- ------- -- --- --- -- ------

	  The following sample  program  demonstrates  the  manner  in
	  which DANUMB is called.

	            DIMENSION NUMBER(5),LETTER(50)
	            DATA NUMBER/-123456,-123,0,123,123456/
	      C
	      C     PRODUCE MARGIN
	            NMB=0
	            KOUNT=0
	          1 NMB=NMB+1
	            IF(NMB.GT.9)NMB=0
	            J=KOUNT
	            CALL DANUMB(0,NMB,10,LETTER,KOUNT,KOUNT,50)
	            IF(J.LT.KOUNT)GO TO 1
	            TYPE 2,LETTER
	          2 FORMAT(1X,50A1)
	      C
	      C     PRODUCE LEFT JUSTIFIED OUTPUT
	            KOUNT=0
	            DO 3 I=1,5
	            J=KOUNT
	            CALL DANUMB(0,NUMBER(I),10,LETTER,KOUNT,0,50)
	            IF(J.GE.KOUNT)GO TO 4
	          3 CONTINUE
	          4 IF(KOUNT.GT.0)TYPE 2,(LETTER(I),I=1,KOUNT)
	      C
	      C     PRODUCE OUTPUT RIGHT JUSTIFIED IN WIDTH 10 FIELDS
	            KOUNT=0
	            DO 5 I=1,5
	            LFTCOL=KOUNT+10
	            CALL DANUMB(1,NUMBER(I),10,LETTER,KOUNT,LFTCOL,50)
	          5 CONTINUE
	            TYPE 2,(LETTER(I),I=1,KOUNT)
	            STOP
	            END

	  The output generated by the above program is shown below.

	       12345678901234567890123456789012345678901234567890
	       -123456 -123 0 123 123456
	          -123456      -123         0       123    123456
	  FASP, FORTRAN Alphameric Subroutine Package         Page 266
	  DAPAIR, Returns an Index and an Associated Value


	  DDDDD           AAA   PPPPPP        AAA   IIIIII   RRRRRR
	  DD   DD        AAAA   PP    PP     AAAA     II     RR    RR
	  DD    DD      AA AA   PP    PP    AA AA     II     RR    RR
	  DD    DD     AA  AA   PPPPPP     AA  AA     II     RRRRRR
	  DD    DD    AAAAAAA   PP        AAAAAAA     II     RR  RR
	  DD   DD    AA    AA   PP       AA    AA     II     RR   RR
	  DDDDD     AA     AA   PP      AA     AA   IIIIII   RR    RR


	        DAPAIR, Returns an Index and an Associated Value
	        ------  ------- -- ----- --- -- ---------- -----

	  DAPAIR returns to the  calling  program  a  pair  of  values
	  represented by the characters in an input buffer read by the
	  calling program with a multiple of an A1 format.   The  pair
	  of   values  is  assumed  to  consist  of  an  index  (or  a
	  subscript), which is represented first in the input  buffer,
	  and  of  a  value  to  be  associated  with  this index.  If
	  subsequent calls to this routine are to assign a sequence of
	  values  with a constant increment to either the index or the
	  associated value, then the representation of a single  index
	  or  of  a  single  range  of  indexes  is  followed  by  the
	  representations of the several associated values  and/or  of
	  the  several  ranges  of associated values.  If both numbers
	  are specified as members of ranges, then the first  call  to
	  this  routine  returns the first value of the first range as
	  the index and the first value of the  second  range  as  the
	  associated  value,  the  second call to this routine returns
	  the second value of the first range as  the  index  and  the
	  second  value  of  the second range as the associated value,
	  and so on.  If the range of indexes is  exhausted  prior  to
	  the   generation  of  the  final  member  of  the  range  of
	  associated values, then the final  value  of  the  index  is
	  returned  unchanged  with  the subsequent associated values,
	  but the calling program is informed of  this  condition  and
	  can  adjust  the index as necessary.  Once both the range of
	  indexes and the current range of associated values have been
	  exhausted,  then  the  following  representation of a single
	  number or of a range of numbers can specify the indexes of a
	  subsequent  pair,  or  can  specify  additional values to be
	  associated with the same final index.

	  Spaces and/or tabs are allowed between  the  representations
	  of numbers and/or of number ranges.  The calling program can
	  prohibit the appearance of printing characters  between  the
	  representations  of  the  index and its associated value, or
	  between the representations of subsequent associated values,
	  in which case a comma indicates that the following number is
	  to be taken as a new index, or else the calling program  can
	  allow  commas  between the index and the associated value or
	  between  subsequent  associated  values,  in  which  case  2
	  adjacent commas indicate a missing associated value.

	  The ranges of values to be assigned to the indexes or to the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 267
	  DAPAIR, Returns an Index and an Associated Value


	  associated  values can be specified in either slash or colon
	  or asterisk notations.  In asterisk notation, a value to  be
	  repeated  a  given number of times is preceded by the number
	  of times and an asterisk.  In slash or colon notation (the 2
	  characters  are  equivalent), a value which is to start at a
	  specified initial value, then be varied until it  reaches  a
	  final bound is expressed as the initial value, the increment
	  by which the value is to be  varied,  and  the  final  bound
	  separated  by  slashes  or by colons.  If either the initial
	  value or the final  bound  is  missing  in  slash  or  colon
	  notation,  then the missing value is assumed to be zero.  If
	  the increment is not included in slash  or  colon  notation,
	  then  the  increment  is  assumed  to be 1 and only a single
	  slash or a single colon is needed to  separate  the  initial
	  value and the final bound.  For example, the text

	       1/3 4 5/7 8/10 4*11

	  would specify the 4 pairs 1 and 4, 2 and 5, 3 and 6, and  an
	  unchanged  3  and  7.   Depending  upon  how this routine is
	  called, the next pairs returned could be 3 and 8, 3 and 9, 3
	  and  10,  and  then  4 appearances of 3 and 11.  The routine
	  could instead inform the calling program that  a  new  index
	  was  found  but  not  evaluated, then subsequent calls would
	  return the pairs 8 and 11, 9 and 11, 10 and 11, and a  final
	  unchanged 10 and 11.  A semicolon (or a comma if not allowed
	  between adjacent associated values) appearing between the  7
	  and  8  would  force  the  latter  interpretation, since the
	  appearance of a semicolon (or of  a  comma  if  not  allowed
	  between  adjacent  associated  values)  causes the following
	  number to be interpreted as the index of a subsequent pair.

	  An exclamation point and anything to its right are taken  to
	  be  a  comment  and are otherwise ignored.  An ampersand and
	  anything to its right are also ignored, but the  text  being
	  interpreted is assumed to continue with that supplied to the
	  subsequent call  of  this  routine.   Additional  ranges  of
	  associated  values can appear in the text next read into the
	  input buffer after an ampersand  has  been  found,  but  the
	  specification  of a single range cannot be continued in this
	  manner across  a  line  boundary.   For  example,  the  pair
	  specification shown above could instead have been given as

	       1/3 4 5/7&THIS IS THE FIRST LINE
	       8/10 4*11!THIS IS THE SECOND LINE

	  Two versions of the routine are supplied.   DAPAIR  requires
	  the  routines  DANEXT and DASPAN for the evaluation of range
	  specifications.  DAIPAR cannot evaluate ranges, but might be
	  sufficient  if  the  index varies in a predetermined manner,
	  and if ranges are not needed for the  specification  of  the
	  associated values.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 268
	  DAPAIR, Returns an Index and an Associated Value


	              The DAPAIR and DAIPAR Argument Lists
	              --- ------ --- ------ -------- -----

	  The argument lists of routines DAPAIR and DAIPAR are

	        SUBROUTINE DAPAIR(SLACK ,KNDBGN,KNDEND,KONECT,IBUFFR,
	       1    MAXBFR,LOWBFR,KIND  ,NEWBGN,NEWEND,BGNNEW,ENDNEW,
	       2    IWHERE,INCBGN,LMTBGN,BGNINC,BGNLMT,INCEND,LMTEND,
	       3    ENDINC,ENDLMT)

	  and

	        SUBROUTINE DAIPAR(       KNDBGN,KNDEND,KONECT,IBUFFR,
	       1    MAXBFR,LOWBFR,KIND  ,NEWBGN,NEWEND,BGNNEW,ENDNEW)

	  both with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR)

	  The argument lists of these routines are identical with  the
	  exception  that  the first argument and the last 9 arguments
	  of DAPAIR do not appear in the  DAIPAR  argument  list.   In
	  addition,  the  argument  KIND  will  not  be assigned its 3
	  highest possible values by DAIPAR.  These missing  arguments
	  and  the  missing  values  of  KIND  are  all  used  in  the
	  evaluation of value ranges and so are not needed by DAIPAR.

	  The following arguments are used for  input  only,  and  are
	  returned unchanged.

	  SLACK  = the fraction of the increment of a real number (not
	           integer)   range   expressed   in  slash  or  colon
	           notation, by which the returned  value  can  exceed
	           the  final  bound  and  still  be  considered to be
	           within the range.  SLACK is  necessary  because  of
	           the    imprecision    of   calculations   involving
	           fractional real numbers.  For example, if the  user
	           wished  to  have  the increment be 0.666... with an
	           initial value of 3.0 and a final bound of 5.0, then
	           the  user  might  type 3/.667/5 and expect that the
	           numbers 3.000, 3.667, 4.333,  and  5.000  would  be
	           included  within  the  range,  while, actually, the
	           number near 5.00 would be calculated  to  be  5.001
	           and would therefore be outside the range.  Although
	           SLACK can be set to zero, a value of about 0.01  is
	           recommended.   In  the  above  example,  SLACK=0.01
	           would cause the actual final bound to be 5.00667 so
	           that  the  number  calculated  near the final bound
	           would be within the range.   SLACK  is  ignored  if
	           numbers in the range are returned as integers.

	  KNDBGN = specifies whether the  index  is  returned  as  the
	           integer  argument  NEWBGN  or  as the real argument
	           BGNNEW.  The number can be  typed  with  a  decimal
	  FASP, FORTRAN Alphameric Subroutine Package         Page 269
	  DAPAIR, Returns an Index and an Associated Value


	           point and/or an exponent regardless of the value of
	           KNDBGN.
	         = -1, the index is calculated as an octal integer and
	           is  returned  as the argument NEWBGN.  However, the
	           number following the letter E  of  an  exponent  is
	           evaluated in decimal.
	         = 0, the index is calculated as a decimal integer and
	           is returned as the argument NEWBGN.
	         = 1 or greater, the index is  returned  as  the  real
	           argument BGNNEW.  If possible, the real number will
	           be accumulated as an integer, then be converted  to
	           real  and  shifted  as  necessary.   KNDBGN  is the
	           maximum number of digits in the integer.

	  KNDEND = specifies whether the associated value is  returned
	           as  the  integer  argument  NEWEND  or  as the real
	           argument ENDNEW.  The number can be  typed  with  a
	           decimal  point and/or an exponent regardless of the
	           value of KNDEND.
	         = -1, the associated value is calculated as an  octal
	           integer  and  is  returned  as the argument NEWEND.
	           However, the number following the letter  E  of  an
	           exponent is evaluated in decimal.
	         = 0, the associated value is calculated as a  decimal
	           integer and is returned as the argument NEWEND.
	         = 1 or greater, the associated value is  returned  as
	           the  real  argument  ENDNEW.  If possible, the real
	           number will be accumulated as an integer,  then  be
	           converted to real and shifted as necessary.  KNDEND
	           is the maximum number of digits in the integer.

	  KONECT = specifies  the  manner  of  interpretation   of   a
	           following  number when the range of indexes and the
	           range  of  associated   values   have   both   been
	           exhausted.   KONECT  also  specifies whether commas
	           are to indicate that the following number, if  any,
	           is to be the index of a subsequent pair, or whether
	           commas  are  allowed  between   subsequent   values
	           associated with the same index or range of indexes.
	           Regardless of  the  value  of  KONECT,  all  commas
	           appearing to the left of an index are ignored.
	         = -1, 0  or  1,  commas  cannot  appear  between  the
	           specification  of  an  index  and of its associated
	           value and cannot appear between the representations
	           of  subsequent  associated  values.   If a comma is
	           found, then the following number, if any, is  taken
	           to be the index of a subsequent pair of numbers.
	         = -1, when the range of  indexes  and  the  range  of
	           associated  values  have  both  been  exhausted,  a
	           following representation of a number or of a  range
	           of  numbers  on  the  same line is taken to specify
	           additional associated values.

	           If an end of line is  found  before  the  range  of
	  FASP, FORTRAN Alphameric Subroutine Package         Page 270
	  DAPAIR, Returns an Index and an Associated Value


	           indexes   has  been  exhausted,  then  the  calling
	           program can request (by setting KIND=4 to  simulate
	           the finding of an ampersand) that the evaluation of
	           associated values is to be continued  by  the  next
	           call  to this routine in the new text read into the
	           input buffer.  If an end of line  is  found  before
	           the  range  of  indexes has been exhausted, but the
	           calling program leaves KIND unchanged before  again
	           calling  this  routine,  then  the  remaining index
	           values will be returned without associated  values,
	           following   which  the  first  number  in  the  new
	           contents of the text buffer will be interpreted  as
	           the index of a new pair.

	           If an ampersand is found to the right of  an  index
	           specification,  regardless  of whether the range of
	           indexes has been exhausted, then the evaluation  of
	           associated  values  will  be  continued by the next
	           call to this routine in the new text read into  the
	           input  buffer.   If  an ampersand is found prior to
	           the exhaustion of the range  of  indexes,  but  the
	           next  line read into the input buffer is to start a
	           new pair, then KIND should  be  set  to  6  by  the
	           calling program causing the remaining indexes to be
	           generated  first  but  marked  as  having   missing
	           associated values.  If the ampersand is found after
	           the exhaustion of the range  of  indexes,  but  the
	           next  line read into the input buffer is to start a
	           new pair, then KIND should be set to one.

	         = 0, when the range  of  indexes  and  the  range  of
	           associated  values  have  both  been  exhausted,  a
	           following representation of a number or of a  range
	           of  numbers on the same line causes this routine to
	           report a missing comma, and the subsequent call  to
	           this  routine  then  begins  the evaluation of this
	           following number as an index or range of indexes of
	           a subsequent pair.

	           If an end of line is  found  before  the  range  of
	           indexes   has  been  exhausted,  then  the  calling
	           program can request (by setting KIND=4 to  simulate
	           the finding of an ampersand) that the evaluation of
	           associated values is to be continued  by  the  next
	           call  to this routine in the new text read into the
	           input buffer.  If an end of line  is  found  before
	           the  range  of  indexes has been exhausted, but the
	           calling program leaves KIND unchanged before  again
	           calling  this  routine,  then  the  remaining index
	           values will be returned without associated  values,
	           following   which  the  first  number  in  the  new
	           contents of the text buffer will be interpreted  as
	           the index of a subsequent pair.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 271
	  DAPAIR, Returns an Index and an Associated Value


	           If an ampersand is found prior to the exhaustion of
	           the  range  of  indexes,  then  the  evaluation  of
	           associated values will be  continued  by  the  next
	           call  to this routine in the new text read into the
	           input buffer unless the calling program  sets  KIND
	           to  6 prior to the subsequent call to this routine,
	           causing the remaining indexes to be  generated  but
	           marked  as having missing associated values.  If an
	           ampersand is found after the range of  indexes  and
	           the  range  of  associated  values  have  both been
	           exhausted, then the first number evaluated  by  the
	           subsequent  call  to  this  routine in the new text
	           read into the input buffer is  assumed  to  be  the
	           index of a new pair of values.

	           = 1, when the range of indexes  and  the  range  of
	           associated  values  have  both  been  exhausted,  a
	           following representation of a number or of a  range
	           of  numbers  on  the  same line is taken to specify
	           additional associated values.

	           If either an ampersand or an end of line  is  found
	           before  the  range  of  indexes has been exhausted,
	           then the remaining index values  will  be  returned
	           without  associated  values,  following  which  the
	           calling program will be informed that  the  end  of
	           line or ampersand has been reached.

	         = 2,  3  or  4,  same  as  when  KONECT=-1,  0  or  1
	           respectively,  except  that  commas can appear (but
	           are not required) between  the  representations  of
	           the  index  and  the  first  associated  value  and
	           between   the   representations    of    subsequent
	           associated  values.   An  extra  comma  indicates a
	           missing associated value.  If KONECT=3, and if  the
	           range of indexes and the range of associated values
	           have  both  been  exhausted,  then  KIND  will   be
	           returned  set to 10 to indicate a missing semicolon
	           if a following number is found whether or not  this
	           following  number  is  preceded by a comma, and the
	           subsequent call to  this  routine  will  begin  the
	           evaluation  of  the following number as an index or
	           range of indexes  of  a  subsequent  pair.   Unlike
	           commas,  semicolons  are  always  reported  to  the
	           calling program regardless of the value of KONECT.

	  IBUFFR = input buffer array containing characters  typed  by
	           the user, read by a multiple of an A1 format, which
	           is  to  be  searched  for  number   specifications.
	           IBUFFR  then  contains  one  character per computer
	           storage location.

	  MAXBFR = maximum subscript of the IBUFFR array locations  to
	           be searched.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 272
	  DAPAIR, Returns an Index and an Associated Value


	  The following arguments are used  both  for  input  to  this
	  routine, and for output to the calling program.

	  LOWBFR = input containing the subscript  within  the  IBUFFR
	           array  of  the first (leftmost) character which can
	           be scanned for a number specification.   LOWBFR  is
	           returned pointing to the next character which would
	           be interpreted  by  the  subsequent  call  to  this
	           routine  if  this subsequent call needs to evaluate
	           further number specifications.  LOWBFR is  returned
	           unchanged if this routine merely generates the next
	           associated value  within  a  previously  determined
	           range.   If  there are no printing characters at or
	           to   the   right   of   IBUFFR(LOWBFR),   but   the
	           interpretation    of   additional   characters   is
	           attempted, then LOWBFR will be returned  containing
	           MAXBFR+1.   LOWBFR  must  be  reset  by the calling
	           program to point to  the  first  character  in  the
	           IBUFFR array each time a new line of text is read.

	  KIND   = input containing -1, an error was detected  by  the
	           calling  program  (rather  than by this routine) in
	           the results returned by the previous call  to  this
	           routine and any additional numbers through the next
	           appearance of a comma  (unless  KONECT  is  greater
	           than  1)  or  a  semicolon  or  an  ampersand or an
	           unknown character or the end  of  line  are  to  be
	           ignored.  The next number to the right of the comma
	           or on the line following the ampersand  or  end  of
	           line  is to be interpreted as the index of the next
	           pair.  An  unknown  character  or  a  semicolon  is
	           reported  to  the  calling  program  if it is found
	           instead.
	         = input containing 0, this routine has not  yet  been
	           called  during the execution of the current logical
	           section of the calling program.  This routine is to
	           begin  evaluation of the contents of the input text
	           buffer,  not  continue  the  generation  of  ranges
	           evaluated   by  previous  calls  to  this  routine.
	           LOWBFR should point to the first character  in  the
	           IBUFFR array to be interpreted.
	         = input  greater  than  zero,  the  value   of   KIND
	           indicates  the  condition  returned by the previous
	           call to this routine and in most cases has not been
	           modified   by  the  calling  program.   KIND  being
	           returned with one of the values 7,  8,  9,  10  (if
	           KONECT  is 2 or 4), 13 and 14 indicates that a pair
	           of values is being  returned,  although  either  or
	           both  members  of  the  pair could be missing.  The
	           other values of KIND  indicate  special  conditions
	           for which a pair of numbers is not returned.
	         = 1, nothing, except perhaps leading commas or else a
	           comment  indicated  by a leading exclamation point,
	           was found at or to  the  right  of  IBUFFR(LOWBFR).
	  FASP, FORTRAN Alphameric Subroutine Package         Page 273
	  DAPAIR, Returns an Index and an Associated Value


	           The  calling program should read a new line of text
	           into IBUFFR.
	         = 2, a semicolon was  found  as  the  first  printing
	           character at or to the right of IBUFFR(LOWBFR).  If
	           the range of indexes has not  been  exhausted  when
	           the  semicolon is found, then the remaining members
	           of the range are reported to  the  calling  program
	           before  the  semicolon  is reported.  It is assumed
	           that the calling program will treat  the  semicolon
	           as  marking  the  end  of  a  logical group of pair
	           specifications if KONECT is not greater than 1,  or
	           the end of a single pair specification if KONECT is
	           greater than 1.
	         = 3, an ampersand was found while searching  for  the
	           next range of indexes.  LOWBFR is returned pointing
	           beyond the end of the buffer.  The calling  program
	           should  read  a  new  line  of  text into the input
	           buffer before again  calling  this  routine.   This
	           value  of  KIND  is not returned if an ampersand is
	           found while searching for  a  range  of  associated
	           values.
	         = 4, the range of indexes was not exhausted,  but  an
	           ampersand   was   found   instead  of  a  range  of
	           associated values.  The calling program should read
	           a  new  line  of  text into the buffer before again
	           calling this routine.  The subsequent call to  this
	           routine  will continue the evaluation of associated
	           ranges in the new contents of  the  buffer.   If  a
	           semicolon (or a comma if KONECT is not greater than
	           1) is found at the start of the new contents of the
	           buffer,  then  the  remaining  index values will be
	           returned to the calling  program  but  the  calling
	           program will be informed that the associated values
	           are  missing.   If  the  subsequent  call  to  this
	           routine is instead to begin the evaluation of a new
	           set of leading indexes and associated values,  then
	           the  calling  program  should  set  KIND  to  6  to
	           simulate the lack  of  an  ampersand,  causing  the
	           remaining  indexes  to  be generated, but marked as
	           having missing associated values.  If the remaining
	           indexes  are not wanted, then KIND should be set to
	           one.
	         = 5, the range  of  indexes  was  exhausted,  but  an
	           ampersand   was   found   instead  of  a  range  of
	           associated values.  The calling program should read
	           a  new  line  of  text into the buffer before again
	           calling this routine.  The subsequent call to  this
	           routine  will continue the evaluation of associated
	           ranges in the new contents of  the  buffer.   Since
	           the   range  of  indexes  has  been  exhausted,  no
	           additional missing values will  be  reported  if  a
	           semicolon (or a comma if KONECT is not greater than
	           1) is found at the start of the new contents of the
	           buffer.   If the subsequent call to this routine is
	  FASP, FORTRAN Alphameric Subroutine Package         Page 274
	  DAPAIR, Returns an Index and an Associated Value


	           always to begin the evaluation  of  a  new  set  of
	           leading  indexes  and  associated  values, then the
	           calling program should set KIND to one.
	         = 6, an end of  line  was  found  but  the  range  of
	           indexes   was  not  exhausted.   If  KIND  is  sent
	           unchanged to the subsequent call of  this  routine,
	           then  the remaining indexes will be returned to the
	           calling program, but the calling  program  will  be
	           informed  that  the  associated values are missing.
	           If the subsequent call to this routine  is  instead
	           to  continue the evaluation of associated ranges in
	           the new contents of the buffer read by the  calling
	           program  before  this routine is again called, then
	           KIND should be set to 4 to simulate the  appearance
	           of  an  ampersand at the end of the preceding line.
	           If the remaining indexes are not wanted, then  KIND
	           should be set to one.
	         = 7, both an index and an associated value are  being
	           returned to the calling program.
	         = 8, an  index  is  being  returned  to  the  calling
	           program,  but  the  associated  value  is  missing.
	           NEWEND and ENDNEW are returned undefined.
	         = 9, an associated value is  being  returned  to  the
	           calling  program, but the range of indexes has been
	           exhausted.   NEWBGN   or   BGNNEW,   whichever   is
	           appropriate,  is  returned  unchanged  (but  can be
	           modified as desired by the calling program).
	         = 10,  the  ranges  of  both  the  indexes  and   the
	           associated  values have been exhausted.  This value
	           is never returned if KONECT=-1 or 1.

	           If KONECT has either of the values 2 or 4, then the
	           ranges  of  both  the  indexes  and  the associated
	           values have been exhausted, but an extra comma  was
	           found   indicating   a  missing  associated  value.
	           NEWBGN or  BGNNEW,  whichever  is  appropriate,  is
	           returned  unchanged (but can be modified as desired
	           by the calling program).

	           If KONECT=0, then the ranges of  both  the  indexes
	           and  associated  values  have been exhausted, but a
	           following number was found which was  not  preceded
	           by  a  comma.   KIND  should  be  set  to -1 by the
	           calling program before this routine is called  next
	           if  the  lack of a comma indicates a serious enough
	           error that all numbers should be ignored until  the
	           next  comma is found.  If KONECT=3, then the ranges
	           of both the indexes and associated values have been
	           exhausted,  but  a following number was found which
	           was not preceded by a semicolon, but which  may  or
	           may  not  have been preceded by one or more commas.
	           KIND should be set to -1  by  the  calling  program
	           before this routine is called next if the lack of a
	           semicolon indicates a serious enough error that all
	  FASP, FORTRAN Alphameric Subroutine Package         Page 275
	  DAPAIR, Returns an Index and an Associated Value


	           numbers  should be ignored until the next semicolon
	           is found.  If KONECT is 0  or  3,  then  LOWBFR  is
	           returned  pointing  to  the  first character of the
	           number  specification,  and  the  number  will   be
	           evaluated  as  an  index  if this routine is called
	           again without KIND having been changed.
	         = 11, an unknown character was found.  If  the  range
	           of  indexes has not been exhausted when the unknown
	           character is found, then the remaining  members  of
	           the  range  are  reported  to  the  calling program
	           before the unknown character is  reported.   LOWBFR
	           is  returned  pointing to the next character to the
	           right of the unknown character.  If this routine is
	           called without changing the value of KIND, then the
	           number to the right of the unknown  character  will
	           be interpreted as the index of the next pair.
	         = 12,   an   error   was   found   within   a   range
	           specification.    The  finding  of  such  an  error
	           terminates the generation of the range of  indexes.
	           IWHERE is returned pointing to the character at the
	           start of the specification  containing  the  error.
	           LOWBFR is returned pointing to the character to the
	           right of the specification  containing  the  error.
	           If  this  routine  is  called  without changing the
	           value of KIND, then the number to the right of  the
	           unknown  character will be interpreted as the index
	           of the next pair.
	         = 13, an index and  the  associated  value  zero  are
	           being  returned  to  the calling program.  The zero
	           was indicated by the lack of a number to the  right
	           of  an  asterisk.  A missing number to the right of
	           an asterisk in the  specification  of  a  range  of
	           indexes  is  not  allowed  and  would  return  KIND
	           containing the value 12.
	         = 14, same  as  KIND=13  except  that  the  range  of
	           indexes was exhausted.  NEWBGN or BGNNEW, whichever
	           is appropriate, is returned unchanged (but  can  be
	           modified as desired by the calling program).

	  NEWBGN = returned containing the next value  of  an  integer
	           index  if  KIND  is  returned containing one of the
	           values 7, 8 or 13 and if KNDBGN  is  less  than  or
	           equal to zero.  NEWBGN should not be changed by the
	           calling program unless KIND is returned  containing
	           one  of  the values 9, 10 or 14 indicating that the
	           range of indexes has been exhausted.

	  NEWEND = returned containing  the  next  associated  integer
	           value if KIND is returned with one of the values 7,
	           9, 13 or 14 and if KNDEND is less than or equal  to
	           zero.   NEWEND  can  be  returned  changed  by this
	           routine even if an associated value  is  not  found
	           but  then  must  not  be  changed  by  the  calling
	           program.  If the range  of  associated  values  has
	  FASP, FORTRAN Alphameric Subroutine Package         Page 276
	  DAPAIR, Returns an Index and an Associated Value


	           been  exhausted,  or  if  the  associated  value is
	           indicated by an extra comma  to  be  missing,  then
	           NEWEND does not contain an associated integer value
	           but instead indicates to  the  subsequent  call  to
	           this  routine  the  reason why a value could not be
	           returned.

	  BGNNEW = returned containing the next value of a real  index
	           if KIND is returned containing one of the values 7,
	           8 or 13 and if KNDBGN is greater than zero.  BGNNEW
	           should not be changed by the calling program unless
	           KIND is returned containing one of the values 9, 10
	           or 14 indicating that the range of indexes has been
	           exhausted.

	  ENDNEW = returned containing the next associated real  value
	           if KIND is returned with one of the values 7, 9, 13
	           or 14 and if KNDEND is greater than  zero.   ENDNEW
	           should not be changed by the calling program.

	  The following argument is used for output only, and  is  not
	  included in the DAIPAR argument list.

	  IWHERE = returned pointing to the left character of a  range
	           notation  which  was found to contain an error such
	           as too many asterisks, too many slashes,  too  many
	           colons,  or the absence of a number to the right of
	           an asterisk in the  specification  of  a  range  of
	           leading indexes.

	  The remaining DAPAIR arguments  are  used  only  during  the
	  generation of values within ranges and should be sent to the
	  subsequent DAPAIR call unchanged.  These arguments should be
	  stated  by name in the call statements and should be ignored
	  by the calling program except insofar  as  is  necessary  to
	  transmit  their  values  to  the  subsequent  call  to  this
	  routine.


	  Values Returned for Typical Range Specification Combinations
	  ------ -------- --- ------- ----- ------------- ------------

	  Shown on the following pages are results returned by  DAPAIR
	  during  the  evaluation  of  several  typical lines of input
	  text.  The line of  text  is  shown  first,  followed  by  a
	  description of the results obtained with KONECT values of -1
	  (left column), 0 (center column) and 1 (right column).   The
	  returned  values of the argument named KIND are indicated by
	  the following descriptions in  which  the  digits  1  and  2
	  represent  the  returned index and returned associated value
	  respectively, and in which #  represents  any  number.   The
	  index is enclosed in parentheses if the index range has been
	  exhausted but associated values are still being found.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 277
	  DAPAIR, Returns an Index and an Associated Value


	  KIND=1, empty         KIND= 7, 1 and 2
	      =2, ;                 = 8, 1 and missing #
	      =3, &                 = 9, (1) and 2
	      =4, & but # needed    =10, unexpected # (KONECT=0,3)
	      =5, & but # expected  =10, (1) and missing #(KONECT=2,4)
	      =6, empty but # needed

	  In the examples shown on the following pages, it is  assumed
	  that KIND will be changed by the calling program to have the
	  value 4 whenever it is returned set to 6  by  this  routine.
	  The  initial  values  returned  during  the  evaluation of a
	  subsequent line when KIND is input set to 4 are indicated by
	  "# next line" rather than by merely a #.

	       KONECT=-1           KONECT=0            KONECT=1

	  !
	       empty               empty               empty

	  &
	       &                   &                   &

	  ,
	       empty               empty               empty

	  ,&
	       &                   &                   &

	  1
	       empty but # needed  empty but # needed  1 and missing #
	       1 and # next line   1 and # next line   empty

	  1!FOLLOWED BY A LINE BEGINNING WITH A COMMA
	       empty but # needed  empty but # needed
	       1 and missing #     1 and missing #     (same as above)
	       values after comma  values after comma

	  1&
	       & but # needed      & but # needed      1 and missing #
	       1 and # next line   1 and # next line   &

	  1&FOLLOWED BY A LINE BEGINNING WITH A COMMA
	       & but # needed      & but # needed
	       1 and missing #     1 and missing #     (same as above)
	       values after comma  values after comma

	  1,
	       1 and missing #     1 and missing #     1 and missing #
	       empty               empty               empty

	  1,&
	       1 and missing #     1 and missing #     1 and missing #
	       &                   &                   &
	  FASP, FORTRAN Alphameric Subroutine Package         Page 278
	  DAPAIR, Returns an Index and an Associated Value


	  1 2
	       1 and 2             1 and 2             1 and 2
	       empty               empty               empty

	  1 2&
	       1 and 2             1 and 2             1 and 2
	       & but # expected    &                   &
	       (1) and # next line

	  1 2&FOLLOWED BY A LINE BEGINNING WITH A COMMA
	       1 and 2
	       & but # expected    (same as above)     (same as above)
	       values after comma

	  1 2,
	       1 and 2             1 and 2             1 and 2
	       empty               empty               empty

	  1 2,&
	       1 and 2             1 and 2             1 and 2
	       &                   &                   &

	  1 2 3
	       1 and 2             1 and 2             1 and 2
	       (1) and 3           unexpected #        (1) and 3
	       empty               empty but # needed  empty
	                           3 and # next line

	  1 2 3!FOLLOWED BY A LINE BEGINNING WITH A COMMA
	                           1 and 2
	       (same as above)     unexpected #        (same as above)
	                           empty but # needed
	                           3 and missing #
	                           values after comma
	  1 2 3&
	       1 and 2             1 and 2             1 and 2
	       (1) and 3           unexpected #        (1) and 3
	       & but # expected    & but # needed      &
	       (1) and # next line 3 and # next line

	  1 2 3&FOLLOWED BY A LINE BEGINNING WITH A COMMA
	       1 and 2             1 and 2
	       (1) and 3           unexpected #        (same as above)
	       & but # expected    & but # needed
	       values after comma  3 and missing #
	                           values after comma
	  1 4/6
	       1 and 4             1 and 4             1 and 4
	       (1) and 5           (1) and 5           (1) and 5
	       (1) and 6           (1) and 6           (1) and 6
	       empty               empty               empty

	  FASP, FORTRAN Alphameric Subroutine Package         Page 279
	  DAPAIR, Returns an Index and an Associated Value


	  1 4/6&
	       1 and 4             1 and 4             1 and 4
	       (1) and 5           (1) and 5           (1) and 5
	       (1) and 6           (1) and 6           (1) and 6
	       & but # expected    &                   &
	       (1) and # next line

	  1 4/6&FOLLOWED BY A LINE BEGINNING WITH A COMMA
	       1 and 4
	       (1)and 5            (same as above)     (same as above)
	       (1) and 6
	       & but # expected
	       values after comma

	  1 4/6 7/9
	       1 and 4             1 and 4             1 and 4
	       (1) and 5           (1) and 5           (1) and 5
	       (1) and 6           (1) and 6           (1) and 6
	       (1) and 7           unexpected #        (1) and 7
	       (1) and 8           empty but # needed  (1) and 8
	       (1) and 9           7 and # next line   (1) and 9
	       empty               8 and # next line   empty
	                           9 and # next line

	  1 4/6 7/9!FOLLOWED BY A LINE BEGINNING WITH A COMMA
	                           1 and 4
	       (same as above)     (1) and 5           (same as above)
	                           (1) and 6
	                           unexpected #
	                           empty but # needed
	                           7 and missing #
	                           8 and missing #
	                           9 and missing #
	                           values after comma
	  1 4/6 7/9&
	       1 and 4             1 and 4             1 and 4
	       (1) and 5           (1) and 5           (1) and 5
	       (1) and 6           (1) and 6           (1) and 6
	       (1) and 7           unexpected #        (1) and 7
	       (1) and 8           & but # needed      (1) and 8
	       (1) and 9           7 and # next line   (1) and 9
	       & but # expected    8 and # next line   &
	       (1) and # next line 9 and # next line

	  1 4/6 7/9&FOLLOWED BY A LINE BEGINNING WITH A COMMA
	       1 and 4             1 and 4
	       (1) and 5           (1) and 5           (same as above)
	       (1) and 6           (1) and 6
	       (1) and 7           unexpected #
	       (1) and 8           & but # needed
	       (1) and 9           7 and missing #
	       & but # expected    8 and missing #
	       values after comma  9 and missing #
	                           values after comma
	  FASP, FORTRAN Alphameric Subroutine Package         Page 280
	  DAPAIR, Returns an Index and an Associated Value


	  1/3 4
	       1 and 4             1 and 4             1 and 4
	       empty but # needed  empty but # needed  2 and missing #
	       2 and # next line   2 and # next line   3 and missing #
	       3 and # next line   3 and # next line   empty

	  1/3 4!FOLLOWED BY A LINE BEGINNING WITH A COMMA
	       1 and 4             1 and 4
	       empty but # needed  empty but # needed  (same as above)
	       2 and missing #     2 and missing #
	       3 and missing #     3 and missing #
	       values after comma  values after comma

	  1/3 4&
	       1 and 4             1 and 4             1 and 4
	       & but # needed      & but # needed      2 and missing #
	       2 and # next line   2 and # next line   3 and missing #
	       3 and # next line   3 and # next line   &

	  1/3 4&FOLLOWED BY A LINE BEGINNING WITH A COMMA
	       1 and 4             1 and 4
	       & but # needed      & but # needed      (same as above)
	       2 and missing #     2 and missing #
	       3 and missing #     3 and missing #
	       values after comma  values after comma

	  1/3 4/6  !  or   1/3 4 5 6   or   1/3 4/5 6   or   1/3 4 5/6
	       1 and 4             1 and 4             1 and 4
	       2 and 5             2 and 5             2 and 5
	       3 and 6             3 and 6             3 and 6
	       empty               empty               empty

	  1/3 4 7/9 10 13
	       1 and 4             1 and 4             1 and 4
	       2 and 7             2 and 7             2 and 7
	       3 and 8             3 and 8             3 and 8
	       (3) and 9           (3) and 9           (3) and 9
	       (3) and 10          unexpected #        (3) and 10
	       (3) and 13          10 and 13           (3) and 13
	       empty               empty               empty

	  Each of the examples shown  above  which  does  not  include
	  commas  would be interpreted the same for KONECT values 2, 3
	  and 4 as for -1, 0 and 1  respectively.   The  rest  of  the
	  examples  would  also  be  interpreted  the  same for KONECT
	  values of 2, 3 and 4 as for -1, 0 and 1 respectively if  the
	  commas are replaced by semicolons.  The examples shown below
	  illustrate the results  obtained  using  the  higher  KONECT
	  values when commas appear to the right of the index.  Commas
	  appearing to the left of  the  index  are  ignored  for  all
	  KONECT values.

	  FASP, FORTRAN Alphameric Subroutine Package         Page 281
	  DAPAIR, Returns an Index and an Associated Value


	     KONECT=2            KONECT=3            KONECT=4

	  1/3 4 5 6!  OR  1/3,4,5,6
	     1 and 4             1 and 4             1 and 4
	     2 and 5             2 and 5             2 and 5
	     3 and 6             3 and 6             3 and 6
	     empty               empty               empty

	  1/3,,5 6!  OR  1/3,,5,6
	     1 and missing #     1 and missing #     1 and missing #
	     2 and 5             2 and 5             2 and 5
	     3 and 6             3 and 6             3 and 6
	     empty               empty               empty

	  1/3 4,,6!  OR  1/3,4,,6
	     1 and 4             1 and 4             1 and 4
	     2 and missing #     2 and missing #     2 and missing #
	     3 and 6             3 and 6             3 and 6
	     empty               empty               empty

	  1/3 4;!  OR  1/3,4;  OR 1/3 4,;  OR  1/3,4,;  OR  1/3 4,,;
	     1 and 4             1 and 4             1 and 4
	     2 and missing #     2 and missing #     2 and missing #
	     3 and missing #     3 and missing #     3 and missing #
	     ;                   ;                   ;
	     empty               empty               empty

	  1;1,4;1,4,5;,,1,4,,;,,1,4,,6,,8!WITH NUMBER ON NEXT LINE
	     1 and missing #     1 and missing #     1 and missing #
	     ;                   ;                   ;
	     1 and 4             1 and 4             1 and 4
	     ;                   ;                   ;
	     1 and 4             1 and 4             1 and 4
	     (1) and 5           unexpected #        (1) and 5
	     ;                   5 and missing #     ;
	     1 and 4             ;                   1 and 4
	     (1) and missing #   1 and 4             (1) and missing #
	     (1) and missing #   ;                   (1) and missing #
	     ;                   1 and 4             ;
	     1 and 4             unexpected #        1 and 4
	     (1) and missing #   6 and missing #     (1) and missing #
	     (1) and 6           unexpected #        (1) and 6
	     (1) and missing #   empty but # needed  (1) and missing #
	     (1) and 8           8 and # next line   (1) and 8
	     empty                                   empty

	  1/3 4!FOLLOWED BY LINE WITH OPTIONAL COMMA AND 2 NUMBERS
	     1 and 4             1 and 4             1 and 4
	     empty but # needed  empty but # needed  2 and missing #
	     2 and # next line   2 and # next line   3 and missing #
	     3 and # next line   3 and # next line   empty

	  FASP, FORTRAN Alphameric Subroutine Package         Page 282
	  DAPAIR, Returns an Index and an Associated Value


	  1/3 4,!FOLLOWED BY LINE BEGINNING WITH 2 NUMBERS
	     (same as above)     (same as above)     (same as above)

	  1/3 4,!FOLLOWED BY LINE BEGINNING WITH COMMA THEN NUMBER
	     1 and 4             1 and 4             1 and 4
	     empty but # needed  empty but # needed  2 and missing #
	     2 and missing #     2 and missing #     3 and missing #
	     3 and # next line   3 and # next line    empty


	                An Example of the Use of DAPAIR
	                -- ------- -- --- --- -- ------

	  The program  listed  on  the  following  pages  reports  the
	  results returned during the processing of a line of text for
	  3 values of KONECT.  Processing  of  the  line  of  text  is
	  discontinued  for  the  particular  value of KONECT when the
	  routine returns either  an  ampersand  or  an  end  of  line
	  indication.   If  an end of line is found when an associated
	  value is needed, then an ampersand is simulated.   The  user
	  is asked to supply a new line of text when processing of the
	  previous line of text has been completed for all 3 values of
	  KONECT.   An asterisk is used to prompt the user to type the
	  line of text if an empty indication has  been  returned  for
	  all  3 values of KONECT.  An ampersand is used to prompt the
	  user  if  the  routine  has  indicated  the   need   for   a
	  continuation  line,  in which case processing continues only
	  for the values of KONECT which requested  the  continuation.
	  The  table  of  returned  values on the preceding pages is a
	  slightly edited dialog between the user and this program.

	        DIMENSION IBUFFR(72),JBUFFR(72),IFDONE(3)
	  C     ARRAYS USED TO GENERATE TEXT DESCRIPTIONS
	        DIMENSION  LGND1 ( 5),LGND4 (14),LGND5 (16),
	       1LGND6 (18),LGND7 ( 5),LGND8 ( 9),LGND10(12),
	       2LGND11( 7),LGND12( 5),LGND13(6)
	        DATA LGND1 /1HE,1HM,1HP,1HT,1HY/
	        DATA LGND4 /1H&,1H ,1HB,1HU,1HT,1H ,1H#,1H ,1HN,1HE,
	       11HE,1HD,1HE,1HD/
	        DATA LGND5 /1H&,1H ,1HB,1HU,1HT,1H ,1H#,1H ,1HE,1HX,
	       11HP,1HE,1HC,1HT,1HE,1HD/
	        DATA LGND6 /1HE,1HM,1HP,1HT,1HY,1H ,1HB,1HU,1HT,1H ,
	       11H#,1H ,1HN,1HE,1HE,1HD,1HE,1HD/
	        DATA LGND7 /1H ,1HA,1HN,1HD,1H /
	        DATA LGND8 /1HM,1HI,1HS,1HS,1HI,1HN,1HG,1H ,1H#/
	        DATA LGND10/1HU,1HN,1HE,1HX,1HP,1HE,1HC,1HT,1HE,1HD,
	       11H ,1H#/
	        DATA LGND11/1HU,1HN,1HK,1HN,1HO,1HW,1HN/
	        DATA LGND12/1HE,1HR,1HR,1HO,1HR/
	        DATA LGND13/1HN,1HU,1HL,1HL,1H ,1H#/
	  C     ARRAYS USED TO KEEP 3 COLUMNS SEPARATED
	        DIMENSION LOWBFR(3),KIND  (3),NEWBGN(3),
	       1NEWEND(3),BGNNEW(3),ENDNEW(3),IWHERE(3),
	       2INCBGN(3),LMTBGN(3),BGNINC(3),BGNLMT(3),
	  FASP, FORTRAN Alphameric Subroutine Package         Page 283
	  DAPAIR, Returns an Index and an Associated Value


	       3INCEND(3),LMTEND(3),ENDINC(3),ENDLMT(3)
	        DATA ITTY,JTTY,SLACK,MAXBFR/5,5,0.01,72/
	        DATA ILEFT,IRIGHT,IAND,IEND,IBLANK/
	       11H(,1H),1H&,1H;,1H /
	  C
	        WRITE(JTTY,1)
	      1 FORMAT(22H TEST DAIPAR (Y OR N) ,$)
	        READ(ITTY,2)IANSWR
	      2 FORMAT(1A1)
	        IF(IANSWR.NE.1HY)WRITE(JTTY,3)
	      3 FORMAT(22H DAPAIR WILL BE CALLED)
	        WRITE(JTTY,4)
	      4 FORMAT(41H COMMAS BETWEEN INDEX AND VALUE (Y OR N) ,$)
	        READ(ITTY,2)JANSWR
	        IBEGIN=-2
	        IF(JANSWR.EQ.1HY)IBEGIN=1
	        IF(JANSWR.NE.1HY)WRITE(JTTY,5)
	      5 FORMAT(28H COMMAS WILL TERMINATE PAIRS)
	        WRITE(JTTY,6)
	      6 FORMAT(15H KNDBGN,KNDEND ,$)
	        READ(ITTY,7)KNDBGN,KNDEND
	      7 FORMAT(3I)
	  C
	  C     REQUEST NEXT LINE OF TEXT TO BE EVALUATED
	      8 DO 9 KNCT=1,3
	        KIND(KNCT)=0
	      9 IFDONE(KNCT)=0
	        WRITE(JTTY,10)
	     10 FORMAT(2H *,$)
	        GO TO 13
	     11 WRITE(JTTY,12)
	     12 FORMAT(2H &,$)
	     13 DO 14 KNCT=1,3
	        LOWBFR(KNCT)=1
	     14 IF(IFDONE(KNCT).GT.0)IFDONE(KNCT)=0
	        READ(ITTY,15)IBUFFR
	     15 FORMAT(72A1)
	  C
	  C     PROCESS CONTENTS OF BUFFER FOR ALL 3 VALUES OF KONECT
	     16 INDEX=0
	        LIMIT=0
	        DO 47 KNCT=1,3
	        KONECT=KNCT+IBEGIN
	        LIMIT=LIMIT+20
	        IF(IFDONE(KNCT).NE.0)GO TO 46
	        IF(IANSWR.NE.1HY)
	       1CALL DAPAIR  (SLACK ,KNDBGN,KNDEND,KONECT,IBUFFR,
	       2MAXBFR      ,LOWBFR(KNCT),KIND  (KNCT),NEWBGN(KNCT),
	       3NEWEND(KNCT),BGNNEW(KNCT),ENDNEW(KNCT),IWHERE(KNCT),
	       4INCBGN(KNCT),LMTBGN(KNCT),BGNINC(KNCT),BGNLMT(KNCT),
	       5INCEND(KNCT),LMTEND(KNCT),ENDINC(KNCT),ENDLMT(KNCT))
	        IF(IANSWR.EQ.1HY)
	       1CALL DAIPAR  (       KNDBGN,KNDEND,KONECT,IBUFFR,
	       2MAXBFR      ,LOWBFR(KNCT),KIND  (KNCT),NEWBGN(KNCT),
	  FASP, FORTRAN Alphameric Subroutine Package         Page 284
	  DAPAIR, Returns an Index and an Associated Value


	       3NEWEND(KNCT),BGNNEW(KNCT),ENDNEW(KNCT))
	        GO TO(18,20,21,22,24,26,29,29,28,17,39,41,29,28),
	       1KIND(KNCT)
	     17 IF(KONECT.EQ.2)GO TO 28
	        IF(KONECT.EQ.4)GO TO 28
	        GO TO 37
	  C
	  C     BUFFER IS EMPTY
	     18 DO 19 I=1,5
	        INDEX=INDEX+1
	     19 JBUFFR(INDEX)=LGND1(I)
	        GO TO 43
	  C
	  C     SEMICOLON
	     20 INDEX=INDEX+1
	        JBUFFR(INDEX)=IEND
	        GO TO 45
	  C
	  C     AMPERSAND INSTEAD OF LEADING NUMBER
	     21 INDEX=INDEX+1
	        JBUFFR(INDEX)=IAND
	        GO TO 44
	  C
	  C     AMPERSAND WHEN ASSOCIATED NUMBER NEEDED
	     22 DO 23 I=1,14
	        INDEX=INDEX+1
	     23 JBUFFR(INDEX)=LGND4(I)
	        GO TO 44
	  C
	  C     AMPERSAND WHEN ASSOCIATED NUMBER EXPECTED
	     24 DO 25 I=1,16
	        INDEX=INDEX+1
	     25 JBUFFR(INDEX)=LGND5(I)
	        GO TO 44
	  C
	  C     END OF LINE WHEN ASSOCIATED NUMBER NEEDED
	     26 DO 27 I=1,18
	        INDEX=INDEX+1
	     27 JBUFFR(INDEX)=LGND6(I)
	        KIND(KNCT)=4
	        GO TO 44
	  C
	  C     REPRESENT LEADING NUMBER
	     28 INDEX=INDEX+1
	        JBUFFR(INDEX)=ILEFT
	     29 CALL DASHOW(KNDBGN,0,4,4,4,
	       13,NEWBGN(KNCT),BGNNEW(KNCT),MAXBFR,INDEX,JBUFFR,IERR)
	        IF(KIND(KNCT).EQ.9)GO TO 30
	        IF(KIND(KNCT).EQ.10)GO TO 30
	        IF(KIND(KNCT).NE.15)GO TO 31
	     30 INDEX=INDEX+1
	        JBUFFR(INDEX)=IRIGHT
	  C
	  C     INSERT ' AND ' BETWEEN LEADING AND TRAILING NUMBERS
	  FASP, FORTRAN Alphameric Subroutine Package         Page 285
	  DAPAIR, Returns an Index and an Associated Value


	     31 DO 32 I=1,5
	        INDEX=INDEX+1
	     32 JBUFFR(INDEX)=LGND7(I)
	        IF(KIND(KNCT).EQ.8)GO TO 33
	        IF(KIND(KNCT).EQ.10)GO TO 33
	        IF(KIND(KNCT).GE.13)GO TO 35
	  C
	  C     REPRESENT TRAILING NUMBER
	        CALL DASHOW(KNDEND,0,4,4,4,
	       13,NEWEND(KNCT),ENDNEW(KNCT),MAXBFR,INDEX,JBUFFR,IERR)
	        GO TO 45
	  C
	  C     REPRESENT MISSING NUMBER
	     33 DO 34 I=1,9
	        INDEX=INDEX+1
	     34 JBUFFR(INDEX)=LGND8(I)
	        GO TO 45
	  C
	  C     REPRESENT NULL NUMBER
	     35 DO 36 I=1,6
	        INDEX=INDEX+1
	     36 JBUFFR(INDEX)=LGND13(I)
	        GO TO 45
	  C
	  C     NUMBER WHEN COMMA EXPECTED
	     37 DO 38 I=1,12
	        INDEX=INDEX+1
	     38 JBUFFR(INDEX)=LGND10(I)
	        GO TO 45
	  C
	  C     UNKNOWN CHARACTER
	     39 DO 40 I=1,7
	        INDEX=INDEX+1
	     40 JBUFFR(INDEX)=LGND11(I)
	        KIND(KNCT)=-1
	        GO TO 45
	  C
	  C     RANGE NOTATION ERROR
	     41 DO 42 I=1,5
	        INDEX=INDEX+1
	     42 JBUFFR(INDEX)=LGND12(I)
	        KIND(KNCT)=-1
	        GO TO 45
	  C
	  C     MARK THAT PROCESSING DONE FOR THIS VALUE OF KONECT
	     43 IFDONE(KNCT)=-1
	        GO TO 45
	     44 IFDONE(KNCT)=1
	  C
	  C     FILL REST OF COLUMN WITH SPACES
	     45 MAXPRT=INDEX
	     46 IF(INDEX.GE.LIMIT)GO TO 47
	        INDEX=INDEX+1
	        JBUFFR(INDEX)=IBLANK
	  FASP, FORTRAN Alphameric Subroutine Package         Page 286
	  DAPAIR, Returns an Index and an Associated Value


	        GO TO 46
	     47 CONTINUE
	  C
	  C     REPORT RESULTS FOR ALL 3 VALUES OF KONECT
	        WRITE(JTTY,48)(JBUFFR(I),I=1,MAXPRT)
	     48 FORMAT(2X,100A1)
	  C
	  C     DETERMINE IF PROCESSING DONE FOR ALL VALUES OF KONECT
	        DO 49 KNCT=1,3
	        IF(IFDONE(KNCT).EQ.0)GO TO 16
	     49 CONTINUE
	  C
	  C     DETERMINE IF SERIES IS TO CONTINUE ON FOLLOWING LINE
	        DO 50 KNCT=1,3
	        IF(IFDONE(KNCT).GT.0)GO TO 11
	     50 CONTINUE
	        GO TO 8
	        END


	  Typical Dialog Between DAPAIR Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  TEST DAIPAR (Y OR N) N
	  DAPAIR WILL BE CALLED
	  COMMAS BETWEEN INDEX AND VALUE (Y OR N) N
	  COMMAS WILL TERMINATE PAIRS
	  KNDBGN,KNDEND 0 0
	  *1/3 4;5/7 8!END OF LINE WHEN VALUE NEEDED
	   1 AND 4             1 AND 4             1 AND 4
	   2 AND MISSING #     2 AND MISSING #     2 AND MISSING #
	   3 AND MISSING #     3 AND MISSING #     3 AND MISSING #
	   ;                   ;                   ;
	   5 AND 8             5 AND 8             5 AND 8
	   EMPTY BUT # NEEDED  EMPTY BUT # NEEDED  6 AND MISSING #
	                                           7 AND MISSING #
	                                           EMPTY
	  &9/11 12 13
	   6 AND 9             6 AND 9
	   7 AND 10            7 AND 10
	   (7) AND 11          (7) AND 11
	   (7) AND 12          UNEXPECTED #
	   (7) AND 13          12 AND 13
	   EMPTY               EMPTY
	  *1/3 4!TEST OF FOLLOWING COMMA
	   1 AND 4             1 AND 4             1 AND 4
	   EMPTY BUT # NEEDED  EMPTY BUT # NEEDED  2 AND MISSING #
	                                           3 AND MISSING #
	                                           EMPTY
	  &,5 6
	   2 AND MISSING #     2 AND MISSING #
	   3 AND MISSING #     3 AND MISSING #
	   5 AND 6             5 AND 6
	   EMPTY               EMPTY
	  FASP, FORTRAN Alphameric Subroutine Package         Page 287
	  DAPATH, Routine to Represent Integer Sequence of Form 1.2.3


	  DDDDD          AAA   PPPPPP        AAA   TTTTTTTT   HH    HH
	  DD   DD       AAAA   PP    PP     AAAA      TT      HH    HH
	  DD    DD     AA AA   PP    PP    AA AA      TT      HH    HH
	  DD    DD    AA  AA   PPPPPP     AA  AA      TT      HHHHHHHH
	  DD    DD   AAAAAAA   PP        AAAAAAA      TT      HH    HH
	  DD   DD   AA    AA   PP       AA    AA      TT      HH    HH
	  DDDDD    AA     AA   PP      AA     AA      TT      HH    HH



	  DAPATH, Routine to Represent Integer Sequence of Form 1.2.3
	  ------  ------- -- --------- ------- -------- -- ---- -----

	  DAPATH represents a sequence of unsigned  integers  so  that
	  they   can  be  written  with  a  FORTRAN  format  statement
	  containing a multiple A1 alphameric  specification.   Values
	  within  the sequence which are equal to or greater than zero
	  are represented  directly  and  are  separated  by  periods.
	  Values  less  than  zero  are  not represented, but the same
	  separating periods are inserted into the output text  buffer
	  as  if  the values were represented.  No printing characters
	  are inserted into the output text  buffer  if  the  sequence
	  consists  of  a  single  negative  value.   For example, the
	  sequence

	       100, 200, -1, 400

	  would insert the following into the output text buffer

	       1H1,1H0,1H0,1H.,1H2,1H0,1H0,1H.,1H.,1H4,1H0,1H0

	  which when written with a 12A1 format (where the  number  to
	  the left of the A1 can be greater than 12) would produce

	       100.200..400


	                    The DAPATH Argument List
	                    --- ------ -------- ----

	  The argument list of routine DAPATH is

	        SUBROUTINE DAPATH(LOWVLU,KNTVLU,IVALUE,JSTIFY,IFILL ,
	       1    IWIDTH,LFTCOL,MAXBFR,IBUFFR,KOUNT ,IERR  )

	  with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR),IVALUE(KNTVLU)

	  The following arguments are used for  input  only,  and  are
	  returned unchanged.

	  LOWVLU = subscript  of  the  IVALUE  array  location   which
	           contains   the   first   value   which   is  to  be
	  FASP, FORTRAN Alphameric Subroutine Package         Page 288
	  DAPATH, Routine to Represent Integer Sequence of Form 1.2.3


	           represented.  If LOWVLU is greater than KNTVLU,  or
	           else  if LOWVLU equals KNTVLU and IVALUE(LOWVLU) is
	           less than zero, then no printing characters will be
	           inserted  into the IBUFFR array.  If IVALUE(LOWVLU)
	           is less  than  zero  and  KNTVLU  is  greater  than
	           LOWVLU,  then the first printing character returned
	           in the IBUFFR array will be a period.

	  KNTVLU = subscript  of  the  IVALUE  array  location   which
	           contains   the   final   value   which   is  to  be
	           represented.  If IVALUE(KNTVLU) is less  than  zero
	           and  KNTVLU  is greater than LOWVLU, then the final
	           printing character returned  in  the  IBUFFR  array
	           will be a period.

	  IVALUE = array  containing   in   locations   IVALUE(LOWVLU)
	           through  and  including  IVALUE(KNTVLU) the integer
	           sequence which is to be represented.  Values  equal
	           to  or  greater  than zero are represented directly
	           and are separated by  periods.   Values  less  than
	           zero  are  not represented, but the same separating
	           periods appear as if the values were represented.

	  JSTIFY = -1, left justify the representation of the  integer
	           sequence     in    the    field    consisting    of
	           IBUFFR(LFTCOL+1) through IBUFFR(LFTCOL+IWIDTH)  (or
	           through  IBUFFR(MAXBFR)  if  MAXBFR  is  less  than
	           LFTCOL+IWIDTH).
	         = 0,  center  the  representation  of   the   integer
	           sequence     in    the    field    consisting    of
	           IBUFFR(LFTCOL+1) through IBUFFR(LFTCOL+IWIDTH)  (or
	           through  IBUFFR(MAXBFR)  if  MAXBFR  is  less  than
	           LFTCOL+IWIDTH).  IBUFFR array locations  which  are
	           to  the  left  of the representation of the integer
	           sequence are filled with spaces.
	         = 1, right justify the representation of the  integer
	           sequence     in    the    field    consisting    of
	           IBUFFR(LFTCOL+1) through IBUFFR(LFTCOL+IWIDTH)  (or
	           through  IBUFFR(MAXBFR)  if  MAXBFR  is  less  than
	           LFTCOL+IWIDTH).  IBUFFR array locations  which  are
	           to  the  left  of the representation of the integer
	           sequence are filled with spaces.

	  IFILL  = 0, do not fill the portion of the field which is to
	           the  right  of  the  representation  of the integer
	           sequence with spaces.  The value of  IFILL  has  no
	           effect   on   the   printing   characters   in  the
	           representation of the integer sequence.  KOUNT will
	           be  returned  pointing  to  the  rightmost printing
	           character in  the  representation  of  the  integer
	           sequence.
	         = 1, fill with spaces the portion of the field  which
	           is  to  the  right  of  the  representation  of the
	           integer    sequence    and    extending     through
	  FASP, FORTRAN Alphameric Subroutine Package         Page 289
	  DAPATH, Routine to Represent Integer Sequence of Form 1.2.3


	           IBUFFR(LFTCOL+IWIDTH) (or through IBUFFR(MAXBFR) if
	           MAXBFR is less than LFTCOL+IWIDTH).  KOUNT will  be
	           returned  set  equal  to  LFTCOL+IWIDTH  or MAXBFR,
	           whichever is the smaller.

	  IWIDTH = width, stated as the number of columns or of IBUFFR
	           array  locations, of the field in which the integer
	           sequence  is  to  be  represented.   The  rightmost
	           IBUFFR   array   location  in  the  field  has  the
	           subscript LFTCOL+IWIDTH or else  MAXBFR,  whichever
	           is the smaller.

	  LFTCOL = subscript of the IBUFFR array location which is  to
	           the  immediate  left  of  the leftmost IBUFFR array
	           location into which either a space or  a  character
	           of  the  representation of the integer sequence can
	           be placed.

	  MAXBFR = subscript of the rightmost  IBUFFR  array  location
	           into  which  could be placed a space or a character
	           of the representation of the  integer  sequence  if
	           IWIDTH is large enough.

	  The  following  argument  is  returned   by   this   routine
	  containing the representation of the integer sequence.

	  IBUFFR = array in which the representation  of  the  integer
	           sequence   is   returned,  1  character  per  array
	           location as though read by  a  multiple  of  an  A1
	           format.

	  The following arguments are used only for output  from  this
	  routine.  Their input values are ignored.

	  KOUNT  = returned containing the subscript of the  rightmost
	           IBUFFR  array  location  into which a character has
	           been placed by this routine.

	  IERR   = -1 returned if the  representation  of  the  entire
	           integer  sequence  would  not  fit  into  the field
	           indicated by LFTCOL and by either IWIDTH or MAXBFR,
	           whichever  indicates  the  smaller  field.   If the
	           representation would not fit and MAXBFR is  greater
	           than    or    equal    to    LFTCOL+IWIDTH,    then
	           IBUFFR(LFTCOL+1)     through     and      including
	           IBUFFR(LFTCOL+IWIDTH)   are   returned   containing
	           asterisks, and  KOUNT  is  returned  set  equal  to
	           LFTCOL+IWIDTH.  If the representation would not fit
	           and MAXBFR is less  than  LFTCOL+IWIDTH,  then  the
	           asterisks  extend  through IBUFFR(MAXBFR) and KOUNT
	           is returned set equal to MAXBFR.
	         = 0 returned if the entire integer sequence could  be
	           represented in the field.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 290
	  DAPATH, Routine to Represent Integer Sequence of Form 1.2.3


	  DAPATH Demonstration Program, and Dialog Between It and User
	  ------ ------------- -------  --- ------ ------- -- --- ----

	        DIMENSION IBUFFR(60),IVALUE(20)
	        DATA ISLASH/1H//
	        DATA ITTY,JTTY,IWIDTH/5,5,18/
	  C
	  C     GET NEXT INTEGER SEQUENCE TO BE REPRESENTED
	      1 WRITE(ITTY,2)
	      2 FORMAT(2H *,$)
	        READ(JTTY,3)IBUFFR
	      3 FORMAT(60A1)
	        LOWBFR=1
	        KNTVLU=0
	        CALL DATEAM(0,0,1,20,60,
	       1IBUFFR,LOWBFR,KNTVLU,KIND,IVALUE,IVALUE)
	  C
	  C     REPRESENT THE INTEGER SEQUENCE
	        DO 4 I=1,60
	      4 IBUFFR(I)=ISLASH
	        LFTCOL=1
	        DO 5 KOLUMN=1,3
	        JSTIFY=KOLUMN-2
	        CALL DAPATH(1,KNTVLU,IVALUE,JSTIFY,1,
	       1IWIDTH,LFTCOL,60,IBUFFR,KOUNT,IERR)
	        LFTCOL=KOUNT+1
	      5 CONTINUE
	        WRITE(ITTY,6)(IBUFFR(I),I=1,LFTCOL)
	      6 FORMAT(1X,60A1)
	        GO TO 1
	        END

	  The program prompts the user with an asterisk, then reads  a
	  series  of  up  to 20 numbers.  The left justified, centered
	  and right justified representations of the series  are  then
	  reported to the user.

	  *0
	  /0                 /        0         /                 0/
	  *-1
	  /                  /                  /                  /
	  *0 2
	  /0.2               /       0.2        /               0.2/
	  *-1 -1
	  /.                 /        .         /                 ./
	  *0 2 4
	  /0.2.4             /      0.2.4       /             0.2.4/
	  *-1 2 -1
	  /.2.               /       .2.        /               .2./
	  *0 2 4 8 16 32 64
	  /0.2.4.8.16.32.64  / 0.2.4.8.16.32.64 /  0.2.4.8.16.32.64/
	  *-1 2 4 -1 16 32 -1
	  /.2.4..16.32.      /   .2.4..16.32.   /      .2.4..16.32./
	  FASP, FORTRAN Alphameric Subroutine Package         Page 291
	  DAPICK, Routine to Interpret Array Name and Subscript Ranges


	  DDDDD           AAA   PPPPPP     IIIIII     CCCCC   KK   KK
	  DD   DD        AAAA   PP    PP     II     CC        KK  KK
	  DD    DD      AA AA   PP    PP     II    CC         KK KK
	  DD    DD     AA  AA   PPPPPP       II    CC         KKKKK
	  DD    DD    AAAAAAA   PP           II    CC         KKK KK
	  DD   DD    AA    AA   PP           II     CC        KK   KK
	  DDDDD     AA     AA   PP         IIIIII     CCCCC   KK    KK



	  DAPICK, Routine to Interpret Array Name and Subscript Ranges
	  ------  ------- -- --------- ----- ---- --- --------- ------

	  DAPICK is used along with several other routines in the FASP
	  package for the purpose of specifying by name, examining and
	  modifying  the  values  of   multiply   subscripted   arrays
	  equivalenced   with   or  otherwise  loaded  into  a  singly
	  subscripted buffer.  The interaction between these  routines
	  is  described at the start of the DALOAD documentation.  The
	  sample program  at  the  end  of  the  DALOAD  documentation
	  illustrates the use of most of these routines.

	  DAPICK identifies the array name and subscript ranges  typed
	  by  the user and read by the calling program with a multiple
	  of an A1 format.  Spaces and/or tab  characters  can  appear
	  anywhere in the text interpreted by DAPICK, but are ignored.
	  The printing characters in  the  buffer  array  are  matched
	  against  the  words  in  the  dictionary  constructed by the
	  DALOAD routine.  The array name typed by the user must match
	  a  name  in  the  dictionary exactly.  Abbreviations are not
	  recognized.  The match must include all printing  characters
	  typed by the user through the end of the buffer or up to but
	  not including a left  parenthesis,  equal  sign,  semicolon,
	  exclamation   point   or  ampersand.   Any  other  unmatched
	  printing characters will cause the comparison to fail.

	  Numbers indicating subscript ranges follow  the  array  name
	  and  are  enclosed  between left and right parentheses.  The
	  subscript range specifications are separated by  commas  and
	  consist  of the starting value, a slash character or a colon
	  (the 2 characters are equivalent),  and  the  ending  value.
	  The starting value of a range can be less than, equal to, or
	  greater than the ending value.  The numbers  indicating  the
	  subscript  ranges  can  be  signed,  but  cannot  contain an
	  exponent, neither the E of scientific notation nor K  nor  M
	  being accepted.  If a slash or a colon is present but either
	  number is missing, then the missing number is assumed to  be
	  the  corresponding  limit  for the subscript as specified by
	  the dictionary.  If a single number appears without a  slash
	  and  without  a  colon, then the range is assumed to consist
	  only of the indicated number.  If nothing or just a slash or
	  just  a colon appears between the parentheses and/or commas,
	  then the range is assumed  to  extend  across  all  possible
	  values of the subscript as specified by the dictionary.  For
	  FASP, FORTRAN Alphameric Subroutine Package         Page 292
	  DAPICK, Routine to Interpret Array Name and Subscript Ranges


	  example, if the input buffer contains the text

	       R2A(2/,,3,12/14)

	  and if the dictionary  indicates  that  R2A  is  dimensioned
	  (3,4,3,18), then DAPICK would specify that

	    a. the first subscript should be varied from 2 through the
	       upper limit of 3

	    b. the second subscript should be varied  from  the  lower
	       limit of 1 through the upper limit of 4

	    c. the third subscript should have the single value 3

	    d. the fourth subscript should be varied from  12  through
	       14.

	  After being evaluated, the  subscript  ranges  are  compared
	  with the limits stored in the dictionary.  If the dictionary
	  indicates that the name is not subscripted or  that  it  can
	  take  only  the  single subscript 1, then in either of these
	  cases the  complete  lack  of  any  parenthetical  subscript
	  notation,  or else the single subscript 1 typed by the user,
	  will be accepted.

	  If an equal sign is found to the right of the array name  or
	  to  the  right of the array name and of its subscripts, then
	  the location of the first character  to  the  right  of  the
	  equal sign is also identified to the calling program.

	  Semicolons preceding the array name are ignored, except that
	  at  least  one  semicolon  can  be  required  to  precede an
	  additional array name in a line of text in which a  previous
	  call  to this routine has already found and processed one or
	  more other array names.

	  If an exclamation point or an ampersand is found anywhere in
	  the  text  typed  by  the  user,  then  the  exclamation  or
	  ampersand and all characters to its right are taken to be  a
	  comment and are otherwise ignored.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 293
	  DAPICK, Routine to Interpret Array Name and Subscript Ranges


	                    The DAPICK Argument List
	                    --- ------ -------- ----

	  The argument list of routine DAPICK IS

	        SUBROUTINE DAPICK(MAXBFR,IBUFFR,LTRLOW,LTRUSD,LTRSTR,
	       1    NUMLOW,NUMUSD,NUMSTR,MAXSUB,LOWBFR,KIND  ,LRGLTR,
	       2    LRGNUM,LRGKNT,INITAL,KOUNT ,LTRINI,NUMINI,KNTSUB,
	       3    INISUB,LMTSUB)

	  with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR),LTRSTR(LTRUSD),
	       1NUMSTR(NUMUSD),INISUB(MAXSUB),LMTSUB(MAXSUB)

	  The following are input arguments left unchanged.

	  MAXBFR = maximum subscript of the locations  in  the  IBUFFR
	           array containing characters read by the the calling
	           program and which are to  be  interpreted  by  this
	           routine.

	  IBUFFR = input buffer array containing characters  typed  by
	           the  user  and  read by a multiple of an A1 format,
	           which are  to  be  searched  for  array  names  and
	           subscript values.  IBUFFR then contains 1 character
	           per computer storage location.

	  LTRLOW = lowest subscript of the  locations  in  the  LTRSTR
	           array containing the characters of the names in the
	           dictionary as originally read  by  DALOAD  using  a
	           multiple  of an A1 format.  LTRSTR(LTRLOW) contains
	           either the first letter of the name  of  the  first
	           logical  group  of  names in the dictionary or else
	           (if the first group itself isn't named)  the  first
	           letter  of  the first name within the first logical
	           group in the dictionary.

	  LTRUSD = highest subscript of the locations  in  the  LTRSTR
	           array containing the characters of the names in the
	           dictionary as originally read  by  DALOAD  using  a
	           multiple  of an A1 format.  LTRSTR(LTRUSD) contains
	           the  last  character  of  the  last  name  in   the
	           dictionary.

	  LTRSTR = array containing the characters forming  the  names
	           in  the  dictionary, 1 character per array location
	           as originally read by DALOAD using a multiple of an
	           A1 format.

	  NUMLOW = lowest subscript of the  locations  in  the  NUMSTR
	           array    containing    the    numeric   information
	           corresponding to the names  stored  in  the  LTRSTR
	           array.   NUMSTR(NUMLOW)  must  contain the start of
	  FASP, FORTRAN Alphameric Subroutine Package         Page 294
	  DAPICK, Routine to Interpret Array Name and Subscript Ranges


	           the description of a logical group  of  names,  not
	           the start of the description of an individual name.

	  NUMUSD = highest subscript of the locations  in  the  NUMSTR
	           array    containing    the    numeric   information
	           corresponding to the names  stored  in  the  LTRSTR
	           array.

	  NUMSTR = array   containing    the    numeric    information
	           corresponding  to  the  names  stored in the LTRSTR
	           array.  The construction of  the  NUMSTR  array  is
	           described  in  detail  in the DALOAD documentation.
	           For each name in the dictionary, the  NUMSTR  array
	           contains

	             a. the number of characters in the name

	             b. an indication of the associated data type

	             c. the number of subscript ranges

	             d. pairs of starting and ending values  of  these
	                ranges.

	           If the number of  characters  is  instead  zero  or
	           negative,  then its absolute value is the number of
	           characters in the name of a logical group of names,
	           and  the  next location, rather than indicating the
	           data type, contains the number of locations  within
	           a  singly  subscripted buffer which would be needed
	           to store the values  of  the  multiply  subscripted
	           arrays  which  are  within  the  logical  group and
	           equivalenced with or otherwise loaded into  such  a
	           singly subscripted buffer.

	  MAXSUB = highest subscript of the locations  in  the  INISUB
	           and LMTSUB arrays which can be used by this routine
	           to store the subscript ranges typed  by  the  user.
	           The start of the first range is stored in INISUB(1)
	           and the end of the first range  in  LMTSUB(1).   If
	           the  array  names  stored  in  the  dictionary  are
	           actually the names of FORTRAN language arrays, then
	           the  FORTRAN  limit  of  7  subscripts would apply,
	           suggesting that MAXSUB should be 7  and  that  both
	           INISUB and LMTSUB should be dimensioned to at least
	           7.  If more than MAXSUB subscript ranges are  typed
	           by the user, then the excess ranges to the right of
	           those accepted are ignored (that is, KNTSUB is  not
	           incremented,  the  values  of  the  bounds  are not
	           stored in the INISUB  and  LMTSUB  arrays  and  the
	           appearance  of the excess ranges is not taken to be
	           an error), except for  such  interpretation  as  is
	           necessary  to  determine  the  location  within the
	           buffer of the closing parenthesis.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 295
	  DAPICK, Routine to Interpret Array Name and Subscript Ranges


	  The following arguments are  used  both  for  input  to  the
	  DAPICK routine, and for output to the calling program.

	  LOWBFR = input containing the subscript  within  the  IBUFFR
	           array  of  the first (leftmost) character which can
	           be scanned for an array name.  If the characters in
	           the  buffer  do not match a name in the dictionary,
	           then  LOWBFR  will  be  returned  pointing  to  the
	           leftmost   printing   character   which  is  not  a
	           semicolon nor an exclamation point nor an ampersand
	           and  which  is  not  to the right of an exclamation
	           point  and  which  is  not  to  the  right  of   an
	           ampersand,  or  else  will  be  returned containing
	           MAXBFR+1 if no such printing characters  are  found
	           in  the  buffer.   If  the  text in the buffer does
	           match a word in the dictionary, then LOWBFR will be
	           returned  pointing  to  the  first character to the
	           right of the name, or to the first character to the
	           right  of the subscript range if present, or to the
	           first character to the  right  of  the  equal  sign
	           either  following  the subscript range or following
	           the name directly.   If  a  match  is  found,  then
	           LOWBFR  is  returned containing the location of the
	           first character of the text  in  the  IBUFFR  array
	           which  should  be interpreted by the DAVARY routine
	           to obtain the numeric values, if any, typed by  the
	           user to the right of the equal sign.

	  KIND   = input  to  this  routine  describing  the  previous
	           processing,  if  any,  of the line of text typed by
	           the user and contained in the  input  buffer  array
	           IBUFFR.   KIND  is  returned to the calling program
	           describing the type of  information  found  in  the
	           buffer.

	         KIND  is  input  to  this  routine  with  its   value
	         specifying the following information.

	         = -1 input, none of the characters currently  in  the
	           IBUFFR  array have been processed by previous calls
	           to DAPICK or DAVARY.  An initial semicolon  is  not
	           required  since  the  current  call  to DAPICK will
	           evaluate the first character  typed  by  the  user.
	           KIND will be returned containing the value 3 if the
	           input buffer is empty or merely contains semicolons
	           and/or a comment indicated by a leading exclamation
	           point.
	         = 0 input, a semicolon was typed by the user when the
	           user  was  asked  to  define  the  new value of the
	           previously selected array.  DAVARY returned control
	           to DAPICK to continue processing of the contents of
	           the IBUFFR array after having first advanced LOWBFR
	           beyond  the  location  of  the  semicolon.   If the
	           remainder of the buffer is empty or contains merely
	  FASP, FORTRAN Alphameric Subroutine Package         Page 296
	  DAPICK, Routine to Interpret Array Name and Subscript Ranges


	           semicolons  and/or a comment indicated by a leading
	           exclamation point or by a leading  ampersand,  then
	           KIND will be returned with the value 4.
	         = 1  (or  greater)  input,  the  subscripts  of   the
	           previously  specified  simulated  array were varied
	           through the entire  range  selected  by  the  user.
	           DAROLL  (or  DALOOP) has then returned control back
	           to DAPICK to continue processing of  the  remaining
	           characters  in  the input buffer.  If the remainder
	           of  the  buffer  is  empty   or   contains   merely
	           semicolons  and/or a comment indicated by a leading
	           exclamation point or by a leading  ampersand,  then
	           KIND  will be returned with the value 4.  If an new
	           array specification appears in the buffer, it  must
	           follow  (appear  to  the  right  of)  at  least one
	           semicolon.  KIND is returned containing the value 8
	           if  the first printing character at or to the right
	           of LOWBFR is not a  semicolon  nor  an  exclamation
	           point nor an ampersand.

	         KIND is returned  by  this  routine  with  its  value
	         specifying the following information.

	         = 1 returned, the text typed by the  user  matched  a
	           name  in the dictionary, but no equal sign followed
	           the name or subscript ranges in the  IBUFFR  array.
	           LOWBFR  is returned pointing to the first character
	           to  the  right  of  the  right  parenthesis  or  if
	           subscripts   were   not   indicated  to  the  first
	           character (which would have to be a space, a tab, a
	           semicolon,  an  exclamation  point, an ampersand or
	           else be beyond the end of the buffer) to the  right
	           of the name.
	         = 2 returned, the text typed by the  user  matched  a
	           name  in  the dictionary, and an equal sign follows
	           the  name  or  the  subscript  ranges.   LOWBFR  is
	           returned  pointing  to  the  first character to the
	           right of the equal sign.
	         = 3 returned, the input buffer contained no  printing
	           characters   other   than   semicolons  and/or  the
	           characters of a  comment  indicated  by  a  leading
	           exclamation point, and KIND was input containing -1
	           indicating that this  routine  has  not  previously
	           been  called  to  process  any  of  the  characters
	           currently  in  the  buffer.   LOWBFR  is   returned
	           pointing  to  the  next character beyond the end of
	           the buffer.
	         = 4  returned,  same  as  when   KIND   is   returned
	           containing  3,  except  that KIND was input greater
	           than or equal to zero.   The  characters,  if  any,
	           evaluated   by  this  call  to  DAPICK  were  those
	           remaining unprocessed  after  the  previous  return
	           from  DAVARY,  and  were  not within an unprocessed
	           buffer just read by the calling program.   KIND  is
	  FASP, FORTRAN Alphameric Subroutine Package         Page 297
	  DAPICK, Routine to Interpret Array Name and Subscript Ranges


	           also returned containing 4, regardless of the input
	           value of KIND, if the input  buffer  contained  the
	           characters  of  a  comment  indicated  by a leading
	           ampersand, but  contained  no  printing  characters
	           other  than  possible semicolons to the left of the
	           ampersand.

	           Returned values of 3 and 4 for KIND can be  treated
	           by  the  calling  program  as  identical.  If these
	           values are  treated  as  different,  the  suggested
	           interpretation  is  that  KIND=3 indicates that the
	           user did not  type  anything  on  the  line,  while
	           KIND=4  indicates  that the contents of a non-empty
	           line have been processed  so  the  user  should  be
	           asked  to  type  a new line.  Comments indicated by
	           exclamation points and by  ampersands  are  handled
	           differently  by this routine only when they are the
	           leftmost printing characters  (except  perhaps  for
	           semicolons)  in  the entire line typed by the user.
	           In this case, a  comment  indicated  by  a  leading
	           ampersand   returns  KIND=4  since  by  typing  the
	           ampersand the user has indicated that he wishes  to
	           type another line.
	         = 5 returned, the text typed by the  user  matched  a
	           name  in  the  dictionary,  but  was followed by an
	           incorrect number of subscript ranges.
	         = 6 returned, the text typed by the  user  matched  a
	           name  in  the  dictionary  and  was followed by the
	           correct number of subscripts  ranges,  but  one  or
	           more  of  the ranges extended outside of the limits
	           indicated for these ranges by the dictionary.
	         = 7 returned, the  input  buffer  contained  printing
	           characters   (other   than  semicolons  and/or  the
	           characters of a  comment  indicated  by  a  leading
	           exclamation  point  or by a leading ampersand), but
	           no  match  with  a  name  in  the  dictionary   was
	           obtained.  LOWBFR is returned pointing to the first
	           (leftmost)  printing  character  which  is  not   a
	           semicolon.
	         = 8 returned, KIND was input greater than  zero,  but
	           the  first printing character in the buffer was not
	           a  semicolon  nor  an  exclamation  point  nor   an
	           ampersand.   The  initial  semicolon is required to
	           insure that the user really  meant  that  the  text
	           remaining  in the input buffer after the completion
	           of  the  processing  of  the  previously   selected
	           simulated array is to be acted upon by DAPICK.

	  The following arguments are used  only  for  output.   Their
	  input values are ignored.

	  LRGLTR = returned containing the  subscript  of  the  LTRSTR
	           array  location  which contains the first letter of
	           the name associated with the logical group of names
	  FASP, FORTRAN Alphameric Subroutine Package         Page 298
	  DAPICK, Routine to Interpret Array Name and Subscript Ranges


	           in  the  dictionary  which  includes the name which
	           matched that typed by the user.

	  LRGNUM = returned containing the  subscript  of  the  NUMSTR
	           array  location  which  contains  the  first of the
	           numeric information  associated  with  the  logical
	           group of names in the dictionary which includes the
	           name  which  matched  that  typed  by   the   user.
	           NUMSTR(LRGNUM)  contains  as its absolute value the
	           number of  characters  starting  at  LTRSTR(LRGLTR)
	           which  are  contained  in  the name, if any, of the
	           logical group of names.  NUMSTR(LRGNUM+1)  contains
	           the number of locations within a singly subscripted
	           buffer which would be needed to store the values of
	           the  multiply  subscripted  arrays which are within
	           the  logical  group  and   equivalenced   with   or
	           otherwise  loaded  into  such  a singly subscripted
	           buffer.

	  LRGKNT = sequence  number  within  the  dictionary  of   the
	           logical group of names containing the name matching
	           that typed by the user.  If the name typed  by  the
	           user is contained in the third logical group in the
	           dictionary,   then   LRGKNT   would   be   returned
	           containing the value 3.

	  INITAL = returned containing the location of  the  start  of
	           the  array  specified  by  the user relative to the
	           singly subscripted buffer containing the arrays  in
	           the  logical  group  and  with  which the specified
	           array  is  equivalenced.   If  the  logical  groups
	           represent  the  contents of individual records in a
	           file, and if arrays ABC(10), DEF(10), GHI(10)  etc.
	           are  contained  in  a particular record, and if the
	           user typed the array name GHI (regardless  of  what
	           subscripts   within  the  range  1  through  10  he
	           happened to type), then INITAL  would  be  returned
	           with the value 10+10+1 or 21.

	  KOUNT  = sequence number of the name selected  by  the  user
	           within  the logical group of names containing it in
	           the dictionary.  This number does not  include  the
	           name,  if any, of the logical group itself.  If the
	           user types the name of the third array described in
	           the  logical group, then KOUNT is returned with the
	           value 3.

	  LTRINI = returned containing the subscript of  the  location
	           within  the  LTRSTR  array which contains the first
	           letter of the name matching that typed by the user.

	  NUMINI = returned containing the subscript of  the  location
	           within the NUMSTR array which contains the start of
	           the  numeric  information   describing   the   name
	  FASP, FORTRAN Alphameric Subroutine Package         Page 299
	  DAPICK, Routine to Interpret Array Name and Subscript Ranges


	           matching  that  typed  by the user.  NUMSTR(NUMINI)
	           contains the number  of  characters  in  the  name,
	           NUMSTR(NUMINI+1)  the  indication of the associated
	           data type (-1 for  octal  integer,  0  for  decimal
	           integer, and +1 for real), and NUMSTR(NUMINI+2) the
	           number of subscript ranges allowed (and required).

	  KNTSUB = returned containing the number of subscripts ranges
	           found.

	  INISUB = array returned containing the  starting  values  of
	           the  subscript ranges typed by the user.  The start
	           of the first subscript range typed by the  user  is
	           returned   in   INISUB(1)   and  of  the  final  in
	           INISUB(KNTSUB).

	  LMTSUB = array returned containing the ending values of  the
	           subscript ranges typed by the user.  The end of the
	           first subscript range typed by the user is returned
	           in LMTSUB(1) and of the final in LMTSUB(KNTSUB).



	                An Example of the Use of DAPICK
	                -- ------- -- --- --- -- ------

	  The sample program listed on the  following  pages  reads  a
	  line  of  text  from  the user's terminal, then compares the
	  contents of the line with a dictionary which is  defined  by
	  DATA statements at the start of the program, but which could
	  have been constructed instead  by  having  DALOAD  read  the
	  COMMON  statements  listed  as comment cards at the start of
	  the program.  The program summarizes the  evaluation  before
	  asking for the next array name specification.

	  A sample dialog between the program and  user  is  presented
	  following the listing of the program.

	  To  demonstrate  that  neither  the  input  text   nor   the
	  dictionary  need to start at the beginning of the respective
	  arrays, all of these arrays contain nonsense values ahead of
	  the valid information.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 300
	  DAPICK, Routine to Interpret Array Name and Subscript Ranges


	  C     PROGRAM TO DEMONSTRATE DAPICK ROUTINE
	  C
	  C     FOLLOWING DATA STATEMENTS SIMULATE DICTIONARY WHICH
	  C     DALOAD WOULD CONSTRUCT IF IT READ FOLLOWING AS DATA
	  C
	  C     COMMON/FIRST/A(10,10),BC(10,10),DEF(10,10)
	  C     COMMON/SECOND/GHI(10),JKL,MNO(10),PQR(1)
	  C     COMMON/THIRD/STU(10,10),VW(10,10/1),X(10/1,10/1)
	  C
	        DIMENSION NUMSTR(72),LTRSTR(46),IBUFFR(60),JBUFFR(6),
	       1KBUFFR(6),INISUB(7),LMTSUB(7)
	  C
	        DATA NUMSTR/
	       1100,100,100,
	       2 -5,300,  0,
	       3  1,  1,  2,  1, 10,  1, 10,
	       4  2,  1,  2,  1, 10,  1, 10,
	       5  3,  1,  2,  1, 10,  1, 10,
	       6 -6, 22,  0,
	       7  3,  1,  1,  1, 10,
	       8  3,  0,  0,
	       9  3,  0,  1,  1, 10,
	       1  3,  1,  1,  1,  1,
	       2 -5,300,  0,
	       3  3,  1,  2,  1, 10,  1, 10,
	       4  2,  1,  2,  1, 10, 10,  1,
	       5  1,  1,  2, 10,  1, 10,  1/
	  C
	        DATA LTRSTR/
	       11H*,1H*,1H*,1H*,1H*,1H*,
	       21HF,1HI,1HR,1HS,1HT,
	       31HA,1HB,1HC,1HD,1HE,1HF,
	       41HS,1HE,1HC,1HO,1HN,1HD,
	       51HG,1HH,1HI,1HJ,1HK,1HL,1HM,1HN,1HO,1HP,1HQ,1HR,
	       61HT,1HH,1HI,1HR,1HD,
	       71HS,1HT,1HU,1HV,1HW,1HX/
	  C
	        DATA NUMLOW,NUMUSD,LTRLOW,LTRUSD,MAXBFR,MAXSUB,ITTY/
	       14,72,7,46,60,7,5/
	        DATA ISPACE/1H /
	  C
	  C     READ USER TYPED ARRAY SPECIFICATION
	      1 WRITE(ITTY,2)
	      2 FORMAT(' **********'/' ARRAY NAME:'$)
	        LOWBFR=11
	        KIND=-1
	        READ(ITTY,3)(IBUFFR(I),I=LOWBFR,MAXBFR)
	      3 FORMAT(60A1)
	  C
	  C     EVALUATE USER SUPPLIED TEXT
	      4 LAST=KIND
	        CALL  DAPICK  (MAXBFR,IBUFFR,LTRLOW,LTRUSD,LTRSTR,
	       1 NUMLOW,NUMUSD,NUMSTR,MAXSUB,LOWBFR,KIND  ,LRGLTR,
	       2 LRGNUM,LRGKNT,INITAL,KOUNT ,LTRINI,NUMINI,KNTSUB,
	  FASP, FORTRAN Alphameric Subroutine Package         Page 301
	  DAPICK, Routine to Interpret Array Name and Subscript Ranges


	       3 INISUB,LMTSUB)
	  C
	  C     DETERMINE UNPROCESSED TEXT IF ANY
	        LIMIT=MAXBFR
	        GO TO 6
	      5 LIMIT=LIMIT-1
	      6 IF(LIMIT.LT.LOWBFR)GO TO 7
	        IF(IBUFFR(LIMIT).EQ.ISPACE)GO TO 5
	  C
	  C     REPORT TYPE OF INFORMATION FOUND
	      7 IF((LAST.GT.0).AND.(KIND.NE.4))WRITE(ITTY,8)
	      8 FORMAT(' ')
	        GO TO(21,9,11,1,13,15,17,19),KIND
	      9 WRITE(ITTY,10)
	     10 FORMAT(' EQUALS SIGN FOLLOWS NAME')
	        GO TO 21
	     11 WRITE(ITTY,12)
	     12 FORMAT(' EMPTY')
	        GO TO 1
	     13 WRITE(ITTY,14)
	     14 FORMAT(' WRONG NUMBER OF SUBSCRIPTS')
	        GO TO 21
	     15 WRITE(ITTY,16)
	     16 FORMAT(' SUBSCRIPTS OUT OF RANGE')
	        GO TO 21
	     17 WRITE(ITTY,18)(IBUFFR(I),I=LOWBFR,LIMIT)
	     18 FORMAT(' NO MATCH FOUND WITH ',60A1)
	        GO TO 1
	     19 WRITE(ITTY,20)(IBUFFR(I),I=LOWBFR,LIMIT)
	     20 FORMAT(' SEMICOLON REQUIRED BEFORE ',60A1)
	        GO TO 1
	  C
	  C     REPORT ARRAY NAME, SUBSCRIPTS AND LOCATION IN BUFFER
	     21 IF(KNTSUB.GT.0)WRITE(ITTY,22)(INISUB(I),LMTSUB(I),
	       1I=1,KNTSUB)
	     22 FORMAT(' SUBSCRIPTS FOUND',7(I3,1H/,I3,1H,))
	        J=LTRINI+NUMSTR(NUMINI)-1
	        K=LRGLTR-NUMSTR(LRGNUM)-1
	        DO 23 I=1,6
	        JBUFFR(I)=ISPACE
	        IF(LTRINI.LE.J)JBUFFR(I)=LTRSTR(LTRINI)
	        KBUFFR(I)=ISPACE
	        IF(LRGLTR.LE.K)KBUFFR(I)=LTRSTR(LRGLTR)
	        LRGLTR=LRGLTR+1
	     23 LTRINI=LTRINI+1
	        WRITE(ITTY,24)LRGKNT,KBUFFR,INITAL,KOUNT,JBUFFR
	     24 FORMAT(' GROUP',I2,' NAMED ',6A1,' LOCATION',I4,
	       1' STARTS ARRAY',I2,' NAMED ',6A1)
	        GO TO 4
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 302
	  DAPICK, Routine to Interpret Array Name and Subscript Ranges


	  Typical Dialog Between DAPICK Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  **********
	  ARRAY NAME:DEF(4,);DEF(,7);DEF(4,7)!A COMMENT

	  SUBSCRIPTS FOUND  4/  4,  1/ 10,
	  GROUP 1 NAMED FIRST  LOCATION 201 STARTS ARRAY 3 NAMED DEF

	  SUBSCRIPTS FOUND  1/ 10,  7/  7,
	  GROUP 1 NAMED FIRST  LOCATION 201 STARTS ARRAY 3 NAMED DEF

	  SUBSCRIPTS FOUND  4/  4,  7/  7,
	  GROUP 1 NAMED FIRST  LOCATION 201 STARTS ARRAY 3 NAMED DEF
	  **********
	  ARRAY NAME:DEF(1/2,3/4,5/6,7/8);DEF(4,12)DEF

	  WRONG NUMBER OF SUBSCRIPTS
	  SUBSCRIPTS FOUND  1/  2,  3/  4,  5/  6,  7/  8,
	  GROUP 1 NAMED FIRST  LOCATION 201 STARTS ARRAY 3 NAMED DEF

	  SUBSCRIPTS OUT OF RANGE
	  SUBSCRIPTS FOUND  4/  4, 12/ 12,
	  GROUP 1 NAMED FIRST  LOCATION 201 STARTS ARRAY 3 NAMED DEF

	  SEMICOLON REQUIRED BEFORE DEF
	  **********
	  ARRAY NAME:X(,);X(3/,);X(,/7);X(3/,/7);X(6/9,2/4);X(9/6,4/2)

	  SUBSCRIPTS FOUND 10/  1, 10/  1,
	  GROUP 3 NAMED THIRD  LOCATION 201 STARTS ARRAY 3 NAMED X

	  SUBSCRIPTS FOUND  3/  1, 10/  1,
	  GROUP 3 NAMED THIRD  LOCATION 201 STARTS ARRAY 3 NAMED X

	  SUBSCRIPTS FOUND 10/  1, 10/  7,
	  GROUP 3 NAMED THIRD  LOCATION 201 STARTS ARRAY 3 NAMED X

	  SUBSCRIPTS FOUND  3/  1, 10/  7,
	  GROUP 3 NAMED THIRD  LOCATION 201 STARTS ARRAY 3 NAMED X

	  SUBSCRIPTS FOUND  6/  9,  2/  4,
	  GROUP 3 NAMED THIRD  LOCATION 201 STARTS ARRAY 3 NAMED X

	  SUBSCRIPTS FOUND  9/  6,  4/  2,
	  GROUP 3 NAMED THIRD  LOCATION 201 STARTS ARRAY 3 NAMED X
	  **********
	  ARRAY NAME:UNKNOWN

	  NO MATCH FOUND WITH UNKNOWN
	  **********
	  ARRAY NAME: ;;;!SEMICOLONS AND A COMMENT

	  EMPTY
	  FASP, FORTRAN Alphameric Subroutine Package         Page 303
	  DAPICK, Routine to Interpret Array Name and Subscript Ranges


	  **********
	  ARRAY NAME:STU;STU();STU(,);STU(,)=

	  WRONG NUMBER OF SUBSCRIPTS
	  GROUP 3 NAMED THIRD  LOCATION   1 STARTS ARRAY 1 NAMED STU

	  WRONG NUMBER OF SUBSCRIPTS
	  SUBSCRIPTS FOUND  1/ 10,
	  GROUP 3 NAMED THIRD  LOCATION   1 STARTS ARRAY 1 NAMED STU

	  SUBSCRIPTS FOUND  1/ 10,  1/ 10,
	  GROUP 3 NAMED THIRD  LOCATION   1 STARTS ARRAY 1 NAMED STU

	  EQUALS SIGN FOLLOWS NAME
	  SUBSCRIPTS FOUND  1/ 10,  1/ 10,
	  GROUP 3 NAMED THIRD  LOCATION   1 STARTS ARRAY 1 NAMED STU
	  **********
	  ARRAY NAME:JKL;JKL=;JKL(1);JKL(1)=!A COMMENT

	  SUBSCRIPTS FOUND  1/  1,
	  GROUP 2 NAMED SECOND LOCATION  11 STARTS ARRAY 2 NAMED JKL

	  EQUALS SIGN FOLLOWS NAME
	  SUBSCRIPTS FOUND  1/  1,
	  GROUP 2 NAMED SECOND LOCATION  11 STARTS ARRAY 2 NAMED JKL

	  SUBSCRIPTS FOUND  1/  1,
	  GROUP 2 NAMED SECOND LOCATION  11 STARTS ARRAY 2 NAMED JKL

	  EQUALS SIGN FOLLOWS NAME
	  SUBSCRIPTS FOUND  1/  1,
	  GROUP 2 NAMED SECOND LOCATION  11 STARTS ARRAY 2 NAMED JKL
	  **********
	  ARRAY NAME:PQR;PQR=;PQR(1);PQR(1)=PQR

	  SUBSCRIPTS FOUND  1/  1,
	  GROUP 2 NAMED SECOND LOCATION  22 STARTS ARRAY 4 NAMED PQR

	  EQUALS SIGN FOLLOWS NAME
	  SUBSCRIPTS FOUND  1/  1,
	  GROUP 2 NAMED SECOND LOCATION  22 STARTS ARRAY 4 NAMED PQR

	  SUBSCRIPTS FOUND  1/  1,
	  GROUP 2 NAMED SECOND LOCATION  22 STARTS ARRAY 4 NAMED PQR

	  EQUALS SIGN FOLLOWS NAME
	  SUBSCRIPTS FOUND  1/  1,
	  GROUP 2 NAMED SECOND LOCATION  22 STARTS ARRAY 4 NAMED PQR

	  SEMICOLON REQUIRED BEFORE PQR
	  FASP, FORTRAN Alphameric Subroutine Package         Page 304
	  DAPLAT, Scatter Plot Routine for Printer


	  DDDDD          AAA  PPPPPP    LL              AAA  TTTTTTTT
	  DD   DD       AAAA  PP    PP  LL             AAAA     TT
	  DD    DD     AA AA  PP    PP  LL            AA AA     TT
	  DD    DD    AA  AA  PPPPPP    LL           AA  AA     TT
	  DD    DD   AAAAAAA  PP        LL          AAAAAAA     TT
	  DD   DD   AA    AA  PP        LL         AA    AA     TT
	  DDDDD    AA     AA  PP        LLLLLLLL  AA     AA     TT

	            DAPLAT, Scatter Plot Routine for Printer
	            ------- ------- ---- ------- --- -------

	  DAPLAT is a FORTRAN subroutine  which  constructs  printable
	  plots  having  proportions which are selected by the calling
	  program.  Each plot can contain one or more curves and  each
	  curve  can  be  represented  by  its  own alphabetic letter.
	  Points on a curve can  optionally  be  connected  either  by
	  asterisks or by some alphabetic letter which need not be the
	  same as that used to represent the  points  themselves.   If
	  plotting  points  not  connected  by lines, a pin map can be
	  simulated  by  using  the  closest  empty  location  if  the
	  location representing the point is already in use.

	  The plot can be ruled  with  grid  lines  at  evenly  spaced
	  intervals  across the width and height of the plot.  Numbers
	  printed  alongside  the  plot   are   represented   with   5
	  significant digits, but with suppression of rightmost zeroes
	  beyond the decimal point.  If the number cannot  be  printed
	  in  floating  point  form,  the  number  is  represented  in
	  scientific notation instead.

	  If two or more different alphabetic letters are to appear in
	  the  same  location  in  the printed plot, an ampersand will
	  appear instead.  However, if the  line  segments  connecting
	  points  are  to  be  formed from a different letter than the
	  letter representing the  points  themselves,  then  both  of
	  these  letters, where used for previous curves or where used
	  elsewhere  on  the  current  curve,  are  not   changed   to
	  ampersands  by  coincidence  with the present curve.  Points
	  and lines which are formed from asterisks  can  be  selected
	  either  to  be  superseded  by  (be  dominated by) any other
	  characters, or else to  supersede  (be  dominant  over)  any
	  other characters.  The character set and dominance rules can
	  be changed by the calling program if necessary.

	  When line segments are formed from  different  letters  than
	  are  used  to  represent points, and when these letters vary
	  from one  curve  to  the  next,  then  the  order  in  which
	  overlapping  curves are specified can change which locations
	  of  the  plot  contain  ampersands.   For  example,  if   we
	  superimpose  the horizontal and vertical line patterns shown
	  below (assuming that the  asterisks  are  dominated  by  all
	  other characters)

	  FASP, FORTRAN Alphameric Subroutine Package         Page 305
	  DAPLAT, Scatter Plot Routine for Printer


	       horizontal line pattern         vertical line pattern
	     10 -EDDDDDDDDDDDDDDDDDDDE     10 -B---C---D-+-E---*---A
	         !                   !         A   B   C   D   *   *
	         DCCCCCCCCCCCCCCCCCCCD         A   B   C   D   *   *
	         !                   !         A   B   C   D   *   *
	         CBBBBBBBBBBBBBBBBBBBC         A   B   C   D   *   *
	      5 -+         +         +      5 -A   B   C + D   *   *
	         BAAAAAAAAAAAAAAAAAAAB         A   B   C   D   *   *
	         !                   !         A   B   C   D   *   *
	         A*******************A         A   B   C   D   *   *
	         !                   !         A   B   C   D   *   *
	      0 -*********************      0 -B---C---D-+-E---*---A
	         !         !         !         !         !         !
	         0         5        10         0         5        10

	  then we get the 2 plots shown below depending  upon  whether
	  the horizontal or vertical lines are specified first.

	        horizontal lines first          vertical lines first
	     10 -&DDD&DDDDDDDEDDDDDDD&     10 -&DDD&DDDDDDDEDDDDDDD&
	         A   B   C   D   *   *         A   B   C   D   *   *
	         &CCCCCCCCCCC&CCCCCCCD         &CCC&CCCCCCCDCCCCCCCD
	         A   B   C   D   *   *         A   B   C   D   *   *
	         &BBBBBBB&BBB&BBBBBBBC         &BBBBBBBCBBB&BBBBBBBC
	      5 -A   B   C + D   *   *      5 -A   B   C + D   *   *
	         BAAA&AAA&AAA&AAAAAAAB         BAAABAAA&AAA&AAAAAAAB
	         A   B   C   D   *   *         A   B   C   D   *   *
	         A***B***C***D*******A         A***B***C***D*******A
	         A   B   C   D   *   *         A   B   C   D   *   *
	      0 -B***C***D***E*******A      0 -B***C***D***E*******A
	         !         !         !         !         !         !
	         0         5        10         0         5        10

	  The important differences between the above 2 plots  are  at
	  X=2,  Y=8  and at X=4, Y=6.  The choice of whether or not to
	  place an  ampersand  at  a  particular  location  along  the
	  representation  of  a  curve must be made by comparing the 2
	  letters being used for the curve  with  the  letter  if  any
	  already  occupying  that  location.  In the left plot above,
	  the horizontal line segment  formed  of  B's  was  specified
	  before  the  vertical  line  of  C's.   When  the  point  of
	  intersection was reached, the B already on the plot was  not
	  found  to  match  either  the D's being used for the current
	  points or  the  C's  being  used  for  the  connecting  line
	  segments so the B was changed to an ampersand.  In the right
	  plot above, the vertical line of C's  was  specified  before
	  the  horizontal  line  of  B's.   When  the intersection was
	  reached, the C already on the plot was found to match one of
	  the  letters  B  and  C  being used to represent the current
	  curve.  Since a line segment rather than a point  was  being
	  constructed  at  the  intersection,  the  matching character
	  already on the plot was left  unchanged.   If  a  point  was
	  being  constructed  at  the  intersection  instead of a line
	  segment, then the character on  the  plot  would  have  been
	  FASP, FORTRAN Alphameric Subroutine Package         Page 306
	  DAPLAT, Scatter Plot Routine for Printer


	  changed to the character being used to represent the point.


	                    The DAPLAT Argument List
	                    --- ------ -------- ----

	  The argument list of routine DAPLAT is

	        SUBROUTINE DAPLAT( IPLOT,MAXWID,MAXHIH,LETTER,KONECT,
	       1    XPOINT,YPOINT,MINSUB,MAXSUB, XLEFT,YLOWER,XRIGHT,
	       2    YUPPER, IGRID, IEDGE,MARGIN,MSHWID,MSHHIH,LTROFF,
	       3    LINOFF,LINPRT, IDISK,IRESET,LTRERR,LINERR)

	  with the associated DIMENSION statement

	        DIMENSION XPOINT(MAXSUB),YPOINT(MAXSUB)


	            Arguments Used to Input Values to DAPLAT
	            --------- ---- -- ----- ------ -- ------

	  The following input arguments  are  used  by  each  call  to
	  DAPLAT whether or not a plot is generated.

	  IPLOT  = -1, add the points and/or lines represented by  the
	           coordinates  in the XPOINT and YPOINT arrays to the
	           plot storage, then return to  the  calling  program
	           without  generating  the  plot.   Additional DAPLAT
	           calls will be executed before the  plot  is  to  be
	           printed.
	         = 0, add the points and/or lines in  the  XPOINT  and
	           YPOINT  arrays  to  the plot storage, then generate
	           the plot and clear the plot storage after the  plot
	           is  generated.  Additional calls to DAPLAT, if any,
	           will store upon a blank plot surface.
	         = 1, add the points and/or lines in  the  XPOINT  and
	           YPOINT  arrays  to  the plot storage, then generate
	           the plot but do not clear the  plot  storage  after
	           the  plot  is generated.  The currently stored plot
	           will be added to by additional calls to DAPLAT.

	  MAXWID = width of the plot stated as the number  of  columns
	           of  characters forming the plotting area upon which
	           data can be plotted.  MAXWID is normally 1  plus  a
	           multiple  of MSHWID.  The recommended maximum value
	           of MAXWID is 101.  It should be noted that the plot
	           usually  has  an additional margin of 12 characters
	           along the left side in which scale numbers and  the
	           carriage  control  character  are  printed,  and an
	           additional 4 characters can appear to the right  of
	           the  plot  in the lower-right scale number.  If the
	           output is being written to a terminal so  that  the
	           character  in column 1 is interpreted as a carriage
	           control, and if wraparound at the right  margin  of
	  FASP, FORTRAN Alphameric Subroutine Package         Page 307
	  DAPLAT, Scatter Plot Routine for Printer


	           the portion of the rightmost scale number extending
	           beyond the right edge of the  plot  is  acceptable,
	           then MAXWID can be set to 61 on terminals which can
	           display 72 characters per line, and can be  set  to
	           121  on  terminals which can display 132 characters
	           per line.  The largest accepted value of MAXWID  is
	           131, which can lead to a lower scale 147 characters
	           wide  which  is  too  large  to  output   on   most
	           line-printers.   If  the  value  of IEDGE turns off
	           both left scale numbers  and  lower  scale  numbers
	           (this option is described after the sample program,
	           not in the  ordinary  argument  descriptions)  then
	           only the carriage control character, either a space
	           or an asterisk depending upon the value of  LINPRT,
	           will appear to the left of the plot (providing that
	           the  value  of  MARGIN  does   not   also   request
	           additional  spaces)  so  the  maximum  width  of  a
	           printed line would then be merely MAXWID+MARGIN+1.
	         = 0, use the last nonzero value specified for  MAXWID
	           as the width of the plot, or use the value 101 if a
	           nonzero value of MAXWID has not been specified.

	  MAXHIH = height of the plot stated as the  number  of  lines
	           forming  the  plotting  area upon which data can be
	           plotted.   Normally  MAXHIH  would  be  1  plus   a
	           multiple  of  MSHHIH.   The  plot has an additional
	           lower margin of 2 lines (or 3 lines if the  numbers
	           below the lower scale are in scientific notation).
	         = 0, use the last nonzero value specified for  MAXHIH
	           as the height of the plot, or use the value 51 if a
	           nonzero value of MAXHIH has not been specified.

	  LETTER = 0, plot the points having coordinates in the XPOINT
	           and  YPOINT  arrays with nondominant asterisks.  If
	           one (or more) of these points is to appear  at  the
	           same  location  on  the plot as some other point or
	           portion of a line segment which is  represented  by
	           an  alphabetic  character  or by an ampersand, then
	           the other point or portion of  a  line  segment  is
	           shown instead of the current point.
	         = within the range 1 through 26, LETTER is the serial
	           number  within  the  alphabet of the letter used to
	           plot the points having coordinates  in  the  XPOINT
	           and   YPOINT  arrays.   LETTER=3  would  cause  the
	           plotted points to be represented with C's.
	         = 27 (or greater), plot the points having coordinates
	           in  the  XPOINT  and  YPOINT  arrays  with dominant
	           asterisks.  If one (or more) of these points is  to
	           appear  at  the  same  location on the plot as some
	           other point or portion of a line segment  which  is
	           represented  by  an  alphabetic  character or by an
	           ampersand, then the current point is shown  instead
	           of the other point or portion of a line segment.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 308
	  DAPLAT, Scatter Plot Routine for Printer


	  KONECT = less than -1, simulate a pin map.  Store the points
	           having  coordinates in the XPOINT and YPOINT arrays
	           for plotting (either by the current call to  DAPLAT
	           if  IPLOT  is greater than or equal to zero or by a
	           subsequent call to DAPLAT if IPLOT is not equal  to
	           zero).   If LETTER is greater than zero, and if the
	           location representing the point already contains  a
	           printing   character   other   than  a  nondominant
	           asterisk  (selected  either  by  LETTER=0   or   by
	           KONECT=0),  then  search  for  the closest location
	           which is empty  or  which  contains  a  nondominant
	           asterisk.   If  LETTER  is zero and if the location
	           representing  the  point   already   contains   any
	           printing  character,  then  search  for the closest
	           location which contains a space.  If, after  having
	           searched  a number of concentric boxes equal to the
	           absolute value of KONECT, no available location has
	           yet  been  found,  then  abandon the attempt.  Note
	           that if several points coincide, it  is  much  more
	           efficient  to  have them adjacent in the XPOINT and
	           YPOINT arrays if the pin map option is  used  since
	           then  the  locations  already found to be in use do
	           not have to be searched again for  each  subsequent
	           point.   The following are examples of the sizes of
	           pin groups possible for various values of KONECT.

	                KONECT=-2  KONECT=-3  KONECT=-4  KONECT=-5

	                                                 555555555
	                                       4444444   544444445
	                             33333     4333334   543333345
	                   222       32223     4322234   543222345
	                   212       32123     4321234   543212345
	                   222       32223     4322234   543222345
	                             33333     4333334   543333345
	                                       4444444   544444445
	                                                 555555555

	           The plot shown  below  is  typical  of  a  pin  map
	           simulation.  The 7 appearances of the letter A were
	           plotted first, then the letter B was  requested  to
	           be plotted at the same locations as the A's, and so
	           on through the letter Y.  KONECT had the  value  -4
	           but  the search patterns did not fill the allowed 4
	           boxes.  The  rectangle  drawn  with  asterisks  was
	           plotted  in  curve mode with both LETTER and KONECT
	           being zero.  The rectangle could have been  plotted
	           either  before  or  after the points of the pin map
	           since nondominant asterisks are  considered  to  be
	           the same as spaces when a pin map is simulated, and
	           since  nondominant  asterisks  cannot  supersede  a
	           letter already in the plot.  In a real application,
	           such lines of asterisks could be used to  represent
	           a geographical boundary or a network of streets and
	  FASP, FORTRAN Alphameric Subroutine Package         Page 309
	  DAPLAT, Scatter Plot Routine for Printer


	           roads.

	                   15 -+---------+---------+---------+
	                       !    UTSRQ          TSRQPY    !
	                       !   *VGFEP**********UGFEOX    !
	                       !UTSRQHADO          VHADNTSRQ !
	                       !VGFEPIBCN        RQPIBCMGFEP !
	                   10 -+WHADOJKLM+       SGFEJKLHADO +
	                       !XIBCNWXY         THADOWUIBCN !
	                       !YJKLM            UIBCN VJKLM !
	                       !   *             VJKLM WXY   !
	                       !   *             WXY   *     !
	                    5 -+ UTSRQ   +UTSRQ    +   *     +
	                       ! VGFEP    VGFEP        *     !
	                       ! WHADO****WHADO*********     !
	                       ! XIBCN    XIBCN              !
	                       ! YJKLM    YJKLM              !
	                    0 -+---------+---------+---------+
	                       !         !         !         !
	                       0        10        20        30

	           Many of the points in the 3 pin groups in the upper
	           right  corner  of  the above plot have been shifted
	           further out in the search  patterns  due  to  their
	           intended  destinations  being already in use.  This
	           can be verified by tracing the  spiral  but  broken
	           paths along which the letters A through Y have been
	           positioned.  The 2 pin groups  in  the  upper  left
	           corner   have  similarly  spread  slightly  due  to
	           overlap of the search patterns.

	           Some distortion cannot be avoided when a pin map is
	           simulated  by  DAPLAT.   The  concentric  boxes  of
	           characters do not  print  as  squares  due  to  the
	           differing  numbers  of  rows  and columns per inch.
	           Also, the pin map simulation  does  not  provide  a
	           true  window (that is, the portion displayed is not
	           necessarily the same as  if  displayed  on  a  plot
	           showing  a  larger  area)  since  points  which are
	           outside the plot are  not  represented  even  if  a
	           search  pattern  centered  at them would spill over
	           onto the plot, while points at the borders must  be
	           shown within the plot since the search pattern does
	           not include the area outside the plot.

	           The  plot  shown  below  demonstrates  these   edge
	           distortions.   This  plot was generated by plotting
	           the same points as in the pin  map  shown  earlier,
	           but  the  window  size  was reduced to include only
	           those coordinates which  were  on  and  within  the
	           rectangle  of  asterisks  in the earlier plot.  The
	           plot size was reduced to maintain the  same  ratios
	           of  data  coordinates to printed columns and lines.
	           The left of the pin groups in  the  original  upper
	  FASP, FORTRAN Alphameric Subroutine Package         Page 310
	  DAPLAT, Scatter Plot Routine for Printer


	           left  corner  does  not  appear in the smaller plot
	           since the center  of  this  group  is  outside  the
	           smaller  window.   The  pin group in the lower left
	           corner was only partially plotted since the  4  box
	           limit  was  reached  before  all  of  the requested
	           points could be represented.  The pin group in  the
	           lower  center  is  both wider and extends to higher
	           coordinates than in the larger plot, but all points
	           were   included   without   exhausting  the  search
	           pattern.

	                   13 -+QGFEP----+----TPGFEO
	                       !RHADO         UQHADN
	                       !SIBCN        RQPIBCM
	                       !TJKLM        SGFEJKL
	                       !UVWXY        THADORS
	                    8 -+         +   UIBCN +
	                       !             VJKLM !
	                       PONM  YXWVUTS WXY   !
	                       IHGL   MLKJIR       !
	                       DCFK   NEDCHQ       !
	                    3 -ABEJ---OFABGP-------+
	                       !         !         !
	                       4        14        24

	         = -1, store the input  data  as  unconnected  points.
	           Store  the  points having coordinates in the XPOINT
	           and YPOINT  arrays  for  plotting  (either  by  the
	           current  call to DAPLAT if IPLOT is greater than or
	           equal to zero or by a subsequent call to DAPLAT  if
	           IPLOT  is not equal to zero).  If LETTER is greater
	           than zero, and  if  there  already  is  a  printing
	           character  other than a nondominant asterisk at the
	           location representing  the  point,  then  place  an
	           ampersand at the location instead.
	         = equal to or greater than zero, store the input data
	           as a curve.
	         = 0, store  the  points  having  coordinates  in  the
	           XPOINT  and YPOINT arrays for plotting, and connect
	           these with lines formed of  nondominant  asterisks.
	           If  some other character already is in the plot, or
	           is later added to the plot at the  locations  along
	           the line, then this other character is seen instead
	           of the asterisk.
	         = within the range 1 through 26, KONECT is the serial
	           number  within  the  alphabet of the letter used to
	           connect the points having coordinates in the XPOINT
	           and YPOINT arrays.
	         = 27  (or   greater),   store   the   points   having
	           coordinates  in  the  XPOINT  and YPOINT arrays for
	           plotting, and connect these with  lines  formed  of
	           dominant   asterisks.    If  some  other  character
	           already is in the plot, or if a  later  attempt  is
	           made to add some other character to the plot at the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 311
	  DAPLAT, Scatter Plot Routine for Printer


	           locations along the line, then the asterisk is seen
	           instead of this other character.

	  XPOINT = the   array   of   abscissae   (X   or   horizontal
	           coordinates) of the data points to be plotted.

	  YPOINT = the array of ordinates (Y or vertical  coordinates)
	           of the data points to be plotted.

	  MINSUB = the subscript in the XPOINT and  YPOINT  arrays  of
	           the coordinates of the first point to be plotted.

	  MAXSUB = the subscript in the XPOINT and  YPOINT  arrays  of
	           the  coordinates  of the final point to be plotted.
	           If it is desired that the current  call  to  DAPLAT
	           generate  the  previously  stored  plot but not add
	           points or lines to this plot, then MAXSUB should be
	           less than MINSUB.

	  XLEFT  = the horizontal data coordinate to be placed in  the
	           center  of the character column at the left edge of
	           the plot.  If a scale number is printed  below  the
	           left  column  of  the  plot, then this scale number
	           will have a value equal to that of XLEFT.  Only the
	           portion  of  the curve inside the window defined by
	           XLEFT, YLOWER, XRIGHT and YUPPER will be  shown  in
	           the  plot.   Points  shown  on  the  plot must have
	           horizontal     coordinates     in     the     range
	           XLEFT-((XRIGHT-XLEFT)/(2*(MAXWID-1)))   to  XRIGHT+
	           ((XRIGHT-XLEFT)/(2*(MAXWID-1))).    The    vertical
	           coordinate  range would be expressed similarly.  If
	           a line segment crosses the window, the  portion  of
	           the  line  segment which is outside the window will
	           not be represented.

	           The  data  coordinates  can  either   increase   or
	           decrease  from left to right or from bottom to top.
	           In other words, XRIGHT can be either  greater  than
	           or  less  than  XLEFT,  and  YUPPER  can  be either
	           greater than or  less  than  YLOWER.   If  multiple
	           curves are being superimposed on a single plot, the
	           curves need not all have the same  data  coordinate
	           limits,  however,  the  scale  numbers shown on the
	           plot will correspond to the data coordinate  limits
	           of the final curve.

	  YLOWER = the vertical data coordinate to be  placed  in  the
	           center  of  the character line at the lower edge of
	           the plot.  If a scale number is printed to the left
	           of  the  bottom  line  of the plot, then this scale
	           number will have a value equal to that of YLOWER.

	  XRIGHT = the horizontal data coordinate to be placed in  the
	           center of the character column at the right edge of
	  FASP, FORTRAN Alphameric Subroutine Package         Page 312
	  DAPLAT, Scatter Plot Routine for Printer


	           the plot.  If a scale number is printed  below  the
	           right  column  of  the plot, then this scale number
	           will have a value equal to that of XRIGHT.

	  YUPPER = the vertical data coordinate to be  placed  in  the
	           center  of  the character line at the upper edge of
	           the plot.  If a scale number is printed to the left
	           of the top line of the plot, then this scale number
	           will have a value equal to that of YUPPER.


	        Input Arguments Used Only if a Plot is Generated
	        ----- --------- ---- ---- -- - ---- -- ---------

	  The  following  arguments  are  ignored  unless  a  plot  is
	  generated  by  the  current  call to DAPLAT.  However, these
	  arguments and in particular IDISK  should  always  be  given
	  reasonable  values  since  the stored plot will be generated
	  and the plot storage cleared if the size  of  the  plot  (as
	  indicated  by MAXWID and MAXHIH) is changed while points and
	  lines are still stored from the previous call to DAPLAT.

	  IGRID  = 0, if the plot is generated, the plot will show  an
	           internal  grid.   This internal grid will be formed
	           of vertical lines spaced  every  MSHWID  characters
	           across  the  width  of  the  plot and of horizontal
	           lines spaced every MSHHIH lines across  the  height
	           of the plot.
	         = 1, if the plot is generated, the plot will show the
	           intersections of the lines of an internal grid, but
	           will not  show  the  grid  lines  themselves.   The
	           internal   grid  would,  if  shown,  be  formed  of
	           vertical  lines  spaced  every  MSHWID   characters
	           across  the  width  of  the  plot and of horizontal
	           lines spaced every MSHHIH lines across  the  height
	           of the plot.
	         = 2, if the plot is generated, the plot will not show
	           an internal grid.  However, regardless of the value
	           of IGRID, scale numbers will be printed  along  the
	           scales  at  the  intervals  indicated by MSHWID and
	           MSHHIH.

	  IEDGE  = 0, place numbers both to the left of and below  the
	           plot to identify the coordinate ranges.
	         = 1, place numbers to the left of the  plot,  but  do
	           not place numbers below the plot.
	         = 2, place numbers below the plot,  but  not  to  the
	           left of the plot.  Unless prevented by the value of
	           MARGIN, the distance between the  carriage  control
	           character in column 1 and the left edge of the plot
	           will be just large enough to allow a  scale  number
	           immediately below the left edge of the plot.
	         = 3, do not place numbers either to the  left  of  or
	           below  the  plot.  Unless prevented by the value of
	  FASP, FORTRAN Alphameric Subroutine Package         Page 313
	  DAPLAT, Scatter Plot Routine for Printer


	           MARGIN,  no  characters  will  appear  between  the
	           carriage control character in column 1 and the left
	           edge of the plot.

	  MARGIN = the lower limit to the number of  characters  which
	           must  appear  in  the  output  between the carriage
	           control character in column 1 and the left edge  of
	           the  plot.   MARGIN  is  used  to force the plot to
	           remain a fixed distance from the  carriage  control
	           character  in  column  1 even if a nonzero value of
	           IEDGE has deselected scale  numbers  so  that  this
	           spacing  would not be necessary.  MARGIN is assumed
	           to be at least 11 if IEDGE is zero or 1.

	  MSHWID = greater than zero but not greater than the width of
	           the  plot,  use  MSHWID  as  the  width of the grid
	           divisions  stated  as  the  number  of  columns  of
	           characters.   MSHWID=10  would  give  vertical grid
	           lines spaced every 10 characters across  the  width
	           of the plot area.
	         = 0, use the last nonzero value specified for  MSHWID
	           as  the grid division width, or use the value 10 if
	           a nonzero value of MSHWID has not been specified by
	           a previous call to this routine.
	         = greater than  the  plot  width,  do  not  plot  any
	           vertical  grid  lines  and  do  not represent scale
	           numbers below the plot.

	           The examples shown below illustrate the combination
	           of MAXWID=11 with various values of MSHWID.

	                   MSHWID=4                 MSHWID=10
	             100 -+---+A--+--         100 -+----A----+
	                  !   * * !                !   * *   !
	                  A*********A              A*********A
	               0 -+ **+  **             0 -+ **   ** +
	                  ! * *** *                ! * *** * !
	                  ! *** ***                ! *** *** !
	            -100 -+A*-+---*A-        -100 -+A*-----*A+
	                  !   !   !                !         !
	                -100 -20 60              -100       100

	                   MSHWID=11                MSHWID=12
	             100 -+----A-----         100 ------A-----
	                  !   * *                      * *
	                  A*********A              A*********A
	               0 -+ **   **             0 -  **   **
	                  ! * *** *                  * *** *
	                  ! *** ***                  *** ***
	            -100 -+A*-----*A-        -100 --A*-----*A-
	                  !
	                -100

	  MSHHIH = greater than zero but not greater than  the  height
	  FASP, FORTRAN Alphameric Subroutine Package         Page 314
	  DAPLAT, Scatter Plot Routine for Printer


	           of  the  plot, use MSHHIH as the height of the grid
	           divisions stated as the number of lines.   MSHHIH=5
	           would  give  horizontal  grid  lines spaced every 5
	           lines across the height of the plot area.
	         = 0, use the last nonzero value specified for  MSHHIH
	           as  the grid division height, or use the value 5 if
	           a nonzero value of MSHHIH has not been specified by
	           a previous call to this routine.
	         = greater than the  plot  height,  do  not  plot  any
	           horizontal  grid  lines  and do not represent scale
	           numbers to the left  of  the  plot.   This,  unlike
	           deselection  of  the  left  scale numbers by IEDGE,
	           does not change  the  horizontal  location  of  the
	           plot.

	           The examples shown below illustrate the combination
	           of MAXHIH=7 with various values of MSHHIH.

	                   MSHHIH=4                 MSHHIH=6
	                  !    A    !         100 -+----A----+
	                  !   * *   !              !   * *   !
	           33.333-A*********A              A*********A
	                  ! **   ** !              ! **   ** !
	                  ! * *** * !              ! * *** * !
	                  ! *** *** !              ! *** *** !
	            -100 -+A*--+--*A+        -100 -+A*--+--*A+
	                  !    !    !              !    !    !
	                -100   0   100           -100   0   100

	                   MSHHIH=7                 MSHHIH=8
	                  !    A    !              !    A    !
	                  !   * *   !              !   * *   !
	                  A*********A              A*********A
	                  ! **   ** !              ! **   ** !
	                  ! * *** * !              ! * *** * !
	                  ! *** *** !              ! *** *** !
	            -100 -+A*--+--*A+              !A*     *A!
	                  !    !    !              !    !    !
	                -100   0   100           -100   0   100

	  LTROFF = number  of  columns  of  characters  by  which  the
	           leftmost  grid  line is offset from the left border
	           of the plot.  LTROFF can be in the range zero up to
	           but  not  including MSHWID.  If LTROFF is negative,
	           then it is assumed to have the value  MSHWID+LTROFF
	           instead.   If  LTROFF  is  nonzero,  then  the left
	           border of the plot will be ruled  with  exclamation
	           points.   The right border is similarly ruled if it
	           does not bear a grid line.

	  LINOFF = number of lines of characters by which  the  lowest
	           grid  line  is  offset from the lower border of the
	           plot.  LINOFF can be in the range zero  up  to  but
	           not  including MSHHIH.  If LINOFF is negative, then
	  FASP, FORTRAN Alphameric Subroutine Package         Page 315
	  DAPLAT, Scatter Plot Routine for Printer


	           it is  assumed  to  have  the  value  MSHHIH+LINOFF
	           instead.   If  LINOFF  is  nonzero,  then the lower
	           border of the plot will be ruled with minus  signs.
	           The upper border is similarly marked if it does not
	           bear a grid line.

	  LINPRT = -1, do not include a carriage control character  to
	           the left of each line of the plot.  Since the minus
	           sign of a negative scale number can then appear  in
	           column  1, the resulting output must not be treated
	           as though the left column contains carriage control
	           characters.
	         = 0, the plot  will  be  viewed  by  the  user  on  a
	           terminal,  either  typed  directly with IDISK being
	           given the terminal unit number,  or  typed  by  the
	           user after this routine has written the plot into a
	           file on the unit the number of which  is  contained
	           in  IDISK.   A  blank  or  space  will  be  used as
	           carriage control character to give single spacing.
	         = 1, the plot will be printed on the line printer  by
	           the  user  after  the  program has written the plot
	           into a file.  An asterisk will be used as  carriage
	           control  character  to  give  single  spacing  with
	           suppression of skipping extra  lines  at  the  page
	           boundaries.   On  the  PDP-10,  an  asterisk as the
	           carriage control character  gives  overprinting  on
	           the terminal as opposed to single spacing.

	  IDISK  = the unit number of the device onto which the  plots
	           are to be written.  This routine will only generate
	           the plot.  It is the responsibility of the  calling
	           program  to  open  the output file and to write the
	           captions, the  form  feeds  and/or  the  separating
	           lines.   IDISK  should always be given a legal unit
	           number since DAPLAT will generate the stored  plot,
	           if any, using the new value of IDISK before storing
	           the new curve if the new  plot  size  differs  from
	           that  used  to  store  the  previous curves even if
	           IPLOT=-1.


	  Argument Used Initially for Input, but then Returned Changed
	  -------- ---- --------- --- -----  --- ---- -------- -------

	  The following  argument  must  be  defined  by  the  calling
	  program  before this routine is first called.  This argument
	  is returned by this routine set to zero, and this zero value
	  should  be  sent  unchanged  to any subsequent calls to this
	  routine.

	  IRESET = 0, the plot  storage  has  been  initialized  by  a
	           previous  call  to  this  routine.   If  IPLOT  was
	           nonzero during the previous call to  this  routine,
	           then  the  current call to this routine will add to
	  FASP, FORTRAN Alphameric Subroutine Package         Page 316
	  DAPLAT, Scatter Plot Routine for Printer


	           the plot already started by the previous call.
	         = (greater than zero),  used  when  this  routine  is
	           first called to initialize the arrays and variables
	           which will be used to store the plot, or  to  cause
	           the  current  call  to  this  routine to insert the
	           points or lines into a blank plot even if IPLOT was
	           nonzero during the previous call to this routine so
	           that the plot storage was not blanked out after the
	           plot  was  generated.   IRESET  is  returned set to
	           zero.
	         = 1, plot storage is to  be  initialized  before  any
	           points  or  lines are inserted into the plot by the
	           current call to this routine.  However, unless this
	           routine  is  used  upon  a  computer which does not
	           allow the testing of the value of a variable  which
	           has  not yet been defined, having IRESET always set
	           to zero will produce the expected results since one
	           of  the  variables set within the routine is tested
	           at the start of the routine  to  determine  whether
	           the plot storage has been initialized.
	         = 2, 3, 4 or 5, plot storage  is  to  be  initialized
	           except  for  the character set, the dominance rules
	           and/or the size of the plot storage  which  can  be
	           predefined  by  the calling program.  These options
	           are described later in this documentation.


	      Arguments Returned by DAPLAT Containing Error Counts
	      --------- -------- -- ------ ---------- ----- ------

	  LTRERR = returned containing the number of points which were
	           outside the current plot.

	  LINERR = returned containing the  number  of  line  segments
	           which were completely outside the current plot.  If
	           a  pin  map  is  being   simulated,   LINERR   also
	           accumulates  the number of points which should have
	           been displayed on the plot, but for which there was
	           no  empty  location  within  the  allowed distance.
	           LTRERR and LINERR are returned containing the error
	           totals accumulated during all calls to DAPLAT which
	           added curves or points to the same plot.  If DAPLAT
	           is called with argument IPLOT equal to zero causing
	           the plot storage to be zeroed  after  printing  the
	           currently  stored  plot,  then it is the subsequent
	           call to DAPLAT which zeroes the error totals.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 317
	  DAPLAT, Scatter Plot Routine for Printer


	  Typical Scales Produced Using MSHWID Values in Range 1 to 10
	  ------- ------ -------- ----- ------ ------ -- ----- - -- --

	    XRIGHT=-XLEFT=150 and YUPPER=-YLOWER=1234500/(10**MSHWID)

	       1.2345E5 -+++++++++++++++++++++++++++++++++++++++++
	      -1.2345E5 -+++++++++++++++++++++++++++++++++++++++++
	                 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	                 *****************************************

	          12345 -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	         -12345 -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	                 ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! !
	                -2-1-1-1-9-8-6-5-3-2 0 2 3 5 6 8 9 1 1 1 2
	                E2E2E2E2E1E1E1E1E1E1  E1E1E1E1E1E1E2E2E2E2

	         1234.5 ---+--+--+--+--+--+--+--+--+--+--+--+--+--
	        -1234.5 ---+--+--+--+--+--+--+--+--+--+--+--+--+--
	                   !  !  !  !  !  !  !  !  !  !  !  !  !
	                  -1 -1 -90-68-45-23 0  23 45 68 90 1  1
	                  E2 E2                            E2 E2

	         123.45 -+---+---+---+---+---+---+---+---+---+---+
	        -123.45 -+---+---+---+---+---+---+---+---+---+---+
	                 !   !   !   !   !   !   !   !   !   !   !
	               -150-120 -90 -60 -30  0  30  60  90  120 150

	         12.345 -+----+----+----+----+----+----+----+----+
	        -12.345 -+----+----+----+----+----+----+----+----+
	                 !    !    !    !    !    !    !    !    !
	               -150 -113  -75 -37.5  0   37.5 75   113  150

	         1.2345 ---+-----+-----+-----+-----+-----+-----+--
	        -1.2345 ---+-----+-----+-----+-----+-----+-----+--
	                   !     !     !     !     !     !     !
	                 -135   -90   -45    0    45    90    135

	        0.12345 -------+------+------+------+------+------
	       -0.12345 -------+------+------+------+------+------
	                       !      !      !      !      !
	                     -105   -52.5    0    52.5    105

	       0.012345 -----+-------+-------+-------+-------+----
	      -0.012345 -----+-------+-------+-------+-------+----
	                     !       !       !       !       !
	                   -120     -60      0      60      120

	       1.235E-3 ---+--------+--------+--------+--------+--
	      -1.235E-3 ---+--------+--------+--------+--------+--
	                   !        !        !        !        !
	                 -135     -67.5      0      67.5      135
	  FASP, FORTRAN Alphameric Subroutine Package         Page 318
	  DAPLAT, Scatter Plot Routine for Printer


	                An Example of the use of DAPLAT
	                -- ------- -- --- --- -- ------

	  As an example of the use  of  this  routine,  the  following
	  program  was  used  to  generate the 3 plots shown below the
	  program.

	        DIMENSION XPOINT(10),YPOINT(10)
	        DATA XPOINT/0. ,1. ,2. ,3. ,4. ,0. ,1. ,2. ,3. ,4. /
	        DATA YPOINT/1. ,1.5,2.5,2.5,1.5,2. ,2.3,3. ,2.5,2. /
	        DATA IRESET,IDISK/1,1/
	        DO 2 JGRID=1,3
	        IGRID=JGRID-1
	        WRITE(IDISK,1)IGRID
	      1 FORMAT(7H IGRID=,I2)
	  C
	  C  IPLOT=-1 MAXWID=41 MAXHIH=16 LETTER=1  KONECT=2
	  C MINSUB=1  MAXSUB=5   XLEFT=0  YLOWER=.5 XRIGHT=4
	  C YUPPER=3.5 IEDGE=0  MARGIN=0  MSHWID=0  MSHHIH=0 LTROFF=0
	  C LINOFF=0  LINPRT=1
	        CALL DAPLAT(-1,41,16,1,2,
	       1XPOINT,YPOINT,1,5,0.,.5,4.,
	       23.5,IGRID,0,0,0,0,0,
	       30,1,IDISK,IRESET,LTRERR,LINERR)
	  CHANGING IPLOT=0, LETTER=3, KONECT=4, MINSUB=6, MAXSUB=10
	        CALL DAPLAT(0,41,16,3,4,
	       1XPOINT,YPOINT,6,10,0.,.5,4.,
	       23.5,IGRID,0,0,0,0,0,
	       30,1,IDISK,IRESET,LTRERR,LINERR)
	      2 WRITE(IDISK,3)
	      3 FORMAT(//)
	        STOP
	        END

	   IGRID= 0
	  *      3.5 -+---------+---------+---------+---------+
	  *           !         !         !         !         !
	  *           !         !         !         !         !
	  *           !         !        DCDD       !         !
	  *           !         !    DDDD !  DDDDD  !         !
	  *      2.5 -+---------+-DDD----BABBBBBBB&&&D--------+
	  *           !       DDCD     BB !         !B&DD     !
	  *           !  DDDDD  !    BB   !         !  BBDDDD !
	  *           CDD       !  BB     !         !    BB  DC
	  *           !         !BB       !         !      BB !
	  *      1.5 -+--------BA---------+---------+--------BA
	  *           !    BBBB !         !         !         !
	  *           ! BBB     !         !         !         !
	  *           AB        !         !         !         !
	  *           !         !         !         !         !
	  *      0.5 -+---------+---------+---------+---------+
	  *           !         !         !         !         !
	  *           0         1         2         3         4
	  FASP, FORTRAN Alphameric Subroutine Package         Page 319
	  DAPLAT, Scatter Plot Routine for Printer


	   IGRID= 1
	  *      3.5 -+---------+---------+---------+---------+
	  *           !                                       !
	  *           !                                       !
	  *           !                  DCDD                 !
	  *           !              DDDD    DDDDD            !
	  *      2.5 -+         + DDD    BABBBBBBB&&&D        +
	  *           !       DDCD     BB            B&DD     !
	  *           !  DDDDD       BB                BBDDDD !
	  *           CDD          BB                    BB  DC
	  *           !          BB                        BB !
	  *      1.5 -+        BA         +         +        BA
	  *           !    BBBB                               !
	  *           ! BBB                                   !
	  *           AB                                      !
	  *           !                                       !
	  *      0.5 -+---------+---------+---------+---------+
	  *           !         !         !         !         !
	  *           0         1         2         3         4



	   IGRID= 2
	  *      3.5 -+---------+---------+---------+---------+
	  *           !                                       !
	  *           !                                       !
	  *           !                  DCDD                 !
	  *           !              DDDD    DDDDD            !
	  *      2.5 -+           DDD    BABBBBBBB&&&D        +
	  *           !       DDCD     BB            B&DD     !
	  *           !  DDDDD       BB                BBDDDD !
	  *           CDD          BB                    BB  DC
	  *           !          BB                        BB !
	  *      1.5 -+        BA                            BA
	  *           !    BBBB                               !
	  *           ! BBB                                   !
	  *           AB                                      !
	  *           !                                       !
	  *      0.5 -+---------+---------+---------+---------+
	  *           !         !         !         !         !
	  *           0         1         2         3         4
	  FASP, FORTRAN Alphameric Subroutine Package         Page 320
	  DAPLAT, Scatter Plot Routine for Printer


	                  Modification of Plot Format
	                  ------------ -- ---- ------

	  If an internal grid is  not  generated,  then  at  any  edge
	  either  the outermost grid line or the border, but not both,
	  can be ruled.  If an internal grid is  not  generated,  then
	  the  digits in the tens and hundreds position in the decimal
	  integer value of IGRID can be used to suppress the ruling of
	  specific  outermost  grid lines.  If an internal grid is not
	  being generated but a  particular  outermost  grid  line  is
	  requested,  then the corresponding border is not ruled.  Any
	  border can be ruled if an internal grid is generated.  If an
	  internal  grid  is generated, or if neither an internal grid
	  nor a particular outermost grid  line  is  being  generated,
	  then the value of the tens or hundreds digits of the decimal
	  integer value of IEDGE can direct whether the  corresponding
	  border  is to be ruled.  The meanings assigned to each digit
	  in the value of IGRID are as follow

	  ONES DIGIT OF IGRID

	    0  The plot will show an internal grid.  The values of the
	       tens and hundreds digits of IGRID are ignored.
	    1  The plot will show the intersections of the lines of an
	       internal  grid,  but  will  not  include the grid lines
	       themselves.  The ruling of the outermost grid lines  is
	       controlled  by  the  values  in  the  tens and hundreds
	       digits of IGRID.
	    2  The plot will not include an internal grid.  The ruling
	       of the outermost grid lines is controlled by the values
	       in the tens and hundreds digits of IGRID.

	  TENS DIGIT OF IGRID

	    0  Show both the leftmost and rightmost grid lines.
	    1  Show leftmost grid line, but do not show rightmost grid
	       line.   Note  that  if  the  effective  value of MSHWID
	       equals the effective value  of  MAXWID  then  a  single
	       vertical  grid line is ruled and this grid line is both
	       the leftmost  and  rightmost  grid  line  and  will  be
	       plotted except for a tens digit value of 3.
	    2  Show rightmost grid line, but do not show leftmost grid
	       line.
	    3  Do not show either leftmost or rightmost grid lines.

	  HUNDREDS DIGIT OF IGRID

	    0  Show both the lower and upper grid lines.
	    1  Show lower grid line, but do not show upper grid  line.
	       Note  that  if the effective value of MSHHIH equals the
	       effective value of MAXHIH then a single horizontal grid
	       line  is ruled and this grid line is both the lower and
	       upper grid line  and  will  be  plotted  except  for  a
	       hundreds digit value of 3.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 321
	  DAPLAT, Scatter Plot Routine for Printer


	    2  Show upper grid line, but do not show lower grid line.
	    3  Do not show either lower or upper grid lines.

	  The tens and hundreds digits in the decimal integer value of
	  IEDGE  are  used to suppress the ruling of specific edges of
	  the plot which do not happen to coincide with  visible  grid
	  lines.   The meanings assigned to each digit in the value of
	  IEDGE are as follow

	  ONES DIGIT OF IEDGE

	    0  Show numbers both to the left of and below the plot.
	    1  Show numbers to the left of the plot, but not below the
	       plot.
	    2  Show numbers below the plot, but not to the left of the
	       plot.
	    3  Do not show numbers either to the left of or below  the
	       plot.

	  TENS DIGIT OF IEDGE

	    0  Show both the left and right border lines.
	    1  Show left border line, but do not show the right border
	       line.
	    2  Show right border line, but do  not  show  left  border
	       line.
	    3  Do not show either left or right border lines.

	  HUNDREDS DIGIT OF IEDGE

	    0  Show both the lower and upper border lines.
	    1  Show lower border line,  but  do  not  show  the  upper
	       border line.
	    2  Show upper border line, but do not  show  lower  border
	       line.
	    3  Do not show either lower or upper border lines.


	           Erasure of Points, Lines and Pin Clusters
	           ------- -- ------  ----- --- --- --------

	  A LETTER argument value of -1 will cause the erasure of  the
	  specified points, lines or selected levels in pin clusters.

	  If LETTER is  -1  and  KONECT  is  zero  (or  greater),  all
	  printing  characters  will  be  changed  to spaces along the
	  lines specified by values in the XPOINT and YPOINT arrays.

	  If LETTER is -1 and KONECT is less than  zero,  spaces  will
	  replace  the  printing characters on the edges of the square
	  selected by  taking  the  central  point  as  square  1  and
	  counting  the concentric squares around this point until the
	  absolute value of KONECT is reached.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 322
	  DAPLAT, Scatter Plot Routine for Printer


	  The illustrations shown below demonstrate erasure  of  edges
	  of  pin  clusters.   At  the left is shown the starting plot
	  completely filled with the letter A.  At the right is  shown
	  the  plot  after it has been modified by calling DAPLAT with
	  LETTER being -1 while KONECT was consecutively -1 (revealing
	  the  center point at 1,1), -3, -5, -7, -9 and -11 (revealing
	  the columns containing the left and right grid lines).   The
	  erasure  of each box required a separate call to DAPLAT with
	  XPOINT(1)=1.0, YPOINT(1)=1.0, MINSUB=1, and MAXSUB=1.

	   2 -AAAAAAAAAAAAAAAAAAAAA       2 -+A-A-AAAAAAAAAAA-A-A+
	      AAAAAAAAAAAAAAAAAAAAA          !A A A    !    A A A!
	      AAAAAAAAAAAAAAAAAAAAA          !A A A AAAAAAA A A A!
	      AAAAAAAAAAAAAAAAAAAAA          !A A A A  !  A A A A!
	      AAAAAAAAAAAAAAAAAAAAA          !A A A A AAA A A A A!
	   1 -AAAAAAAAAAAAAAAAAAAAA       1 -+A-A-A-A-A+A-A-A-A-A+
	      AAAAAAAAAAAAAAAAAAAAA          !A A A A AAA A A A A!
	      AAAAAAAAAAAAAAAAAAAAA          !A A A A  !  A A A A!
	      AAAAAAAAAAAAAAAAAAAAA          !A A A AAAAAAA A A A!
	      AAAAAAAAAAAAAAAAAAAAA          !A A A    !    A A A!
	   0 -AAAAAAAAAAAAAAAAAAAAA       0 -+A-A-AAAAAAAAAAA-A-A+
	      !         !         !          !         !         !
	      0         1         2          0         1         2

	  If LETTER is -2 and KONECT is -2 or less, then  spaces  will
	  replace  the  printing characters either on the edges of, or
	  within, the square selected by KONECT.  LETTER values of  -1
	  and  -2  are  equivalent  if KONECT is -1 or greater.  As an
	  example of the erasure of entire pin  clusters,  a  starting
	  plot  completely  filled  with  the letter A was modified to
	  produce the plot shown below  by  specifying  the  X  and  Y
	  coordinates listed to its left with LETTER=-2 and KONECT=-3.

	                             2 -AAAAAAAAAAA-----AA--+
	           X     Y              !    AAAAAA     AA  !
	                                !    AAAAAA     AA  !
	          0.0   0.0             !    AAA        AAAAA
	          0.2   1.4             !    AAA     AAAAAAAA
	          0.7   0.2          1 -+    AAA  +  AAA    +
	          1.0   1.0             AAAAAAAA     AAA    !
	          1.3   1.8             AAAAA        AAA    !
	          1.8   0.6             !  AA     AAAAAA    !
	          2.0   2.0             !  AA     AAAAAA    !
	                             0 -+--AA-----AAAAAAAAAAA
	                                !         !         !
	                                0         1         2


	    Increasing Maximum Plot Size and Restoring Plot Storage
	    ---------- ------- ---- ---- --- --------- ---- -------

	  As supplied, DAPLAT contains a storage array large enough to
	  hold  5151  characters,  this being the number of characters
	  needed for a plot of the default size of 51  lines  each  of
	  FASP, FORTRAN Alphameric Subroutine Package         Page 323
	  DAPLAT, Scatter Plot Routine for Printer


	  101  characters.   This  plot  storage  is  contained in the
	  labeled block COMMON/FASPA/ which must contain at  least  20
	  words  more  than  the  words  needed to store MAXWID*MAXHIH
	  characters, six characters being held in the right  30  bits
	  of  each  word.   The  20 additional words store information
	  about plot size  and  scaling.   The  labeled  common  block
	  COMMON/FASPA/  contains  all  the  information  necessary to
	  generate the plot, with the exception of the character  list
	  in   COMMON/FASPB/,   the   character   dominance  rules  in
	  COMMON/FASPC/ (needed if more points  or  lines  are  to  be
	  added to the same plot), and the arguments LINPRT and IDISK.

	  If a plot is requested which is larger than can be  held  in
	  the labeled common block, then the effective value of MAXHIH
	  is reduced so that the plot will fit.   The  labeled  common
	  block  can be made larger than the 879 locations (calculated
	  as 20+(((51*101)+5)/6) words) provided in this routine if

	    a. The larger specification of the  labeled  common  block
	       COMMON/FASPA/  is loaded by the calling program or by a
	       block data routine before DAPLAT  is  loaded.   On  the
	       DECsystem10  computer  at least, the specification of a
	       labeled common block which is loaded first  establishes
	       its  length,  but  must  be  at  least  as large as the
	       specification of the same common block in  any  routine
	       which is loaded later.

	    b. The first three locations in the labeled  common  block
	       COMMON/FASPA/ are integer.

	    c. Prior  to  the  first  call  to  DAPLAT,  the  first  3
	       locations in the labeled common block COMMON/FASPA/ are
	       loaded with the following information either by a block
	       data routine or by the main program.

	        1st location (initialized to have  the  value  859  if
	            this  routine  is  called with IRESET=1 or 4) must
	            contain a value which is 20 less  than  the  total
	            number of locations in this common block.  This is
	            the number of locations in this common block which
	            can  be  used  to  store  values  identifying  the
	            characters which  are  to  appear  upon  the  plot
	            surface.

	        2nd location (initialized to have the value 30 if this
	            routine is called with IRESET=1 or 4) must contain
	            a value which is 3 more than the maximum value  of
	            the  arguments  LETTER  and  KONECT.   This is the
	            number  of  different  characters  by  which  data
	            points  and lines can be represented, including in
	            this count the space indicating an empty position,
	            and  the  ampersand  indicating superimposed data.
	            If the second location in COMMON/FASPA/ is set  to
	            a  value greater than 30, then the calling program
	  FASP, FORTRAN Alphameric Subroutine Package         Page 324
	  DAPLAT, Scatter Plot Routine for Printer


	            must  also  allocate  a   correspondingly   larger
	            COMMON/FASPB/   and   COMMON/FASPC/,  must  itself
	            define the contents of  these  common  blocks  and
	            must  call  this  routine  initially  with  IRESET
	            having the value 5 to prevent the redefinition  by
	            this  routine  of  the  contents  of  these common
	            blocks.  If the second location  in  COMMON/FASPA/
	            is  set  to the value 3, then the space, ampersand
	            and nondominant asterisk (or whatever  happens  to
	            be  selected when LETTER or KONECT is set to zero)
	            would be the only characters allowed,  other  than
	            those   forming  the  grid  lines  and  grid  line
	            intersections, in the plot.

	        3rd location (initialized to have the value 6 if  this
	            routine is called with IRESET=1 or 4) must contain
	            a value which is 1 more than the number  of  times
	            the  value  in  the second location in this common
	            block can be multiplied by itself and still  yield
	            as  the  result  a  value which can be stored as a
	            positive single precision integer by the  computer
	            upon which this routine is being run.  This is the
	            number  of  characters,  each  of  which  can   be
	            identified  by a value in the range zero through 1
	            less than the value in the 2nd  location  in  this
	            common  block,  which can be stored in each of the
	            locations in an array the dimension  of  which  is
	            indicated  by  the  value in the first location in
	            this common block.  The value in this 3rd location
	            cannot  exceed 22 unless the size of COMMON/FASPD/
	            is increased.  If LETTER or  KONECT  can  take  on
	            values  through 27, then the values representing 6
	            characters can be packed into a single positive 32
	            bit  number.   If  LETTER and KONECT cannot exceed
	            zero, then the values representing  22  characters
	            can be packed into a single positive 36 bit number
	            although then one of the 3 possible values in each
	            byte  is  wasted  since the ampersand would not be
	            necessary.

	    d. The argument named IRESET has either of the values 2 or
	       5  when  this  routine  is first called.  These are the
	       only values of IRESET which initialize the rest of plot
	       storage  in  labeled common block COMMON/FASPA/, but do
	       not modify the values of the first 3 locations.  IRESET
	       controls  the following selective initialization of the
	       plot storage in COMMON/FASPA/, of the character list in
	       COMMON/FASPB/  and  of the character dominance rules in
	       COMMON/FASPC/.

	       IRESET = 0, the  entire  plot  storage,  the  character
	                list,  and  the  character dominance rules are
	                not changed.
	              = 1, the entire plot storage, the character list
	  FASP, FORTRAN Alphameric Subroutine Package         Page 325
	  DAPLAT, Scatter Plot Routine for Printer


	                and the dominance rules are to be initialized.
	              = 2, the character list, the character dominance
	                rules,  and  all but the first three locations
	                in the plot storage  are  to  be  initialized.
	                The  first three locations in the plot storage
	                are not changed.
	              = 3,  the  character  list  and  the   character
	                dominance  rules  are  to be initialized.  The
	                entire plot storage is not changed.
	              = 4,  the  entire  plot   storage   is   to   be
	                initialized.  The character list and character
	                dominance rules are not changed.
	              = 5, all but the first three  locations  in  the
	                plot  storage  are  to  be  initialized.   The
	                character list, the character dominance  rules
	                and  the  first  three  locations  in the plot
	                storage are not changed.

	  A partially constructed plot  can  be  added  to  and/or  be
	  displayed by another program if

	    a. DAPLAT has been called with its  argument  IPLOT  being
	       given   either  of  the  values  -1  or  1  so  that  a
	       description of the plot is  preserved  in  the  labeled
	       block COMMON/FASPA/.

	    b. The entire contents of COMMON/FASPA/ are written into a
	       binary file after DAPLAT returns control to the calling
	       program.  If the character set or the  dominance  rules
	       have  been  changed, then the contents of COMMON/FASPB/
	       and of COMMON/FASPC/ should similarly be  written  into
	       the file.

	    c. The subsequent program restores  the  contents  of  the
	       common  block  or  blocks,  then defines IRESET to be 3
	       before DAPLAT is first called if only the  contents  of
	       COMMON/FASPA/  have  been  restored,  or  else  defines
	       IRESET to be zero if the contents of COMMON/FASPB/  and
	       of COMMON/FASPC/ have similarly been restored.


	     Changing the Character Set Used for Points and Curves
	     -------- --- --------- --- ---- --- ------ --- ------

	  The labeled block COMMON/FASPB/ contains the characters with
	  which  DAPLAT  represents  points  and  curves.  This common
	  block is dimensioned  at  35,  and  contains  the  following
	  characters

	  FASP, FORTRAN Alphameric Subroutine Package         Page 326
	  DAPLAT, Scatter Plot Routine for Printer


	        COMMON/FASPB/LTRALL(35)
	        DIMENSION LTRBGN(35)
	        DATA LTRBGN/1H ,1H*,1H!,1H-,1H+,1H ,1H&,1H*,1HA,1HB,
	       1            1HC,1HD,1HE,1HF,1HG,1HH,1HI,1HJ,1HK,1HL,
	       2            1HM,1HN,1HO,1HP,1HQ,1HR,1HS,1HT,1HU,1HV,
	       3            1HW,1HX,1HY,1HZ,1H*/
	        DO 1 I=1,35
	      1 LTRALL(I)=LTRBGN(I)

	  LTRALL(1)  and  LTRBGN(2)  contain  the   carriage   control
	  characters used for LINPRT=0 and 1 respectively.

	  LTRALL(3) through LTRALL(5) contain the characters used  for
	  vertical grid lines, for horizontal grid lines, and for grid
	  line intersections respectively.

	  LTRALL(6)  contains  the  space  character  used   for   the
	  background  of  the  plot.  Changing this character does not
	  change  the  space  character  appearing  around  the  scale
	  numbers in the margins.

	  LTRALL(7) contains the ampersand used  where  curves  and/or
	  points coincide.

	  LTRALL(8) through LTRALL(35) contain the characters used for
	  LETTER or KONECT=0 through LETTER or KONECT=27 respectively.

	  The dominance rules for the characters in LTRALL(7)  through
	  and including LTRALL(35) are contained in COMMON/FASPC/.

	        COMMON/FASPC/MASTER(29)
	        MASTER(1)=1  !AMPERSAND DOMINANT OVER ALL BUT 2ND *
	        MASTER(2)=-1 !NONDOMINANT ASTERISK
	        DO 2 I=3,28
	      2 MASTER(I)=0  !ALPHABETIC LETTERS ALL OF SAME DOMINANCE
	        MASTER(29)=2 !DOMINANT ASTERISK

	  When characters having different values in the MASTER  array
	  coincide,  the  character  having  the  larger  value in the
	  MASTER array is dominant.  If the values are equal, then the
	  character  at that position is converted to an ampersand (or
	  to whatever happens to be in LTRALL(7)).

	  If either the character list or the dominance rules  are  to
	  be  changed,  then  either  a block data routine or the main
	  program must define both the LTRALL and  MASTER  arrays  and
	  DAPLAT  must  be  called  the  first time with IRESET set to
	  either 4 or 5 depending upon whether or  not  DAPLAT  is  to
	  initialize the first three locations in COMMON/FASPA/.

	  If LETTER and KONECT are to be allowed  to  take  on  values
	  greater  than  27,  then the calling program must allocate a
	  correspondingly larger COMMON/FASPB/ and COMMON/FASPC/, must
	  itself  define the first three locations in COMMON/FASPA/ as
	  FASP, FORTRAN Alphameric Subroutine Package         Page 327
	  DAPLAT, Scatter Plot Routine for Printer


	  well  as  the  entire  contents  of  COMMON/FASPB/  and   of
	  COMMON/FASPC/  before this routine is first called, and must
	  call this routine initially with IRESET having the  value  5
	  to  prevent  the redefinition by this routine of any of this
	  information.

	  Plots are constructed using the characters in  COMMON/FASPB/
	  when DAPLAT is called having the argument IPLOT greater than
	  or equal to zero.  Only the position of the  letters  within
	  the common block as indicated by the values of LETTER and/or
	  KONECT are used when storing the plot, so  the  same  stored
	  curves and/or points can be plotted with different character
	  sets by different calls to DAPLAT.


	         Hidden Switch used to Enable Time Series Plots
	         ------ ------ ---- -- ------ ---- ------ -----

	  This section describes a feature of DAPLAT which allows  its
	  use  for  the  construction of tall plots formed of segments
	  generated one per each DAPLAT call.   This  feature  is  not
	  meant  for  the  casual  user,  but is described so that the
	  total interface presented by DAPLAT to all other programs is
	  documented.

	  The hidden switch is merely  a  2  state,  on/off  condition
	  enabled  by  the  sign of the argument IGRID which would not
	  logically have a negative value.   If  IGRID  is  less  than
	  zero,  then  1  less  than  its  absolute  value  is used as
	  described in the preceding portion of this manual,  and  the
	  bottom  line  of  the  plot  is not represented in the plot.
	  Instead, after the plot has been generated,  the  characters
	  stored  for the bottom line replace those stored for the top
	  line and the rest of the plot storage is left empty.

	  The following sample plots demonstrate the results  obtained
	  by  the  use  of the hidden switch.  The double lines at the
	  tops of the left two plots and at the bottom  of  the  third
	  plot  are  margin  lines which are visible since they do not
	  coincide with grid lines.

	        IGRID=1        IGRID=-2       IGRID=1        IGRID=-2
	        LINOFF=0       LINOFF=0       LINOFF=1       LINOFF=1

	        !       !      !       ! 2.3 -+---+---+ 2.3 -+---+---+
	     2 -+---+---+   2 -+---+---+      !       !      !       !
	        !       !      !       !      !       !      !       !
	        !       !      !       ! 1.3 -+   +   + 1.3 -+   +   +
	     1 -+   +   +   1 -+   +   +      !       !      !       !
	        !       !      !       !      !       !      !       !
	        !       !      !       ! 0.3 -+---+---+ 0.3 -+---+---+
	     0 -+---+---+                     !       !
	        !   !   !                     !   !   !
	       100 200 300                   100 200 300
	  FASP, FORTRAN Alphameric Subroutine Package         Page 328
	  DAPLAT, Scatter Plot Routine for Printer


	                 Rationalization of Plot Scales
	                 --------------- -- ---- ------

	  The proportions of the grid superimposed upon the plot  area
	  by  the  DAPLAT  routine  must  be  specified by the calling
	  program.  The numbers which are printed beside and below the
	  plot  merely  represent the data unit coordinates plotted at
	  the centers of the columns and lines which bear grid  lines.
	  The  range  of  data  unit  coordinates represented by these
	  scales can be difficult to interpret if the calling  program
	  holds  the  grid  proportions  constant  while attempting to
	  obtain the maximum resolution by adjusting the  minimum  and
	  maximum  coordinates  to  spread  the curves across the full
	  width or height of the plot.  DAPLAT cannot itself calculate
	  the grid proportions which would produce a minimum number of
	  nonzero digits in each scale number.  If predetermined  grid
	  spacings  and  offsets  are  not necessary, then the routine
	  DAGRID can be called once for each scale before the data  is
	  plotted  to  select  the  grid proportions and to expand the
	  coordinate ranges slightly to give neater scale numbers.

	  If DAGRID is used to rationalize the horizontal scale,  then
	  the argument list can be stated as

	        SUBROUTINE DAGRID(JSTIFY,MAXWID,XLEFT ,XRIGHT,MSHWID,
	       1    LTROFF)

	  or, if the routine  is  used  to  rationalize  the  vertical
	  scale, then the argument list can instead by stated as

	        SUBROUTINE DAGRID(JSTIFY,MAXHIH,YLOWER,YUPPER,MSHHIH,
	       1    LINOFF)

	  The first two arguments, JSTIFY and MAXWID,  are  used  only
	  for   input  and  are  returned  unchanged.   The  next  two
	  arguments, XLEFT and XRIGHT (or YLOWER and YUPPER), are used
	  both  for  input of the original range and for returning the
	  modified range.  The final two arguments, MSHWID and  LTROFF
	  (or  MSHHIH  and  LINOFF),  are  used  only  for returning a
	  description of the grid to the  calling  program  and  their
	  input  values  are  ignored.  These arguments are defined as
	  follow.

	  JSTIFY = -2, a grid line is  to  be  included  in  the  left
	           column  (or bottom line) of the plot which would be
	           produced by DAPLAT.
	         = -1, the data unit  coordinate  represented  by  the
	           value  of  XLEFT  (or YLOWER) is to be shown in the
	           left column (or bottom  line)  of  the  plot  which
	           would be produced by DAPLAT.
	         = 0, the data unit coordinate  range  represented  by
	           the  values  of  XLEFT  and  XRIGHT  (or YLOWER and
	           YUPPER) is to be centered in the plot  which  would
	           be produced by DAPLAT.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 329
	  DAPLAT, Scatter Plot Routine for Printer


	         = 1, the data  unit  coordinate  represented  by  the
	           value  of  XRIGHT (or YUPPER) is to be shown in the
	           right column (or top line) of the plot which  would
	           be produced by DAPLAT.
	         = 2, a grid line is  to  be  included  in  the  right
	           column  (or  top  line)  of the plot which would be
	           produced by DAPLAT.

	  MAXWID = width (or height) of the plot stated as the  number
	           of  columns (or lines).  MAXWID should not be input
	           containing a zero or negative value.

	  XLEFT  = input containing the data  unit  coordinate  to  be
	           represented  by  the  center of the left column (or
	           bottom line) of plot.  This should be the  smallest
	           data unit coordinate to be represented if the scale
	           increases toward the right (or  top)  since  DAGRID
	           allows  computation errors which place the returned
	           limiting  data  unit  coordinates  into  the  outer
	           halves of the outermost columns (or lines).
	         = returned containing the data unit coordinate  which
	           would  give  a rational scale if represented by the
	           center of the left column (or of the  bottom  line)
	           of the plot.

	  XRIGHT = input containing the data  unit  coordinate  to  be
	           represented  by  the center of the right column (or
	           top line) of the plot.  This should be the  largest
	           data unit coordinate to be represented if the scale
	           increases toward the right (or top).
	         = returned containing the data unit coordinate  which
	           would  give  a rational scale if represented by the
	           center of the right column (or of the top line)  of
	           the plot.

	  MSHWID = returned containing the  grid  division  width  (or
	           height)  stated as the number of columns (or lines)
	           which would  give  a  rational  scale.   MSHWID  is
	           returned  containing  1  more  than  the  number of
	           columns (or lines) between successive  columns  (or
	           lines) which should bear grid lines.
	         = 0, returned if this routine could  not  rationalize
	           the  scale.   This  could happen if either the data
	           unit coordinate range or the width of the  plot  is
	           too small.

	  LTROFF = returned  containing  the  number  of  columns  (or
	           lines)  by  which  the  left  (or bottom) grid line
	           should be offset from the left (or bottom) edge  of
	           the plot to give a rational scale.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 330
	  DAPLAT, Scatter Plot Routine for Printer


	                An Example of the Use of DAGRID
	                -- ------- -- --- --- -- ------

	  The following demonstration program asks the  user  to  type
	  the  plot width and the limiting data unit coordinates, then
	  calls DAPLAT to display scales  for  each  of  the  possible
	  values  of JSTIFY.  A typical dialog between the program and
	  its user is shown after the listing of the program.

	  C     PROGRAM TO DEMONSTRATE DAGRID ROUTINE
	        DIMENSION XPOINT(2),YPOINT(2)
	        DATA YPOINT/0.0,0.0/
	        DATA ITTY,JTTY/5,5/
	        DIMENSION EXAMPL(20)
	        IRESET=1
	      1 WRITE(JTTY,2)
	      2 FORMAT(7H WIDTH ,$)
	        READ(ITTY,3)MAXWID
	      3 FORMAT(I)
	        IF(MAXWID.LE.0)MAXWID=51
	        WRITE(JTTY,4)
	      4 FORMAT(7H RANGE ,$)
	        READ(ITTY,5)XLEFT,XRIGHT
	      5 FORMAT(2F)
	        XPOINT(1)=XLEFT
	        XPOINT(2)=XRIGHT
	        JSTIFY=-2
	      6 CALL DAGRID(JSTIFY,MAXWID,XLEFT,XRIGHT,MSHWID,LTROFF)
	        IF(MSHWID.LE.0)GO TO 1
	        IF(JSTIFY.EQ.-2)WRITE(JTTY,7)XLEFT,XRIGHT,MSHWID,
	       1LTROFF
	        IF(JSTIFY.EQ.-1)WRITE(JTTY,8)XLEFT,XRIGHT,MSHWID,
	       1LTROFF
	        IF(JSTIFY.EQ.0)WRITE(JTTY,9)XLEFT,XRIGHT,MSHWID,
	       1LTROFF
	        IF(JSTIFY.EQ.1)WRITE(JTTY,10)XLEFT,XRIGHT,MSHWID,
	       1LTROFF
	        IF(JSTIFY.EQ.2)WRITE(JTTY,11)XLEFT,XRIGHT,MSHWID,
	       1LTROFF
	      7 FORMAT(1X/22H LEFT JUSTIFIED GRID  ,2E14.6,2I3)
	      8 FORMAT(1X/22H LEFT JUSTIFIED RANGE ,2E14.6,2I3)
	      9 FORMAT(1X/22H CENTERED RANGE       ,2E14.6,2I3)
	     10 FORMAT(1X/22H RIGHT JUSTIFIED RANGE,2E14.6,2I3)
	     11 FORMAT(1X/22H RIGHT JUSTIFIED GRID ,2E14.6,2I3)
	        CALL DAPLAT(0,MAXWID,1,0,0,
	       1XPOINT,YPOINT,1,2,XLEFT,0.0,XRIGHT,
	       21.0,0,2,5,MSHWID,1,LTROFF,
	       30,0,5,IRESET,LTRERR,LINERR)
	        IF(JSTIFY.GT.1)GO TO 1
	        XLEFT=XPOINT(1)
	        XRIGHT=XPOINT(2)
	        JSTIFY=JSTIFY+1
	        GO TO 6
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 331
	  DAPLAT, Scatter Plot Routine for Printer


	  WIDTH 51
	  RANGE -27 79

	  LEFT JUSTIFIED GRID   -0.500000E+02  0.888889E+02  9  0
	       +-------***************************************---+
	       !        !        !        !        !        !
	      -50      -25       0       25       50       75

	  LEFT JUSTIFIED RANGE  -0.272727E+02  0.863636E+02 11  1
	       ************************************************--+
	        !          !          !          !          !
	       -25         0         25         50         75

	  CENTERED RANGE        -0.318182E+02  0.818182E+02 11  3
	       +-************************************************+
	          !          !          !          !          !
	         -25         0         25         50         75

	  RIGHT JUSTIFIED RANGE -0.340909E+02  0.795455E+02 11  4
	       +--************************************************
	           !          !          !          !          !
	          -25         0         25         50         75

	  RIGHT JUSTIFIED GRID  -0.388889E+02  0.100000E+03  9  5
	       +---***************************************-------+
	            !        !        !        !        !        !
	           -25       0       25       50       75       100
	  WIDTH 51
	  RANGE 112 18

	  LEFT JUSTIFIED GRID    0.125000E+03  0.113636E+02 11  0
	       +-----******************************************--+
	       !          !          !          !          !
	      125        100        75         50         25

	  LEFT JUSTIFIED RANGE   0.112000E+03  0.120000E+02  5  1
	       ************************************************--+
	        !    !    !    !    !    !    !    !    !    !
	       110  100  90   80   70   60   50   40   30   20

	  CENTERED RANGE         0.116000E+03  0.160000E+02  5  3
	       +-************************************************+
	          !    !    !    !    !    !    !    !    !    !
	         110  100  90   80   70   60   50   40   30   20

	  RIGHT JUSTIFIED RANGE  0.118000E+03  0.180000E+02  5  4
	       +--************************************************
	           !    !    !    !    !    !    !    !    !    !
	          110  100  90   80   70   60   50   40   30   20

	  RIGHT JUSTIFIED GRID   0.113636E+03  0.000000E+00 11  6
	       +******************************************-------+
	             !          !          !          !          !
	            100        75         50         25          0
	  FASP, FORTRAN Alphameric Subroutine Package         Page 332
	  DARANK, Returns Sorted Integers Excluding Duplicates


	  DDDDD          AAA  RRRRRR          AAA  NN    NN  KK   KK
	  DD   DD       AAAA  RR    RR       AAAA  NNN   NN  KK  KK
	  DD    DD     AA AA  RR    RR      AA AA  NNNN  NN  KK KK
	  DD    DD    AA  AA  RRRRRR       AA  AA  NN NN NN  KKKKK
	  DD    DD   AAAAAAA  RR  RR      AAAAAAA  NN  NNNN  KKK KK
	  DD   DD   AA    AA  RR   RR    AA    AA  NN   NNN  KK   KK
	  DDDDD    AA     AA  RR    RR  AA     AA  NN    NN  KK    KK


	      DARANK, Returns Sorted Integers Excluding Duplicates
	      ------  ------- ------ -------- --------- ----------

	  A single call to DARANK interprets  an  array  read  by  the
	  calling  program with a multiple of an A1 format and returns
	  the decimal integer values represented by this  array.   The
	  returned   values  are  sorted  into  either  increasing  or
	  decreasing order and do not include  duplicate  values.   If
	  more  values are represented than can be stored in the array
	  provided by the calling program for returning these  values,
	  then  either  the  smallest  or  the  largest  values can be
	  discarded.

	  Numbers can be separated by spaces, by tab characters and/or
	  by  commas.   Excess  commas are ignored and do not indicate
	  either missing or zero values.  The evaluation is terminated
	  when  a  semicolon is found within the contents of the input
	  text buffer or else when all of the  characters  within  the
	  input  text  buffer  have  been interpreted.  An exclamation
	  point and any characters to its right are taken  to  form  a
	  comment  and  are  otherwise  ignored.  An ampersand and any
	  characters to its  right  are  similarly  ignored,  but  the
	  calling  program  is informed that an ampersand was found so
	  that the calling program can read new text  into  the  input
	  buffer  before  calling  this  routine again to continue the
	  evaluation.

	  The representation of a number  can  contain  leading  sign,
	  embedded   decimal  point  and/or  trailing  letter  E  with
	  possibly signed exponent.   A  percent  sign  following  the
	  number  implies  E-2,  trailing  letter  K  implies  E3  and
	  trailing letter M implies E6.  To be recognized as part of a
	  number,  the  percent sign or letter K or M or E must follow
	  either a sign or a digit or a decimal point,  otherwise  the
	  percent  sign  or  letter  K  or  M  or E will be an unknown
	  character.

	  Two versions of  this  routine  are  supplied.   The  longer
	  version,  named  DARANK,  requires that the routines DANEXT,
	  DASPAN and DAHEFT be  loaded  to  allow  the  evaluation  of
	  ranges   specified   in  either  slash,  colon  or  asterisk
	  notations.  The shorter version, named  DAIRNK,  treats  the
	  slash,  colon  and asterisk characters the same as any other
	  unknown characters, but only requires  that  the  additional
	  routines DAMISS and DAHEFT be loaded.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 333
	  DARANK, Returns Sorted Integers Excluding Duplicates


	  The range specifications accepted by the longer  version  of
	  this  routine  are  written  as a lower bound, increment and
	  upper bound  separated  by  slashes  or  by  colons  (the  2
	  characters  are equivalent).  If the increment is to be one,
	  then the lower and upper bounds need be separated only by  a
	  single  slash  or  by  a  single  colon.  If either bound is
	  missing, it is assumed to be zero.  The lower bound  is  the
	  first  number  of  the  series.   The series can then either
	  increase or decrease depending upon whether the upper  bound
	  is  less  than,  equal  to, or greater than the lower bound.
	  The sign of the increment is changed if it does not  conform
	  to  the  relative  values  of  the  bounds.   If  a range is
	  specified which contains more values than can be returned to
	  the  calling  program,  then  the portion of the range which
	  could contain acceptable values is calculated, so  that  all
	  values  within the originally specified range do not have to
	  be individually tested.

	  The longer version of this routine will also accept a single
	  value  preceded  by  a number and an asterisk.  The asterisk
	  notation is used by  other  routines  in  FASP  to  indicate
	  multiple  appearances  of  a  single  value, but the initial
	  number is ignored by DARANK other than to determine that  it
	  is  greater than zero.  If the initial number is not greater
	  than zero, then the value following the separating  asterisk
	  is not returned to the calling program.


	              The DARANK and DAIRNK Argument Lists
	              --- ------ --- ------ -------- -----

	  The argument lists of routines DARANK and DAIRNK are

	        SUBROUTINE DARANK(INCRES,IFTEST,MINMUM,MAXMUM,MINSTR,
	       1    MAXSTR,IBUFFR,MAXBFR,LOWBFR,KIND  ,MAXUSD,ISTORE)

	  and

	        SUBROUTINE DAIRNK(INCRES,IFTEST,MINMUM,MAXMUM,MINSTR,
	       1    MAXSTR,IBUFFR,MAXBFR,LOWBFR,KIND  ,MAXUSD,ISTORE)

	  both with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR),ISTORE(MAXSTR)

	  The argument lists of the 2 routines are identical, with the
	  exception    that    DAIRNK   does   not   recognize   range
	  specifications and so will not return  KIND  containing  the
	  value 5 which would indicate an illegal range specification.

	  The following arguments are used for input and are  returned
	  unchanged.

	  INCRES = specifies whether the returned  values  are  to  be
	  FASP, FORTRAN Alphameric Subroutine Package         Page 334
	  DARANK, Returns Sorted Integers Excluding Duplicates


	           sorted  into  decreasing  or  increasing order, and
	           whether it is the  smaller  or  the  larger  values
	           which are discarded when more values are found than
	           can  be  returned  in  ISTORE(MINSTR)  through  and
	           including ISTORE(MAXSTR).
	         = 1, the  returned  values  are  to  be  sorted  into
	           decreasing  order such that ISTORE(MINSTR) contains
	           a value greater  than  ISTORE(MINSTR+1).   If  more
	           values  are  found  than  can  be  returned  in the
	           available portion of the  ISTORE  array,  then  the
	           smaller values are discarded.
	         = 2, the  returned  values  are  to  be  sorted  into
	           decreasing  order such that ISTORE(MINSTR) contains
	           a value greater  than  ISTORE(MINSTR+1).   If  more
	           values  are  found  than  can  be  returned  in the
	           available portion of the  ISTORE  array,  then  the
	           larger values are discarded.
	         = 3, the  returned  values  are  to  be  sorted  into
	           increasing  order such that ISTORE(MINSTR) contains
	           a value smaller  than  ISTORE(MINSTR+1).   If  more
	           values  are  found  than  can  be  returned  in the
	           available portion of the  ISTORE  array,  then  the
	           smaller values are discarded.
	         = 4, the  returned  values  are  to  be  sorted  into
	           increasing  order such that ISTORE(MINSTR) contains
	           a value smaller  than  ISTORE(MINSTR+1).   If  more
	           values  are  found  than  can  be  returned  in the
	           available portion of the  ISTORE  array,  then  the
	           larger values are discarded.

	  IFTEST = specifies whether the calling program has specified
	           minimum  and/or  maximum  limits  to  the  range of
	           acceptable values.  Values which are  smaller  than
	           the  minimum  limit  or  which are greater than the
	           maximum limit are discarded  if  these  limits  are
	           specified.
	         = -2 or 2, there are no minimum and maximum limits to
	           the range of acceptable values.
	         = -1, values which are smaller than the value of  the
	           argument named MINMUM are discarded.
	         = 0, values which are smaller than the value  of  the
	           argument named MINMUM or which are greater than the
	           value of the argument named MAXMUM  are  discarded.
	           If  MINMUM  is  greater than MAXMUM, then no values
	           whatever will be accepted.
	         = 1, values which are greater than the value  of  the
	           argument named MAXMUM are discarded.

	  MINMUM = lower limit of the range of  acceptable  values  if
	           IFTEST has either of the values -1 or 0.  MINMUM is
	           ignored if IFTEST has any value other than -1 or 0.

	  MAXMUM = upper limit of the range of  acceptable  values  if
	           IFTEST  has either of the values 0 or 1.  MAXMUM is
	  FASP, FORTRAN Alphameric Subroutine Package         Page 335
	  DARANK, Returns Sorted Integers Excluding Duplicates


	           ignored if IFTEST has any value other than 0 or 1.

	  MINSTR = subscript of the first location in the ISTORE array
	           into  which  a  value can be stored if the argument
	           named KIND is input containing a value less than 3.
	           If  KIND  is  input  containing  a  value  of  3 or
	           greater, then ISTORE(MINSTR) through and  including
	           ISTORE(MAXUSD)  are  assumed  to contain a group of
	           integer values which were returned  by  a  previous
	           call  to  this routine sorted in the same direction
	           as currently requested and which are to  be  merged
	           with  the  values found by the current call to this
	           routine.

	  MAXSTR = subscript of the final location in the ISTORE array
	           into  which  a  value  can be stored.  This routine
	           does not report whether more values were found than
	           can  be  returned  in  the available portion of the
	           ISTORE array.  If the user is to be warned  by  the
	           calling  program  that  some values were discarded,
	           then the calling program should allocate  at  least
	           one  more  location  in  the  ISTORE  array than is
	           expected to  be  necessary.   The  calling  program
	           could  then  warn  the  user  that values have been
	           discarded  if  MAXUSD  is  returned  set  equal  to
	           MAXSTR.

	  IBUFFR = input buffer array containing characters  typed  by
	           the user, read by a multiple of an A1 format, which
	           is  to  be  searched  for  the  representations  of
	           numbers.   IBUFFR  then  contains  1  character per
	           computer storage location.

	  MAXBFR = subscript of the final (rightmost) location in  the
	           IBUFFR   array   which  can  be  searched  for  the
	           representation of a number.

	  The following arguments are used  both  for  input  to  this
	  routine and for output to the calling program.

	  LOWBFR = input containing the subscript  within  the  IBUFFR
	           array  of  the first (leftmost) character which can
	           be scanned for  the  representation  of  a  number.
	           LOWBFR  is  returned pointing beyond the end of the
	           buffer if no printing characters other than  commas
	           appear in addition to the numbers in the buffer, or
	           if either an exclamation point or an  ampersand  is
	           encountered.   If a semicolon is found, then LOWBFR
	           is returned pointing to the character to the  right
	           of  the  semicolon.   If  an  unknown  character is
	           found, then LOWBFR  is  returned  pointing  to  the
	           unknown  character  and  must be incremented by the
	           calling program before this routine is called again
	           to   continue   the  evaluation  of  the  remaining
	  FASP, FORTRAN Alphameric Subroutine Package         Page 336
	  DARANK, Returns Sorted Integers Excluding Duplicates


	           contents of the IBUFFR array.  The calling  program
	           must  reset  LOWBFR to point to the first character
	           in the buffer each time a new line of text is read.

	  KIND   = should be set to zero by the calling program before
	           this  routine is first called to return a new group
	           of sorted integers.  KIND  is  returned  describing
	           the  reason  for which control has been transferred
	           back to the calling program.  KIND should  be  sent
	           to the subsequent call to this routine unchanged if
	           additional values are to be searched for  following
	           an  error, or if an ampersand has directed that the
	           calling  program  read  new  text  into  the  input
	           buffer.  This routine will reset MAXUSD to have the
	           value MINSTR-1 if KIND is input containing a  value
	           less  than  3.   MAXUSD will be left unchanged, and
	           new values  will  be  merged  with  the  previously
	           sorted   values   in   ISTORE(MINSTR)  through  and
	           including   ISTORE(MAXUSD)   if   KIND   is   input
	           containing a value of 3 or greater.
	         = 1, returned if no printing  characters  other  than
	           commas  appear  in  addition  to the numbers in the
	           input buffer, or if an exclamation point  is  found
	           to  the  right of the numbers and/or commas.  If an
	           exclamation point is found, then the characters  to
	           the  right  of the exclamation point are assumed to
	           form a comment and are not evaluated and LOWBFR  is
	           returned  containing MAXBFR+1.  The calling program
	           should read a new  line  of  text  into  the  input
	           buffer  and  reset  LOWBFR  to  point  to the first
	           character in the new text before again calling this
	           or  any  other routine in FASP.  If this routine is
	           called again without  the  calling  program  having
	           first  changed the value of KIND to have a value of
	           3 (or  greater),  then  MAXUSD  will  be  reset  to
	           MINSTR-1  before  any  new values are searched for,
	           and any values already in the ISTORE array will  be
	           discarded.   If the subsequent call to this routine
	           is instead to  continue  the  merging  of  the  new
	           values   with  those  previously  found,  then  the
	           calling program should rest KIND to have the  value
	           3 (or greater) before this routine is again called.
	         = 2, returned if a semicolon is found to the right of
	           the numbers and/or commas in the input text buffer.
	           LOWBFR is returned pointing to the character to the
	           right  of the semicolon.  If this routine is called
	           again without  the  calling  program  having  first
	           changed  the value of KIND to have a value of 3 (or
	           greater), then MAXUSD will  be  reset  to  MINSTR-1
	           before  any  new  values  are searched for, and any
	           values  already  in  the  ISTORE  array   will   be
	           discarded.   If the subsequent call to this routine
	           is instead to  continue  the  merging  of  the  new
	           values   with  those  previously  found,  then  the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 337
	  DARANK, Returns Sorted Integers Excluding Duplicates


	           calling program should rest KIND to have the  value
	           3 (or greater) before this routine is again called.
	         = 3, returned if an ampersand was found to the  right
	           of  the  numbers  and/or commas.  The characters to
	           the right of the ampersand are assumed  to  form  a
	           comment  and are not evaluated.  LOWBFR is returned
	           containing MAXBFR+1.  The  calling  program  should
	           read  new  text  into  the  input  buffer and reset
	           LOWBFR to point to the first character of  the  new
	           text.   If this routine is called again without the
	           value of KIND having been  changed,  then  any  new
	           values  which  are  found will be merged with those
	           already in  ISTORE(MINSTR)  through  and  including
	           ISTORE(MAXUSD).
	         = 4, returned if an unknown character  was  found  in
	           the input text buffer.  LOWBFR is returned pointing
	           to this unknown character and must  be  incremented
	           by  the  calling  program  before  this  routine is
	           called again.  The letters  E,  K  and  M  and  the
	           percent  sign  are  unknown  if these do not appear
	           within numbers.   The  asterisk,  slash  and  colon
	           characters  are unknown to DAIRNK.  If this routine
	           is called again without the value  of  KIND  having
	           been  changed,  then any new values which are found
	           will be merged with those already in ISTORE(MINSTR)
	           through and including ISTORE(MAXUSD).
	         = 5, returned if  a  range  specification  was  found
	           which contains too many asterisks, too many slashes
	           or too many colons.  LOWBFR is returned pointing to
	           the  character  to the immediate right of the range
	           specification.  DAIRNK would  instead  return  KIND
	           containing  the  value  4  to  indicate  an unknown
	           character if an asterisk, slash or colon was found.
	           If  this  routine is called again without the value
	           of KIND having been changed, then  any  new  values
	           which  are  found will be merged with those already
	           in    ISTORE(MINSTR)    through    and    including
	           ISTORE(MAXUSD).

	  MAXUSD = returned containing the subscript  of  the  highest
	           location in the ISTORE array used for returning the
	           sorted values.   The  first  value  found  by  this
	           routine  is  placed  into ISTORE(MINSTR) if KIND is
	           input containing a value less than 3,  or  will  be
	           merged   into   the   sorted   numbers  already  in
	           ISTORE(MINSTR) through and including ISTORE(MAXUSD)
	           if KIND is input containing a value of 3 or greater
	           indicating that the previous call to  this  routine
	           has  already  begun  the evaluation of the group of
	           sorted numbers.

	  ISTORE = array in which the sorted  decimal  integer  values
	           are returned.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 338
	  DARANK, Returns Sorted Integers Excluding Duplicates


	                An Example of the Use of DARANK
	                -- ------- -- --- --- -- ------

	  The  following  demonstration  program  reports  the  values
	  represented  by  the  text typed by the user.  The values of
	  the arguments INCRES,  IFTEST,  MINMUM  and  MAXMUM  can  be
	  specified  by  the  user  when  the  program  is  started or
	  whenever a  semicolon  is  encountered  in  the  text  being
	  interpreted.   If  a  zero is typed for the value of INCRES,
	  then the former values of these arguments are  all  retained
	  unchanged.

	        DIMENSION ISTORE(100),IBUFFR(72),JBUFFR(72)
	        DATA INCRES,IFTEST,MINMUM,MAXMUM,KIND,MAXBFR,MINSTR,
	       1ITTY,JTTY/1,2,0,0,0,72,2,5,5/
	        WRITE(JTTY,1)
	      1 FORMAT(15H SIZE OF ARRAY ,$)
	        READ(ITTY,4)MAXSTR
	        MAXSTR=MINSTR+MAXSTR-1
	        IF(MAXSTR.GT.99)MAXSTR=99
	        ISTORE(MINSTR-1)=-999
	        ISTORE(MAXSTR+1)=-999
	        LOWBFR=MAXBFR+1
	      2 WRITE(JTTY,3)
	      3 FORMAT(29H INCRES,IFTEST,MINMUM,MAXMUM ,$)
	        READ(ITTY,4)ISAVE,JSAVE,KSAVE,LSAVE
	      4 FORMAT(4I)
	        IF(ISAVE.LE.0)GO TO 11
	        INCRES=ISAVE
	        IFTEST=JSAVE
	        MINMUM=KSAVE
	        MAXMUM=LSAVE
	        GO TO 11
	  C     OBTAIN NEW TEXT TO BE PROCESSED
	      5 WRITE(JTTY,6)
	      6 FORMAT(2H *,$)
	        GO TO 9
	      7 WRITE(JTTY,8)
	      8 FORMAT(2H &,$)
	      9 READ(ITTY,10)IBUFFR
	     10 FORMAT(72A1)
	        LOWBFR=1
	  C     EVALUATE TEXT AND REPORT RESULTS
	     11 CALL DARANK(INCRES,IFTEST,MINMUM,MAXMUM,MINSTR,
	       1MAXSTR,IBUFFR,MAXBFR,LOWBFR,KIND  ,MAXUSD,ISTORE)
	        IF(ISTORE(MINSTR-1).NE.-999)WRITE(JTTY,12)
	        IF(ISTORE(MAXSTR+1).NE.-999)WRITE(JTTY,12)
	     12 FORMAT(6H ERROR)
	        IF(MAXUSD.LT.MINSTR)GO TO 15
	        KOUNT=0
	        DO 13 INDEX=MINSTR,MAXUSD
	     13 CALL DANUMB(0,ISTORE(INDEX),10,JBUFFR,KOUNT,0,72)
	        WRITE(JTTY,14)(JBUFFR(I),I=1,KOUNT)
	     14 FORMAT(1X,72A1)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 339
	  DARANK, Returns Sorted Integers Excluding Duplicates


	     15 GO TO(5,2,7,16,18),KIND
	     16 WRITE(JTTY,17)IBUFFR(LOWBFR)
	     17 FORMAT(19H ILLEGAL CHARACTER ,1A1)
	        LOWBFR=LOWBFR+1
	        GO TO 11
	     18 WRITE(JTTY,19)
	     19 FORMAT(14H ILLEGAL RANGE)
	        GO TO 11
	        END


	  Typical Dialog Between User and DARANK Demonstration Program
	  ------- ------ ------- ---- --- ------ ------------- -------

	  SIZE OF ARRAY 10
	  INCRES,IFTEST,MINMUM,MAXMUM 3 0 -10 10
	  *-1001/5/1000
	  -6 -1 4 9
	  *-1000/5/1000
	  -10 -5 0 5 10
	  *-999/5/1000
	  -9 -4 1 6
	  *-998/5/1000
	  -8 -3 2 7
	  *-997/5/1000
	  -7 -2 3 8
	  *-996/5/1000
	  -6 -1 4 9
	  *-995/5/1000
	  -10 -5 0 5 10
	  *1001/5/-1000
	  -9 -4 1 6
	  *1000/5/-1000
	  -10 -5 0 5 10
	  *999/5/-1000
	  -6 -1 4 9
	  *998/5/-1000
	  -7 -2 3 8
	  *997/5/-1000
	  -8 -3 2 7
	  *996/5/-10000
	  -9 -4 1 6
	  *995/5/-1000;-50/10/50&SEMICOLON INTERUPTS PROCESSING
	  -10 -5 0 5 10
	  INCRES,IFTEST,MINMUM,MAXMUM 3 2
	  -40 -30 -20 -10 0 10 20 30 40 50
	  &-37-20+10-30,,-33&CONTINUES GROUP AFTER SEMICOLON ABOVE
	  -33 -30 -20 -10 0 10 20 30 40 50
	  &45+55&
	  -20 -10 0 10 20 30 40 45 50 55
	  &35 1000*5 *6 -3*6!LATTER 2 RANGES DON'T SPECIFY ANYTHING
	  0 5 10 20 30 35 40 45 50 55
	  FASP, FORTRAN Alphameric Subroutine Package         Page 340
	  DARITE, Free Format FORTRAN Output Routine


	  DDDDDD         AAAA  RRRRRRR   IIIIII  TTTTTTTTTT  EEEEEEEEE
	  DD    DD      AA AA  RR     RR   II        TT      EE
	  DD     DD    AA  AA  RR     RR   II        TT      EE
	  DD     DD   AA   AA  RRRRRRR     II        TT      EEEEE
	  DD     DD  AAAAAAAA  RR  RR      II        TT      EE
	  DD    DD  AA     AA  RR   RR     II        TT      EE
	  DDDDDD   AA      AA  RR    RR  IIIIII      TT      EEEEEEEEE


	           DARITE, Free Format FORTRAN Output Routine
	           ------  ---- ------ ------- ------ -------

	  DARITE represents a value so that it can be written  with  a
	  FORTRAN format statement containing a multiple A1 alphameric
	  specification.  The value can be represented either  with  a
	  specified  number  of  digits right of the decimal point and
	  with  a  maximum  number  of  significant  digits,   or   in
	  scientific notation as a number in the range 1.0 to 9.999...
	  with a following exponent.  If floating point  notation  has
	  been  requested, but the number cannot fit into the supplied
	  field with the specified  number  of  digits  right  of  the
	  decimal  point,  then  the  number  of  digits  right of the
	  decimal point will be decreased,  and  if  the  number  will
	  still  not  fit,  then scientific notation will be used.  If
	  the number will not fit into the field  even  in  scientific
	  notation, then the field will be filled with asterisks.

	  The representation of the number is rounded based  upon  the
	  digit which would be to the right of the rightmost displayed
	  digit.  If the digit to the right of the rightmost displayed
	  digit  is  0  through  4, then the displayed digits are left
	  unchanged.  If the digit  to  the  right  of  the  rightmost
	  displayed  digit  is 5 through 9, then the absolute value of
	  the displayed value is increased.


	                    The DARITE Argument List
	                    --- ------ -------- ----

	  The argument list of routine DARITE is

	        SUBROUTINE DARITE(VALUE ,JSTIFY,NOTATN,IPART ,ISIGN ,
	       1    KLIP  ,IFILL ,IWIDTH,MINDEC,MAXDEC,MINSIG,MAXSIG,
	       2    INIZRO,MARGIN,IDECML,IEXPNT,IFORMT,IZERO ,LFTCOL,
	       3    MAXBFR,IBUFFR,KOUNT ,IERR  )

	  with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR)

	  The following are input arguments left unchanged

	  VALUE  = the number to be represented
	  FASP, FORTRAN Alphameric Subroutine Package         Page 341
	  DARITE, Free Format FORTRAN Output Routine


	  JSTIFY = -1, left justify the representation of the value in
	           a field of width IWIDTH.
	         = 0, center the representation  of  the  value  in  a
	           field of width IWIDTH.
	         = 1, right justify the representation of the value in
	           a field of width IWIDTH.

	  NOTATN = -1,  represent  in  array  IBUFFR  the   value   in
	           scientific  notation.   The  value  1234  would  be
	           represented in IBUFFR as 1.234E3
	         = 0, represent in IBUFFR the value in floating  point
	           form.   The  value 1234.56 would be displayed as it
	           is written if the number of digits requested  right
	           of  the  decimal  point  is  2  and  if  at least 6
	           significant  digits  in  a  field  of  at  least  7
	           characters are allowed.
	         = 1, multiply value by 100  and  insert  the  percent
	           sign  following  digits  of  number.   IWIDTH  must
	           include room for this  percent  sign.   MINDEC  and
	           MAXDEC  refer  to  the displayed decimal point.  To
	           print tenths of a percent, MAXDEC  would  be  given
	           the value 1, and MINDEC would be 1 or less.
	         = 2, if the value is in range 1000 to 1000000, divide
	           the value by 1000 and insert the letter K following
	           the digits.  If the value is  1000000  or  greater,
	           divide the value by 1000000 and insert the letter M
	           following the digits.  IWIDTH must include room for
	           the  letter K or M.  MINDEC and MAXDEC refer to the
	           displayed decimal point.  MINDEC  and  MAXDEC  both
	           set at 2 would represent the value 1234 as 1.23K.
	         = 3, same as NOTATN=2 except that MINDEC  and  MAXDEC
	           refer  to  the decimal point in the original value,
	           not to the decimal point in the  displayed  number.
	           If  a K or M is displayed right of the number, then
	           MINDEC and MAXDEC values of -1  are  equivalent  to
	           values  of 0.  MINDEC=-2 indicates that there is no
	           lower limit to the number of digits to the right of
	           the  displayed  decimal  point, and is probably the
	           appropriate value unless it is absolutely necessary
	           to  display  the digits which would be to the right
	           of the decimal point in the original value, as  for
	           example  if  the  amounts  are  dollars and must be
	           displayed always including the cents  digits.   The
	           value  1234.56 would be represented as 1.23456K for
	           NOTATN=3 and MAXDEC=2.

	  IPART  = -1, if the value is represented in  floating  point
	           form,  completely  represent  this  value.   If the
	           value  is  represented  in   scientific   notation,
	           represent  only the normalized portion of the value
	           without the  exponent,  it  being  this  normalized
	           value  (in  the  range of 1.0 to 9.999...) which is
	           left  justified,  centered   or   right   justified
	           according  to  the  value  of JSTIFY.  IWIDTH must,
	  FASP, FORTRAN Alphameric Subroutine Package         Page 342
	  DARITE, Free Format FORTRAN Output Routine


	           however, contain sufficient  room  for  either  the
	           normalized   value   or   the  exponent,  whichever
	           requires the most characters to represent.
	         = 0, completely represent  the  value  regardless  of
	           whether in floating point or scientific notation.
	         = 1, if the value is represented  in  floating  point
	           form,  insert nothing (except the possible trailing
	           spaces indicated by IFILL)  into  IBUFFR.   If  the
	           value   is   represented  in  scientific  notation,
	           represent only the exponent portion, it being  this
	           exponent  portion which is left justified, centered
	           or  right  justified  according  to  the  value  of
	           JSTIFY.   IWIDTH  must, however, contain sufficient
	           room  for  either  the  normalized  value  or   the
	           exponent, whichever requires the most characters to
	           represent.

	  ISIGN  = -1, if the value is greater than zero, and if IPART
	           is  less  than  or equal to zero, then place a plus
	           sign to the  left  of  the  representation  of  the
	           value.   If  the value is equal to zero, do not add
	           an extra space where the plus or minus  sign  would
	           otherwise be.
	         = 0, if the value is greater than or equal  to  zero,
	           do  not  add  an  extra  space where the minus sign
	           would otherwise be.
	         = 1, if the value is greater than or equal  to  zero,
	           and  if IPART is less than or equal to zero, then a
	           space will  be  placed  at  the  left  end  of  the
	           representation  of  the value, where the minus sign
	           would otherwise be, even if the number of digits in
	           the representation must be reduced to make room for
	           this space.
	         = 2, if the value is greater than zero, and if  IPART
	           is  less  than  or equal to zero, then place a plus
	           sign to the  left  of  the  representation  of  the
	           value.  If the value is equal to zero, and if IPART
	           is less than or equal to zero, then place at  least
	           1  space  at  the left end of the representation of
	           the value even if  the  number  of  digits  in  the
	           representation  must  be  reduced  to make room for
	           this space.

	  KLIP   = -1, suppress representation of all zeroes which are
	           beyond  the first digit after the decimal point and
	           which do not have a non-zero digit to their  right.
	           If  centering or right justifying, it is the number
	           after removal of the zeroes which  is  centered  or
	           right justified.
	         = 0, represent as zeroes all zeroes which are to  the
	           right of the decimal point.
	         = 1, convert to spaces all zeroes  which  are  beyond
	           the  first  digit after the decimal point and which
	           do not  have  a  non-zero  digit  to  their  right.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 343
	  DARITE, Free Format FORTRAN Output Routine


	           Remaining  characters will be in the same positions
	           as if the zeroes where  nonzeroes.   If  NOTATN  is
	           greater  than  zero, then spaces can appear between
	           the nonspace  characters  of  the  number  and  the
	           following percent sign or K or M since the location
	           of these printing characters is not changed by  the
	           conversion of the trailing zeroes to spaces.
	         = -2, same as KLIP=-1, except  that  if  no  non-zero
	           digit  would  be  represented  to  the right of the
	           decimal  point,  then  the  zero  which  would   be
	           immediately  to  the  right of the decimal point is
	           not represented.  If centering or right justifying,
	           it  is  the  number  after  removal of these zeroes
	           which is centered or right justified.
	         = -3, same as KLIP=-2, except  that  if  no  non-zero
	           digit  would  be  represented  to  the right of the
	           decimal  point,  then  the  decimal  point  is  not
	           represented   either.    If   centering   or  right
	           justifying, it is the number after removal  of  the
	           decimal  point and the zeroes to its right which is
	           centered or right justified.
	         = 2, same as KLIP=1, except that if no non-zero digit
	           would  be  represented to the right of the right of
	           the decimal point, then the  zero  which  would  be
	           immediately  to  the  right of the decimal point is
	           also converted to a  space.   Remaining  characters
	           will be in the same positions as if the zeroes were
	           non-zeroes.
	         = 3, same as KLIP=2, except that if no non-zero digit
	           would  be  represented  to the right of the decimal
	           point, then the decimal point is also converted  to
	           a  space.  Characters which would be to the left of
	           the decimal point will be in the same positions  as
	           if  a  non-zero  digit appeared to the right of the
	           decimal point.

	           For example, the representations of the value 12.34
	           in  floating  point with MAXDEC=4 and in scientific
	           notation with IDECML=5 would be

	                for KLIP.LT.0      12.34        1.23E1
	                    KLIP=0       12.3400     1.23400E1
	                    KLIP=.GT.0   12.34       1.234  E1

	           The value 123000  would  be  represented  as  shown
	           below if NOTATN=2

	                for KLIP=-3       123K        1.23E5
	                    KLIP=-2      123.K        1.23E5
	                    KLIP=-1     123.0K        1.23E5
	                    KLIP=0   123.0000K     1.23000E5
	                    KLIP=1   123.0   K     1.23   E5
	                    KLIP=2   123.    K     1.23   E5
	                    KLIP=3   123     K     1.23   E5
	  FASP, FORTRAN Alphameric Subroutine Package         Page 344
	  DARITE, Free Format FORTRAN Output Routine


	  IFILL  = 0, do not fill the portion of the  field  right  of
	           the    rightmost    nonspace   character   in   the
	           representation of the  value  with  spaces.   KOUNT
	           will  be  left  pointing  at the rightmost nonspace
	           character in the representation of the value.   The
	           value  of  IFILL  has  no  effect  on  the nonspace
	           characters in the representation of the value.   If
	           IFILL=0,  and  if  IPART  is  less than or equal to
	           zero, then the characters originally in the  IBUFFR
	           array  to  the right of the nonspace portion of the
	           representation of the value are left intact.   (The
	           reason  why  IPART  when  greater  than  zero is an
	           exception is that the  normalized  portion  of  the
	           number must be temporarily stored in IBUFFR even if
	           it is not going to be  represented  since  possible
	           exponent  change  due  to  rounding must be checked
	           for.)
	         = 1, fill the field right of the nonspace portion  of
	           the representation of the value with spaces.  KOUNT
	           will be left pointing at LFTCOL+IWIDTH.

	  IWIDTH = the number of characters to  be  in  the  field  in
	           which   the  value  is  represented.   IWIDTH  must
	           include room for exponent, sign and  decimal  point
	           if these are necessary to represent the value.

	  The  following  arguments  control  the  format  of  numbers
	  displayed  in  floating  point form (without E exponent), or
	  displayed with  following  K,  M  or  percent  sign.   These
	  arguments  do  not control the format of numbers represented
	  in scientific notation (either with  displayed  exponent  or
	  with suppressed zero exponent).

	  MINDEC = minimum number of digits  right  of  the  displayed
	           decimal  point  in  numbers  which are displayed in
	           floating point form.  If it would be  necessary  to
	           represent  less  digits  right of the decimal point
	           than indicated by MINDEC, then the  value  will  be
	           represented  in  scientific  notation instead.  The
	           maximum number of digits right of the decimal point
	           is  determined  by  the  combination  of MAXDEC and
	           MAXSIG.
	         = -2, there is no lower limit to the number of digits
	           which  must  be  represented  right  of the decimal
	           point, and even the decimal point itself  need  not
	           be   represented.    MINDEC=-1   is  equivalent  to
	           MINDEC=-2 unless NOTATN=3 while VALUE  is  1000  or
	           greater.
	         = -1, if NOTATN is not 3, or if NOTATN is 3  but  the
	           value  being  represented  is  less than 1000, then
	           MINDEC=-1 is  equivalent  to  MINDEC=-2  such  that
	           there  is  no  lower  limit to the number of digits
	           which must be  represented  right  of  the  decimal
	           point,  and  even the decimal point itself need not
	  FASP, FORTRAN Alphameric Subroutine Package         Page 345
	  DARITE, Free Format FORTRAN Output Routine


	           be represented.

	           If  NOTATN=3  and  VALUE=1000  or   greater,   then
	           MINDEC=-1  would  have  the same effect as MINDEC=0
	           such that all digits to the  left  of  the  decimal
	           point   in   the   original   unshifted  value  (as
	           represented without K or M) must be included in the
	           actual  representation of the value even when the K
	           or M is included.  MINDEC should have the value  -2
	           if,  in  order  to  fit the representation into the
	           available field width while NOTATN=3, it is  to  be
	           possible  that a value which is equal to or greater
	           than 1000 be represented without all of the  digits
	           which  would be to the left of the decimal point in
	           the original value, or  even  without  the  decimal
	           point itself.
	         = equal or greater than zero, if NOTATN is not 3,  or
	           if  NOTATN  is 3 but the value being represented is
	           less than 1000, then MINDEC is the  minimum  number
	           of  digits  which  can  be  displayed  right of the
	           decimal point in a floating point number.  If  less
	           than  MINDEC digits would be displayed right of the
	           decimal point, then the value will  be  represented
	           in  scientific notation instead.  If MINDEC=0, then
	           it is not necessary that any  digits  be  displayed
	           right  of  the decimal point, but the decimal point
	           itself must be displayed.

	           If NOTATN=3 and VALUE=1000 or greater, then  MINDEC
	           is the minimum number of digits to the right of the
	           decimal point in the original value which  must  be
	           displayed.   If  VALUE is between 1000 and 1000000,
	           then at least MINDEC+3  digits  must  be  displayed
	           right of the decimal point.  If VALUE is 1000000 or
	           greater, then at  least  MINDEC+6  digits  must  be
	           displayed right of the decimal point.

	           For example, the value 1234.56 would be represented
	           as follows for various values of MINDEC and NOTATN.
	           It should be noted that when the digit 5  right  of
	           the  decimal  point  in  the  original value is not
	           represented, then the digit 4 left of  the  decimal
	           point is rounded upwards to 5.

	                                  NOTATN=0  NOTATN=2  NOTATN=3
	             for MINDEC=MAXDEC=-1     1235        1K    1.235K
	                 MINDEC=MAXDEC=0     1235.       1.K    1.235K
	                 MINDEC=MAXDEC=1    1234.6      1.2K   1.2346K
	                 MINDEC=MAXDEC=2   1234.56     1.23K  1.23456K

	  MAXDEC = maximum number of digits  right  of  the  displayed
	           decimal  point  in  numbers  displayed  in floating
	           point form.
	         = -2, represent as many digits right of  the  decimal
	  FASP, FORTRAN Alphameric Subroutine Package         Page 346
	  DARITE, Free Format FORTRAN Output Routine


	           point as the field will hold (up to a maximum total
	           number of digits specified by MAXSIG).
	         = -1, if NOTATN is not 3, or if NOTATN is 3  but  the
	           value   being   represented   is  less  than  1000,
	           represent only digits left of  the  decimal  point.
	           The  decimal  point itself will not be represented.
	           If more than IWIDTH or MAXSIG digits  would  appear
	           left  of the decimal point, then the number will be
	           represented in scientific notation.

	           If  NOTATN=3  and  VALUE=1000  or   greater,   then
	           MAXDEC=-1  would  have  the same effect as MAXDEC=0
	           such that all digits which would be to the left  of
	           the   decimal  point  in  the  original  value  (as
	           represented without K or M)  will  if  possible  be
	           included in the representation of the value shifted
	           for the K or M notation.  If MINDEC is greater than
	           -2, and if not all of the digits to the left of the
	           decimal point in the original unshifted  value  can
	           be  included  in the supplied field width, then the
	           value will instead  be  represented  in  scientific
	           notation.
	         = greater than or equal to zero, if NOTATN is not  3,
	           or  if  NOTATN is 3 but the value being represented
	           is less than 1000, represent the value with  MAXDEC
	           digits   right   of   decimal   point.    If   this
	           representation of the value will not fit  into  the
	           field  size  indicated  by  IWIDTH  or MAXSIG, then
	           reduce the number of digits  represented  right  of
	           the  decimal  point so that the representation will
	           fit, or represent the value in scientific  notation
	           if there are more than IWIDTH or MAXSIG digits left
	           of the decimal point.


	           If NOTATN=3 and VALUE=1000 or greater, then  MAXDEC
	           is the number of digits to the right of the decimal
	           point in the original unshifted value which can  be
	           displayed  if  there  is  room  for  these  in  the
	           supplied field width.  If VALUE is between 1000 and
	           1000000,  then  at  most  MAXDEC+3  digits  can  be
	           displayed right of the displayed decimal point.  If
	           VALUE  is 1000000 or greater, then at most MAXDEC+6
	           digits can be displayed right of the decimal point.

	  MINSIG = minimum  number  of  significant  digits   in   the
	           floating point representation of the value.  If the
	           floating point representation of  the  value  would
	           contain  less  than MINSIG significant digits, then
	           the  value  will  be  represented   in   scientific
	           notation.   If  the  value  being displayed has the
	           value zero, then MINSIG is ignored.

	  MAXSIG = selects the maximum number of significant digits in
	  FASP, FORTRAN Alphameric Subroutine Package         Page 347
	  DARITE, Free Format FORTRAN Output Routine


	           the floating point representation of the value.
	         = less than or equal to zero, allow as many digits as
	           the field will hold
	         = greater than zero, MAXSIG is the maximum number  of
	           digits  which  can  be  displayed starting with the
	           leftmost nonzero digit, counting it and all  digits
	           to  its right.  MAXSIG does not include the decimal
	           point, does not include the minus sign if the value
	           is negative, and does not include the percent sign,
	           K or M if NOTATN is greater than zero.  The  number
	           of  digits  displayed right of the decimal point is
	           reduced if necessary so that the number  of  digits
	           starting  at  the  leftmost nonzero displayed digit
	           and counting it and all  digits  displayed  to  its
	           right  does  not exceed MAXSIG.  If MAXSIG would be
	           less than the number of digits left of the  decimal
	           point  in the representation of the value, then the
	           value will be represented in scientific notation.

	  INIZRO = -1, if the number is represented in floating  point
	           form  and has an absolute value less than 1.0, then
	           a zero is displayed left of the  decimal  point  if
	           and only if no digits would otherwise be displayed.
	         = 0, if the number is represented in  floating  point
	           form  and has an absolute value less than 1.0, then
	           a zero is displayed to  the  left  of  the  decimal
	           point.
	         = 1, if the number is represented in  floating  point
	           form  and has an absolute value less than 1.0, then
	           a zero is not displayed to the left of the  decimal
	           point.   If  no digits appear in the representation
	           of the number and IFILL equals  one,  then  neither
	           decimal  point  nor  sign  are  represented and the
	           field will be filled with  spaces.   If  no  digits
	           appear  in  the  representation  of  the number and
	           IFILL is zero indicating that the field is  not  to
	           be  filled  with  spaces  right of the number, then
	           KOUNT will be returned equal to the input value  of
	           LFTCOL.

	           For example, values greater than or equal  to  zero
	           but  less  than 0.005 would be represented as shown
	           below if MAXDEC equals 2

	                       KLIP=0     KLIP=1     KLIP=2     KLIP=3

	           INIZRO=-1      .00        .0        0.         0
	                 = 0     0.00       0.0        0.         0
	                 = 1      .00        .0

	           Likewise, values between -0.005 and zero  would  be
	           represented as follow if MAXDEC equals 2

	  FASP, FORTRAN Alphameric Subroutine Package         Page 348
	  DARITE, Free Format FORTRAN Output Routine


	                       KLIP=0     KLIP=1     KLIP=2     KLIP=3

	           INIZRO=-1     -.00       -.0       -0.        -0
	                 = 0    -0.00      -0.0       -0.        -0
	                 = 1     -.00       -.0

	  MARGIN = 0, if the number is represented in  floating  point
	           form, and if a K, M or percent sign does not follow
	           the representation of the value, then do not add an
	           extra  space  where  the K, M or percent sign would
	           otherwise be.
	         = greater  than  zero,  MARGIN  is  the   number   of
	           characters  in  the  field containing spaces and/or
	           the K, M or percent sign to the right of a floating
	           point  number.   MARGIN  can  be  used  to  force a
	           floating point number to have its  rightmost  digit
	           at  the same position as the rightmost digit of the
	           normalized  portion  of  a  value  represented   in
	           scientific  notation.   For  this  purpose,  MARGIN
	           would be 1  greater  than  IEXPNT.   If  MARGIN  is
	           greater  than  1 and a K, M or percent sign must be
	           placed to the right of the number, then the K, M or
	           percent  sign is placed at the left of the field of
	           spaces where the E of a scientific notation  number
	           would  appear, and the field then contains MARGIN-1
	           spaces to the right of the K, M  or  percent  sign.
	           MARGIN  would  have  the  value  1  if it is merely
	           desired to force a single space to the right of the
	           representation  of  the number if a K, M or percent
	           sign does not appear to its right.

	  The  following  arguments  control  the  format  of   values
	  represented  in  scientific  notation  either with displayed
	  exponent or with suppressed zero exponent (IZERO  less  than
	  or equal to zero).

	  IDECML = same as MAXDEC except that IDECML applies  only  to
	           values displayed in scientific notation.  Note that
	           if the value is  being  represented  in  scientific
	           notation, then a nonzero digit will be used left of
	           the decimal point unless the value is itself  zero.
	           Therefore,  if  IDECML  is greater than or equal to
	           zero, then the maximum number of significant digits
	           which  can  be  displayed in scientific notation is
	           IDECML+1.

	  IEXPNT = minimum number of digits in  the  exponent  if  the
	           value  is  represented  in scientific notation.  If
	           fewer  than  IEXPNT  digits  are  needed   in   the
	           exponent,  these are justified in an exponent field
	           of IEXPNT width with either  spaces  or  zeroes  as
	           fill according to the value of IFORMT.  IEXPNT must
	           include room for  the  sign  (if  the  exponent  is
	           negative) but does not include room for the initial
	  FASP, FORTRAN Alphameric Subroutine Package         Page 349
	  DARITE, Free Format FORTRAN Output Routine


	           letter E of the exponent.

	  IFORMT = 0,  if  IEXPNT  is  greater  than  the  number   of
	           characters  needed  to represent the exponent, then
	           left  justify  the  exponent  within  the  exponent
	           field.
	         = 1,  if  IEXPNT  is  greater  than  the  number   of
	           characters  needed  to represent the exponent, then
	           right justify the digits of the exponent within the
	           exponent field.  If the exponent is negative, place
	           the sign right  of  the  E  at  the  start  of  the
	           exponent.  Zeroes, not spaces, are used to fill the
	           rest of the exponent field.
	         = 2, same as IFORMT=1 except that spaces, not  zeroes
	           are  used  to  fill between the sign if any and the
	           digits of the exponent.
	         = 3, same as IFORMT=2 except that the sign if any  is
	           placed immediately to the left of the digits of the
	           exponent instead of to the right of the  E  at  the
	           start of the exponent.

	           For example, if IEXPNT is 4, then the value  1.2E-3
	           would be represented

	                 for IFORMT=0     1.2E-3
	                     IFORMT=1     1.2E-003
	                     IFORMT=2     1.2E-  3
	                     IFORMT=3     1.2E  -3

	  IZERO  = -1, if the value is being represented in scientific
	           notation  and  has  a  zero  exponent (value of the
	           number is zero or is in either range  -9.99...   to
	           -1.00...   or  range 1.00...  to 9.99...), then the
	           representation of the number will  not  include  an
	           exponent field.
	         = 0, if the value is being represented in  scientific
	           notation  and  has  a  zero  exponent (value of the
	           number is zero or is in either range  -9.99...   to
	           -1.00...   or  range 1.00...  to 9.99...), then the
	           exponent field is  of  the  same  size  as  if  the
	           exponent  was  one but the exponent field is filled
	           with spaces.
	         = 1, if the value is being represented in  scientific
	           notation,  then the exponent will be displayed even
	           if this exponent is zero.

	           For example, if IEXPNT is 4,  then  the  value  1.2
	           would be represented

	                 for IZERO=-1         1.2
	                     IZERO=0     1.2
	                     IZERO=1     1.2E   0

	  The following  arguments,  together  with  IWIDTH  described
	  FASP, FORTRAN Alphameric Subroutine Package         Page 350
	  DARITE, Free Format FORTRAN Output Routine


	  earlier,  define the usable portion of the IBUFFR array, and
	  are returned unchanged.

	  LFTCOL = the subscript of the  IBUFFR  array  entry  to  the
	           immediate  left of the field in which the number is
	           to be represented.  Although LFTCOL will usually be
	           equal  to  the  number of characters already in the
	           IBUFFR array, differently named arguments should be
	           used  for  LFTCOL  and KOUNT since, if the compiler
	           transfers these by value rather  than  by  address,
	           then  the  return  from this routine could copy out
	           the new value  of  KOUNT  before  copying  out  the
	           unchanged value of LFTCOL.

	  MAXBFR = the maximum dimension  of  the  IBUFFR  array.   If
	           LFTCOL+IWIDTH  is  greater  than  MAXBFR,  then the
	           effective   value   of   IWIDTH   is   reduced   to
	           MAXBFR-LFTCOL.

	  The following are output arguments

	  IBUFFR = array in which the number is to be represented  and
	           which  can  then  be printed by the calling program
	           using a multiple of an A1 format.

	  KOUNT  = returned  pointing  to  the   rightmost   character
	           inserted  into  the IBUFFR array.  This will always
	           equal LFTCOL+IWIDTH if IFILL=1.

	  IERR   = -1 returned if the field was filled with  asterisks
	           due to field overflow even in scientific notation.
	         = 0 returned if the value was represented in floating
	           point  form with or without following percent sign,
	           K or M.
	         = 1 or greater returned if value was  represented  in
	           scientific  notation.  IERR is the number of digits
	           which are shown left of the exponent prior  to  the
	           suppression  of  rightmost  zeroes  which  might be
	           requested by nonzero values of KLIP.  If IPART is 1
	           causing only the exponent to be shown, then IERR is
	           the number of digits which  would  shown  if  IPART
	           instead  had  the  value  -1  (again  prior  to the
	           suppression of rightmost zeroes).  If this  routine
	           is  being  called to append the representation of a
	           number to a line of  text  which  already  contains
	           other  information,  then  the  calling program can
	           test  the  returned  value  of  IERR  to  determine
	           whether  there  was  enough  room at the end of the
	           line  for  the  number  to  be   represented   with
	           sufficient accuracy.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 351
	  DARITE, Free Format FORTRAN Output Routine


	                An Example of the Use of DARITE
	                -- ------- -- --- --- -- ------

	  The following sample  program  demonstrates  the  manner  in
	  which DARITE is called.

	             DIMENSION IBUFFR(12),VALUE(2)
	             DATA VALUE/1.2345678E4,1.2345678E-6/
	             DATA IBUFFR(1)/1H(/
	             DO 4 ITEM=1,2
	             DO 3 MAXSIG=1,8
	       C     VALUE=VALUE(ITEM) IWIDTH=10       IDECML=MAXSIG-1
	       C     JSTIFY=1          MINDEC=-2       IEXPNT=0
	       C     NOTATN=0          MAXDEC=-2       IFORMT=0
	       C     IPART =0          MINSIG=MAXSIG   IZERO =1
	       C     ISIGN =0          MAXSIG          LFTCOL=1
	       C     KLIP  =0          INIZRO=0        MAXBFR=12
	       C     IFILL =1          MARGIN=0        IBUFFR
	             CALL DARITE(VALUE(ITEM),1,0,0,0,
	            10,1,10,-2,-2,MAXSIG,MAXSIG,0,0,
	            2MAXSIG-1,0,0,1,1,12,IBUFFR,KOUNT,IERR)
	             KOUNT=KOUNT+1
	             IBUFFR(KOUNT)=1H)
	             IF(MAXSIG.EQ.1)WRITE(1,1)MAXSIG,
	            1(IBUFFR(I),I=1,KOUNT),VALUE(ITEM)
	           1 FORMAT(1X/1X,'MAXSIG=',1I1,1X,12A1,
	            1'   VALUE =',1E16.8)
	             IF(MAXSIG.GT.1)WRITE(1,2)MAXSIG,
	            1(IBUFFR(I),I=1,KOUNT)
	           2 FORMAT(1X,'MAXSIG=',1I1,1X,12A1)
	           3 CONTINUE
	           4 CONTINUE
	             END

	  The output generated by the above program is shown below

	       MAXSIG=1 (      1.E4)   VALUE =  0.12345678E+05
	       MAXSIG=2 (     1.2E4)
	       MAXSIG=3 (    1.23E4)
	       MAXSIG=4 (   1.235E4)
	       MAXSIG=5 (    12346.)
	       MAXSIG=6 (   12345.7)
	       MAXSIG=7 (  12345.68)
	       MAXSIG=8 ( 12345.678)

	       MAXSIG=1 (  0.000001)   VALUE =  0.12345678E-05
	       MAXSIG=2 ( 0.0000012)
	       MAXSIG=3 (0.00000123)
	       MAXSIG=4 (  1.235E-6)
	       MAXSIG=5 ( 1.2346E-6)
	       MAXSIG=6 (1.23457E-6)
	       MAXSIG=7 (1.23457E-6)
	       MAXSIG=8 (1.23457E-6)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 352
	  DARITE, Free Format FORTRAN Output Routine


	  Demonstration Program to Interactively Test DARITE Arguments
	  ------------- ------- -- ------------- ---- ------ ---------

	  The user of  the  program  listed  on  the  following  pages
	  defines  by  name  and  value  each  argument which is to be
	  tested.  When an empty line is read, the program will report
	  enclosed  in  parentheses the results of calling DARITE with
	  the specified argument values, for all  possible  values  of
	  JSTIFY  and  of  IFILL.  A sample dialog between the program
	  and the user is  presented  following  the  listing  of  the
	  program.



	  C     PROGRAM TO DEMONSTRATE DARITE ROUTINE
	  C
	  C     DEFINE DICTIONARY CONSISTING OF ARGUMENT NAMES
	        DIMENSION ITYPE(23),KNTLTR(23),IWORD(128)
	        DATA MAXWRD,MAXKNT,MAXINP,MAXOUT/128,23,60,132/
	        DATA IWORD/                  1HV,1HA,1HL,1HU,1HE,
	       1 1HJ,1HS,1HT,1HI,1HF,1HY,    1HN,1HO,1HT,1HA,1HT,1HN,
	       2 1HI,1HP,1HA,1HR,1HT,        1HI,1HS,1HI,1HG,1HN,
	       3 1HK,1HL,1HI,1HP,            1HI,1HF,1HI,1HL,1HL,
	       4 1HI,1HW,1HI,1HD,1HT,1HH,    1HM,1HI,1HN,1HD,1HE,1HC,
	       5 1HM,1HA,1HX,1HD,1HE,1HC,    1HM,1HI,1HN,1HS,1HI,1HG,
	       6 1HM,1HA,1HX,1HS,1HI,1HG,    1HI,1HN,1HI,1HZ,1HR,1HO,
	       7 1HM,1HA,1HR,1HG,1HI,1HN,    1HI,1HD,1HE,1HC,1HM,1HL,
	       8 1HI,1HE,1HX,1HP,1HN,1HT,    1HI,1HF,1HO,1HR,1HM,1HT,
	       9 1HI,1HZ,1HE,1HR,1HO,        1HL,1HF,1HT,1HC,1HO,1HL,
	       1 1HM,1HA,1HX,1HB,1HF,1HR,    1HI,1HB,1HU,1HF,1HF,1HR,
	       2 1HK,1HO,1HU,1HN,1HT,        1HI,1HE,1HR,1HR/
	        DATA ITYPE/4,-1,0,0,0,0,-1,0,0,0,
	       10,0,0,0,0,0,0,0,-1,0,
	       2-1,-1,-1/
	        DATA KNTLTR/5,6,6,5,5,4,5,6,6,6,
	       16,6,6,6,6,6,6,5,6,6,
	       26,5,4/
	  C
	  C     DEFINE INITIAL VALUES OF ARGUMENTS
	        DATA NOTATN, IPART, ISIGN,  KLIP, IFILL,IWIDTH,MINDEC,
	       1     MAXDEC,MINSIG,MAXSIG,INIZRO,MARGIN,IDECML,IEXPNT,
	       2     IFORMT, IZERO,MAXBFR/5*0,10,10*0,99/
	        DATA VALUE/0.0/
	  C
	  C     DEFINE NEEDED CHARACTERS
	        DATA IWHAT,IBLANK,ITAB/1H?,1H ,1H /
	  C
	  C     INPUT AND OUTPUT BUFFERS
	        DIMENSION IBUFFR(132),JBUFFR(60)
	  C
	  C     INPUT AND OUTPUT UNIT NUMBERS
	        DATA ITTY,JTTY/5,5/
	  C
	        WRITE(JTTY,1)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 353
	  DARITE, Free Format FORTRAN Output Routine


	      1 FORMAT(1X,37HPROGRAM TO DEMONSTRATE DARITE ROUTINE/
	       11X,47HTYPE ARGUMENT NAME AND VALUE, 1 OR MORE ON LINE/
	       21X,41HEMPTY LINE CALLS DARITE WITH THESE VALUES/
	       31X,43HSPACE IN BUFFER PRINTS AS <, UNDEFINED AS >)
	  C
	  C     READ USER SPECIFICATION OF ARGUMENT VALUES
	      2 WRITE(JTTY,3)
	      3 FORMAT(1X,1H*,$)
	        READ(ITTY,4)JBUFFR
	      4 FORMAT(60A1)
	  C
	  C     IDENTIFY THE ARGUMENT
	        LOWBFR=0
	      5 LOWBFR=LOWBFR+1
	      6 INIBFR=LOWBFR
	        CALL DAVERB(1,MAXWRD,IWORD,1,MAXKNT,
	       1KNTLTR,JBUFFR,MAXINP,LOWBFR,KIND,MATCH,LCNWRD,
	       2LCNKNT,LCNBFR)
	        GO TO(21,9,8,8,17),KIND
	  C
	  C     OBTAIN VALUE OF ARGUMENT
	      7 LOWBFR=LOWBFR+1
	      8 KONTRL=ITYPE(MATCH)
	        IF(KONTRL.LT.0)KONTRL=1
	        CALL DAHEFT(KONTRL,1,0,JBUFFR,MAXINP,LOWBFR,KIND,
	       1ISHIFT,JSHIFT,KSHIFT,LSHIFT,IVALUE,AVALUE)
	        GO TO(2,10,12),KIND
	  C
	  C     ALLOW COMMA OR EQUAL SIGN
	      9 IF(JBUFFR(LOWBFR).EQ.1H=)GO TO 13
	        GO TO 11
	     10 IF(JBUFFR(LOWBFR).EQ.1H=)GO TO 7
	     11 IF(JBUFFR(LOWBFR).EQ.1H,)GO TO 5
	        IF(JBUFFR(LOWBFR).EQ.1H;)GO TO 5
	        IF(JBUFFR(LOWBFR).EQ.1H!)GO TO 2
	        LCNBFR=LOWBFR
	        GO TO 18
	  C
	  C     SET ARGUMENT IF VALUE FOUND
	     12 IF(ITYPE(MATCH).LT.0)GO TO 15
	        IF(MATCH.EQ.1)VALUE=AVALUE
	        IF(MATCH.EQ.2)JSTIFY=IVALUE
	        IF(MATCH.EQ.3)NOTATN=IVALUE
	        IF(MATCH.EQ.4)IPART=IVALUE
	        IF(MATCH.EQ.5)ISIGN=IVALUE
	        IF(MATCH.EQ.6)KLIP=IVALUE
	        IF(MATCH.EQ.7)IFILL=IVALUE
	        IF(MATCH.EQ.8)IWIDTH=IVALUE
	        IF(MATCH.EQ.9)MINDEC=IVALUE
	        IF(MATCH.EQ.10)MAXDEC=IVALUE
	        IF(MATCH.EQ.11)MINSIG=IVALUE
	        IF(MATCH.EQ.12)MAXSIG=IVALUE
	        IF(MATCH.EQ.13)INIZRO=IVALUE
	        IF(MATCH.EQ.14)MARGIN=IVALUE
	  FASP, FORTRAN Alphameric Subroutine Package         Page 354
	  DARITE, Free Format FORTRAN Output Routine


	        IF(MATCH.EQ.15)IDECML=IVALUE
	        IF(MATCH.EQ.16)IEXPNT=IVALUE
	        IF(MATCH.EQ.17)IFORMT=IVALUE
	        IF(MATCH.EQ.18)IZERO=IVALUE
	        IF(MATCH.EQ.20)MAXBFR=IVALUE
	        GO TO 6
	  C
	  C     ARGUMENT TYPED BY USER FOUND TO BE IN ERROR
	     13 WRITE(JTTY,14)
	     14 FORMAT(1X,22HARGUMENT NOT SPECIFIED)
	        GO TO 2
	     15 J=LCNWRD+KNTLTR(LCNKNT)-1
	        WRITE(JTTY,16)(IWORD(I),I=LCNWRD,J)
	     16 FORMAT(1X,16HUSER CANNOT SET ,100A1)
	        GO TO 2
	     17 LOWBFR=LOWBFR-1
	     18 IF(LOWBFR.GE.MAXINP)GO TO 19
	        IF(JBUFFR(LOWBFR+1).EQ.IBLANK)GO TO 19
	        IF(JBUFFR(LOWBFR+1).EQ.ITAB)GO TO 19
	        IF(JBUFFR(LOWBFR+1).EQ.1H,)GO TO 19
	        IF(JBUFFR(LOWBFR+1).EQ.1H=)GO TO 19
	        LOWBFR=LOWBFR+1
	        GO TO 18
	     19 WRITE(JTTY,20)(JBUFFR(I),I=LCNBFR,LOWBFR),IWHAT
	     20 FORMAT(1X,100A1)
	        GO TO 2
	  C
	  C     TEST IF ANYTHING WAS TYPED WHEN END OF LINE FOUND
	     21 IF(INIBFR.GT.1)GO TO 2
	  C
	  C     REPORT ARGUMENT VALUES TO USER
	        WRITE(JTTY,22)NOTATN, IPART, ISIGN,  KLIP,IWIDTH,
	       1MINDEC,MAXDEC,MINSIG,MAXSIG,INIZRO,MARGIN,IDECML,
	       2IEXPNT,IFORMT, IZERO,MAXBFR, VALUE
	     22 FORMAT(7H NOTATN,1I3,7H  IPART,1I3,7H  ISIGN,1I3,
	       1       7H   KLIP,1I3,7H IWIDTH,1I3,7H MINDEC,1I3/
	       2       7H MAXDEC,1I3,7H MINSIG,1I3,7H MAXSIG,1I3,
	       3       7H INIZRO,1I3,7H MARGIN,1I3,7H IDECML,1I3/
	       4       7H IEXPNT,1I3,7H IFORMT,1I3,7H  IZERO,1I3,
	       5       7H MAXBFR,1I3,7H  VALUE,1E13.5)
	  C
	  C     LOOP FOR IFILL=0 AND 1 FOR JSTIFY=-1, 0 AND 1
	        DO 31 IJSTIF=1,3
	        JSTIFY=IJSTIF-2
	        LFTCOL=0
	        DO 29 IIFILL=1,2
	        IFILL=IIFILL-1
	  C
	  C     INSERT VALUE OF IFILL INTO OUTPUT TEXT
	        IBUFFR(LFTCOL+1)=IBLANK
	        IBUFFR(LFTCOL+2)=1HF
	        IBUFFR(LFTCOL+3)=1HI
	        IBUFFR(LFTCOL+4)=1HL
	        LFTCOL=LFTCOL+4
	  FASP, FORTRAN Alphameric Subroutine Package         Page 355
	  DARITE, Free Format FORTRAN Output Routine


	        AVALUE=IFILL
	        CALL DARITE(AVALUE,1,0,0,0,
	       10,0,2,-1,-1,0,2,
	       20,0,0,0,0,0,LFTCOL,
	       3MAXOUT,IBUFFR,LFTCOL,IERR)
	  C
	  C     INSERT TEXT LEFT OF VALUE, LEAVING ROOM FOR IERR
	        LFTERR=LFTCOL+4
	        IBUFFR(LFTCOL+1)=IBLANK
	        IBUFFR(LFTCOL+2)=1HE
	        IBUFFR(LFTCOL+3)=1HR
	        IBUFFR(LFTCOL+4)=1HR
	        IBUFFR(LFTCOL+7)=IBLANK
	        IBUFFR(LFTCOL+8)=1H(
	        LFTCOL=LFTCOL+8
	        IBUFFR(LFTCOL+IWIDTH+1)=1H)
	  C
	  C     CALL DARITE TO REPRESENT VALUE WITH USER SET FORMAT
	        LIMIT=LFTCOL+MAXBFR
	        CALL DARITE( VALUE,JSTIFY,NOTATN, IPART, ISIGN,
	       1  KLIP, IFILL,IWIDTH,MINDEC,MAXDEC,MINSIG,MAXSIG,
	       2INIZRO,MARGIN,IDECML,IEXPNT,IFORMT, IZERO,LFTCOL,
	       3 LIMIT,IBUFFR, KOUNT,  IERR)
	        IF(IBUFFR(LFTCOL).NE.1H()TYPE 23
	        IF(IBUFFR(LFTCOL+IWIDTH+1).NE.1H))TYPE 24
	     23 FORMAT(1X,33HCHARACTER LEFT OF FIELD DESTROYED)
	     24 FORMAT(1X,34HCHARACTER RIGHT OF FIELD DESTROYED)
	  C
	  C     INSERT VALUE OF IERR INTO TEXT LEFT OF VALUE
	        AVALUE=IERR
	        CALL DARITE(AVALUE,1,0,0,0,
	       10,0,2,-1,-1,0,2,
	       20,0,0,0,0,0,LFTERR,
	       3MAXOUT,IBUFFR,I,IERR)
	  C
	  C     MARK SPACES AND EMPTY LOCATIONS RETURNED BY DARITE
	        I=LFTCOL+1
	     25 IF(I.GT.KOUNT)GO TO 26
	        IF(IBUFFR(I).EQ.IBLANK)IBUFFR(I)=1H<
	        I=I+1
	        GO TO 25
	     26 KOUNT=KOUNT+1
	        IF(KOUNT.GT.LFTCOL+IWIDTH)GO TO 27
	        IBUFFR(KOUNT)=1H>
	        GO TO 26
	     27 IF(KOUNT.GE.LFTCOL+IWIDTH+IEXTRA)GO TO 28
	        KOUNT=KOUNT+1
	        IBUFFR(KOUNT)=IBLANK
	        GO TO 27
	     28 LFTCOL=KOUNT
	     29 CONTINUE
	  C
	  C     DISPLAY THE RESULT TO USER
	        WRITE(JTTY,30)JSTIFY,(IBUFFR(I),I=1,KOUNT)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 356
	  DARITE, Free Format FORTRAN Output Routine


	     30 FORMAT(1X,3HJST,I2,120A1)
	     31 CONTINUE
	  C
	  C     GO BACK TO ASK USER FOR NEXT ARGUMENT TO CHANGE
	        GO TO 2
	        END



	  Typical Dialog Between DARITE Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  PROGRAM TO DEMONSTRATE DARITE ROUTINE
	  TYPE ARGUMENT NAME AND VALUE, 1 OR MORE ON LINE
	  EMPTY LINE CALLS DARITE WITH THESE VALUES
	  SPACE IN BUFFER PRINTS AS <, UNDEFINED AS >
	  *MAXD -2 MAXS 6 VALUE 123.45678
	  *
	  NOTATN  0  IPART  0  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  0
	  MAXDEC -2 MINSIG  0 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  0
	  IEXPNT  0 IFORMT  0  IZERO  0 MAXBFR 99  VALUE  0.12346E+03
	  JST-1 FIL 0 ERR 0 (123.457>>>) FIL 1 ERR 0 (123.457<<<)
	  JST 0 FIL 0 ERR 0 (<123.457>>) FIL 1 ERR 0 (<123.457<<)
	  JST 1 FIL 0 ERR 0 (<<<123.457) FIL 1 ERR 0 (<<<123.457)
	  *MINS 6 MIND 4 !IMPOSSIBLE CONDITIONS TO FORCE E NOTATION
	  *
	  NOTATN  0  IPART  0  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  4
	  MAXDEC -2 MINSIG  6 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  0
	  IEXPNT  0 IFORMT  0  IZERO  0 MAXBFR 99  VALUE  0.12346E+03
	  JST-1 FIL 0 ERR 1 (1.E2>>>>>>) FIL 1 ERR 1 (1.E2<<<<<<)
	  JST 0 FIL 0 ERR 1 (<<<1.E2>>>) FIL 1 ERR 1 (<<<1.E2<<<)
	  JST 1 FIL 0 ERR 1 (<<<<<<1.E2) FIL 1 ERR 1 (<<<<<<1.E2)
	  *IDEC 5 IEXP 3 IFOR 1 !MAKE DISPLAY LOOK BETTER
	  *
	  NOTATN  0  IPART  0  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  4
	  MAXDEC -2 MINSIG  6 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  5
	  IEXPNT  3 IFORMT  1  IZERO  0 MAXBFR 99  VALUE  0.12346E+03
	  JST-1 FIL 0 ERR 5 (1.2346E002) FIL 1 ERR 5 (1.2346E002)
	  JST 0 FIL 0 ERR 5 (1.2346E002) FIL 1 ERR 5 (1.2346E002)
	  JST 1 FIL 0 ERR 5 (1.2346E002) FIL 1 ERR 5 (1.2346E002)
	  *VAL 9.085E-7 !TRY A NEGATIVE EXPONENT
	  *
	  NOTATN  0  IPART  0  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  4
	  MAXDEC -2 MINSIG  6 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  5
	  IEXPNT  3 IFORMT  1  IZERO  0 MAXBFR 99  VALUE  0.90850E-06
	  JST-1 FIL 0 ERR 5 (9.0850E-07) FIL 1 ERR 5 (9.0850E-07)
	  JST 0 FIL 0 ERR 5 (9.0850E-07) FIL 1 ERR 5 (9.0850E-07)
	  JST 1 FIL 0 ERR 5 (9.0850E-07) FIL 1 ERR 5 (9.0850E-07)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 357
	  DARITE, Free Format FORTRAN Output Routine


	  *IPAR -1 !LOOK AT NORMALIZED PART ONLY
	  *
	  NOTATN  0  IPART -1  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  4
	  MAXDEC -2 MINSIG  6 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  5
	  IEXPNT  3 IFORMT  1  IZERO  0 MAXBFR 99  VALUE  0.90850E-06
	  JST-1 FIL 0 ERR 6 (9.08500>>>) FIL 1 ERR 6 (9.08500<<<)
	  JST 0 FIL 0 ERR 6 (<9.08500>>) FIL 1 ERR 6 (<9.08500<<)
	  JST 1 FIL 0 ERR 6 (<<<9.08500) FIL 1 ERR 6 (<<<9.08500)
	  *IPAR 1 !LOOK AT EXPONENT
	  *
	  NOTATN  0  IPART  1  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  4
	  MAXDEC -2 MINSIG  6 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  5
	  IEXPNT  3 IFORMT  1  IZERO  0 MAXBFR 99  VALUE  0.90850E-06
	  JST-1 FIL 0 ERR 6 (E-07>>>>>>) FIL 1 ERR 6 (E-07<<<<<<)
	  JST 0 FIL 0 ERR 6 (<<<E-07>>>) FIL 1 ERR 6 (<<<E-07<<<)
	  JST 1 FIL 0 ERR 6 (<<<<<<E-07) FIL 1 ERR 6 (<<<<<<E-07)
	  *VAL 9.99996E-7 IPA 0 !TEST ROUNDING
	  *
	  NOTATN  0  IPART  0  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  4
	  MAXDEC -2 MINSIG  6 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  5
	  IEXPNT  3 IFORMT  1  IZERO  0 MAXBFR 99  VALUE  0.10000E-05
	  JST-1 FIL 0 ERR 5 (1.0000E-06) FIL 1 ERR 5 (1.0000E-06)
	  JST 0 FIL 0 ERR 5 (1.0000E-06) FIL 1 ERR 5 (1.0000E-06)
	  JST 1 FIL 0 ERR 5 (1.0000E-06) FIL 1 ERR 5 (1.0000E-06)
	  *IPA -1 !LOOK AT NORMALIZED PART
	  *
	  NOTATN  0  IPART -1  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  4
	  MAXDEC -2 MINSIG  6 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  5
	  IEXPNT  3 IFORMT  1  IZERO  0 MAXBFR 99  VALUE  0.10000E-05
	  JST-1 FIL 0 ERR 6 (9.99996>>>) FIL 1 ERR 6 (9.99996<<<)
	  JST 0 FIL 0 ERR 6 (<9.99996>>) FIL 1 ERR 6 (<9.99996<<)
	  JST 1 FIL 0 ERR 6 (<<<9.99996) FIL 1 ERR 6 (<<<9.99996)
	  *IPA 1 !LOOK AT EXPONENT
	  *
	  NOTATN  0  IPART  1  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  4
	  MAXDEC -2 MINSIG  6 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  5
	  IEXPNT  3 IFORMT  1  IZERO  0 MAXBFR 99  VALUE  0.10000E-05
	  JST-1 FIL 0 ERR 6 (E-07>>>>>>) FIL 1 ERR 6 (E-07<<<<<<)
	  JST 0 FIL 0 ERR 6 (<<<E-07>>>) FIL 1 ERR 6 (<<<E-07<<<)
	  JST 1 FIL 0 ERR 6 (<<<<<<E-07) FIL 1 ERR 6 (<<<<<<E-07)
	  *IDEC 4 IPA -1 !REDUCE DIGITS TO SAME FOR ALL OR PART
	  *
	  NOTATN  0  IPART -1  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  4
	  MAXDEC -2 MINSIG  6 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  4
	  IEXPNT  3 IFORMT  1  IZERO  0 MAXBFR 99  VALUE  0.10000E-05
	  JST-1 FIL 0 ERR 5 (1.0000>>>>) FIL 1 ERR 5 (1.0000<<<<)
	  JST 0 FIL 0 ERR 5 (<<1.0000>>) FIL 1 ERR 5 (<<1.0000<<)
	  JST 1 FIL 0 ERR 5 (<<<<1.0000) FIL 1 ERR 5 (<<<<1.0000)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 358
	  DARITE, Free Format FORTRAN Output Routine


	  *IPA 1 !MAKE SURE THAT EXPONENT SHOWS RESULTS OF ROUNDING
	  *
	  NOTATN  0  IPART  1  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  4
	  MAXDEC -2 MINSIG  6 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  4
	  IEXPNT  3 IFORMT  1  IZERO  0 MAXBFR 99  VALUE  0.10000E-05
	  JST-1 FIL 0 ERR 5 (E-06>>>>>>) FIL 1 ERR 5 (E-06<<<<<<)
	  JST 0 FIL 0 ERR 5 (<<<E-06>>>) FIL 1 ERR 5 (<<<E-06<<<)
	  JST 1 FIL 0 ERR 5 (<<<<<<E-06) FIL 1 ERR 5 (<<<<<<E-06)
	  *MAXB 5 IPA 0 !REDUCE BUFFER LENGTH TO MIDDLE OF FIELD
	  *
	  NOTATN  0  IPART  0  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  4
	  MAXDEC -2 MINSIG  6 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  4
	  IEXPNT  3 IFORMT  1  IZERO  0 MAXBFR  5  VALUE  0.10000E-05
	  JST-1 FIL 0 ERR 1 (1E-06>>>>>) FIL 1 ERR 1 (1E-06>>>>>)
	  JST 0 FIL 0 ERR 1 (1E-06>>>>>) FIL 1 ERR 1 (1E-06>>>>>)
	  JST 1 FIL 0 ERR 1 (1E-06>>>>>) FIL 1 ERR 1 (1E-06>>>>>)
	  *IPA -1
	  *
	  NOTATN  0  IPART -1  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  4
	  MAXDEC -2 MINSIG  6 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  4
	  IEXPNT  3 IFORMT  1  IZERO  0 MAXBFR  5  VALUE  0.10000E-05
	  JST-1 FIL 0 ERR 4 (1.000>>>>>) FIL 1 ERR 4 (1.000>>>>>)
	  JST 0 FIL 0 ERR 4 (1.000>>>>>) FIL 1 ERR 4 (1.000>>>>>)
	  JST 1 FIL 0 ERR 4 (1.000>>>>>) FIL 1 ERR 4 (1.000>>>>>)
	  *IPA 1
	  *
	  NOTATN  0  IPART  1  ISIGN  0   KLIP  0 IWIDTH 10 MINDEC  4
	  MAXDEC -2 MINSIG  6 MAXSIG  6 INIZRO  0 MARGIN  0 IDECML  4
	  IEXPNT  3 IFORMT  1  IZERO  0 MAXBFR  5  VALUE  0.10000E-05
	  JST-1 FIL 0 ERR 4 (E-06>>>>>>) FIL 1 ERR 4 (E-06<>>>>>)
	  JST 0 FIL 0 ERR 4 (E-06>>>>>>) FIL 1 ERR 4 (E-06<>>>>>)
	  JST 1 FIL 0 ERR 4 (<E-06>>>>>) FIL 1 ERR 4 (<E-06>>>>>)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 359
	  DAROME, Roman Numeral Generator


	  DDDDDDD      AAA    RRRRRRRRR OOOOOOOOO MMM     MMM EEEEEEEE
	  DDD   DDD  AAA AAA  RRR   RRR OOO   OOO MMMM   MMMM EEE
	  DDD   DDD AAA   AAA RRRRRRR   OOO   OOO MMM M M MMM EEEEEE
	  DDD   DDD AAAAAAAAA RRR  RRR  OOO   OOO MMM  M  MMM EEE
	  DDDDDDD   AAA   AAA RRR   RRR OOOOOOOOO MMM     MMM EEEEEEEE



	                DAROME, Roman Numeral Generator
	                ------  ----- ------- ---------

	  DAROME represents an integer value in Roman numeral notation
	  so  that  it  can be written with a FORTRAN format statement
	  containing  a  multiple   of   an   A1   alphameric   format
	  specification.   The argument list of DAROME is identical to
	  that of DANUMB except for the DANUMB argument  IRADIX  which
	  is not applicable to the construction of Roman numerals.

	  Values over 3999 cannot  be  represented  in  Roman  numeral
	  notation  since  the  the  largest  number  having  a letter
	  equivalent is 1000 represented  by  M.   The  routine  could
	  represent  larger  numbers  if letter assignments for larger
	  powers of ten and for halves of powers of  ten  are  decided
	  upon  and  incorporated into the array which specifies these
	  assignments in DAROME.  Values of zero  or  less  cannot  be
	  represented by DAROME since Roman numeral notation cannot be
	  used to represent these values.

	  DAROME has no  output  argument  used  to  signal  an  error
	  condition.   Instead,  the character count KOUNT is returned
	  unchanged if the representation of the number will  not  fit
	  into  the  buffer provided or if the value is not within the
	  range which can be represented.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 360
	  DAROME, Roman Numeral Generator


	                    The DAROME Argument List
	                    --- ------ -------- ----

	  The argument list of routine DAROME is

	        SUBROUTINE DAROME(KONTRL,NUMBER,LETTER,KOUNT,LFTCOL,
	       1MAX)

	  with the associated DIMENSION statement

	        DIMENSION LETTER(MAX)

	  The following are input arguments left unchanged

	  KONTRL = 0, left justify the representation of the number.

	           If KOUNT is  less  than  LFTCOL,  then  the  output
	           buffer  starting  at  LETTER(KOUNT+1) and extending
	           through LETTER(LFTCOL) will be filled with spaces.

	           If KOUNT is less than or equal to LFTCOL, then  the
	           leftmost    character    of   the   Roman   numeral
	           representation of the  number  will  be  placed  in
	           LETTER(LFTCOL+1).

	           If KOUNT  is  greater  than  LFTCOL,  meaning  that
	           characters  are  already  in  use  to  the right of
	           LFTCOL,  then   a   space   will   be   placed   in
	           LETTER(KOUNT+1),  and  the  leftmost  letter of the
	           representation of the  number  will  be  placed  in
	           LETTER(KOUNT+2).

	           If the representation of the number will  fit  into
	           the  output  buffer, then the character count KOUNT
	           will be  left  pointing  to  the  location  of  the
	           rightmost  letter  of  the  representation  of  the
	           number.  If the representation of the number  would
	           extend  to  the  right  of  LETTER(MAX),  then  the
	           character count KOUNT is returned unchanged.

	         = 1, right justify the representation of  the  number
	           so  that the rightmost letter of the representation
	           of the number is placed in LETTER(LFTCOL).

	           If the representation of the number  requires  less
	           than  LFTCOL-KOUNT characters, then fill the output
	           buffer with spaces starting at LETTER(KOUNT+1)  and
	           extending  up  to  the  leftmost  character  of the
	           representation of the number.

	           If the representation of the number will  fit  into
	           the  output  buffer, then the character count KOUNT
	           will be returned equal to  LFTCOL.   If  LFTCOL  is
	           greater than the dimension of the buffer, or if the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 361
	  DAROME, Roman Numeral Generator


	           number is too large to be represented  starting  at
	           LETTER(KOUNT+1)  and ending at LETTER(LFTCOL), then
	           the character count KOUNT is returned unchanged.

	  NUMBER = the integer value to be represented.

	  The  following  argument  is   an   array   to   which   the
	  representation of the value is appended.

	  LETTER = the output buffer into which DAROME will place  the
	           representation  of  the  number  and  which  can be
	           written by a  multiple  of  an  A1  format  by  the
	           calling program.

	  The following argument is used for both input to, and output
	  from this routine.

	  KOUNT  = is  input  containing  the  number  of   characters
	           already in use in the output buffer LETTER array.

	           If the representation of the value  will  fit  into
	           the  letter  array,  then  KOUNT  will  be returned
	           containing the location within the LETTER array  of
	           the  rightmost  character  of the representation of
	           the value.  KOUNT is returned unchanged  either  if
	           the  representation  of the value will not fit into
	           the  LETTER  array  or  if  the  value  cannot   be
	           represented using Roman numeral notation.

	  The following are input arguments which describe the size of
	  the  output  text  buffer.   These  arguments  are  returned
	  unchanged.

	  LFTCOL = number of characters in the buffer which are to  be
	           to  the left of the representation of the number if
	           KONTRL equals 0.

	         = position in the buffer at which is to be placed the
	           right letter of the representation of the number if
	           KONTRL equals 1.

	  MAX    = the dimension of the output  buffer  LETTER  array.
	           The   character   count   KOUNT  will  be  returned
	           unchanged if the representation of the value  would
	           extend beyond LETTER(MAX).
	  FASP, FORTRAN Alphameric Subroutine Package         Page 362
	  DAROME, Roman Numeral Generator


	            Program to Demonstrate the Use of DAROME
	            ------- -- ----------- --- --- -- ------

	  The program listed below accepts  a  value  from  the  user,
	  twice   generates   the   left   justified   Roman   numeral
	  representation of the number, with  the  first  starting  in
	  column  6, then generates the right justified representation
	  ending in column 59.  The asterisks originally in the buffer
	  are   retained   in  column  1  by  setting  KOUNT=1  before
	  generating the first representation, to  the  right  of  the
	  second  representation  by  incrementing  KOUNT by 1, and in
	  column 60 by setting LFTCOL=59 for the right  justification.
	  A  sample  dialog  between  the  program  and  the  user  is
	  presented below the listing of the program.

	        DIMENSION LETTER(60)
	        DATA ITTY,JTTY,MAX/5,5,60/
	  C
	  C     REQUEST AND READ NUMBER TO BE CONVERTED
	        WRITE(JTTY,1)
	      1 FORMAT(1X,37HPROGRAM TO DEMONSTRATE DAROME ROUTINE)
	      2 WRITE(JTTY,3)
	      3 FORMAT(7H VALUE ,$)
	        READ(ITTY,4)NUMBER
	      4 FORMAT(I)
	        DO 5 I=1,MAX
	      5 LETTER(I)=1H*
	  C
	  C     CONVERT NUMBER TO ROMAN NUMERAL FORM
	        KOUNT=1
	        LFTCOL=5
	        KONTRL=0
	        IPASS=-2
	      6 CALL DAROME(KONTRL,NUMBER,LETTER,KOUNT,LFTCOL,
	       1MAX)
	        IPASS=IPASS+1
	        IF(IPASS.LT.0)GO TO 6
	        IF(IPASS.GT.0)GO TO 7
	        KONTRL=1
	        KOUNT=KOUNT+1
	        LFTCOL=MAX-1
	        GO TO 6
	  C
	  C     REPORT RESULTS TO USER
	      7 WRITE(JTTY,8)LETTER
	      8 FORMAT(1X,60A1)
	        GO TO 2
	        END

	  PROGRAM TO DEMONSTRATE DAROME ROUTINE
	  VALUE 3846
	  *    MMMDCCCXLVI MMMDCCCXLVI*                   MMMDCCCXLVI*
	  VALUE 29
	  *    XXIX XXIX*                                        XXIX*
	  FASP, FORTRAN Alphameric Subroutine Package         Page 363
	  DASAVE, Integer & Character FORTRAN DATA Statement Generator


	  DDDDD          AAA    SSSSSS        AAA  VV    VV  EEEEEEEE
	  DD   DD       AAAA  SS             AAAA  VV   VV   EE
	  DD    DD     AA AA  SS            AA AA  VV  VV    EE
	  DD    DD    AA  AA    SSSS       AA  AA  VV VV     EEEEE
	  DD    DD   AAAAAAA        SS    AAAAAAA  VVVV      EE
	  DD   DD   AA    AA        SS   AA    AA  VVV       EE
	  DDDDD    AA     AA  SSSSSS    AA     AA  VV        EEEEEEEE



	  DASAVE, Integer & Character FORTRAN DATA Statement Generator
	  ------  ------- - --------- ------- ---- --------- ---------

	  The FORTRAN DATA statement generator  routine  named  DASAVE
	  allows  the  compilation  into  a FORTRAN program of integer
	  data which has been calculated  by  another  program  or  of
	  alphameric  data  which  another  program  has  read using a
	  multiple of an A1 format.

	  The DASAVE routine accepts as input an integer or alphameric
	  array  which  can  be  longer  than  can be represented by a
	  single DATA statement.  Output  consists  of  the  DIMENSION
	  statements  for  the original array and for component arrays
	  each small  enough  to  be  represented  by  a  single  DATA
	  statement,   of  the  EQUIVALENCE  statements  necessary  to
	  reconstruct the original array from  the  component  arrays,
	  and  of  the  DATA  statements  representing  the  component
	  arrays.   A  maximum  of  200  component   arrays   can   be
	  represented,   but  this  limit  can  easily  be  raised  by
	  increasing the dimension of a single array internal  to  the
	  DASAVE  routine.  In addition to the length limit imposed by
	  the maximum number of component arrays, the manner in  which
	  the names of the component arrays are constructed limits the
	  length of the original array to 99999 locations.

	  The width of the statements and  the  number  of  lines  per
	  statement  are  specified  by  the  calling  program.  If an
	  integer array is being represented, the DATA statements  can
	  have  the  numbers arranged in columns or else compressed to
	  produce a shorter output file.  Alphameric arrays are always
	  represented with the characters arranged in columns.

	  A single call to DASAVE either can produce the complete  set
	  of  DIMENSION,  EQUIVALENCE and DATA statements necessary to
	  represent the contents of the input array,  or  can  produce
	  only  those  statements  of a particular type which would be
	  combined  with  statements  generated  by  other  calls   to
	  represent  the  contents  of  the  input  array.  If several
	  arrays are being represented in a single output  file  by  a
	  sequence  of  calls  to this routine, then separate calls to
	  this  routine  should  be  used  to  generate  all  of   the
	  statements  of  a particular type necessary to represent all
	  of the arrays before generating all of the statements of the
	  next  type  since  some compilers require that all DIMENSION
	  FASP, FORTRAN Alphameric Subroutine Package         Page 364
	  DASAVE, Integer & Character FORTRAN DATA Statement Generator


	  and  EQUIVALENCE  statements  appear  prior  to   any   DATA
	  statements.



	                The DASAVE Routine Argument List
	                --- ------ ------- -------- ----

	  The argument list of routine DASAVE is

	        SUBROUTINE DASAVE(IPART ,IFORMT,MAXCLM,MAXLIN,IDATA ,
	       1    KNTDAT,LETTER,KNTLTR,NAME  ,KNTNAM,IOUT  ,IERR  )

	  with the associated DIMENSION statement

	        DIMENSION IDATA(KNTDAT),LETTER(KNTLTR),NAME(KNTNAM)

	  All arguments except IERR are used for input  only  and  are
	  returned unchanged.

	  IPART  = specifies whether the current call to this  routine
	           is  to  generate all of the statements necessary to
	           represent the  contents  of  the  input  array,  or
	           whether  the current call is to generate only those
	           statements of a  particular  type  which  could  be
	           combined  with  the output from other calls to this
	           routine to represent  the  contents  of  the  input
	           array.
	         = -1, construct DIMENSION and EQUIVALENCE  statements
	           but not DATA statements
	         = 0,  construct  DIMENSION,  EQUIVALENCE   and   DATA
	           statements
	         = 1, construct DIMENSION statements only
	         = 2, construct EQUIVALENCE statements only
	         = 3, construct DATA statements only
	         = -4, -3  or  -2,  identical  to  IPART=-1,  0  or  1
	           respectively,  except  that the resulting DIMENSION
	           statements specify the component  arrays  necessary
	           to construct the original array, but do not include
	           the name and dimension of the original array.

	  IFORMT = specifies whether  the  characters  in  the  LETTER
	           array  or the integer values in the IDATA array are
	           to be represented.  If  integer  values  are  being
	           represented, then IFORMT also specifies whether the
	           DATA statements  are  to  be  written  with  spaces
	           compacted  out,  or  with  the  numbers arranged in
	           columns.
	         = -1, represents the characters in LETTER(1)  through
	           and  including  LETTER(KNTLTR)  in  a  column form.
	           Each character  is  preceded  by  1H  in  the  DATA
	           statements.
	         = 0,  represents  the  integer  values  in   IDATA(1)
	           through  and  including  IDATA(KNTDAT) in a compact
	  FASP, FORTRAN Alphameric Subroutine Package         Page 365
	  DASAVE, Integer & Character FORTRAN DATA Statement Generator


	           form.  Although this compact form is acceptable  to
	           a   FORTRAN   compiler,   a   person   would   have
	           considerable   difficulty   locating   the    value
	           associated   with   a   particular  subscript  when
	           visually scanning DATA statements written  in  this
	           compact form.
	         = 1 or greater, represents  the  integers  values  in
	           IDATA(1)  through  and including IDATA(KNTDAT) in a
	           column form.  If IFORMT is less than the number  of
	           characters  needed to represent the value requiring
	           the most characters, then the columns  will  be  of
	           the  same  width as the representation of the value
	           requiring the most characters.  If IFORMT is  equal
	           to  or greater than the number of characters needed
	           to  represent  the   value   requiring   the   most
	           characters,  then  the  width  of  the columns will
	           equal IFORMT.

	  MAXCLM = the maximum number  of  characters  to  be  in  the
	           statement  field  of  each line in the output.  The
	           maximum value of MAXCLM  is  66  which  is  the  72
	           character  total width of a FORTRAN statement minus
	           the  6  characters  in  the  statement  number  and
	           continuation fields.

	  MAXLIN = the maximum number of lines onto  which  a  FORTRAN
	           statement can be written.  MAXLIN includes both the
	           initial line of  the  statement  and  all  possible
	           continuation  lines.   There is no limit imposed by
	           this  routine,  but  the  FORTRAN   compiler   will
	           probably  restrict  the number of lines to a number
	           such as 10 or 20.

	  IDATA  = the  array  of  integer  values  which  are  to  be
	           represented in the output DATA statements if IFORMT
	           has the value zero or greater.

	  KNTDAT = the number of values in the IDATA array  which  are
	           to  be  represented if IFORMT has the value zero or
	           greater.  All values  starting  with  IDATA(1)  and
	           extending    through    IDATA(KNTDAT)    will    be
	           represented.

	  LETTER = the array of characters which are to be represented
	           in  the  output  DATA  statements if IFORMT has the
	           value -1.  Each location in the LETTER array  holds
	           a  single character read by an A1 format or defined
	           by a 1H field.

	  KNTLTR = the number of locations in the LETTER  array  which
	           contain  characters to be represented if IFORMT has
	           the value  -1.   LETTER(1)  through  and  including
	           LETTER(KNTLTR)  each  contain  a  single  character
	           which is to be represented.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 366
	  DASAVE, Integer & Character FORTRAN DATA Statement Generator


	  NAME   = an array containing the letters forming the name of
	           the  array  as  it is to be written into the output
	           DATA statements.  Each letter  in  the  NAME  array
	           must  be  read  by  an A1 format or defined by a 1H
	           field in a DATA statement in the calling program.

	           The name of a component  array  is  constructed  by
	           placing   the   digits   of   the  first  subscript
	           represented by the component array to the right  of
	           the   basic  name,  or  if  this  would  produce  a
	           component array name longer than  6  characters  by
	           replacing  the  rightmost letters of the basic name
	           with the digits of the first subscript  represented
	           by  the  component  array.  Therefore, names of the
	           following types result.

	           basic name    names of typical component arrays

	           A             A001    A210    A419
	           ABC           ABC001  ABC210  ABC419
	           ABCDEF        ABCDE1  ABC210  ABC419

	           The names of all component arrays are made to be of
	           the  same  length  by  the  insertion of zeroes, if
	           necessary, between the characters of the basic name
	           and  the  character  representations of the smaller
	           corresponding IDATA array subscripts.

	  KNTNAM = the number of letters in the name contained in  the
	           NAME array.  KNTNAM must be 6 or less.  The name is
	           contained in NAME(1) through NAME(KNTNAM).

	  IOUT   = the unit number onto which the DATA statements  are
	           to be written.  This routine will only generate the
	           FORTRAN statements necessary to represent the data.
	           It  is the responsibility of the calling program to
	           open the output file and to write any other FORTRAN
	           statements  and/or  FORTRAN  comment  lines  which,
	           depending upon the application, might be  necessary
	           either   before  or  after  the  output  from  this
	           routine.

	  IERR   = returned   describing   whether   the   values   or
	           characters  could  be represented.  The input value
	           of IERR is ignored.
	         = 0, returned if the values or  characters  could  be
	           represented.
	         = 1, returned if the line width specified  by  MAXCLM
	           was too short.
	         = 2,  returned  if  more  than  200  individual  DATA
	           statements would be required.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 367
	  DASAVE, Integer & Character FORTRAN DATA Statement Generator


	             Sample Output from the DASAVE routine
	              ------ ------ ---- --- ---- -------

	  The following short main program produced the output printed
	  below  it.  The only difference between the 2 DASAVE routine
	  calls is in the value of IFORMT which is 0 in the first call
	  and 1 in the second.

	        DIMENSION IDATA(115),NAME(6)
	        DATA NAME/1HI,1HV,1HA,1HL,1HU,1HE/
	        DATA IOUT,KNTDAT/1,115/
	        DO 1 I=1,KNTDAT
	      1 IDATA(I)=KNTDAT-I+1
	        WRITE(IOUT,2)
	      2 FORMAT(13H COMPACT FORM)
	        CALL DASAVE(0,0,54,5,IDATA,
	       1KNTDAT,LETTER,1,NAME,6,IOUT,IERR)
	        WRITE(IOUT,3)
	      3 FORMAT(12H COLUMN FORM)
	        CALL DASAVE(0,1,54,5,IDATA,
	       1KNTDAT,LETTER,1,NAME,6,IOUT,IERR)
	        STOP
	        END

	   COMPACT FORM
	        DIMENSION IVALUE(115),IVALU1(80),IVAL81(35)
	        EQUIVALENCE (IVALU1(1),IVALUE(1)),
	       1(IVAL81(1),IVALUE(81))
	        DATA IVALU1/115,114,113,112,111,110,109,108,107,106,
	       1105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,
	       289,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,
	       371,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,
	       453,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36/
	        DATA IVAL81/35,34,33,32,31,30,29,28,27,26,25,24,23,22,
	       121,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1/
	   COLUMN FORM
	        DIMENSION IVALUE(115),IVALU1( 50),IVAL51( 50),
	       1          IVA101( 15)
	        EQUIVALENCE (IVALU1(1),IVALUE(  1)),
	       1            (IVAL51(1),IVALUE( 51)),
	       2            (IVA101(1),IVALUE(101))
	        DATA IVALU1/115,114,113,112,111,110,109,108,107,106,
	       1            105,104,103,102,101,100, 99, 98, 97, 96,
	       2             95, 94, 93, 92, 91, 90, 89, 88, 87, 86,
	       3             85, 84, 83, 82, 81, 80, 79, 78, 77, 76,
	       4             75, 74, 73, 72, 71, 70, 69, 68, 67, 66/
	        DATA IVAL51/ 65, 64, 63, 62, 61, 60, 59, 58, 57, 56,
	       1             55, 54, 53, 52, 51, 50, 49, 48, 47, 46,
	       2             45, 44, 43, 42, 41, 40, 39, 38, 37, 36,
	       3             35, 34, 33, 32, 31, 30, 29, 28, 27, 26,
	       4             25, 24, 23, 22, 21, 20, 19, 18, 17, 16/
	        DATA IVA101/ 15, 14, 13, 12, 11, 10,  9,  8,  7,  6,
	       1              5,  4,  3,  2,  1/
	  FASP, FORTRAN Alphameric Subroutine Package         Page 368
	  DASHOW, Displays Integer or Real Number in Narrowest Field


	  DDDDD         AAA    SSSSSS  HH    HH    OOOOO    WW      WW
	  DD   DD      AAAA  SS        HH    HH   OO   OO   WW      WW
	  DD    DD    AA AA  SS        HH    HH  OO     OO  WW  WW  WW
	  DD    DD   AA  AA    SSSS    HHHHHHHH  OO     OO  WW WWWW WW
	  DD    DD  AAAAAAA        SS  HH    HH  OO     OO  WWWW  WWWW
	  DD   DD  AA    AA        SS  HH    HH   OO   OO   WWW    WWW
	  DDDDD   AA     AA  SSSSSS    HH    HH    OOOOO    WW      WW


	   DASHOW, Displays Integer or Real Number in Narrowest Field
	   ------  -------- ------- -- ---- ------ -- --------- -----

	  DASHOW represents an integer value or a real value  so  that
	  it can be written with a FORTRAN format statement containing
	  a multiple A1 alphameric specification.  The  representation
	  is left justified and rightmost fill with spaces (blanks) is
	  not provided.  If the array which is supplied to receive the
	  representation  of  the number is too short, then this array
	  is instead filled with asterisks.

	  Integers can be  represented  as  either  octal  or  decimal
	  numbers.    Real   values  can  be  represented  without  an
	  exponent, or can be represented  in  a  scientific  notation
	  consisting of the representation of a value in the range 1.0
	  through  9.999...   followed  by  the   letter   E   and   a
	  representation  of  the  power  of ten by which the original
	  value was multiplied to obtain the value  within  the  range
	  1.0  through 9.999...  If a real value is being represented,
	  then any zero which is to the right of the decimal point and
	  which  does  not  have  a  nonzero  value  to  its  right is
	  suppressed.  A real value which is  represented  without  an
	  exponent  and  which  has an absolute value less than one is
	  represented without a zero to the left of the decimal  point
	  unless this zero would be the only digit shown.

	  DASHOW calls DANUMB to  represent  integers  and  DARITE  to
	  represent  real  values.   DARITE must be called directly if
	  more flexibility in the representation  of  real  values  is
	  required.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 369
	  DASHOW, Displays Integer or Real Number in Narrowest Field


	                    The DASHOW Argument List
	                    --- ------ -------- ----

	  The argument list of routine DASHOW is

	        SUBROUTINE DASHOW(KONTRL,MINDEC,MAXDEC,MINSIG,MAXSIG,
	       1    IDECML,IVALUE,VALUE ,MAXBFR,KOUNT ,IBUFFR,IERR  )

	  with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR)

	  The following  argument  is  used  only  for  input  and  is
	  returned unchanged.

	  KONTRL = selects whether  the  value  being  represented  is
	           input as an integer or as a real number.
	         = -1,  represent  the  integer  value  input  as  the
	           argument  named  IVALUE  as  an  octal  number.  It
	           should be noted that  it  is  the  value  which  is
	           represented,  not  the  particular  bit sequence by
	           which this  value  happens  to  be  stored  in  the
	           computer.   The integer having the decimal value -8
	           would be represented as the octal number -10.
	         = 0,  represent  the  integer  value  input  as   the
	           argument named IVALUE as a decimal number.
	         = 1 or greater, represent the real value input as the
	           argument  named  VALUE with no more than MAXDEC nor
	           less than MINDEC digits to the right of the decimal
	           point  and  with  no more than MAXSIG nor less than
	           MINSIG significant digits.  If the value cannot  be
	           represented  using  the specified numbers of digits
	           in floating point form  (without  an  E  exponent),
	           then the value is instead represented in scientific
	           notation (with  an  E  exponent)  and  with  IDECML
	           digits  to  the  right  of the decimal point in the
	           representation of the value which  either  has  the
	           value  zero,  or  which  has  been  modified though
	           multiplication by a power of  ten  so  as  to  fall
	           within the range 1.0 through 9.999...

	  The following arguments control the representation of  those
	  real  values which are shown in floating point form (without
	  an E exponent).  These arguments are returned unchanged, and
	  do  not  control  the representation of integers or of those
	  real values which are shown in scientific notation (with  an
	  E  exponent).   However,  if MAXSIG is set to zero, then the
	  real value will be shown in scientific notation.

	  MINDEC = 0, there is no lower limit to the number of  digits
	           which  must  be  shown  to the right of the decimal
	           point of a number  represented  in  floating  point
	           form,  and  the field into which the representation
	           of the number is inserted does  not  even  need  to
	  FASP, FORTRAN Alphameric Subroutine Package         Page 370
	  DASHOW, Displays Integer or Real Number in Narrowest Field


	           include room for the decimal point.
	         = greater than zero, MINDEC is the minimum number  of
	           digits  which  can  be  shown  to  the right of the
	           decimal point of a number represented  in  floating
	           point  form  if  the  rightmost  of these digits is
	           nonzero.  If it would not be possible to include at
	           least  this  number  of  digits to the right of the
	           decimal point, then the value will  be  represented
	           in  scientific notation instead.  After determining
	           that it would be possible  to  represent  at  least
	           MINDEC  digits  to  the right of the decimal point,
	           then each digit  which  is  to  the  right  of  the
	           decimal  point  and  which  does not have a nonzero
	           digit to its  right  is  suppressed  and  even  the
	           decimal  point  will  not  be shown if there are no
	           nonzero digits to the right of the decimal point.

	  MAXDEC = 0, represent only the digits which are to the  left
	           of  the  decimal  point  of a number represented in
	           floating point form.  The decimal point will not be
	           shown.
	         = greater than zero, MAXDEC is the maximum number  of
	           digits  which  can  be  shown  to  the right of the
	           decimal point of a number represented  in  floating
	           point  form.   If  MAXSIG  (the  maximum  number of
	           significant digits) minus the number of  digits  to
	           the  left  of the decimal point is less than MAXDEC
	           but not less than MINDEC, then the number of digits
	           to the right of the decimal point is instead set to
	           MAXSIG minus the number of digits to  the  left  of
	           the  decimal  point.  If MAXSIG minus the number of
	           digits to the left of the  decimal  point  is  less
	           than  MINDEC,  then  the  number  is represented in
	           scientific notation instead.

	  MINSIG = minimum number of significant digits which  can  be
	           shown  in  a  number  represented in floating point
	           form if the rightmost of these digits  is  nonzero.
	           If  the  floating point representation of the value
	           would contain less than MINSIG significant  digits,
	           then  the  value  will be represented in scientific
	           notation.  If the value  being  displayed  has  the
	           value zero, then MINSIG is ignored.

	  MAXSIG = 0, represent the value input as the argument  named
	           VALUE  in  scientific notation (with an E exponent)
	           rather than in floating point form  (without  an  E
	           exponent).
	         = greater than zero, MAXSIG is the maximum number  of
	           digits  which  can be shown in a number represented
	           in floating point form, starting with the  leftmost
	           nonzero  digit,  counting  it and all digits to its
	           right.  MAXSIG does not include the  decimal  point
	           and does not include the minus sign if the value is
	  FASP, FORTRAN Alphameric Subroutine Package         Page 371
	  DASHOW, Displays Integer or Real Number in Narrowest Field


	           negative.  The number of digits  displayed  to  the
	           right  of the decimal point is reduced if necessary
	           so that  the  number  of  digits  starting  at  the
	           leftmost  nonzero  displayed  digit and counting it
	           and all digits displayed  to  its  right  does  not
	           exceed  MAXSIG.   If  MAXSIG would be less than the
	           number of digits left of the decimal point  in  the
	           representation of the value, then the value will be
	           represented in scientific notation.

	  The following argument controls the representation of  those
	  values  which  are  shown  in scientific notation (with an E
	  exponent).  This argument is returned  unchanged,  and  does
	  not  control the representation of integers or of those real
	  values which are represented in floating point form (without
	  an E exponent).

	  IDECML = same as MAXDEC except that IDECML applies  only  to
	           values displayed in scientific notation.  Note that
	           if the value is  being  represented  in  scientific
	           notation, then a nonzero digit will be used left of
	           the decimal point unless the value is itself  zero.
	           Therefore, the maximum number of significant digits
	           which can be displayed in  scientific  notation  is
	           IDECML+1.

	  The following arguments are used  only  for  input  and  are
	  returned unchanged.

	  IVALUE = input  containing   the   integer   value   to   be
	           represented  if  KONTRL  is  less  than or equal to
	           zero.

	  VALUE  = input containing the real value to  be  represented
	           if KONTRL is greater than zero.

	  MAXBFR = subscript of the rightmost location in  the  IBUFFR
	           array  which  can  be  used by this routine for the
	           return of characters in the representation  of  the
	           number.   The representation of the number will use
	           fewer locations in the IBUFFR array if possible.

	  The following argument  is  used  both  for  input  to  this
	  routine and for output to the calling program.

	  KOUNT  = input containing the  subscript  of  the  rightmost
	           (highest  subscript  value)  IBUFFR  array location
	           which  is  currently  in  use  and  which  must  be
	           preserved.   The  representation of the number will
	           be  returned  starting   in   IBUFFR(KOUNT+1)   and
	           extending through IBUFFR(MAXBFR) if necessary.
	         = returned containing the subscript of the  rightmost
	           IBUFFR  array  location in which a character of the
	           representation of  the  number  is  returned.   The
	  FASP, FORTRAN Alphameric Subroutine Package         Page 372
	  DASHOW, Displays Integer or Real Number in Narrowest Field


	           portion  of  the  IBUFFR  array to the right of the
	           representation and extending through IBUFFR(MAXBFR)
	           is returned undefined, but possibly changed.

	  The following arguments are used  only  for  output.   Their
	  input values are ignored.

	  IBUFFR = array  in  which  the  characters  which  form  the
	           representation of the number are returned as though
	           read by a multiple of an A1 format specification or
	           as  though  defined  by  several  1H  fields.   The
	           leftmost  character  of   the   representation   is
	           returned  in  IBUFFR(KOUNT+1).   KOUNT  is returned
	           containing  the  subscript  of  the  IBUFFR   array
	           location  containing the rightmost character of the
	           representation of the number.

	  IERR   = -1,   returned   if   the   field   starting   with
	           IBUFFR(KOUNT+1)      and      extending     through
	           IBUFFR(MAXBFR)  was  too  short  to   contain   the
	           representation   of  the  number.   This  field  is
	           returned  containing  asterisks,   and   KOUNT   is
	           returned set equal to MAXBFR.  If KONTRL is greater
	           than zero, then the field was too short to  contain
	           even  the  representation  of  the  real  number in
	           scientific notation.
	         = 0, returned if KONTRL is less than or equal to zero
	           and  the integer value could be shown, or if KONTRL
	           is  greater  than  zero  and  the  real  value  was
	           represented in floating point form.
	         = 1 or greater, returned if KONTRL is  input  greater
	           than  zero selecting the representation of the real
	           number which was input as the argument named VALUE,
	           and   this  value  was  represented  in  scientific
	           notation.  IERR is the number of digits which would
	           be  shown  to  the  left  of  the  exponent  if the
	           rightmost of these digits is nonzero.  Zeroes which
	           are  to the right of the decimal point and which do
	           not have a nonzero digit to  their  right  are  not
	           shown  but  are  included in the value of IERR.  If
	           this  routine  is  being  called  to   append   the
	           representation  of a number to a line of text which
	           already  contains  other  information,   then   the
	           calling program can test the returned value of IERR
	           to determine whether there was enough room  at  the
	           end  of  the  line for the number to be represented
	           with sufficient accuracy.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 373
	  DASHOW, Displays Integer or Real Number in Narrowest Field


	  Demonstration Program to Interactively Test DASHOW Arguments
	  ------------- ------- -- ------------- ---- ------ ---------

	  The user of the program listed below types a pair  or  pairs
	  of input argument names and values.  DASHOW is called at the
	  end of each input line, or whenever a semicolon is found.

	        DIMENSION IBUFFR(60),JBUFFR(60),KNTLTR(9),IWORD(53),
	       1NUMTYP(9)
	        DATA IWORD/                 1HK,1HO,1HN,1HT,1HR,1HL,
	       1  1HM,1HI,1HN,1HD,1HE,1HC,  1HM,1HA,1HX,1HD,1HE,1HC,
	       2  1HM,1HI,1HN,1HS,1HI,1HG,  1HM,1HA,1HX,1HS,1HI,1HG,
	       3  1HI,1HD,1HE,1HC,1HM,1HL,  1HI,1HV,1HA,1HL,1HU,1HE,
	       4  1HV,1HA,1HL,1HU,1HE,      1HM,1HA,1HX,1HB,1HF,1HR/
	        DATA KONTRL,MINDEC,MAXDEC,MINSIG,MAXSIG,IDECML,IVALUE,
	       1VALUE,MAXBFR/0,0,0,0,0,0,0,0.0,60/,ITTY,JTTY/5,5/,
	       2KNTLTR/6,6,6,6,6,6,6,5,6/,NUMTYP/0,0,0,0,0,0,0,1,0/
	        KIND=0
	      1 WRITE(JTTY,2)KONTRL,MINDEC,MAXDEC,MINSIG,MAXSIG,
	       1IDECML,MAXBFR,IVALUE,VALUE
	      2 FORMAT(8H  KONTRL,I3,7H MINDEC,I3,7H MAXDEC,I3,
	       17H MINSIG,I3,7H MAXSIG,I3,7H IDECML,I3/8H  MAXBFR,I3,
	       27H IVALUE,I13,7H  VALUE,1E13.4)
	      3 WRITE(JTTY,4)
	      4 FORMAT(2H *,$)
	        READ(ITTY,5)JBUFFR
	      5 FORMAT(60A1)
	        LOWBFR=1
	  C     OBTAIN NEXT USER SPECIFICATION OF ARGUMENT VALUE
	      6 CALL DALEAD(-2,-3,1,1,53,
	       1IWORD,1,9,KNTLTR,NUMTYP,2,1,
	       2IWORD,2,1,KNTLTR,JBUFFR,60,LOWBFR,
	       3KIND,KOMAND,KWRDID,KCNTID,LOCAL,LWRDID,LCNTID,
	       4INITAL,JVALUE,AVALUE,IFLOAT)
	        GO TO(8,8,3,6,7,6,6,6,8,3,6,7,6,6,6),KIND
	      7 IF(KOMAND.EQ.1)KONTRL=JVALUE
	        IF(KOMAND.EQ.2)MINDEC=JVALUE
	        IF(KOMAND.EQ.3)MAXDEC=JVALUE
	        IF(KOMAND.EQ.4)MINSIG=JVALUE
	        IF(KOMAND.EQ.5)MAXSIG=JVALUE
	        IF(KOMAND.EQ.6)IDECML=JVALUE
	        IF(KOMAND.EQ.7)IVALUE=JVALUE
	        IF(KOMAND.EQ.8)VALUE =AVALUE
	        IF(KOMAND.EQ.9)MAXBFR=JVALUE
	        GO TO 6
	  C     REPORT REPRESENTATION OF NUMBER IN SPECIFIED FORMAT
	      8 KOUNT=0
	        CALL DASHOW(KONTRL,MINDEC,MAXDEC,MINSIG,MAXSIG,
	       1    IDECML,IVALUE,VALUE ,MAXBFR,KOUNT ,IBUFFR,IERR  )
	        IF(KOUNT.GT.0)WRITE(JTTY,9)IERR,(IBUFFR(I),I=1,KOUNT)
	      9 FORMAT(3H  (,1I2,2H) ,60A1)
	        IF(KIND.EQ.1)GO TO 1
	        GO TO 6
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 374
	  DASHOW, Displays Integer or Real Number in Narrowest Field


	  Typical Dialog Between DASHOW Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	   KONTRL  0 MINDEC  0 MAXDEC  0 MINSIG  0 MAXSIG  0 IDECML  0
	   MAXBFR 60 IVALUE            0  VALUE   0.0000E+00
	  *KONTRL 1 MAXD 2 MAXS 6 VAL 12.03;VAL 12.003;VAL 12.006
	   ( 0) 12.03
	   ( 0) 12
	   ( 0) 12.01
	   KONTRL  1 MINDEC  0 MAXDEC  2 MINSIG  0 MAXSIG  6 IDECML  0
	   MAXBFR 60 IVALUE            0  VALUE   0.1201E+02
	  *VAL -0.03;VAL -0.003;VAL -.006;MINS 4;IDEC 3
	   ( 0) -.03
	   ( 0) -0
	   ( 0) -.01
	   ( 1) -6E-3
	   ( 4) -6E-3
	   KONTRL  1 MINDEC  0 MAXDEC  2 MINSIG  4 MAXSIG  6 IDECML  3
	   MAXBFR 60 IVALUE            0  VALUE  -0.6000E-02
	  *VAL 12345.6;VAL 1234.56;VAL 123.456;VAL 12.3456;VAL 1.23456
	   ( 0) 12345.6
	   ( 0) 1234.56
	   ( 0) 123.46
	   ( 0) 12.35
	   ( 4) 1.235
	   KONTRL  1 MINDEC  0 MAXDEC  2 MINSIG  4 MAXSIG  6 IDECML  3
	   MAXBFR 60 IVALUE            0  VALUE   0.1235E+01
	  *MAXS 4 MINS 4 MIND 2 VA 9.994;VA 9.996;VA 99.994;VA 99.996
	   ( 4) 9.994
	   ( 0) 10
	   ( 0) 99.99
	   ( 4) 1E2
	   KONTRL  1 MINDEC  2 MAXDEC  2 MINSIG  4 MAXSIG  4 IDECML  3
	   MAXBFR 60 IVALUE            0  VALUE   0.1000E+03
	  *MAXS 0 MAXB 7 VAL 0.001234;MAXB 6;MAXB 5;MAXB 4;MAXB 3
	   ( 3) 1.23E-3
	   ( 2) 1.2E-3
	   ( 1) 1E-3
	   ( 1) 1E-3
	   (-1) ***
	   KONTRL  1 MINDEC  2 MAXDEC  2 MINSIG  4 MAXSIG  0 IDECML  3
	   MAXBFR  3 IVALUE            0  VALUE   0.1234E-02
	  *MAXS 0 MAXB 7 VAL -0.001234;MAXB 6;MAXB 5;MAXB 4;MAXB 3
	   ( 2) -1.2E-3
	   ( 1) -1E-3
	   ( 1) -1E-3
	   (-1) ****
	   (-1) ***
	   KONTRL  1 MINDEC  2 MAXDEC  2 MINSIG  4 MAXSIG  0 IDECML  3
	   MAXBFR  3 IVALUE            0  VALUE  -0.1234E-02
	  FASP, FORTRAN Alphameric Subroutine Package         Page 375
	  DASITE, Routine to Locate Simulated Array Item in Buffer


	    DDDDD          AAA    SSSSSS  IIIIII  TTTTTTTT  EEEEEEEE
	    DD   DD       AAAA  SS          II       TT     EE
	    DD    DD     AA AA  SS          II       TT     EE
	    DD    DD    AA  AA    SSSS      II       TT     EEEEE
	    DD    DD   AAAAAAA        SS    II       TT     EE
	    DD   DD   AA    AA        SS    II       TT     EE
	    DDDDD    AA     AA  SSSSSS    IIIIII     TT     EEEEEEEE



	    DASITE, Routine to Locate Simulated Array Item in Buffer
	    ------  ------- -- ------ --------- ----- ---- -- ------

	  DASITE returns the  position  within  a  singly  subscripted
	  buffer  of  a single item of a possibly multiply subscripted
	  array equivalenced with or otherwise loaded into part or all
	  of  the singly subscripted buffer (as defined perhaps by the
	  dictionary constructed by the DALOAD routine).  There is  no
	  upper  limit  to  the  number  of  subscripts  of the arrays
	  simulated in the buffer (other than the obvious restrictions
	  imposed  by  the lengths of the NOWSUB and NUMSTR arrays and
	  by the length of the buffer itself).  The range of values of
	  any  subscript  can  start  at  any  value and can be either
	  increasing or decreasing.  This conversion is  the  opposite
	  of that performed by DANAME.

	  For  example,  if  the  first  statement  read  during   the
	  construction of the dictionary by DALOAD was

	        DIMENSION FIRST(10),SECOND(10,10),THIRD(10,10,10)

	  and if it is assumed that the first (left) subscript of each
	  simulated  array  varies the most rapidly (the usual FORTRAN
	  convention for array names appearing without  subscripts  in
	  READ and WRITE statements) then the simulated array location
	  THIRD(3,2,1) would be equivalent to the  singly  subscripted
	  buffer  location  having  the subscript 123.  The array name
	  and its subscripts are converted by  DASITE  to  the  buffer
	  location  subscript  by determining that the locations below
	  the desired location include

	    a. all 10 locations of the FIRST array

	    b. all 100 locations of the SECOND array

	    c. the 10 locations THIRD(1,1,1) through THIRD(10,1,1)

	    d. the 2 locations THIRD(1,2,1) and THIRD(2,2,1)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 376
	  DASITE, Routine to Locate Simulated Array Item in Buffer


	                    The DASITE Argument List
	                    --- ------ -------- ----

	  The argument list of routine DASITE is

	        SUBROUTINE DASITE(IRAPID,KOUNT ,LOWSUB,KNTSUB,NOWSUB,
	       1    IEXTRA,LRGNUM,NUMUSD,NUMSTR,LSTKNT,NUMINI,INITAL,
	       2    LOCATN)

	  with the associated DIMENSION statement

	        DIMENSION NOWSUB(KNTSUB),NUMSTR(NUMUSD)

	  The following arguments are  used  as  input  only  and  are
	  returned unchanged

	  IRAPID = 0, the simulated arrays, if  multiply  subscripted,
	           have   their   left  subscripts  varying  the  most
	           rapidly.  This is the normal FORTRAN convention for
	           READs  or  WRITEs in which the name of the array is
	           used without any subscripts.
	         = 1, the simulated arrays, if  multiply  subscripted,
	           have   their  right  subscripts  varying  the  most
	           rapidly.

	  KOUNT  = sequence number of  the  desired  array  among  all
	           arrays  in  the  buffer.   The first array would be
	           selected by KOUNT=1, the second by KOUNT=2  and  so
	           on.

	  LOWSUB = subscript of the NOWSUB array  location  containing
	           the  first  simulated  subscript  of  the  possibly
	           multiply subscripted  array  location  being  found
	           within the singly subscripted buffer.

	  KNTSUB = subscript of the NOWSUB array  location  containing
	           the  final  simulated  subscript  of  the  possibly
	           multiply subscripted  array  location  being  found
	           within the singly subscripted buffer.  If the lower
	           portion of the NOWSUB array is  used,  then  LOWSUB
	           will have the value 1 and KNTSUB will be the number
	           of simulated subscripts of  the  possibly  multiply
	           subscripted array.

	  NOWSUB = array containing the simulated  subscripts  of  the
	           possibly  multiply subscripted array location being
	           found  within  the   singly   subscripted   buffer.
	           NOWSUB(LOWSUB)  through  NOWSUB(KNTSUB) contain the
	           values of the simulated subscripts.

	  IEXTRA = 0, for  each  simulated  array,  the  NUMSTR  array
	           contains  only  the  number  of  subscripts and the
	           subscript limits.
	         = greater  than  zero,  NUMSTR(LRGNUM)  contains  the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 377
	  DASITE, Routine to Locate Simulated Array Item in Buffer


	           first of IEXTRA words which appear before the first
	           subscript description.   Thereafter,  IEXTRA  extra
	           words  are  to  be  ignored between descriptions of
	           consecutive simulated arrays.
	         = -1, the description of  the  subscript  ranges  for
	           each  of  the  simulated  arrays  is  preceded by a
	           variable number  of  words  to  be  ignored.   Each
	           section to be ignored starts with a word containing
	           the number of words exclusive of itself  which  are
	           to  be  ignored  before the next subscript count is
	           found.  NUMSTR(LRGNUM) then contains the number  of
	           words  exclusive  of itself which are to be ignored
	           before  the  first  subscript   count   and   range
	           descriptions.
	         = -2, the contents of the NUMSTR array  were  defined
	           by  the  DALOAD  routine.   The  description of the
	           subscript ranges for each of the  simulated  arrays
	           is  preceded  by 2 extra words.  LRGNUM can contain
	           the subscript of the start of the description of  a
	           logical   group  of  arrays,  or  can  contain  the
	           subscript of the start of the  description  of  the
	           first    array    in   the   logical   group.    If
	           NUMSTR(LRGNUM) is less than or equal to  zero  then
	           the subsequent array description is the first which
	           can be matched by this routine, and the  dictionary
	           is  effectively  terminated prior to the next array
	           description which  does  not  start  with  a  value
	           greater  than  zero.   If NUMSTR(LRGNUM) is greater
	           than zero, then the array description starting with
	           NUMSTR(LRGNUM) is the first which can be matched by
	           this routine, and  the  dictionary  is  effectively
	           terminated  prior  to  the  first array description
	           which does not start  with  a  value  greater  than
	           zero.

	  LRGNUM = if IEXTRA is greater than -2, or else if  IEXTRA=-2
	           and  NUMSTR(LRGNUM)  is  greater  than  zero,  then
	           LRGNUM  is  the  subscript  of  the  NUMSTR   array
	           location containing the start of the description of
	           the simulated array  which  would  be  selected  if
	           KOUNT=1.
	         = if IEXTRA=-2 and if NUMSTR(LRGNUM) is less than  or
	           equal  to  zero,  then  NUMSTR(LRGNUM) is the first
	           location in the description of the logical group of
	           arrays  containing  the array to be identified, and
	           the subsequent description is of  the  array  which
	           would be selected if KOUNT=1.

	  NUMUSD = subscript of the NUMSTR array  location  containing
	           the  end  of the description of the final simulated
	           array.

	  NUMSTR = array  describing  the  subscript  limits  of   the
	           possibly  multiply  subscripted arrays simulated in
	  FASP, FORTRAN Alphameric Subroutine Package         Page 378
	  DASITE, Routine to Locate Simulated Array Item in Buffer


	           the singly subscripted buffer.  The contents of the
	           NUMSTR  array  are, for each array simulated in the
	           buffer, the number of subscripts of  the  simulated
	           array followed by left and right limiting values of
	           these subscripts (values which the subscripts would
	           have  if  the  arrays  simulated in the buffer were
	           actually included in DIMENSION statements).  If the
	           item  in  the  buffer would be subscripted at 1, or
	           would not subscripted, then a single 0 can be  used
	           in place of the sequence 1,1,1.  it should be noted
	           that the right limit can be  either  greater  than,
	           equal to or less than the left limit.

	  The following arguments are used as both input and output

	  LSTKNT = should be set to zero by the calling program before
	           DASITE  is first called and whenever the dictionary
	           corresponding to the buffer changes.
	         = returned containing the input value of KOUNT.   The
	           subsequent  call to this routine will use the input
	           values of LSTKNT, NUMINI  and  INITAL  rather  than
	           recompute these for the simulated arrays earlier in
	           the dictionary if the new value of KOUNT is greater
	           than or equal to LSTKNT.

	  NUMINI = input value is ignored if  LSTKNT  is  zero  or  if
	           LSTKNT  is  greater  than  KOUNT.  NUMINI is set by
	           each call to DASITE and should never be set by  the
	           calling program.
	         = if LSTKNT is input  greater  than  zero,  then  the
	           value  of  NUMINI, as returned by the previous call
	           to this routine, is the  subscript  of  the  NUMSTR
	           array   location   containing   the  start  of  the
	           description of the array  having  as  its  sequence
	           number  the  value  of  LSTKNT.   If IEXTRA=0, then
	           NUMSTR(NUMINI) contains the subscript count at  the
	           start of the description.
	         = returned containing the  subscript  of  the  NUMSTR
	           array   location   containing   the  start  of  the
	           description of the array  having  as  its  sequence
	           number the input value of KOUNT.

	  INITAL = input  value  is  ignored  if   LSTKNT   is   input
	           containing  zero or if LSTKNT is input greater than
	           KOUNT.  INITAL is set by each call  to  DASITE  and
	           should never be set by the calling program.
	         = if LSTKNT is input  greater  than  zero,  then  the
	           value  of  INITAL, as returned by the previous call
	           to this routine, is the subscript within the singly
	           subscripted  buffer  of the location containing the
	           start of the simulated array having as its sequence
	           number the input value of LSTKNT.
	         = returned containing the subscript within the singly
	           subscripted  buffer  of the location containing the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 379
	  DASITE, Routine to Locate Simulated Array Item in Buffer


	           start of the simulated array having as its sequence
	           number the input value of KOUNT.

	  The following argument is returned  as  output.   Its  input
	  value is ignored.

	  LOCATN = if  returned  greater  than  zero,  LOCATN  is  the
	           subscript   of   the  location  within  the  singly
	           subscripted  buffer  which   corresponds   to   the
	           simulated  array  location which is selected by the
	           input  value  of  KOUNT  and  by   the   subscripts
	           contained in the NOWSUB array.
	         = 0, returned if one or more of  the  the  subscripts
	           contained in the NOWSUB array are not in the ranges
	           predicted by the NUMSTR array.
	         = -1,  returned  if  the  NOWSUB  array  contains   a
	           different  number  of  subscripts than indicated by
	           the NUMSTR array.
	         = -2, returned  if  the  NUMSTR  array  contains  the
	           descriptions  of  less  simulated  arrays  than the
	           input value of KOUNT.  This value of LOCATN is also
	           returned  if  an  error  is  detected in the NUMSTR
	           array.

	  For example, if the singly subscripted buffer  contains  the
	  values of the arrays A, B and E subscripted

	       A(1/3,1/5), B(1/5,1/6), E(1/10,1/10)

	  (this specification means that the left subscript of array A
	  can range from 1 through 3 and that the second subscript can
	  range from 1 through 5) and contains nonsubscripted items  C
	  and D in the order

	       A,B,C,D,E

	  then  the  contents  of  the  NUMSTR  array  would  be  (for
	  IEXTRA=0)

	       2,1,3,1,5,2,1,5,1,6,0,0,2,1,10,1,10

	  or

	       2,1,3,1,5,2,1,5,1,6,1,1,1,1,1,1,2,1,10,1,10

	  If KOUNT has the value 2 and if the  NOWSUB  array  contains
	  the  values  4  and 3 selecting B(4,3) and if IRAPID has the
	  value 0, so that all of  array  A,  B(1,1)  through  B(5,1),
	  B(1,2)  through  B(5,2),  and B(1,3) through B(3,3) would be
	  below B(4,3) then LOCATN would be returned as 15+5+5+3+1=29.

	  If IRAPID=0, then the order of the A  array  in  the  singly
	  subscripted  buffer  would be (reading across each line from
	  left to right)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 380
	  DASITE, Routine to Locate Simulated Array Item in Buffer


	       A(1,1),A(2,1),A(3,1),A(1,2),A(2,2),A(3,2),
	       A(1,3),A(2,3),A(3,3),A(1,4),A(2,4),A(3,4),
	       A(1,5),A(2,5),A(3,5)

	  If IRAPID=1, then the order of the A  array  in  the  singly
	  subscripted buffer would be

	       A(1,1),A(1,2),A(1,3),A(1,4),A(1,5)
	       A(2,1),A(2,2),A(2,3),A(2,4),A(2,5)
	       A(3,1),A(3,2),A(3,3),A(3,4),A(3,5)

	  If the Z array is effectively subscripted  Z(4/3,-1/1)  then
	  its representation in the NUMSTR array would be

	       2,4,3,-1,1

	  and if IRAPID=0, then its order in  the  singly  subscripted
	  buffer would be

	       Z(4,-1),Z(3,-1),Z(4,0),Z(3,0),Z(4,1),Z(3,1)

	  If instead IRAPID=1, then the order of the Z  array  in  the
	  singly subscripted buffer would be

	       Z(4,-1),Z(4,0),Z(4,1),Z(3,-1),Z(3,0),Z(3,1)



	    Use of DASITE with the Named Array Manipulation Routines
	    --- -- ------ ---- --- ----- ----- ------------ --------

	  If the DALOAD routine was used to construct  the  dictionary
	  the  numeric  portion  of  which  is contained in the NUMSTR
	  array, and if the DAPICK routine has been  called  prior  to
	  DASITE   to   identify   the   location  within  the  buffer
	  corresponding  to  the  start  of  the   possibly   multiply
	  subscripted array equivalenced with or otherwise loaded into
	  part or all of the buffer, then  DASITE  does  not  need  to
	  calculate  the  sizes  of  the  arrays  below the identified
	  array, but  DASITE  must  calculate  the  additional  offset
	  required  in the buffer to obtain the location corresponding
	  to a particular set of subscripts.  This set  of  subscripts
	  will  have been constructed by the DAROLL or DALOOP routine,
	  and will have been based upon the subscript ranges  returned
	  by  DAPICK.   When DASITE is called subsequent to DAPICK and
	  DAROLL (or DALOOP), the  arguments  KOUNT,  KNTSUB,  LRGNUM,
	  NUMINI  and  INITAL should all be input to DASITE containing
	  the values assigned to the arguments of the  same  names  by
	  DAPICK, and LSTKNT should be set equal to the value of KOUNT
	  returned by DAPICK.  IEXTRA should  be  set  to  -2,  LOWSUB
	  should  be  set  to  1,  and  the  NOWSUB array should be as
	  produced by the DAROLL or DALOOP routine.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 381
	  DASPAN, Routine to Evaluate Range Specifications


	   DDDDD          AAA    SSSSSS  PPPPPP        AAA  NN    NN
	   DD   DD       AAAA  SS        PP    PP     AAAA  NNN   NN
	   DD    DD     AA AA  SS        PP    PP    AA AA  NNNN  NN
	   DD    DD    AA  AA    SSSS    PPPPPP     AA  AA  NN NN NN
	   DD    DD   AAAAAAA        SS  PP        AAAAAAA  NN  NNNN
	   DD   DD   AA    AA        SS  PP       AA    AA  NN   NNN
	   DDDDD    AA     AA  SSSSSS    PP      AA     AA  NN    NN



	        DASPAN, Routine to Evaluate Range Specifications
	        ------  ------- -- -------- ----- --------------

	  DASPAN evaluates range specifications typed by the user  and
	  read by the calling program with a multiple of an A1 format.
	  Such range specifications can consist of a single number, or
	  of  2  numbers separated by an asterisk, or of either 2 or 3
	  numbers separated by slashes or by colons (the 2  characters
	  are equivalent).  The asterisk notation is meant to indicate
	  that the value to  the  right  of  the  asterisk  is  to  be
	  repeated  the number of times indicated by the number to the
	  left of the asterisk.  Numbers specified  in  the  slash  or
	  colon  notation  can  be  interpreted as the lower and upper
	  bounds of a range if 2 numbers are present, or as the  lower
	  bound,  the increment, and the upper bound, if 3 numbers are
	  included.

	  DASPAN reports to the calling program  whether  the  numbers
	  are  present  in  the  series  specification, as well as the
	  values of those numbers  which  are  present.   The  calling
	  program  will  have to assign default values for any numbers
	  which are missing.  The range specification /2/10  or  :2:10
	  indicates that the range is to extend from the default lower
	  bound with an increment of 2 through the upper bound of  10.
	  Each  of  the  range specifications 1/10 or 1:10 or 1//10 or
	  1::10 is taken to mean that the range is to  extend  from  1
	  through  10  with  the  default  increment.   If the numbers
	  specify the values of  a  subscript  of  an  array,  then  a
	  missing  lower  bound  might  be  taken to indicate that the
	  subscript being varied starts at its minimum possible  value
	  (usually 1), while a missing upper bound might indicate that
	  the subscript is to terminate at its maximum possible value.

	  The only printing delimiter character allowed between series
	  specifications  is  the  comma.   Two  commas  with no other
	  printing characters between them are  taken  to  indicate  a
	  missing   series  specification.   The  calling  program  is
	  informed if a semicolon is encountered  in  the  text  being
	  evaluated  by this routine.  The semicolon might be typed by
	  the user to signal that the calling program is to  terminate
	  its  requests  for data from the user.  An exclamation point
	  and any characters to its right are taken to  be  a  comment
	  and  are otherwise ignored.  An ampersand and the characters
	  to its right are similarly considered to form a comment, but
	  FASP, FORTRAN Alphameric Subroutine Package         Page 382
	  DASPAN, Routine to Evaluate Range Specifications


	  the calling program is informed that an ampersand was found.
	  Such an ampersand might be typed by  the  user  to  indicate
	  that  the  input  text  is  to be continued on the following
	  line.

	  Two versions  of  the  routine  are  supplied.   DASPAN  can
	  evaluate real numbers as well as integers including E, K and
	  M notations for specifying either of these.  If the  calling
	  program  does  not otherwise reference the free format input
	  routine DAHEFT, if the evaluation of real and octal  numbers
	  is  not  needed,  and  if  integers can be specified without
	  resorting to the E, K and  M  notations,  then  the  routine
	  DAISPN  should be used instead of DASPAN.  Numbers evaluated
	  by DAISPN must consist only of digits following the optional
	  sign.  DAISPN treats the characters ., %, K and M as illegal
	  characters.



	              The DASPAN and DAISPN Argument Lists
	              --- ------ --- ------ -------- -----

	  The argument lists of routines DASPAN and DAISPN are

	        SUBROUTINE DASPAN(KONTRL,KONECT,IBUFFR,MAXBFR,LOWBFR,
	       1    MANY  ,KIND  ,INIGOT,INCGOT,LMTGOT,INIVAL,INCVAL,
	       2    LMTVAL,VALINI,VALINC,VALLMT)

	  and

	        SUBROUTINE DAISPN       (KONECT,IBUFFR,MAXBFR,LOWBFR,
	       1    MANY  ,KIND  ,INIGOT,INCGOT,LMTGOT,INIVAL,INCVAL,
	       2    LMTVAL)

	  both with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR)

	  The ordering of the arguments is the same for both routines,
	  but  the  first argument of DASPAN, and the last 3 arguments
	  of DASPAN are not included in the DAISPN argument list.  The
	  argument  definitions  for  DAISPN are identical to those of
	  DASPAN with the exception that the  range  specification  is
	  always returned in integer form for DAISPN.

	  The following arguments are used  for  input  only  and  are
	  returned unchanged.

	  KONTRL = -1, the number in the  IBUFFR  array  is  an  octal
	           number.   The  number  can  be typed with a decimal
	           point and/or with an exponent.  However, the number
	           following the letter E of the exponent is evaluated
	           in decimal.  The  value  of  the  octal  number  is
	           returned  as one of the arguments INIVAL, INCVAL or
	  FASP, FORTRAN Alphameric Subroutine Package         Page 383
	  DASPAN, Routine to Evaluate Range Specifications


	           LMTVAL.  It must be noted that numbers evaluated as
	           negative  octal  integers  have  the negative octal
	           integer  as  their  value,   not   as   their   bit
	           representation  in  computer storage.  For example,
	           on a 36 bit twos  complement  computer,  the  octal
	           number  -400000000000 (which could also be typed as
	           -4E11 or -4E+11 where the 11  after  the  E  is  in
	           decimal) is represented as bit pattern having octal
	           notation  400000000000   and   the   octal   number
	           -377777777777  is  represented  by  the bit pattern
	           400000000001.
	         = 0, the number in the  IBUFFR  array  is  a  decimal
	           integer.   The  number  can be typed with a decimal
	           point (for example 1.23K or  1.23E3  equals  1230),
	           but  is  stored  as  an  integer  in DAHEFT, and is
	           output as one of the arguments  INIVAL,  INCVAL  or
	           LMTVAL.  Any decimal integer which the computer can
	           represent can be evaluated.  This includes, on twos
	           complement  computers,  the largest negative number
	           the absolute value of which cannot be  stored.   On
	           the  PDP-10, a 36 bit computer with twos complement
	           notation,  the  range  of   decimal   integers   is
	           -34359738368   through   34359738367   (the   octal
	           notation of the  bit  patterns  being  400000000000
	           through 377777777777).
	         = 1 or greater, the number in the IBUFFR array  is  a
	           real  number.  If possible, the real number will be
	           accumulated as an integer,  then  be  converted  to
	           real  and shifted if necessary.  KONTRL is then the
	           maximum number of digits in the integer.  The value
	           is output as one of the arguments VALINI, VALINC or
	           VALLMT.  If the item has more than  KONTRL  digits,
	           then  the  entire  evaluation is done in real mode.
	           The advantage of calculating  the  real  values  in
	           integer as long as the precision of the computer is
	           not overflowed  is  that  the  calculation  of  the
	           portion of the number right of the decimal point is
	           more exact.  As an example, if  KONTRL  is  greater
	           than  or  equal  to 4, then the number 33.33 can be
	           stored as the integer 3333, then  be  converted  to
	           the  real  value  3333.0  and  divided  by 100.0 to
	           obtain the final answer.  If it makes no difference
	           whether  the  number typed as 33.33 has value 33.33
	           or 33.32999...  then KONTRL can be given the  value
	           1.

	  KONECT = -1, once a slash, a colon, an asterisk or a  number
	           is   found   in   the   IBUFFR  array,  the  series
	           specification will extend to the next space or  tab
	           character,  or  to any character other than a slash
	           or a colon or an asterisk which immediately follows
	           a   number   in   the   series  specification.   If
	           KONECT=-1, then the text
	  FASP, FORTRAN Alphameric Subroutine Package         Page 384
	  DASPAN, Routine to Evaluate Range Specifications


	                1/2+3/4 5/6+7/+8

	           would contain the range specifications 1 to 2, 3 to
	           4, 5 to 6, and 7 to 8.
	         = 0, spaces and/or tab characters can appear  between
	           the  numbers  of a series in addition to slashes or
	           colons or asterisk.  The slashes or colons  or  the
	           asterisk are, however, required.
	         = 1, spaces and/or tab characters can appear  between
	           the  numbers of a series in addition to or in place
	           of slashes or colons or  asterisks.   If  KONECT=1,
	           then the text

	                1 2 3,4/5 6,7 8/9,10 / 11 12

	           is exactly equivalent, except for the value of KIND
	           returned for the first series, to the text

	                1/2/3,4/5/6,7/8/9,10/11/12

	           The first series (1 2 3) in the first example would
	           return  KIND=5 indicating a series in which neither
	           a slash nor a colon nor an asterisk appeared, while
	           the   corresponding  series  specification  in  the
	           second example would return KIND=6 indicating  that
	           at   least   1  slash  or  at  least  1  colon  was
	           encountered in the series specification.

	  IBUFFR = input buffer array containing characters  typed  by
	           the  user,  as  read by a multiple of an A1 format,
	           which is to be searched for series  specifications.
	           IBUFFR  then  contains  one  character per computer
	           storage location.

	  MAXBFR = maximum subscript of the IBUFFR array locations  to
	           be searched

	  The following arguments are used as both input and output.

	  LOWBFR = input containing the subscript  within  the  IBUFFR
	           array  of  the first (leftmost) character which can
	           be scanned for a series specification.  LOWBFR will
	           be  returned  pointing to the next character beyond
	           the series specification.  LOWBFR and MANY must  be
	           set  by  the  calling  program  before  anything is
	           processed in the current  contents  of  the  IBUFFR
	           array,  but  then  should  not  be  modified by the
	           calling program until the entire  contents  of  the
	           IBUFFR array have been processed.

	           If KONECT is less than or equal  to  0,  forcing  a
	           series specification to contain either a slash or a
	           colon or an  asterisk  between  the  numbers  of  a
	           series,  and if a second number immediately follows
	  FASP, FORTRAN Alphameric Subroutine Package         Page 385
	  DASPAN, Routine to Evaluate Range Specifications


	           a first without a  separating  slash  or  colon  or
	           asterisk,  then LOWBFR will be returned pointing to
	           the first  character  of  the  second  number.   If
	           KONECT  is  -1  and  if  either  a  space  or a tab
	           character  follows  a  series  specification,  then
	           LOWBFR  will  be  returned pointing to the space or
	           tab character.  If KONECT is greater than or  equal
	           to  0, allowing spaces and tab characters to appear
	           within a series specification, then LOWBFR will  be
	           returned  pointing  to  the  first character to the
	           right of the series  and  which  is  not  itself  a
	           space,  a  tab  character,  a  slash, a colon or an
	           asterisk and which cannot appear within  a  number.
	           If  there are no printing characters at or to right
	           of LOWBFR, then LOWBFR will be returned  containing
	           MAXBFR+1 and KIND will be returned containing one.

	  MANY   = should be input  containing  zero  each  time  this
	           routine  is  called  to  begin  processing of a new
	           logical  section  of  text,  as  for  example  when
	           beginning  processing of a line of text not tied to
	           the previous line by an ampersand at the end of the
	           previous  line,  or when processing the text to the
	           right of a semicolon.  The initial zeroing of  this
	           argument  must  be done by the calling program, but
	           thereafter the value returned by the previous  call
	           to  this  routine  can  usually  be  used.  MANY is
	           returned set to zero each time a semicolon (KIND=2)
	           is  found, and each time an end of line not tied to
	           the following line  by  an  ampersand  (KIND=1)  is
	           found.   MANY  is  returned containing one plus its
	           input absolute value each time a description  of  a
	           series  specification  is returned by this routine,
	           each time  an  erroneous  series  specification  is
	           found,  each time an unknown character is found, or
	           each  time  an  indication  of  a  missing   series
	           specification   is   found.    KIND   is   returned
	           containing  the  value  3  and  MANY  is   returned
	           containing  the  negative  of  the  number of items
	           found if the next printing  character  following  a
	           comma  is an ampersand.  MANY should not be changed
	           by the calling program if an ampersand (KIND  being
	           returned=3) is found indicating that the subsequent
	           call to this routine is to process text which is to
	           be  treated  as  though it appeared in place of the
	           ampersand and the characters  to  its  right.   The
	           effect  is  not  quite  the same as if the user had
	           typed all of the text on  a  single  line  since  a
	           single  series specification cannot be split across
	           the line boundary.

	           If MANY is input containing zero, then  an  initial
	           comma in the input text buffer is taken to indicate
	           an initial missing item, and MANY is then  returned
	  FASP, FORTRAN Alphameric Subroutine Package         Page 386
	  DASPAN, Routine to Evaluate Range Specifications


	           containing  1.  If MANY is input greater than zero,
	           then an initial comma is ignored if followed  by  a
	           series  specification.   If  MANY  is input greater
	           than zero, then an initial  comma  followed  by  no
	           other printing characters, by a semicolon, or by an
	           exclamation point indicates  a  missing  item.   If
	           MANY  is  input  greater than zero, then an initial
	           comma followed  by  an  ampersand  will  cause  the
	           remaining  characters  in the buffer to be ignored,
	           and MANY will be returned containing  the  negative
	           of  its  input  value.   If MANY is input negative,
	           then it is assumed that the contents of the current
	           buffer  continue  a  previous line which terminated
	           with a comma followed by an ampersand, and MANY  is
	           returned greater than zero.

	  The following arguments are used only for output.

	  KIND   = returned describing the kind of item located in the
	           IBUFFR array.
	         = 1,  either  no  printing  characters  or  else   an
	           exclamation  point  as the first printing character
	           (marking the rest of the line  as  a  comment)  was
	           found  at  or  to the right of IBUFFR(LOWBFR).  The
	           calling program should read a new line into IBUFFR.
	           MANY,  INIGOT,  INCGOT and LMTGOT are each returned
	           with the value zero.
	         = 2, a semicolon was  found  as  the  first  printing
	           character  at  or  to  the right of IBUFFR(LOWBFR).
	           LOWBFR is returned pointing to the  next  character
	           beyond  the  location  of  the  semicolon.   It  is
	           assumed  the  calling  program   will   treat   the
	           appearance of the semicolon as marking the end of a
	           statement.  MANY is returned set to zero.
	         = 3, an ampersand was found  as  the  first  printing
	           character  at  or  to  the right of IBUFFR(LOWBFR).
	           The text to the right of the ampersand is taken  as
	           a comment so LOWBFR is returned pointing beyond the
	           right end of the buffer.  It is  assumed  that  the
	           calling  program will read in the contents of a new
	           buffer, then again request a new series  evaluation
	           from  this  routine.  The value of MANY must not be
	           changed  by  the  calling  program  prior  to  this
	           following  call.   The effect is not quite the same
	           as if the user had typed  all  of  the  text  on  a
	           single  line since a series specification cannot be
	           split across a line boundary.
	         = 4, a number or series specification was not  found,
	           but  a  comma was found indicating a missing series
	           specification.  INIGOT, INCGOT and LMTGOT are  each
	           returned  with  the  value  zero  so  KIND=4 can be
	           considered  equivalent  to  KIND=5   if   such   is
	           appropriate  to  the  application  for  which  this
	           routine is being used.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 387
	  DASPAN, Routine to Evaluate Range Specifications


	         = 5, a single number with neither a slash nor a colon
	           nor  an  asterisk  was  found  in the input buffer.
	           Both INIGOT and LMTGOT are returned  containing  1,
	           and  the  value of the number is returned either in
	           both INIVAL  and  LMTVAL  or  in  both  VALINI  and
	           VALLMT,   whichever   is  appropriate.   INCGOT  is
	           returned containing zero.
	         = 6, either 2 or 3 numbers were  found,  but  without
	           slashes  or  colons or asterisks.  The value of the
	           left number is returned in either INIVAL or VALINI,
	           of the right in either LMTVAL or VALLMT, and of the
	           middle, if present, in  either  INCVAL  or  VALINC,
	           whichever  is  appropriate.   INIGOT and LMTGOT are
	           each returned containing  1.   INCGOT  is  returned
	           containing  1 only if 3 numbers were found.  KONECT
	           would have to be input as 1 for KIND to be returned
	           as 6.
	         = 7, a series specification containing  one  or  more
	           slashes  and/or  colons was found.  The location of
	           the slash or slashes or colon or colons relative to
	           the numbers, if any, in the series specification is
	           indicated by the returned values of INIGOT,  INCGOT
	           and LMTGOT.
	         = 8,  a  series  specification  containing  a  single
	           asterisk  was found.  INCGOT is returned containing
	           zero.  The location of the asterisk relative to the
	           numbers,  if  any,  in  the series specification is
	           indicated by the  returned  values  of  INIGOT  and
	           LMTGOT.
	         = 9, a series specification was found which  included
	           too many numbers, too many slashes, too many colons
	           or too many asterisks.  INIGOT, INCGOT  and  LMTGOT
	           are each returned containing zero.
	         = 10, the first  printing  character  (other  than  a
	           possible comma if MANY was input greater than zero)
	           in  or  to  right  of  IBUFFR(LOWBFR)  was  not   a
	           character  which could appear in a number or number
	           range, and was not a comma, semicolon,  exclamation
	           point or ampersand.  LOWBFR is returned pointing to
	           the next character  beyond  this  initial  printing
	           character.   The  calling  program  must  decrement
	           LOWBFR by 1 if  the  unknown  character  is  to  be
	           identified by other routines in this package.

	  INIGOT = 0, returned if the characters in the buffer do  not
	           represent  a series specification which includes an
	           initial number.  INIVAL  or  VALINI,  whichever  is
	           appropriate,  is  returned  undefined, but probably
	           changed.
	         = 1,  returned  if  the  characters  in  the   buffer
	           represent  a series specification which includes an
	           initial number.  This initial number would probably
	           be interpreted as the start of a range if preceding
	           a slash or a colon, or as the number of  times  the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 388
	  DASPAN, Routine to Evaluate Range Specifications


	           following  number is to be repeated if preceding an
	           asterisk.    INIVAL   or   VALINI,   whichever   is
	           appropriate,  is  returned  containing this initial
	           number.

	  INCGOT = 0, returned if the characters in the buffer do  not
	           represent  a  series specification which includes a
	           middle   number.    INCGOT   is   always   returned
	           containing  zero for a series specified in asterisk
	           notation, since such a series specification  cannot
	           include   a   middle  number.   INCVAL  or  VALINC,
	           whichever is appropriate,  is  returned  undefined,
	           but probably changed.
	         = 1,  returned  if  the  characters  in  the   buffer
	           represent  a  series specification which includes a
	           middle number.  This middle number  would  probably
	           be  interpreted  as  the  increment  by  which  the
	           initial number is to be varied until it reaches the
	           final  number.   INCVAL  or  VALINC,  whichever  is
	           appropriate, is returned containing this increment.

	  LMTGOT = 0, returned if the characters in the buffer do  not
	           represent  a  series specification which includes a
	           final  number.   LMTVAL  or  VALLMT,  whichever  is
	           appropriate,  is  returned  undefined, but probably
	           changed.
	         = 1,  returned  if  the  characters  in  the   buffer
	           represent  a  series specification which includes a
	           final number.  This final number would probably  be
	           interpreted  as  the  end of a range if following a
	           slash or a colon, or if following  an  asterisk  as
	           the  number  which  is to be repeated the number of
	           times  indicated  by  the  number   preceding   the
	           asterisk.    LMTVAL   or   VALLMT,   whichever   is
	           appropriate,  is  returned  containing  this  final
	           number.   If  merely  a single number is found with
	           neither asterisk nor slash nor colon,  then  INCGOT
	           is returned containing zero, both INIGOT and LMTGOT
	           are  returned  containing  1,  and  the  number  is
	           returned  either  in  both  INIVAL and LMTVAL or in
	           both VALINI and VALLMT.

	         The following illustration shows the returned  values
	         of  INIGOT,  INCGOT  and  LMTGOT  for  various series
	         specifications.  Colons could appear in place of  any
	         or  all  slashes shown in the examples.  Those series
	         specifications containing spaces in place of  slashes
	         or   asterisks   would  require  KONECT=1  for  their
	         evaluation as single  range  specifications.   It  is
	         assumed  that  KONTRL=0 so that the evaluated numbers
	         are returned  in  INIVAL,  INCVAL  and  LMTVAL.   The
	         letter  u in place of a returned value indicates that
	         the corresponding argument is returned undefined  but
	         probably changed.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 389
	  DASPAN, Routine to Evaluate Range Specifications


	                                                        LMTVAL
	                                                      INCVAL !
	                                                    INIVAL ! !
	                                                LMTGOT   ! ! !
	                                              INCGOT !   ! ! !
	                                            INIGOT ! !   ! ! !
	         empty  or  /      or  //     or  *      0 0 0   u u u
	         ///    or  5///9  or  5 2 2 9           0 0 0   u u u
	         **     or  5*2*9  or  5*2/9  or 5/2*9   0 0 0   u u u
	         /9     or  //9    or  *9                0 0 1   u u 9
	         /2/                                     0 1 0   u 2 u
	         /2/9   or  /2 9                         0 1 1   u 2 9
	         5/     or  5//    or  5*                1 0 0   5 u u
	         5                                       1 0 1   5 u 5
	         5/9    or  5//9   or  5 9    or  5*9    1 0 1   5 u 9
	         5/2/   or  5 2/                         1 1 0   5 2 u
	         5/2/9  or  5 2/9  or  5/2 9  or  5 2 9  1 1 1   5 2 9

	  INIVAL = returned containing the number at the start of  the
	           range  specification  if  this  is  evaluated as an
	           octal or decimal integer (KONTRL input less than or
	           equal to zero and INIGOT returned = 1).

	  INCVAL = returned containing the middle number in the  range
	           specification  if  this is evaluated as an octal or
	           decimal integer (KONTRL input less than or equal to
	           zero and INCGOT returned = 1).

	  LMTVAL = returned containing the number at the  end  of  the
	           range  specification  if  this  is  evaluated as an
	           octal or decimal integer (KONTRL input less than or
	           equal to zero and LMTGOT returned = 1).

	  VALINI = returned containing the number at the start of  the
	           range  specification if this is evaluated as a real
	           number (KONTRL input greater than zero  and  INIGOT
	           returned = 1).

	  VALINC = returned containing the middle number in the  range
	           specification if this is evaluated as a real number
	           (KONTRL input greater than zero and INCGOT returned
	           = 1).

	  VALLMT = returned containing the number at the  end  of  the
	           range  specification if this is evaluated as a real
	           number (KONTRL input greater than zero  and  LMTGOT
	           returned = 1).
	  FASP, FORTRAN Alphameric Subroutine Package         Page 390
	  DASPAN, Routine to Evaluate Range Specifications


	       Demonstration Program to Interactively Test DASPAN
	       ------------- ------- -- ------------- ---- ------

	  The program listed on the following pages accepts a line  of
	  text from the user, then reports each punctuation mark, each
	  single value, and each range together with  the  portion  of
	  the  text  by  which  these  are specified.  A sample dialog
	  between the program and the user is presented following  the
	  listing of the program.

	  C     PROGRAM TO DEMONSTRATE DASPAN ROUTINE
	  C
	        DIMENSION IBUFFR(60),JBUFFR(60),LEGEND(28)
	        DATA LEGEND/1HI,1HN,1HI,1HT,1HI,1HA,1HL,1H ,
	       11H,,1H ,1HI,1HN,1HC,1HR,1HE,1HM,1HE,1HN,1HT,1H ,
	       21H,,1H ,1HL,1HI,1HM,1HI,1HT,1H /
	        DATA ITTY,JTTY/5,5/
	        DATA MAXBFR,MAXOUT/60,60/
	        DATA IGREAT,IBLANK/1H>,1H /
	        WRITE(JTTY,1)
	      1 FORMAT(1X,37HPROGRAM TO DEMONSTRATE DASPAN ROUTINE/
	       124H TEST DAISPN (Y OR N) = ,$)
	        READ(ITTY,2)IANS
	      2 FORMAT(1A1)
	        KONTRL=0
	        IF(IANS.EQ.1HY)GO TO 4
	        WRITE(JTTY,3)
	      3 FORMAT(10H KONTRL = ,$)
	        READ(ITTY,6)KONTRL
	      4 IRADIX=10
	        IF(KONTRL.LT.0)IRADIX=8
	        WRITE(JTTY,5)
	      5 FORMAT(10H KONECT = ,$)
	        READ(ITTY,6)KONECT
	      6 FORMAT(1I)
	        MANY=0
	  C
	  C     READ TEXT TYPED BY USER
	      7 WRITE(JTTY,8)
	      8 FORMAT(1X,1H*,$)
	        READ(ITTY,9)IBUFFR
	      9 FORMAT(60A1)
	        LOWBFR=1
	     10 INIBFR=LOWBFR
	        IF(IANS.EQ.1HY)
	       1  CALL DAISPN(       KONECT,IBUFFR,MAXBFR,LOWBFR,
	       2MANY  ,KIND  ,INIGOT,INCGOT,LMTGOT,INIVAL,INCVAL,
	       3LMTVAL)
	        IF(IANS.NE.1HY)
	       1  CALL DASPAN(KONTRL,KONECT,IBUFFR,MAXBFR,LOWBFR,
	       2MANY  ,KIND  ,INIGOT,INCGOT,LMTGOT,INIVAL,INCVAL,
	       3LMTVAL,VALINI,VALINC,VALLMT)
	        IF(LOWBFR.LE.INIBFR)GO TO 12
	        J=LOWBFR-1
	  FASP, FORTRAN Alphameric Subroutine Package         Page 391
	  DASPAN, Routine to Evaluate Range Specifications


	        WRITE(JTTY,11)(IBUFFR(I),I=INIBFR,J),IGREAT
	     11 FORMAT(1X,1H<,100A1)
	     12 GO TO(13,15,17,19,25,25,25,25,21,23),KIND
	  C
	  C     REPORT IF OTHER THAN SINGLE NUMBER OR CORRECT SERIES
	     13 WRITE(JTTY,14)
	     14 FORMAT(6H EMPTY)
	        GO TO 7
	     15 WRITE(JTTY,16)
	     16 FORMAT(17H END OF STATEMENT)
	        GO TO 10
	     17 WRITE(JTTY,18)
	     18 FORMAT(10H AMPERSAND)
	        GO TO 7
	     19 WRITE(JTTY,20)MANY
	     20 FORMAT(8H MISSING,I3)
	        GO TO 10
	     21 WRITE(JTTY,22)
	     22 FORMAT(15H TOO MANY ITEMS)
	        GO TO 10
	     23 WRITE(JTTY,24)
	     24 FORMAT(18H ILLEGAL DELIMITER)
	        GO TO 10
	  C
	  C     REPORT SINGLE NUMBER OR CORRECT SERIES
	     25 KOUNT=1
	        JBUFFR(1)=IBLANK
	        DO 37 IPASS=1,3
	        GO TO(26,29,32),IPASS
	     26 IF(INIGOT.EQ.0)GO TO 37
	        DO 27 I=1,8
	        KOUNT=KOUNT+1
	     27 JBUFFR(KOUNT)=LEGEND(I)
	        IF(KONTRL.GT.0)GO TO 28
	        NUMBER=INIVAL
	        GO TO 34
	     28 VALUE=VALINI
	        GO TO 36
	     29 IF(INCGOT.EQ.0)GO TO 37
	        J=11
	        IF(KOUNT.GT.1)J=9
	        DO 30 I=J,20
	        KOUNT=KOUNT+1
	     30 JBUFFR(KOUNT)=LEGEND(I)
	        IF(KONTRL.GT.0)GO TO 31
	        NUMBER=INCVAL
	        GO TO 34
	     31 VALUE=VALINC
	        GO TO 36
	     32 IF(LMTGOT.EQ.0)GO TO 37
	        J=23
	        IF(KOUNT.GT.1)J=21
	        DO 33 I=J,28
	        KOUNT=KOUNT+1
	  FASP, FORTRAN Alphameric Subroutine Package         Page 392
	  DASPAN, Routine to Evaluate Range Specifications


	     33 JBUFFR(KOUNT)=LEGEND(I)
	        IF(KONTRL.GT.0)GO TO 35
	        NUMBER=LMTVAL
	     34 LFTCOL=KOUNT
	        CALL DANUMB(0,NUMBER,IRADIX,JBUFFR,
	       1KOUNT,LFTCOL,MAXOUT)
	        GO TO 37
	     35 VALUE=VALLMT
	     36 LFTCOL=KOUNT
	        CALL DARITE(VALUE,-1,0,0,0,
	       1-3,0,10,-1,-2,6,6,
	       2-1,0,5,0,0,0,LFTCOL,
	       3MAXOUT,JBUFFR,KOUNT,IERR)
	     37 CONTINUE
	        IF(KIND.EQ.5)WRITE(JTTY,38)MANY,(JBUFFR(I),I=1,KOUNT)
	     38 FORMAT(8H NUMBER ,I3,1H ,100A1)
	        IF(KIND.EQ.6)WRITE(JTTY,39)MANY,(JBUFFR(I),I=1,KOUNT)
	     39 FORMAT(8H SERIES ,I3,1H ,100A1)
	        IF(KIND.EQ.7)WRITE(JTTY,40)MANY,(JBUFFR(I),I=1,KOUNT)
	     40 FORMAT(8H SERIES ,I3,1H/,100A1)
	        IF(KIND.EQ.8)WRITE(JTTY,41)MANY,(JBUFFR(I),I=1,KOUNT)
	     41 FORMAT(8H SERIES ,I3,1H*,100A1)
	        GO TO 10
	        END



	  Typical Dialog Between DASPAN Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  PROGRAM TO DEMONSTRATE DASPAN ROUTINE
	  TEST DAISPN (Y OR N) = N
	  KONTRL = 4
	  KONECT = -1
	  *10-20 30 -40,50 , -60  ,  70 , &COMMA ALSO STARTS NEXT LINE
	  <10>
	  NUMBER   1  INITIAL 10, LIMIT 10
	  <-20>
	  NUMBER   2  INITIAL -20, LIMIT -20
	  < 30>
	  NUMBER   3  INITIAL 30, LIMIT 30
	  < -40>
	  NUMBER   4  INITIAL -40, LIMIT -40
	  <,50>
	  NUMBER   5  INITIAL 50, LIMIT 50
	  < , -60>
	  NUMBER   6  INITIAL -60, LIMIT -60
	  <  ,  70>
	  NUMBER   7  INITIAL 70, LIMIT 70
	  < , &COMMA ALSO STARTS NEXT LINE >
	  AMPERSAND
	  *,10/20-30/40 -50/60  ,  -70/80,&COMMA ONLY BEFORE AMPERSAND
	  MISSING  8
	  <,10/20>
	  FASP, FORTRAN Alphameric Subroutine Package         Page 393
	  DASPAN, Routine to Evaluate Range Specifications


	  SERIES   9/ INITIAL 10, LIMIT 20
	  <-30/40>
	  SERIES  10/ INITIAL -30, LIMIT 40
	  < -50/60>
	  SERIES  11/ INITIAL -50, LIMIT 60
	  <  ,  -70/80>
	  SERIES  12/ INITIAL -70, LIMIT 80
	  <,&COMMA ONLY BEFORE AMPERSAND >
	  AMPERSAND
	  *3*-16.01  ,  ,   //77K   ;  ,  /87.2/   &COMMA ON NEXT LINE
	  <3*-16.01>
	  SERIES  13* INITIAL 3, LIMIT -16.01
	  <  ,  >
	  MISSING 14
	  <,   //77K>
	  SERIES  15/ LIMIT 77000
	  <   ;>
	  END OF STATEMENT
	  <  >
	  MISSING  1
	  <,  /87.2/>
	  SERIES   2/ INCREMENT 87.2
	  <   &COMMA ON NEXT LINE >
	  AMPERSAND
	  *, / , // , *  &COMMA ON NEITHER LINE
	  <, />
	  SERIES   3/
	  < , //>
	  SERIES   4/
	  < , *>
	  SERIES   5*
	  <  &COMMA ON NEITHER LINE                        >
	  AMPERSAND
	  */9 , //9 , *9  !COMMENT NOT MARKING A CONTINUATION
	  </9>
	  SERIES   6/ LIMIT 9
	  < , //9>
	  SERIES   7/ LIMIT 9
	  < , *9>
	  SERIES   8* LIMIT 9
	  <  !COMMENT NOT MARKING A CONTINUATION          >
	  EMPTY
	  */2/
	  </2/>
	  SERIES   1/ INCREMENT 2
	  <                                                         >
	  EMPTY
	  */2/9
	  </2/9>
	  SERIES   1/ INCREMENT 2, LIMIT 9
	  <                                                        >
	  EMPTY
	  *5/ , 5// , 5*
	  <5/>
	  FASP, FORTRAN Alphameric Subroutine Package         Page 394
	  DASPAN, Routine to Evaluate Range Specifications


	  SERIES   1/ INITIAL 5
	  < , 5//>
	  SERIES   2/ INITIAL 5
	  < , 5*>
	  SERIES   3* INITIAL 5
	  <                                               >
	  EMPTY
	  * 5
	  < 5>
	  NUMBER   1  INITIAL 5, LIMIT 5
	  <                                                          >
	  EMPTY
	  *5/9 , 5//9 , 5*9
	  <5/9>
	  SERIES   1/ INITIAL 5, LIMIT 9
	  < , 5//9>
	  SERIES   2/ INITIAL 5, LIMIT 9
	  < , 5*9>
	  SERIES   3* INITIAL 5, LIMIT 9
	  <                                            >
	  EMPTY
	  *5/2/
	  <5/2/>
	  SERIES   1/ INITIAL 5, INCREMENT 2
	  <                                                        >
	  EMPTY
	  *5/2/9
	  <5/2/9>
	  SERIES   1/ INITIAL 5, INCREMENT 2, LIMIT 9
	  <                                                       >
	  EMPTY
	  */// , 5///9 , /2/2/ , 5//2/ , ** , 5*2*9 , 5*2/9 , 5/2*9
	  <///>
	  TOO MANY ITEMS
	  < , 5///9>
	  TOO MANY ITEMS
	  < , /2/2/>
	  TOO MANY ITEMS
	  < , 5//2/>
	  TOO MANY ITEMS
	  < , **>
	  TOO MANY ITEMS
	  < , 5*2*9>
	  TOO MANY ITEMS
	  < , 5*2/9>
	  TOO MANY ITEMS
	  < , 5/2*9>
	  TOO MANY ITEMS
	  <    >
	  EMPTY
	  FASP, FORTRAN Alphameric Subroutine Package         Page 395
	  DASWAP, Swaps Adjacent Regions in Buffer


	  DDDDDDD      AAA     SSSSSSS  WWW    WWW    AAA    PPPPPPPPP
	  DDD   DDD  AAA AAA  SSS       WWW    WWW  AAA AAA  PPP   PPP
	  DDD   DDD AAA   AAA  SSSSSSS  WWW WW WWW AAA   AAA PPPPPPPPP
	  DDD   DDD AAAAAAAAA       SSS WWWW  WWWW AAAAAAAAA PPP
	  DDDDDDD   AAA   AAA SSSSSSSS  WWW    WWW AAA   AAA PPP



	            DASWAP, Swaps Adjacent Regions in Buffer
	            ------  ----- -------- ------- -- ------

	  DASWAP is a FORTRAN routine which  interchanges  2  adjacent
	  regions  in  the  input array without the use of a temporary
	  storage array.  The swap is performed by moving  the  values
	  directly  to  the  locations which they are to occupy in the
	  result.  This operation is often useful for the manipulation
	  of  characters  read  1  to a computer storage location by a
	  multiple of an A1 format or else defined by  other  routines
	  within this package.


	                    The DASWAP Argument List
	                    --- ------ -------- ----

	  The argument list of routine DASWAP is

	        SUBROUTINE DASWAP(IARRAY,LOW,MID,MAX)

	  with the associated DIMENSION statement

	        DIMENSION IARRAY(MAX)

	  IARRAY is used for  both  input  to  and  output  from  this
	  routine.   The rest of the arguments are used for input only
	  and are returned unchanged.

	  IARRAY = the array which is input  containing  in  locations
	           IARRAY(LOW)  through  IARRAY(MID) the lower section
	           of text which is  to  be  swapped  with  the  upper
	           section  of text in locations IARRAY(MID+1) through
	           IARRAY(MAX).   Each  IARRAY  location  contains   a
	           single  character as though read by an A1 format or
	           defined by a 1H field.

	  LOW    = the subscript within the IARRAY array of the lowest
	           location within the lower region.

	  MID    = the  subscript  within  the  IARRAY  array  of  the
	           highest location within the lower region.

	  MAX    = the  subscript  within  the  IARRAY  array  of  the
	           highest location within the higher region.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 396
	  DASWAP, Swaps Adjacent Regions in Buffer


	      Demonstration of Manner in which Regions are Swapped
	      ------------- -- ------ -- ----- ------- --- -------

	   A B C D 1 2   Illustration at left demonstrates how regions
	   . <-------<   of  4  items,  letters  A through D, and of 2
	   . >---> . .   items, digits 1 and 2,  are  swapped.   2  is
	   . . . >--->   moved into location holding B, which is moved
	   <-------< .   into location holding  D,  which  is  finally
	   >---> . . .   moved  into  location  originally  holding 2.
	   . . >---> .   This swapped half of items so  same  sequence
	   1 2 A B C D   is performed with items at 1, A and C.

	   On this and the following  page  are  shown  all  pairs  of
	   regions  for which the sums of the region sizes vary from 2
	   through 8, except for those cases in which 1 region  has  a
	   zero length.

	   sum=2      sum=3                sum=4
	   
	   A 1        A 1 2   A B 1        A 1 2 3   A B 1 2   A B C 1
	   <-<        . <-<   <---<        . . <-<   . <---<   <-----<
	   >->        <-< .   >-> .        . <-< .   . >--->   >-> . .
	   1 A        >--->   . >->        <-< . .   <---< .   . >-> .
	              1 2 A   1 A B        >----->   >---> .   . . >->
	                                   1 2 3 A   1 2 A B   1 A B C
	   sum=5
	   
	   A 1 2 3 4   A B 1 2 3   A B C 1 2   A B C D 1
	   . . . <-<   . . <---<   . <-----<   <-------<
	   . . <-< .   <---< . .   . >---> .   >-> . . .
	   . <-< . .   >-----> .   <-----< .   . >-> . .
	   <-< . . .   . <---< .   >---> . .   . . >-> .
	   >------->   . >----->   . . >--->   . . . >->
	   1 2 3 4 A   1 2 3 A B   1 2 A B C   1 A B C D
	   
	   sum=6
	   
	   A 1 2 3 4 5   A B 1 2 3 4   A B C 1 2 3   A B C D 1 2
	   . . . . <-<   . . . <---<   . . <-----<   . <-------<
	   . . . <-< .   . <---< . .   . . >----->   . >---> . .
	   . . <-< . .   . >------->   . <-----< .   . . . >--->
	   . <-< . . .   . . <---< .   . >-----> .   <-------< .
	   <-< . . . .   <---< . . .   <-----< . .   >---> . . .
	   >--------->   >-------> .   >-----> . .   . . >---> .
	   1 2 3 4 5 A   1 2 3 4 A B   1 2 3 A B C   1 2 A B C D
	   
	   A B C D E 1
	   <---------<
	   >-> . . . .
	   . >-> . . .
	   . . >-> . .
	   . . . >-> .
	   . . . . >->
	   1 A B C D E
	  FASP, FORTRAN Alphameric Subroutine Package         Page 397
	  DASWAP, Swaps Adjacent Regions in Buffer


	   Illustrations shown below demonstrate sums of 7 and 8.

	   A 1 2 3 4 5 6   A B 1 2 3 4 5   A B C 1 2 3 4
	   . . . . . <-<   . . . . <---<   . . . <-----<
	   . . . . <-< .   . . <---< . .   <-----< . . .
	   . . . <-< . .   <---< . . . .   >-------> . .
	   . . <-< . . .   >---------> .   . <-----< . .
	   . <-< . . . .   . . . <---< .   . >-------> .
	   <-< . . . . .   . <---< . . .   . . <-----< .
	   >----------->   . >--------->   . . >------->
	   1 2 3 4 5 6 A   1 2 3 4 5 A B   1 2 3 4 A B C
	   
	   A B C D 1 2 3   A B C D E 1 2   A B C D E F 1
	   . . <-------<   . <---------<   <-----------<
	   . . >-----> .   . >---> . . .   >-> . . . . .
	   . <-------< .   . . . >---> .   . >-> . . . .
	   . >-----> . .   <---------< .   . . >-> . . .
	   <-------< . .   >---> . . . .   . . . >-> . .
	   >-----> . . .   . . >---> . .   . . . . >-> .
	   . . . >----->   . . . . >--->   . . . . . >->
	   1 2 3 A B C D   1 2 A B C D E   1 A B C D E F
	   
	   A 1 2 3 4 5 6 7   A B 1 2 3 4 5 6   A B C 1 2 3 4 5
	   . . . . . . <-<   . . . . . <---<   . . . . <-----<
	   . . . . . <-< .   . . . <---< . .   . <-----< . . .
	   . . . . <-< . .   . <---< . . . .   . >---------> .
	   . . . <-< . . .   . >----------->   . . . <-----< .
	   . . <-< . . . .   . . . . <---< .   <-----< . . . .
	   . <-< . . . . .   . . <---< . . .   >---------> . .
	   <-< . . . . . .   <---< . . . . .   . . <-----< . .
	   >------------->   >-----------> .   . . >--------->
	   1 2 3 4 5 6 7 A   1 2 3 4 5 6 A B   1 2 3 4 5 A B C
	   
	   A B C D 1 2 3 4   A B C D E 1 2 3   A B C D E F 1 2
	   . . . <-------<   . . <---------<   . <-----------<
	   . . . >------->   . . >-----> . .   . >---> . . . .
	   . . <-------< .   <---------< . .   . . . >---> . .
	   . . >-------> .   >-----> . . . .   . . . . . >--->
	   . <-------< . .   . . . >-----> .   <-----------< .
	   . >-------> . .   . <---------< .   >---> . . . . .
	   <-------< . . .   . >-----> . . .   . . >---> . . .
	   >-------> . . .   . . . . >----->   . . . . >---> .
	   1 2 3 4 A B C D   1 2 3 A B C D E   1 2 A B C D E F
	   
	   A B C D E F G 1
	   <-------------<
	   >-> . . . . . .
	   . >-> . . . . .
	   . . >-> . . . .
	   . . . >-> . . .
	   . . . . >-> . .
	   . . . . . >-> .
	   . . . . . . >->
	   1 A B C D E F G
	  FASP, FORTRAN Alphameric Subroutine Package         Page 398
	  DATALL, Time Series Plot Routine for Printer


	   DDDDD          AAA  TTTTTTTT      AAA  LL        LL
	   DD   DD       AAAA     TT        AAAA  LL        LL
	   DD    DD     AA AA     TT       AA AA  LL        LL
	   DD    DD    AA  AA     TT      AA  AA  LL        LL
	   DD    DD   AAAAAAA     TT     AAAAAAA  LL        LL
	   DD   DD   AA    AA     TT    AA    AA  LL        LL
	   DDDDD    AA     AA     TT   AA     AA  LLLLLLLL  LLLLLLLL



	          DATALL, Time Series Plot Routine for Printer
	          ------  ---- ------ ---- ------- --- -------

	  DATALL is a FORTRAN subroutine  which  constructs  printable
	  plots  with  a vertical axis representing time (or any other
	  variable which has a  constant  increment  between  samples)
	  extending  onto  as many lines and pages as are necessary to
	  represent the data.  The points which represent a particular
	  data  item in consecutive time periods can be connected with
	  line segments to form a curve.  A curve  does  not  need  to
	  extend  across  all  time  periods.  The sections of a curve
	  which are outside the plot  area  are  not  represented.   A
	  maximum  of  26  curves are distinguishable by being plotted
	  with different letters, but there is no limit to  the  total
	  number  of  curves  which  can  be included in the plot of a
	  particular time period or in the plot of all  time  periods.
	  Overlapping  sections  of  curves  represented  by different
	  letters are indicated by ampersands.

	  DATALL is called once for  each  time  period  to  append  a
	  representation  of the data for that time period to the plot
	  of the data for the previous time period.  Arrays  input  to
	  DATALL specify the horizontal or non-time coordinate of each
	  point for the time period,  the  letters  with  which  these
	  points  are  to  be  plotted, and the letters with which the
	  points are to be connected with the points for the  previous
	  time  period.  The segment of the plot representing a single
	  time period can contain several points and/or lines.  It  is
	  optional whether the plot segment representing a time period
	  is ruled with a grid line  and  is  identified  by  a  scale
	  number.

	  DATALL is a  relatively  short  routine  which  relies  upon
	  DAPLAT  for  its plotting capabilities.  The routines DARITE
	  and PLTCUT must also  be  loaded  as  these  are  called  by
	  DAPLAT.   DAPLAT  must  not  be  called by any other program
	  until the plotting of all time periods  has  been  completed
	  since  DAPLAT  has internal storage which is used by DATALL.
	  If the user's program calls  DAPLAT  to  do  other  plotting
	  after the plotting of the data for all time periods has been
	  completed, then this subsequent  call  to  DAPLAT  must  use
	  non-zero values for the arguments MAXWID, MAXHIH, MSHWID and
	  MSHHIH since the default values of  these  DAPLAT  arguments
	  are  changed  by  DATALL.   The character set used for plots
	  FASP, FORTRAN Alphameric Subroutine Package         Page 399
	  DATALL, Time Series Plot Routine for Printer


	  produced by DATALL can be manipulated as  described  in  the
	  instruction  manual  for  DAPLAT.   The  maximum  plot  size
	  limitation for DAPLAT applies to each time  period,  not  to
	  the  entire plot of all time periods, and so should be of no
	  concern to the user.



	                    The DATALL Argument List
	                    --- ------ -------- ----

	  The argument list of routine DATALL is

	        SUBROUTINE DATALL(LSTLIN,MRKLIN,MAXWID,IFLTTR,LETTER,
	       1    IFCNCT,KONECT,XPOINT,MINSUB,MAXSUB, XLEFT,YVALUE,
	       2    XRIGHT, IGRID, IEDGE,MARGIN,MSHWID,MSHHIH,LTROFF,
	       3    LINPRT, IDISK,IRESET,LSTORE,XSTORE)

	  with the associated DIMENSION statement

	        DIMENSION      LETTER(MAXSUB),KONECT(MAXSUB),
	       1XPOINT(MAXSUB),LSTORE(MAXSUB),XSTORE(MAXSUB)


	            Arguments Used to Input Values to DATALL
	            --------- ---- -- ----- ------ -- ------

	  The following arguments are used to input values to DATALL.

	  LSTLIN = 0, the current time period is the final time period
	           to  be  represented  in  the  plot.   Scale numbers
	           ranging in value from that of XLEFT through that of
	           XRIGHT  are  to be written below the representation
	           of  the  current  time  period,  and  the  internal
	           storage in DATALL and DAPLAT is then to be cleared.
	         = greater than zero, the current time period  is  not
	           the  final  time  period  in  the plot.  Subsequent
	           calls to DATALL will add additional segments to the
	           current plot.  The value of LSTLIN is ignored other
	           than to determine whether it is greater than  zero.
	           If  the main program knows the total number of time
	           periods, it can count LSTLIN down to zero.  If  the
	           main program does not know the total number of time
	           periods, it is sufficient to set LSTLIN to 1  until
	           the final time period.

	  MRKLIN = 0, the current value of YVALUE can  be  printed  to
	           the  left  of the bottom line in the representation
	           of the current time period and a line can be  ruled
	           through  this  bottom  line.   Whether the value of
	           YVALUE will actually be printed to the left of  the
	           the  bottom  line  will  depend  upon  the value of
	           IEDGE.  Whether  a  line  will  actually  be  ruled
	           through the bottom line will depend upon the values
	  FASP, FORTRAN Alphameric Subroutine Package         Page 400
	  DATALL, Time Series Plot Routine for Printer


	           of IGRID and of IEDGE, and upon whether the current
	           line  is  at  either  the  top or the bottom of the
	           entire plot.
	         = greater than zero, a scale  number  is  not  be  be
	           placed beside the bottom line in the representation
	           of the current time period  and  this  bottom  line
	           cannot  be  ruled  as  a  grid  line.  The value of
	           MRKLIN is ignored other than to  determine  whether
	           it is greater than zero.  If the value of YVALUE is
	           to be printed beside some but not all time  periods
	           (for  example,  perhaps  beside  every  third  time
	           period), then MRKLIN can be counted down to zero by
	           the  main  program,  and  when equal to zero can be
	           reset back to its initial value  after  DATALL  has
	           been called.

	  MAXWID = width of the plot stated as the number  of  columns
	           of  characters forming the plotting area upon which
	           data can be plotted.  MAXWID is normally 1  plus  a
	           multiple of MSHWID.  The maximum effective value of
	           MAXWID  is  131.   It  should  be  noted  that   an
	           additional 12 characters along the left side of the
	           plot  are  used  for  the  scale  numbers  and  the
	           carriage control character.
	         = 0, use the last nonzero value specified for  MAXWID
	           either  to  DATALL or to DAPLAT as the width of the
	           plot, or use the value 101 if a  nonzero  value  of
	           MAXWID has not been specified.

	  IFLTTR = selects whether the points are  to  be  represented
	           using  alphabetic  letters  which are identified by
	           the LETTER array or which  are  identified  by  the
	           locations  of  the coordinates of the points in the
	           XPOINT array.
	         = 0, the LETTER array identifies the characters to be
	           plotted at the points.
	         = 1, the points are plotted using the letters  having
	           the  same  sequence  numbers in the alphabet as the
	           subscripts of the locations  in  the  XPOINT  array
	           containing  the  coordinates.  The point having its
	           horizontal  coordinate  in   XPOINT(3)   would   be
	           represented  by the letter C, the 3rd letter in the
	           alphabet.  Points having subscripts greater than 26
	           are represented by asterisks which will replace any
	           other characters  already  in  the  plot  at  these
	           locations.   The  contents  of the LETTER array are
	           ignored.

	  LETTER = an array identifying the  letters  to  be  used  to
	           represent   the   points  having  their  horizontal
	           coordinates in the XPOINT  array  locations  having
	           the  same  subscripts  as the LETTER array.  LETTER
	           array values of -1 indicate that the  corresponding
	           points  are not to be plotted.  LETTER array values
	  FASP, FORTRAN Alphameric Subroutine Package         Page 401
	  DATALL, Time Series Plot Routine for Printer


	           of zero indicate that the corresponding points  are
	           to  be plotted with asterisks.  Values greater than
	           zero are the sequence numbers within  the  alphabet
	           of  the letters to be used to represent the points.
	           If an alphabetic letter and an asterisk selected by
	           a  zero value in the LETTER array are to occupy the
	           same printing character position on the plot,  then
	           the  letter  appears.   If different letters are to
	           occupy the same printing character position on  the
	           plot, then an ampersand appears instead.  Values in
	           the LETTER array which are greater than  26  select
	           asterisks  which  will replace any other characters
	           already in the plot at these locations.  If  IFLTTR
	           is  non-zero, then the LETTER array is not used and
	           need not be dimensioned.

	  IFCNCT = selects whether the characters to be plotted  along
	           the  line  segments  connecting  points  are  to be
	           identified by the KONECT array or  are  to  be  the
	           same as those used to represent the points.
	         = -1, points in the current time period are not to be
	           connected  to  the  points  of  the  previous  time
	           period.  The  contents  of  the  KONECT  array  are
	           ignored.
	         = 0, the KONECT array identifies the characters to be
	           plotted along the line segments.
	         = 1, the line segments are to be formed of  the  same
	           characters  as  are  used to plot the points in the
	           current period.  The contents of the  KONECT  array
	           are ignored.

	  KONECT = an array identifying the characters with  which  to
	           connect  points  of  the  current  time period with
	           points of the previous time period which had  their
	           coordinates in XPOINT array locations with the same
	           subscripts.  If XPOINT array locations  having  the
	           same  subscripts  did not specify coordinates to be
	           plotted both in the current time period and in  the
	           previous  time period, then the value in the KONECT
	           array is ignored.   Letters  are  selected  by  the
	           KONECT  array  in  the same manner as by the LETTER
	           array, with the exception that a KONECT array value
	           of  -1  causes the corresponding points, if any, to
	           not be connected.  If IFCNCT is non-zero, then  the
	           KONECT   array   is   not  used  and  need  not  be
	           dimensioned.

	  XPOINT = an array  containing  the  horizontal  or  non-time
	           coordinates  of  the  points  to be plotted for the
	           current time period.  The  coordinate  system  used
	           for  the XPOINT array must be the same as that used
	           for the arguments XLEFT and XRIGHT which select the
	           coordinates  to  be  placed at the left edge and at
	           the right edge  of  the  plot  respectively.   Only
	  FASP, FORTRAN Alphameric Subroutine Package         Page 402
	  DATALL, Time Series Plot Routine for Printer


	           values   of   LETTER,   KONECT  and  XPOINT  having
	           subscripts in the range starting  with  MINSUB  and
	           extending through MAXSUB are used.

	  MINSUB = subscript of the LETTER, KONECT  and  XPOINT  array
	           locations  containing  the  information  about  the
	           first point to be plotted.   The  subscript  ranges
	           can vary from one time period to the next, and need
	           not even overlap.

	  MAXSUB = subscript of the LETTER, KONECT  and  XPOINT  array
	           locations  containing  the  information  about  the
	           final point to be plotted.   The  subscript  ranges
	           can vary from one time period to the next, and need
	           not even overlap.  If no data is to be plotted  for
	           the  current  time  period, then MAXSUB can be less
	           than MINSUB.  It should be noted  that  empty  time
	           periods  at  the  start of the time series plot are
	           discarded, but that once a  non-empty  time  period
	           has  been  encountered,  then  all  remaining  time
	           periods are plotted whether  empty  or  not.   This
	           does  not,  of  course,  insure that something will
	           actually be plotted in the first time period shown,
	           since all of the points might be outside the window
	           defined by XLEFT  and  XRIGHT,  but  only  that  an
	           attempt is made to plot something in the first time
	           period shown.  The arrays XSTORE  and  LSTORE  must
	           also  be  dimensioned to at least the maximum value
	           of MAXSUB.

	  XLEFT  = the horizontal or non-time data  coordinate  to  be
	           placed in the center of the character column at the
	           left edge of  the  plot.   If  a  scale  number  is
	           printed  below  the  left  column of the plot, then
	           this scale number will have a value equal  to  that
	           of  XLEFT.   Only  the portion of the curves in the
	           XPOINT   array   having   values   in   the   range
	           XLEFT-((XRIGHT-XLEFT)/(2*(MAXWID-1)))   to  XRIGHT+
	           ((XRIGHT-XLEFT)/(2*(MAXWID-1))) will  be  shown  on
	           the plot.  If a line segment crosses the plot, then
	           the portion of the line segment  which  is  outside
	           the  plot  area  will not be represented.  The data
	           coordinates can either increase  or  decrease  from
	           left to right.

	  YVALUE = number identifying the current time  period.   This
	           value  must  change  from one call to DATALL to the
	           next, but can either increase or decrease.  If  the
	           current  value of MRKLIN is zero, then the value of
	           YVALUE can be printed to the  left  of  the  lowest
	           line of the current plot segment.

	  XRIGHT = the horizontal or non-time data  coordinate  to  be
	           placed in the center of the character column at the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 403
	  DATALL, Time Series Plot Routine for Printer


	           right edge of the  plot.   If  a  scale  number  is
	           printed  below  the  right column of the plot, then
	           this scale number will have a value equal  to  that
	           of XRIGHT.

	  IGRID  = 0, the plot  will  show  an  internal  grid.   This
	           internal grid will be ruled vertically every MSHWID
	           characters  and,  if  MRKLIN  is  equal  to   zero,
	           horizontally every MSHHIH lines.
	         = 1, the plot will  show  the  intersections  of  the
	           lines  of  an  internal grid, but will not show the
	           grid lines themselves.  The internal grid would, if
	           shown,  have vertical lines every MSHWID characters
	           across the width of the plot and would,  if  MRKLIN
	           is  equal  to  zero,  have  horizontal lines on the
	           bottom  line  of  each  plot  segment.   Each  plot
	           segment   consists   of   MSHHIH   lines,  so  grid
	           intersections can be shown every  MSHHIH  lines  if
	           MRKLIN is always zero.
	         = 2, the plot will not show an internal grid.
	         = greater than 2,  the  decimal  digits  forming  the
	           value  of  IGRID  select  modification  of the grid
	           format as described in  the  documentation  of  the
	           DAPLAT routine.

	  IEDGE  = place numbers both to the left  of  and  below  the
	           plot to identify the coordinate ranges.
	         = 1, place numbers to the left of the  plot,  but  do
	           not place numbers below the plot.
	         = 2, place numbers below the plot,  but  not  to  the
	           left  of  the plot.  Unless increased by the MARGIN
	           argument, the distance between the carriage control
	           character in column 1 and the left edge of the plot
	           will be just large enough to allow a  scale  number
	           immediately below the left edge of the plot.
	         = 3, do not place numbers either to the  left  of  or
	           below  the  plot.   Unless  prevented by the MARGIN
	           argument, no characters  will  appear  between  the
	           carriage control character in column 1 and the left
	           edge of the plot.

	  MARGIN = the lower limit to the number of  characters  which
	           must  appear  in  the  output  between the carriage
	           control character in column 1 and the left edge  of
	           the  plot.   MARGIN  is  used  to force the plot to
	           remain a fixed distance from the  carriage  control
	           character  in  column  1 even if a nonzero value of
	           IEDGE has  deselected  scale  numbers.   MARGIN  is
	           assumed to be at least 11 if IEDGE is zero or 1.

	  MSHWID = width of the grid divisions stated as the number of
	           columns  of  characters.   MSHWID=10 would give the
	           vertical grid lines every 10 characters across  the
	           width of the plot area.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 404
	  DATALL, Time Series Plot Routine for Printer


	         = 0, use the last nonzero value specified for  MSHWID
	           either  to DATALL or to DAPLAT as the grid division
	           width, or use the value 10 if a  nonzero  value  of
	           MSHWID has not been specified.

	  MSHHIH = the number of lines of printing to be  included  in
	           the  plot  segment  representing  the  current time
	           period.  If the points for successive time  periods
	           are  being  connected  by line segments, then these
	           line segments will extend  across  these  lines  of
	           printing.  The points themselves are represented in
	           the bottom line of the plot segment.
	         = 0, assume that MSHHIH=1 is meant.  Each time period
	           will  be  represented  by a single line in the time
	           series plot.

	  LTROFF = number  of  columns  of  characters  by  which  the
	           leftmost  grid  line is offset from the left border
	           of the plot.  LTROFF can be in the range zero up to
	           but  not  including MSHWID.  If LTROFF is negative,
	           then it is assumed to have the value  MSHWID+LTROFF
	           instead.   If  LTROFF  is  nonzero,  then  the left
	           border of the plot will be ruled  with  exclamation
	           points.   The right border is similarly ruled if it
	           does not bear a grid line.

	  LINPRT = -1, do not include a carriage control character  to
	           the left of each line of the plot.  Since the minus
	           sign of a negative scale number can then appear  in
	           column  1, the resulting output must not be treated
	           as though the left column contains carriage control
	           characters.
	         = 0, the plot  will  be  viewed  by  the  user  on  a
	           terminal,  either  typed  directly with IDISK being
	           given the terminal unit number,  or  typed  by  the
	           user after this routine has written the plot into a
	           file on the unit the number of which  is  contained
	           in  IDISK.   A  blank  or  space  will  be  used as
	           carriage control character to give single spacing.
	         = 1, the plot will be printed on the line printer  by
	           the  user  after  the  program has written the plot
	           into a file.  An asterisk will be used as  carriage
	           control  character  to  give  single  spacing  with
	           suppression of skipping extra  lines  at  the  page
	           boundaries.   On  the  PDP-10,  an  asterisk as the
	           carriage control character  gives  overprinting  on
	           the terminal as opposed to single spacing.

	  IDISK  = the unit number of the device onto which the  plots
	           are to be written.  This routine will only generate
	           the plot.  It is the responsibility of the  calling
	           program  to  open  the output file and to write the
	           captions, the  form  feeds  and/or  the  separating
	           lines.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 405
	  DATALL, Time Series Plot Routine for Printer


	  Argument Used Initially for Input, but then Returned Changed
	  -------- ---- --------- --- -----  --- ---- -------- -------

	  The following  argument  must  be  defined  by  the  calling
	  program  before this routine is first called.  This argument
	  is returned by this routine set to -1,  and  this  -1  value
	  should  be  sent  unchanged  to any subsequent calls to this
	  routine.

	  IRESET = used to identify the first call to DATALL  so  that
	           storage  inside DATALL can be properly initialized.
	           However, unless DATALL  is  used  upon  a  computer
	           which  does not allow the testing of the value of a
	           variable which has not  yet  been  defined,  having
	           IRESET  always  set to -1 will produce the expected
	           results since one of the variables set  within  the
	           routine  is  tested  at the start of the routine to
	           determine whether the  internal  storage  has  been
	           initialized.
	         = -1, this is not the first call to DATALL.
	         = 0, DAPLAT has already been called, but  DATALL  has
	           not previously been called.  IRESET is returned set
	           to -1.
	         = 1 (or greater),  neither  DAPLAT  nor  DATALL  have
	           previously been called.  IRESET values greater than
	           1, as described in the documentation of the  DAPLAT
	           argument   also   named  IRESET,  cause  DAPLAT  to
	           preserve  selected  values  in  its  own   internal
	           storage  which have been initialized instead by the
	           calling program.  IRESET is returned set to -1.

	  Arguments Used Only by DATALL For Intermediate Data Storage
	  --------- ---- ---- -- ------ --- ------------ ---- -------

	  The values initially  in  the  array  arguments  LSTORE  and
	  XSTORE are ignored and are destroyed.  These arrays are used
	  by DATALL to store the numbers identifying the letters  used
	  to  plot  the points and to store the horizontal coordinates
	  of these points so that the subsequent call  to  DATALL  can
	  extend  line  segments  from  the  points of the time period
	  previous to it.  The calling program  must  not  modify  the
	  contents  of  these arrays while a time series plot is being
	  generated.  Both arrays must be dimensioned to at least  the
	  maximum  value  of MAXSUB.  This array space can be used for
	  other purposes by the calling program after DATALL has  been
	  called with LSTLIN equal to zero.

	  LSTORE = used to store the contents  of  the  LETTER  array.
	           The  dimension of the LSTORE array must at least be
	           equal to the maximum value  of  MAXSUB  encountered
	           while  IFLTTR is zero.  If IFLTTR is always 1, then
	           LSTORE is never used and need not be dimensioned.

	  XSTORE = used to store the contents of the XPOINT array.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 406
	  DATALL, Time Series Plot Routine for Printer


	                an Example of the Use of DATALL
	                -- ------- -- --- --- -- ------

	  As an example of the use  of  this  routine,  the  following
	  program generated the plots shown on the following pages.

	        DIMENSION XMATRX(11,3),XPOINT(3),LETTER(3),
	       1KONECT(3),XSTORE(3),LSTORE(3)
	        DATA ((XMATRX(I,J),I=1,11),J=1,3)/
	       112.,14.,15.,16.,16.,16.,15.,14.,14.,11.,10.,
	       214.,16.,20.,20.,24.,20.,18.,17., 0., 0., 0.,
	       3 0., 0.,12.,13.,14.,16.,20.,22.,22.,21.,20./
	        DATA IDISK/1/
	        IRESET=1
	        DO 7 KPASS=1,4
	        IGRID=(100*KPASS)-99
	        WRITE(IDISK,1)IGRID
	      1 FORMAT(7H IGRID=,1I4)
	        MSHHIH=2
	        DO 6 JPASS=1,2
	        DO 4 IPASS=1,4
	        IF(IPASS.EQ.2)MRKLIN=1
	        IF(IPASS.EQ.3)MRKLIN=0
	        LSTLIN=10
	        IF(IPASS.GE.3)LSTLIN=6
	        IF(KPASS.GE.2)LSTLIN=2
	        IF(JPASS.EQ.2)LSTLIN=1
	        INDEX=0
	      2 INDEX=INDEX+1
	        YVALUE=INDEX
	        IF(IPASS.EQ.1)MRKLIN=1
	        IF(IPASS.EQ.4)MRKLIN=0
	  C     TRANSFER MATRIX INTO SINGLE DIMENSION ARRAY
	  C     X COORDINATE OF 0 IS TAKEN AS NO POINT
	        DO 3 I=1,3
	        XPOINT(I)=XMATRX(INDEX,I)
	        LETTER(I)=I
	        IF(XPOINT(I).EQ.0.0)LETTER(I)=-1
	      3 KONECT(I)=I
	  C     MAXWID=31  IFLTTR=0   IFCNCT=0   MINSUB=1    MAXSUB=3
	  C      XLEFT=10. XRIGHT=25.  IGRID=1    IEDGE=300  MARGIN=0
	  C     MSHWID=10  LTROFF=0   LINPRT=1
	        CALL DATALL(LSTLIN,MRKLIN,31,0,LETTER,
	       10,KONECT,XPOINT,1,3,10.0,YVALUE,
	       225.0,IGRID,300,0,10,MSHHIH,0,
	       31,IDISK,IRESET,LSTORE,XSTORE)
	        MRKLIN=1-MRKLIN
	        LSTLIN=LSTLIN-1
	        IF(LSTLIN.GE.0)GO TO 2
	      4 WRITE(IDISK,5)
	      5 FORMAT(1X)
	      6 MSHHIH=1
	      7 CONTINUE
	        STOP
	  FASP, FORTRAN Alphameric Subroutine Package         Page 407
	  DATALL, Time Series Plot Routine for Printer


	        END

	   IGRID=   1
	  *           !   A   B                     !
	  *           !    AA  BB                   !
	  *           !      AA  BBB                !
	  *           !        A    BBBB            !
	  *           !   C     A       BBB         !
	  *           !    C     A        B         !
	  *           !     C     A       BB        !
	  *           !      C    A         BBBB    !
	  *           !       C   A             BBB !
	  *           !        CC A          BBBB   !
	  *           !          C&C      BBB       !
	  *           !          A  CCCCBB          !
	  *           !         A     BBCCC         !
	  *           !        A     B     CC       !
	  *           !       A     B        CC     !
	  *           !       A               C     !
	  *           !      AA               C     !
	  *           !   AAA                C      !
	  *           ! AA                  C       !
	  *           !A                   C        !
	  *           A                   C         !
	  *           !         !         !         !
	  *          10        15        20        25

	  *           !   A   B                     !
	  *           !    AA  BB                   !
	  *        2 -+      AA +BBB      +         +
	  *           !        A    BBBB            !
	  *           !   C     A       BBB         !
	  *           !    C     A        B         !
	  *        4 -+     C   + A       BB        +
	  *           !      C    A         BBBB    !
	  *           !       C   A             BBB !
	  *           !        CC A          BBBB   !
	  *        6 -+         +C&C      BBB       +
	  *           !          A  CCCCBB          !
	  *           !         A     BBCCC         !
	  *           !        A     B     CC       !
	  *        8 -+       A +   B     +  CC     +
	  *           !       A               C     !
	  *           !      AA               C     !
	  *           !   AAA                C      !
	  *       10 -+ AA      +         + C       +
	  *           !A                   C        !
	  *           A                   C         !
	  *           !         !         !         !
	  *          10        15        20        25
	  FASP, FORTRAN Alphameric Subroutine Package         Page 408
	  DATALL, Time Series Plot Routine for Printer


	  *        1 -+---A---B-+---------+---------+
	  *           !    AA  BB                   !
	  *           !      AA  BBB                !
	  *           !        A    BBBB            !
	  *        3 -+   C     A       BBB         +
	  *           !    C     A        B         !
	  *           !     C     A       BB        !
	  *           !      C    A         BBBB    !
	  *        5 -+       C + A       +     BBB +
	  *           !        CC A          BBBB   !
	  *           !          C&C      BBB       !
	  *           !          A  CCCCBB          !
	  *        7 -+---------A-----BBCCC---------+
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+---A---B-+---------+---------+
	  *           !    AA  BB                   !
	  *        2 -+      AA +BBB      +         +
	  *           !        A    BBBB            !
	  *        3 -+   C     A       BBB         +
	  *           !    C     A        B         !
	  *        4 -+     C   + A       BB        +
	  *           !      C    A         BBBB    !
	  *        5 -+       C + A       +     BBB +
	  *           !        CC A          BBBB   !
	  *        6 -+         +C&C      BBB       +
	  *           !          A  CCCCBB          !
	  *        7 -+---------A-----BBCCC---------+
	  *           !         !         !         !
	  *          10        15        20        25

	  *           !   AA  BB                    !
	  *           !     AAA BBB                 !
	  *           !         !         !         !
	  *          10        15        20        25

	  *           !   AA  BB                    !
	  *        2 -+-----AAA-BBB-------+---------+
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+---AA--BB+---------+---------+
	  *           !     AAA BBB                 !
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+---AA--BB+---------+---------+
	  *        2 -+-----AAA-BBB-------+---------+
	  *           !         !         !         !
	  *          10        15        20        25
	  FASP, FORTRAN Alphameric Subroutine Package         Page 409
	  DATALL, Time Series Plot Routine for Printer


	   IGRID= 101
	  *           !   A   B                     !
	  *           !    AA  BB                   !
	  *           !      AA  BBB                !
	  *           !        A    BBBB            !
	  *           !   C     A       BBB         !
	  *           !         !         !         !
	  *          10        15        20        25

	  *           !   A   B                     !
	  *           !    AA  BB                   !
	  *        2 -+      AA +BBB      +         +
	  *           !        A    BBBB            !
	  *           !   C     A       BBB         !
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+   A   B +         +         +
	  *           !    AA  BB                   !
	  *           !      AA  BBB                !
	  *           !        A    BBBB            !
	  *        3 -+---C-----A-------BBB---------+
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+   A   B +         +         +
	  *           !    AA  BB                   !
	  *        2 -+      AA +BBB      +         +
	  *           !        A    BBBB            !
	  *        3 -+---C-----A-------BBB---------+
	  *           !         !         !         !
	  *          10        15        20        25

	  *           !   AA  BB                    !
	  *           !     AAA BBB                 !
	  *           !         !         !         !
	  *          10        15        20        25

	  *           !   AA  BB                    !
	  *        2 -+-----AAA-BBB-------+---------+
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+   AA  BB+         +         +
	  *           !     AAA BBB                 !
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+   AA  BB+         +         +
	  *        2 -+-----AAA-BBB-------+---------+
	  *           !         !         !         !
	  *          10        15        20        25
	  FASP, FORTRAN Alphameric Subroutine Package         Page 410
	  DATALL, Time Series Plot Routine for Printer


	   IGRID= 201
	  *           !   A   B                     !
	  *           !    AA  BB                   !
	  *           !      AA  BBB                !
	  *           !        A    BBBB            !
	  *           !   C     A       BBB         !
	  *           !         !         !         !
	  *          10        15        20        25

	  *           !   A   B                     !
	  *           !    AA  BB                   !
	  *        2 -+      AA +BBB      +         +
	  *           !        A    BBBB            !
	  *           !   C     A       BBB         !
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+---A---B-+---------+---------+
	  *           !    AA  BB                   !
	  *           !      AA  BBB                !
	  *           !        A    BBBB            !
	  *        3 -+   C     A       BBB         +
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+---A---B-+---------+---------+
	  *           !    AA  BB                   !
	  *        2 -+      AA +BBB      +         +
	  *           !        A    BBBB            !
	  *        3 -+   C     A       BBB         +
	  *           !         !         !         !
	  *          10        15        20        25

	  *           !   AA  BB                    !
	  *           !     AAA BBB                 !
	  *           !         !         !         !
	  *          10        15        20        25

	  *           !   AA  BB                    !
	  *        2 -+     AAA BBB       +         +
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+---AA--BB+---------+---------+
	  *           !     AAA BBB                 !
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+---AA--BB+---------+---------+
	  *        2 -+     AAA BBB       +         +
	  *           !         !         !         !
	  *          10        15        20        25
	  FASP, FORTRAN Alphameric Subroutine Package         Page 411
	  DATALL, Time Series Plot Routine for Printer


	   IGRID= 301
	  *           !   A   B                     !
	  *           !    AA  BB                   !
	  *           !      AA  BBB                !
	  *           !        A    BBBB            !
	  *           !   C     A       BBB         !
	  *           !         !         !         !
	  *          10        15        20        25

	  *           !   A   B                     !
	  *           !    AA  BB                   !
	  *        2 -+      AA +BBB      +         +
	  *           !        A    BBBB            !
	  *           !   C     A       BBB         !
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+   A   B +         +         +
	  *           !    AA  BB                   !
	  *           !      AA  BBB                !
	  *           !        A    BBBB            !
	  *        3 -+   C     A       BBB         +
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+   A   B +         +         +
	  *           !    AA  BB                   !
	  *        2 -+      AA +BBB      +         +
	  *           !        A    BBBB            !
	  *        3 -+   C     A       BBB         +
	  *           !         !         !         !
	  *          10        15        20        25

	  *           !   AA  BB                    !
	  *           !     AAA BBB                 !
	  *           !         !         !         !
	  *          10        15        20        25

	  *           !   AA  BB                    !
	  *        2 -+     AAA BBB       +         +
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+   AA  BB+         +         +
	  *           !     AAA BBB                 !
	  *           !         !         !         !
	  *          10        15        20        25

	  *        1 -+   AA  BB+         +         +
	  *        2 -+     AAA BBB       +         +
	  *           !         !         !         !
	  *          10        15        20        25
	  FASP, FORTRAN Alphameric Subroutine Package         Page 412
	  DATEAM, Evaluates Several Numbers in a Single Line of Text


	  DDDDD         AAA  TTTTTTTT  EEEEEEEE        AAA  MM      MM
	  DD   DD      AAAA     TT     EE             AAAA  MMM    MMM
	  DD    DD    AA AA     TT     EE            AA AA  MMMM  MMMM
	  DD    DD   AA  AA     TT     EEEEE        AA  AA  MM MMMM MM
	  DD    DD  AAAAAAA     TT     EE          AAAAAAA  MM  MM  MM
	  DD   DD  AA    AA     TT     EE         AA    AA  MM      MM
	  DDDDD   AA     AA     TT     EEEEEEEE  AA     AA  MM      MM


	   DATEAM, Evaluates Several Numbers in a Single Line of Text
	   ------  --------- ------- ------- -- - ------ ---- -- ----

	  A single call to DATEAM interprets  an  array  read  by  the
	  calling  program with a multiple of an A1 format and returns
	  all of the values represented in this array.  If more values
	  are  found  than  can  be  stored  in the array provided for
	  returning these values to the calling program,  then  DATEAM
	  can  indicate the first character of the first extra number,
	  or can scan across and possibly count the excess numbers.

	  Numbers can be separated by spaces, by tab characters and/or
	  by  commas.   Excess  commas are ignored and do not indicate
	  either missing or zero values.  The evaluation is terminated
	  when  a  semicolon is found within the contents of the input
	  text buffer or else when all of the  characters  within  the
	  input  text  buffer  have  been interpreted.  An exclamation
	  point and any characters to its right are taken  to  form  a
	  comment  and  are  otherwise  ignored.  An ampersand and any
	  characters to its  right  are  similarly  ignored,  but  the
	  calling  program  is informed that an ampersand was found so
	  that the calling program can read new text  into  the  input
	  buffer  before  calling  this  routine again to continue the
	  evaluation.


	                    The DATEAM Argument List
	                    --- ------ -------- ----

	  The argument list of routine DATEAM is

	        SUBROUTINE DATEAM(KONTNU,KONTRL,ITRAIL,NUMMAX,MAXBFR,
	       1    IBUFFR,LOWBFR,NUMKNT,KIND  ,NUMVAL,VALNUM)

	  with the associated DIMENSION statement

	        DIMENSION NUMVAL(NUMMAX),VALNUM(NUMMAX),
	       1IBUFFR(MAXBFR)

	  The following arguments are used  for  input  only  and  are
	  returned unchanged.

	  KONTNU = -1, if more values are found than can  be  returned
	           in  the  NUMVAL  or  VALNUM  array,  then  KIND  is
	           returned  containing  5  and  LOWBFR  is   returned
	  FASP, FORTRAN Alphameric Subroutine Package         Page 413
	  DATEAM, Evaluates Several Numbers in a Single Line of Text


	           pointing  to the left character of the first excess
	           number.  If KONTNU contains -1 and too many  values
	           are  found,  then  it is expected that this routine
	           will  be  called  to  continue  processing  of  the
	           contents of the input text buffer after the calling
	           program has processed the values  returned  in  the
	           NUMVAL  or VALNUM array and has reset NUMKNT.  KIND
	           cannot  be  returned  containing  5  if  KONTNU  is
	           greater than or equal to zero.
	         = 0, if more values are found than can be returned in
	           the  NUMVAL or VALNUM array, then the excess values
	           are interpreted and  LOWBFR  is  returned  pointing
	           beyond   the   final  number,  but  NUMKNT  is  not
	           incremented for these excess values and the  excess
	           values are not returned to the calling program.
	         = 1, if more values are found than can be returned in
	           the  NUMVAL or VALNUM array, then the excess values
	           are interpreted, LOWBFR is returned pointing beyond
	           the  final  number,  and  NUMKNT is incremented for
	           each value found, but the  excess  values  are  not
	           returned to the calling program.

	  KONTRL = if the representation of a number is found,  KONTRL
	           specifies  whether  the  value is to be returned in
	           the integer array which is named NUMVAL or  in  the
	           real  array  which is named VALNUM.  The number can
	           be typed with a decimal point  and/or  an  exponent
	           regardless of the value of KONTRL.
	         = -1, the value is calculated as an octal integer and
	           is  returned  in  the  NUMVAL  array.  However, the
	           number following the letter E  of  an  exponent  is
	           evaluated in decimal.
	         = 0, the value is calculated as a decimal integer and
	           is returned in the NUMVAL array.
	         = 1 or greater, the value is returned in  the  VALNUM
	           array.   If  possible,  the  real  number  will  be
	           accumulated as an integer,  then  be  converted  to
	           real  and  shifted  as  necessary.   KONTRL  is the
	           maximum number of digits in the integer.

	  ITRAIL = selects whether exponents are to be recognized.  If
	           exponents  are not to be recognized but an exponent
	           is found, then the evaluation of  the  contents  of
	           the  input  text buffer will be terminated prior to
	           the  exponent  and  the  first  character  of   the
	           exponent  will  be  treated  the  same as any other
	           unknown alphabetic character.  When such an unknown
	           character  is  found, KIND is returned containing 4
	           and LOWBFR is  returned  pointing  to  the  unknown
	           character.
	         = -1, exponents expressed in E  notation  are  to  be
	           recognized,  but the percent sign and the letters K
	           and M are to be  treated  the  same  as  any  other
	           alphabetic characters.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 414
	  DATEAM, Evaluates Several Numbers in a Single Line of Text


	         = 0,  no  exponents  are  to  be   recognized.    The
	           evaluation  will  be  terminated  prior  to percent
	           signs or to the letters E or K or M.
	         = 1,  percent  signs,  the  letters  K  and  M,   and
	           exponents  expressed  in  E  notation are all to be
	           recognized.

	  NUMMAX = highest subscript of the  NUMVAL  or  VALNUM  array
	           locations  into  which  can  be  placed  the values
	           represented by the characters in the IBUFFR  array.
	           The    first    value    found   is   returned   in
	           NUMVAL(NUMKNT+1)  or  VALNUM(NUMKNT+1).    If   the
	           available  portion of the NUMVAL or VALNUM array is
	           full and if an  additional  value  is  encountered,
	           then  KIND is returned set to 5 if KONTNU is -1, or
	           else the evaluation of additional numbers continues
	           until  a semicolon or the end of line is reached if
	           KONTNU is greater than or equal to zero.  If KONTNU
	           is  input  greater  than  zero,  then NUMKNT can be
	           returned greater than  NUMMAX,  and  the  value  of
	           NUMKNT  merely  indicates  the maximum subscript of
	           the NUMVAL or VALNUM array  locations  which  would
	           have  been used if available but no locations above
	           NUMVAL(NUMMAX) or VALNUM(NUMMAX) are actually  used
	           by this routine.

	  MAXBFR = subscript of the IBUFFR array  location  containing
	           the  rightmost (highest subscript) character in the
	           line  of  text  being  interpreted.   MAXBFR  would
	           normally be the dimension of the IBUFFR array.

	  IBUFFR = the input buffer array containing the characters of
	           the  line  of text to be interpreted, one character
	           per array location, as read by a multiple of an  A1
	           format.   The  text  to  be interpreted begins with
	           IBUFFR(LOWBFR) and extends up to the  next  unknown
	           character  or through the next semicolon or through
	           the  end  of  the  line  if  an  ampersand  or   an
	           exclamation point is found.

	  The following arguments are used  both  for  input  to  this
	  routine and for output to the calling program.

	  LOWBFR = input containing the subscript of the IBUFFR  array
	           location   which   contains  the  leftmost  (lowest
	           subscript) character which is to be interpreted  by
	           this  routine.   LOWBFR is returned pointing to the
	           leftmost  character  not  yet  identified  by  this
	           routine.    LOWBFR   is   returned  containing  the
	           subscript of the IBUFFR array  location  containing
	           an   unknown   character   (KIND   being   returned
	           containing 4) or containing the  character  to  the
	           right   of   a   semicolon   (KIND  being  returned
	           containing 2).  It  is  expected  that  some  other
	  FASP, FORTRAN Alphameric Subroutine Package         Page 415
	  DATEAM, Evaluates Several Numbers in a Single Line of Text


	           routine  will  be  called  to  evaluate  an unknown
	           character, but if this routine is instead called to
	           evaluate  the  text  to  the  right  of the unknown
	           character  then  the  calling  program  must  first
	           increment  LOWBFR  by  one.  If KONTNU is set to -1
	           and if more values are found than can be stored  in
	           the  available  portion  of  the  NUMVAL  or VALNUM
	           array,  then  LOWBFR  is  returned  containing  the
	           subscript   of  the  IBUFFR  array  location  which
	           contains the first character  of  the  first  value
	           which  could  not be stored.  If an ampersand or an
	           exclamation point is found or if all characters  in
	           the  input  text buffer have been interpreted, then
	           LOWBFR is returned pointing beyond the right end of
	           the buffer.

	  NUMKNT = input  containing  the  subscript  of  the  highest
	           location  in  the  NUMVAL  or VALNUM array which is
	           currently  in  use  and  which  must  therefore  be
	           returned  unchanged.  The first value found by this
	           routine will be stored in  NUMVAL(NUMKNT+1)  or  in
	           VALNUM(NUMKNT+1).   If KONTNU is less than or equal
	           to zero, or if KONTNU is greater than zero  but  no
	           more  than  NUMMAX-NUMKNT  values  are  found, then
	           NUMKNT is returned containing the subscript of  the
	           highest  location  in  the  NUMVAL  or VALNUM array
	           which was used  by  this  routine  for  storage  of
	           values represented by the text in the IBUFFR array.
	           If KONTNU is  greater  than  zero,  but  more  than
	           NUMMAX-NUMKNT  values are found, then the locations
	           above NUMVAL(NUMMAX) or VALNUM(NUMMAX) are returned
	           unchanged,  but  NUMKNT  is returned incremented as
	           though these excess values had been stored.

	  The following arguments are used  only  for  output  to  the
	  calling  program.  Their input values are ignored.  However,
	  the portion of the NUMVAL or VALNUM array having  subscripts
	  less  than  or  equal  to  the input value of NUMKNT and the
	  portion having subscripts greater than NUMMAX  are  returned
	  unchanged.

	  KIND   = returned describing  the  reason  for  transfer  of
	           control back to the calling program.  KIND does not
	           indicate whether any values have been stored in the
	           NUMVAL  or  VALNUM array.  The calling program must
	           compare the returned value of  NUMKNT  against  its
	           original value to determine whether any values were
	           found by this routine.  If KONTNU is  greater  than
	           zero,  then  the  returned  value  of  NUMKNT  must
	           similarly be tested  against  NUMMAX  to  determine
	           whether  any  excess  values  were  found  but  not
	           returned.
	         = 1, all characters currently within the IBUFFR array
	           have been interpreted.  If an exclamation point was
	  FASP, FORTRAN Alphameric Subroutine Package         Page 416
	  DATEAM, Evaluates Several Numbers in a Single Line of Text


	           found, then the characters  to  the  right  of  the
	           exclamation  point  have been ignored and LOWBFR is
	           returned containing MAXBFR+1.
	         = 2, a  semicolon  was  found.   LOWBFR  is  returned
	           pointing  to  the  character  to  the  right of the
	           semicolon.  If semicolons are to be  considered  as
	           equivalent  to  spaces,  then  the  calling program
	           should  again  call  this  routine  without   first
	           changing the values of any of the arguments.
	         = 3, an ampersand was found.  The characters  to  the
	           right of the ampersand have been ignored and LOWBFR
	           is returned containing MAXBFR+1.  If the  ampersand
	           indicates  that text representing additional values
	           is to be read by the calling program,  then  LOWBFR
	           should  be  reset  to point to the start of the new
	           text before this routine is called again.
	         = 4, an  unknown  character  was  found.   LOWBFR  is
	           returned  containing  the  subscript  of the IBUFFR
	           array location containing this  unknown  character.
	           If  the  unknown  character  is to be considered as
	           equivalent  to  a  space,  then  LOWBFR   must   be
	           incremented  by  one  before this routine is called
	           again.
	         = 5, KONTNU contains -1 and a value was  found  which
	           could not be stored in the available portion of the
	           NUMVAL  or  VALNUM  array.   LOWBFR   is   returned
	           pointing   to   the   leftmost   character  in  the
	           representation of the number.  The calling  program
	           must  supply  additional  space  in  the  NUMVAL or
	           VALNUM array or else must reset KONTNU to  be  zero
	           or  greater  before  again  calling this routine to
	           process the remaining text in the IBUFFR array.

	  NUMVAL = array into which are stored the values  represented
	           by  the  text in the IBUFFR array if KONTRL is less
	           than or equal to zero.  The locations starting with
	           NUMVAL(NUMKNT+1)      and     extending     through
	           NUMVAL(NUMMAX) can be used  for  returning  integer
	           values  to the calling program.  NUMKNT is returned
	           pointing to the  highest  location  in  the  NUMVAL
	           array  which is used to return these values, or, if
	           KONTNU is greater than zero, which would be used if
	           available.

	  VALNUM = array into which are stored the values  represented
	           by  the  text  in  the  IBUFFR  array  if KONTRL is
	           greater than zero.   The  locations  starting  with
	           VALNUM(NUMKNT+1)      and     extending     through
	           VALNUM(NUMMAX)  can  be  used  for  returning  real
	           values  to the calling program.  NUMKNT is returned
	           pointing to the  highest  location  in  the  VALNUM
	           array  which is used to return these values, or, if
	           KONTNU is greater than zero, which would be used if
	           available.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 417
	  DATEAM, Evaluates Several Numbers in a Single Line of Text


	                An Example of the Use of DATEAM
	                -- ------- -- --- --- -- ------

	  The following program calls  DATEAM  to  store  values  into
	  NUMVAL(11)  through  NUMVAL(20)  or  into VALNUM(11) through
	  VALNUM(20).  The user is asked to supply the values  of  the
	  arguments  KONTNU,  KONTRL and ITRAIL, then is prompted with
	  an asterisk to type the first  line  of  text  and  with  an
	  ampersand for each continuation line if any.

	        DIMENSION NUMVAL(20),VALNUM(20),IBUFFR(60)
	        DATA ITTY,JTTY,NUMLOW,NUMMAX,MAXBFR/5,5,10,20,60/
	      1 WRITE(ITTY,2)
	      2 FORMAT(24H KONTNU,KONTRL,ITRAIL = ,$)
	        READ(JTTY,3)KONTNU,KONTRL,ITRAIL
	      3 FORMAT(3I)
	  C
	  C     OBTAIN NEXT LINE OF TEXT TO BE EVALUATED
	        WRITE(ITTY,4)
	      4 FORMAT(2H *,$)
	        NUMKNT=NUMLOW
	        GO TO 7
	      5 WRITE(ITTY,6)
	      6 FORMAT(2H &,$)
	      7 READ(JTTY,8)IBUFFR
	      8 FORMAT(60A1)
	        LOWBFR=1
	  C
	  C     SEARCH FOR VALUES
	      9 CALL DATEAM(KONTNU,KONTRL,ITRAIL,NUMMAX,MAXBFR,
	       1IBUFFR,LOWBFR,NUMKNT,KIND,NUMVAL,VALNUM)
	        IFOUND=NUMKNT-NUMLOW
	        GO TO(10,12,5,20,14),KIND
	  C
	  C     REPORT RESULTS
	     10 WRITE(ITTY,11)IFOUND
	     11 FORMAT(14H  END OF LINE,,I3,14H NUMBERS FOUND)
	        GO TO 16
	     12 WRITE(ITTY,13)IFOUND
	     13 FORMAT(14H  SEMICOLON,  ,I3,14H NUMBERS FOUND)
	        GO TO 16
	     14 WRITE(ITTY,15)IFOUND
	     15 FORMAT(14H  OVERFLOW,   ,I3,14H NUMBERS FOUND)
	     16 IF(IFOUND.LE.0)GO TO 19
	        IF(NUMKNT.GT.NUMMAX)NUMKNT=NUMMAX
	        J=NUMLOW+1
	        IF(KONTRL.LE.0)WRITE(ITTY,17)(NUMVAL(I),I=J,NUMKNT)
	        IF(KONTRL.GT.0)WRITE(ITTY,18)(VALNUM(I),I=J,NUMKNT)
	     17 FORMAT(1X,5I12)
	     18 FORMAT(1X,5E12.4)
	     19 IF(KIND.EQ.1)GO TO 1
	        NUMKNT=NUMLOW
	        GO TO 9
	     20 WRITE(ITTY,21)IBUFFR(LOWBFR)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 418
	  DATEAM, Evaluates Several Numbers in a Single Line of Text


	     21 FORMAT(3H  ?,1A1,1H?)
	        LOWBFR=LOWBFR+1
	        GO TO 9
	        END



	  Typical Dialog Between User and DATEAM Demonstration Program
	  ------- ------ ------- ---- --- ------ ------------- -------

	  KONTNU,KONTRL,ITRAIL = -1 0 1
	  *1K 2K 3K 4K 5K 6K 7K 8K 9K 10K 11K 12K&MORE THAN 10 VALUES
	   OVERFLOW,    10 NUMBERS FOUND
	          1000        2000        3000        4000        5000
	          6000        7000        8000        9000       10000
	  &13K;14K 15K 16K;;!2 GROUPS OF 3 FOLLOWED BY 2 EMPTY GROUPS
	   SEMICOLON,    3 NUMBERS FOUND
	         11000       12000       13000
	   SEMICOLON,    3 NUMBERS FOUND
	         14000       15000       16000
	   SEMICOLON,    0 NUMBERS FOUND
	   END OF LINE,  0 NUMBERS FOUND

	  KONTNU,KONTRL,ITRAIL = 0 1 1
	  *1.01 2.02 3.03 4.04 5.05 6.06 7.07 8.08 9.09 10.10 11.11&
	  &12.12 13.13;1 2 3 4 5 6 7 8 9 10 11 12 13;14
	   SEMICOLON,   10 NUMBERS FOUND
	    0.1010E+01  0.2020E+01  0.3030E+01  0.4040E+01  0.5050E+01
	    0.6060E+01  0.7070E+01  0.8080E+01  0.9090E+01  0.1010E+02
	   SEMICOLON,   10 NUMBERS FOUND
	    0.1000E+01  0.2000E+01  0.3000E+01  0.4000E+01  0.5000E+01
	    0.6000E+01  0.7000E+01  0.8000E+01  0.9000E+01  0.1000E+02
	   END OF LINE,  1 NUMBERS FOUND
	    0.1400E+02

	  KONTNU,KONTRL,ITRAIL = 1 1 1
	  *1.01 2.02 3.03 4.04 5.05 6.06 7.07 8.08 9.09 10.10 11.11&
	  &12.12 13.13;1 2 3 4 5 6 7 8 9 10 11 12 13;14
	   SEMICOLON,   13 NUMBERS FOUND
	    0.1010E+01  0.2020E+01  0.3030E+01  0.4040E+01  0.5050E+01
	    0.6060E+01  0.7070E+01  0.8080E+01  0.9090E+01  0.1010E+02
	   SEMICOLON,   13 NUMBERS FOUND
	    0.1000E+01  0.2000E+01  0.3000E+01  0.4000E+01  0.5000E+01
	    0.6000E+01  0.7000E+01  0.8000E+01  0.9000E+01  0.1000E+02
	   END OF LINE,  1 NUMBERS FOUND
	    0.1400E+02
	  FASP, FORTRAN Alphameric Subroutine Package         Page 419
	  DATEXT, FORTRAN Routine for Large Printable Characters


	   DDDDD          AAA  TTTTTTTT  EEEEEEEE  XX    XX  TTTTTTTT
	   DD   DD       AAAA     TT     EE         XX  XX      TT
	   DD    DD     AA AA     TT     EE          XXXX       TT
	   DD    DD    AA  AA     TT     EEEEE        XX        TT
	   DD    DD   AAAAAAA     TT     EE          XXXX       TT
	   DD   DD   AA    AA     TT     EE         XX  XX      TT
	   DDDDD    AA     AA     TT     EEEEEEEE  XX    XX     TT


	     DATEXT, FORTRAN Routine for Large Printable Characters
	     ------  ------- ------- --- ----- --------- ----------

	  DATEXT is a FORTRAN subroutine  which  enables  the  calling
	  program  to  print  large multiple line lettering similar to
	  that used for the above title.   The  user's  program  calls
	  DATEXT  once  for each line, specifying the characters to be
	  represented, and supplying a buffer array to be  defined  by
	  DATEXT which can then be printed by the calling program with
	  a FORTRAN FORMAT  statement  containing  a  multiple  of  an
	  alphameric  A1  field.   The  spacing between letters can be
	  adjusted to equalize white space.

	  DATEXT letters across the width of a  page.   Each  call  to
	  DATEXT  generates  a  portion of all of the characters to be
	  represented.  DATEXT returns the line height of  the  loaded
	  font,  so  the  calling program can determine how many times
	  DATEXT must be called.  A second  version  of  the  routine,
	  named  DATURN, is also supplied which turns the lettering 90
	  degrees, lettering from the top to the bottom of  the  page,
	  and onto subsequent pages.  Each call to DATURN constructs a
	  small portion of a single  character.   DATURN  signals  the
	  calling program when the final character has been completely
	  represented.  Since neither  routine  has  a  argument  list
	  which  is  a  subset  of  the  other, the differences in the
	  DATURN  argument  list  are  described  after   the   DATEXT
	  description.

	  These routines must be used  with  a  font  created  by  the
	  program  DAFONT.   DAFONT  can  produce  the fonts either as
	  SUBROUTINEs or as BLOCK DATA routines.  The SUBROUTINE forms
	  of  the  fonts  are  supplied but can easily be converted to
	  BLOCK DATA routines if necessary.  The font SUBROUTINEs have
	  names  such as TEXT1 and TEXT2 and were produced when DAFONT
	  processed the data files with names such  as  TEXT1.DAT  and
	  TEXT2.DAT.  These data files are easily modified by the user
	  to define new character  shapes  or  to  change  the  shapes
	  currently available.

	  Only 1 of the fonts should be called from the user's program
	  since  it is the presence in the user's program of a call to
	  the font SUBROUTINE to force the loading of  the  SUBROUTINE
	  which  is  important, not the execution of the call.  If the
	  font is loaded as a separate file, rather  than  in  library
	  search mode, then it need not be called.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 420
	  DATEXT, FORTRAN Routine for Large Printable Characters


	  A dollar sign appearing in the text  to  be  represented  is
	  taken   to   be  a  control  character  and  is  not  itself
	  represented in the output.  If the character  following  the
	  initial  dollar  sign  is  also a dollar sign, then a single
	  dollar sign is represented.  A second character other than a
	  dollar  sign  selects  some  option and neither character is
	  represented.   If   the   font   contains   multiple   shape
	  specifications  for  some  or  all characters, then a dollar
	  sign followed by a digit causes the subsequent characters to
	  be  represented  by  the shape selected by the digit.  If $2
	  appears in the text being represented, then  the  subsequent
	  characters would be represented by the second specifications
	  of their shapes.  If the digit  following  the  dollar  sign
	  selects  a  number  greater  than the number of shapes for a
	  particular character, then the last (highest  valued)  shape
	  for  that  character  is  used.  Either $1 or $= selects the
	  first shape of each of the subsequent characters.   $=  also
	  removes any other modifications of the lettering which might
	  have been selected by previous $-character  pairs.   Several
	  $-letter  pairs  are  recognized and are listed below.  If a
	  leading dollar sign is followed by any character other  than
	  those  which  are listed here, then both the dollar sign and
	  the following character are ignored.

	  $H and $V are used  to  reflect  and  invert  the  character
	  representations.   The  lettering can be read from the other
	  side of the paper if the sentence is spelled  backwards  and
	  if both $H and $V are applied.

	    $H  (Horizontal  reflection)   reflects   the   subsequent
	        character  representations  horizontally  so  that the
	        normal left edge is at the right.  If $H is already in
	        effect,  then a second $H is ignored.  A subsequent $=
	        would return the character representation to normal.

	    $V  (Vertical inversion) inverts the subsequent  character
	        representations  vertically  so  that the normal lower
	        edge is at the top.  If $V is already in effect,  then
	        a  second $V is ignored.  A subsequent $= would return
	        the character representation to normal.

	  $A and $F specify  whether  the  distance  between  adjacent
	  character  representations is to be kept constant or whether
	  the distance between  character  representations  is  to  be
	  adjusted to approximately equalize white space.

	    $A  (Adjust), provided that the argument named MOVE either
	        selects  that  the distance between adjacent character
	        representations is to be  kept  constant  (MOVE=0)  or
	        else  selects  that  the  distance  between  character
	        representations is to  be  adjusted  to  approximately
	        equalize  white  space (MOVE=1), then the distances to
	        the  next   character   representation   and   between
	        subsequent   character   representations   are  to  be
	  FASP, FORTRAN Alphameric Subroutine Package         Page 421
	  DATEXT, FORTRAN Routine for Large Printable Characters


	        adjusted to include approximately  equal  white  space
	        between   the  characters.   A  subsequent  $F,  or  a
	        subsequent $= if MOVE has the value 0, will cause  the
	        distances  between  adjacent character representations
	        to be kept constant.  If MOVE has the  value  1,  then
	        the  inclusion of the $A in the text being represented
	        is not necessary unless a $F has been encountered.  If
	        MOVE   is   less  than  zero,  selecting  that  narrow
	        characters are centered in a wider field, then both $A
	        and $F are ignored.

	    $F  (Fixed), provided that the argument named MOVE  either
	        selects  that  the distance between adjacent character
	        representations is to be  kept  constant  (MOVE=0)  or
	        else  selects  that  the  distance  between  character
	        representations is to  be  adjusted  to  approximately
	        equalize  white  space (MOVE=1), then the distances to
	        the  next   character   representation   and   between
	        subsequent  character  representations  are to be kept
	        constant.  A subsequent $A, or a subsequent $= if MOVE
	        has  the  value  1,  will  cause the distances between
	        adjacent character representations to be  adjusted  to
	        approximately  equalize  white space.  If MOVE has the
	        value 0, then the inclusion of  the  $F  in  the  text
	        being  represented  is  not  necessary unless a $A has
	        been  encountered.   If  MOVE  is  less   than   zero,
	        selecting  that  narrow  characters  are centered in a
	        wider field, then both $A and $F are ignored.

	  $N and $W modify the number of empty columns (or  lines  for
	  routine DATURN) used to represent space characters.

	    $N  (Narrow), space characters are to  be  represented  by
	        half  of  the  usual number of empty columns (or lines
	        for routine DATURN) whether or not a preceding $W  has
	        been  encountered.  If the argument named MOVE has the
	        value -2, then the width of spaces is to  be  half  of
	        the  width  of  the  widest  printing character in the
	        font.  If the argument named MOVE has a value  greater
	        than -2, then the width of spaces is to be half of the
	        most common width of printing characters in the  font.
	        A  subsequent $= would cause subsequent spaces to have
	        their normal  width.   A  subsequent  $W  would  cause
	        subsequent spaces to have one and one half times their
	        normal width whether or not a preceding  $N  has  been
	        encountered.

	    $W  (Wide), space characters are to be represented by  one
	        and  one  half times the usual number of empty columns
	        (or  lines  for  routine  DATURN)  whether  or  not  a
	        preceding  $N  has  been encountered.  If the argument
	        named MOVE has the value -2, then the width of  spaces
	        is  to  be  one  and  one  half times the width of the
	        widest  printing  character  in  the  font.   If   the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 422
	  DATEXT, FORTRAN Routine for Large Printable Characters


	        argument  named MOVE has a value greater than -2, then
	        the width of spaces is to be one and  one  half  times
	        the  most  common  width of printing characters in the
	        font.  A subsequent $= would cause  subsequent  spaces
	        to  have  their  normal  width.  A subsequent $N would
	        cause subsequent spaces to have half of  their  normal
	        width   whether   or  not  a  preceding  $W  has  been
	        encountered.

	  $L, $U and $E control the automatic  capitalization  of  the
	  initial letters of words.

	    $L  (Lower case), if the font describes more than a single
	        shape  for  any character, then for each character the
	        pair of shapes identified by consecutive odd and  even
	        numbers,  counting  the  first shape specified for the
	        character as shape number one, is to be taken  as  the
	        pair  of the upper and lower (or lower and upper) case
	        shapes of the character.  Providing than a  $U  or  $L
	        has  not  already  been  encountered in the text being
	        represented, any printing character  which  follows  a
	        space  or spaces but which is not itself a member of a
	        $-character command pair is to be represented  by  the
	        shape  (upper case) which would have been selected for
	        that character if the $L had not been found,  and  all
	        other  characters  are  to be represented by the other
	        shape (lower case) of the odd-even pair of shapes.  If
	        the  $L  is within the range of a $U or of another $L,
	        then the next character which is not itself  a  member
	        of  a $-character command pair is to be represented by
	        its lower case shape whether  or  not  it  would  have
	        otherwise  been  represented  by its upper case shape.
	        The range of the $L is terminated if either a $E, or a
	        $= or a $ followed by a non-zero digit is found.

	        For example, if the text being represented contains

	             $3A$LN EXAMPLE $LOF ITS USE

	        and if the font contains 4  shapes  for  each  of  the
	        alphabetic  letters (this would require increasing the
	        sizes of some of the  arrays  in  DAFONT,  DATEXT  and
	        DATURN),  then  the  first  letters  of  the words An,
	        Example, Its and Use would  be  represented  by  their
	        third  shapes  in the font and all other letters would
	        be represented by their fourth shapes in the font.

	    $U  (Upper case), if the font describes more than a single
	        shape  for  any character, then for each character the
	        pair of shapes identified by consecutive odd and  even
	        numbers,  counting  the  first shape specified for the
	        character as shape number one, is to be taken  as  the
	        pair  of the upper and lower (or lower and upper) case
	        shapes of the character.  Providing than a  $U  or  $L
	  FASP, FORTRAN Alphameric Subroutine Package         Page 423
	  DATEXT, FORTRAN Routine for Large Printable Characters


	        has  not  already  been  encountered in the text being
	        represented, the next printing character which is  not
	        itself  a member of a $-character command pair and any
	        printing character which follows a space or spaces but
	        is  not  itself a member of a $-character command pair
	        is to be represented by the shape (upper  case)  which
	        would  have been selected for that character if the $U
	        had not been found, and all other characters are to be
	        represented  by  the  other  shape (lower case) of the
	        odd-even pair of shapes.  If  the  $U  is  within  the
	        range  of  a  $L  or  of  another  $U,  then  the next
	        character  which  is  not  itself  a   member   of   a
	        $-character  command  pair is to be represented by its
	        upper  case  shape  whether  or  not  it  would   have
	        otherwise  been  represented  by its lower case shape.
	        The range of the $U is terminated if either a $E, or a
	        $= or a $ followed by a non-zero digit is found.

	        For example, if the text being represented contains

	             $4$UTHE F$UA$US$UP PACKAGE

	        and if the font contains 4  shapes  for  each  of  the
	        alphabetic  letters,  then the name FASP and the first
	        letters  of  the  words  The  and  Package  would   be
	        represented by their fourth shapes in the font and all
	        other letters would  be  represented  by  their  third
	        shapes in the font.

	    $E  (End case), terminates  the  range  of  a  $L  or  $U.
	        Subsequent  characters  for  which  the font describes
	        several shapes will be represented by the same  shapes
	        as  would  have  been selected before the $L or $U was
	        encountered.  The $E can also be used to capitalize  a
	        complete  word.  The $E is ignored if neither a $L nor
	        $U is in effect.

	        For example, the preceding example could be rewritten

	             $4$UTHE $EFASP $UPACKAGE


	                    THE DATEXT Argument List
	                    --- ------ -------- ----

	  The argument list of routine DATEXT is

	        SUBROUTINE DATEXT(LINE  ,JSTIFY,IFILL ,INTRVL,MOVE  ,
	       1    ISPACE,LTTR  ,LTRBGN,LTREND,LFTCOL,IWIDTH,MAXBFR,
	       2    IBUFFR,MAXUSD,MAXLIN,LTRNXT)

	  with the associated DIMENSION statement

	        DIMENSION LTTR(LTREND),IBUFFR(MAXBFR)
	  FASP, FORTRAN Alphameric Subroutine Package         Page 424
	  DATEXT, FORTRAN Routine for Large Printable Characters


	  The following arguments are used for  input  only,  and  are
	  returned unchanged.

	  LINE   = the line within the letter representation which  is
	           to  be placed into the IBUFFR array.  Line number 1
	           is the  top  line  of  the  representation  of  the
	           characters.   Characters  are a total of MAXLIN (an
	           argument returned by each  call  to  this  routine)
	           lines  high.   To  print a letter or letters, it is
	           necessary to call DATEXT  MAXLIN  times  with  LINE
	           being  assigned  the  values 1 through MAXLIN, with
	           the calling program printing the IBUFFR array after
	           each return from DATEXT.  This allows the insertion
	           of the constructed letters into other text or other
	           forms.
	         = 0, place the highest valued line  (that  containing
	           the  bottom line of each character) into the IBUFFR
	           array.  The calling program should set the value of
	           LINE  to one less than the returned value of MAXLIN
	           prior to the subsequent call to this routine.

	  The manner in which line numbers are used is illustrated  by
	  the following program which generated the large letters used
	  as the title at the beginning of the documentation  of  this
	  routine.

	        DIMENSION LTTR(6),IBUFFR(60)
	        DATA LTTR/1HD,1HA,1HT,1HE,1HX,1HT/
	        CALL TEXT4
	        LINE=0
	      1 LINE=LINE+1
	  C
	  C     JSTIFY = 0  (CENTER LETTER REPRESENTATIONS IN IWIDTH)
	  C     IFILL  = 0  (DON'T FILL OUT END WITH SPACES)
	  C     INTRVL = 2  (SPACING BETWEEN LETTER REPRESENTATIONS)
	  C     MOVE   = 1  (ADJUST FOR EQUAL WHITE SPACES)
	  C     ISPACE = 0  (REPRESENT INTIAL SPACES IF ANY)
	  C     LTRBGN = 1  (FIRST LETTER TO REPRESENT IS LTTR(1))
	  C     LTREND = 6  (FINAL LETTER TO REPRESENT IS LTTR(6))
	  C     LFTCOL = 0  (START REPRESENTATION IN IBUFFR(1))
	  C     IWIDTH = 60 (WIDTH OF FIELD WHICH CAN USE)
	  C     MAXBFR = 60 (DIMENSION OF IBUFFR ARRAY)
	  C
	        CALL DATEXT(LINE,0,0,2,1,
	       1    0,LTTR,1,6,0,60,60,
	       1IBUFFR,MAXUSD,MAXLIN,LTRNXT)
	        IF(MAXUSD.LE.0)GO TO 3
	        WRITE(1,2)(IBUFFR(I),I=1,MAXUSD)
	      2 FORMAT(100A1)
	        IF(LINE.LT.MAXLIN)GO TO 1
	      3 STOP
	        END

	  JSTIFY = -1, left justify the letter  representations  in  a
	  FASP, FORTRAN Alphameric Subroutine Package         Page 425
	  DATEXT, FORTRAN Routine for Large Printable Characters


	           field of width IWIDTH.
	         = 0, center the letter representations in a field  of
	           width IWIDTH.
	         = 1, right justify the letter  representations  in  a
	           field of width IWIDTH.

	  IFILL  = 0, if  left  justifying  or  centering  the  letter
	           representations,  do not fill the unused portion of
	           the field right of the letter representations  with
	           spaces.   MAXUSD  will  be returned pointing to the
	           right end of the rightmost letter representation.
	         = 1, if  left  justifying  or  centering  the  letter
	           representations,  do fill the unused portion of the
	           field right  of  the  letter  representations  with
	           spaces.    MAXUSD   will   be  returned  containing
	           LFTCOL+IWIDTH or MAXBFR, whichever is the smaller.

	  INTRVL = the  number  of  space  (blank)  characters  to  be
	           inserted  between  represented characters.  If MOVE
	           is  given  the  value  1  to  select  white   space
	           adjustment,  then  INTRVL  is the apparent distance
	           between the profiles of adjacent characters.

	  MOVE   = -2, characters which are narrower than  the  widest
	           character  are  centered  within  the  width of the
	           widest character.  The width of spaces is also  the
	           width  of  the  widest  character.   No white space
	           adjustment of positions is to be made.  If MOVE  is
	           either  -2 or -1 and if a character is narrow, then
	           the leading and trailing portions of the  width  in
	           which the character is centered will be filled with
	           spaces regardless of  the  value  of  IFILL  or  of
	           ISPACE.
	         = -1, characters which are narrower than most  common
	           width  will  be  centered  within  the  most common
	           width.  No white space adjustment of  positions  is
	           to  be  made.   If  MOVE is -1 or greater, then the
	           most common character width is always used  as  the
	           width of the representation of the space character.
	         = 0, normal  inter-character  spacing  is  acceptable
	           without white space adjustment.
	         = 1, adjust  space  between  characters  to  equalize
	           white spaces.

	  ISPACE = -1, represent both initial and final  spaces  which
	           appear in the LTTR array.
	         = 0, represent initial spaces which  appear  in  LTTR
	           array.   Suppress final spaces which appear in LTTR
	           array.
	         = 1, suppress both initial  and  final  spaces  which
	           appear in LTTR array.

	  LTTR   = array containing the letters to be  represented,  1
	           letter  per  word,  as  read  by  multiple of an A1
	  FASP, FORTRAN Alphameric Subroutine Package         Page 426
	  DATEXT, FORTRAN Routine for Large Printable Characters


	           format.   Since  the  lettering  produced  by  this
	           routine  is  large,  rightmost  spaces  are ignored
	           unless ISPACE=-1.  Note  that  MAXUSD  is  returned
	           equal  to  LFTCOL if LTTR contains only spaces, and
	           ISPACE is greater than or equal to zero, and  IFILL
	           is equal to zero.

	  LTRBGN = subscript of the LTTR array location containing the
	           first character which is to be represented.

	  LTREND = subscript of the LTTR array location containing the
	           final character which is to be represented.

	  LFTCOL = the subscript of the IBUFFR array location  to  the
	           immediate left of the field in which the characters
	           are to be represented.

	  IWIDTH = the width  of  the  field  into  which  the  letter
	           representations  can  be placed.  The maximum value
	           with  which  MAXUSD  can  then   be   returned   is
	           LFTCOL+IWIDTH or MAXBFR, whichever is the smaller.

	  MAXBFR = the dimension of the IBUFFR array  into  which  the
	           representation  is  placed.   If  LFTCOL+IWIDTH  is
	           greater than MAXBFR, then the  effective  value  of
	           IWIDTH is reduced to MAXBFR-LFTCOL.

	  The following arguments are used  only  for  output.   Their
	  input  values  (with  the  exception  of the portions of the
	  IBUFFR array which  are  not  needed  and  so  are  returned
	  unchanged) are ignored and destroyed.

	  IBUFFR = the  array  into  which  are  to  be   placed   the
	           representations of the letters in the LTTR array.

	  MAXUSD = returned by DATEXT containing the subscript of  the
	           IBUFFR  array  location  containing  the  rightmost
	           character of the representation.   If  nothing  has
	           been placed into IBUFFR by the current call to this
	           routine, then MAXUSD is returned set equal  to  the
	           value of LFTCOL.

	  MAXLIN = returned containing the  maximum  value  which  the
	           line  count  LINE  can attain.  This will depend on
	           which font has been  loaded.   MAXLIN  is  returned
	           containing zero if a font has not been loaded.

	  LTRNXT = returned containing the subscript within  the  LTTR
	           array   of   the   first   letter   which  was  not
	           represented.   If  all   letters   requested   were
	           represented,  then LTRNXT will be returned equal to
	           LTREND+1.  If IWIDTH is too small for  all  of  the
	           letters  to  be represented, then LTRNXT will point
	           to the first letter which would not fit.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 427
	  DATEXT, FORTRAN Routine for Large Printable Characters


	  The lettering samples shown below  demonstrate  white  space
	  adjustment.   The  printing  characters  which represent the
	  shapes of the letters in the word "FAULT" have been  changed
	  to  spaces.   The  spaces around the letter shapes have been
	  changed to plus signs where due to the normal shape  of  the
	  letters or to X's where added to obtain the desired spacing.

	  intercharacter spacing 1 with white space adjustment

	  ++++++++++++++++++X++++++++X+++++++++++++++++
	  +        ++++++   X  ++++  X  ++++++        +
	  +  +++++++++++    X  ++++  X  +++++++++  ++++
	  +  ++++++++++  +  X  ++++  X  +++++++++  ++++
	  +     ++++++  ++  X  ++++  X  +++++++++  ++++
	  +  ++++++++       X  ++++  X  +++++++++  ++++
	  +  +++++++  ++++  X+  ++  +X  +++++++++  ++++
	  +  ++++++  +++++  X++    ++X        +++  ++++
	  ++++++++++++++++++X++++++++X+++++++++++++++++

	  intercharacter spacing 2 with white space adjustment

	  ++++++++++++++++++XX++++++++XX+++++++++++++++++
	  +        ++++++   XX  ++++  XX  ++++++        +
	  +  +++++++++++    XX  ++++  XX  +++++++++  ++++
	  +  ++++++++++  +  XX  ++++  XX  +++++++++  ++++
	  +     ++++++  ++  XX  ++++  XX  +++++++++  ++++
	  +  ++++++++       XX  ++++  XX  +++++++++  ++++
	  +  +++++++  ++++  XX+  ++  +XX  +++++++++  ++++
	  +  ++++++  +++++  XX++    ++XX        +++  ++++
	  ++++++++++++++++++XX++++++++XX+++++++++++++++++

	  intercharacter spacing 3 with white space adjustment

	  ++++++++++++++++++XXX++++++++XXX+++++++++++++++++
	  +        ++++++   XXX  ++++  XXX  ++++++        +
	  +  +++++++++++    XXX  ++++  XXX  +++++++++  ++++
	  +  ++++++++++  +  XXX  ++++  XXX  +++++++++  ++++
	  +     ++++++  ++  XXX  ++++  XXX  +++++++++  ++++
	  +  ++++++++       XXX  ++++  XXX  +++++++++  ++++
	  +  +++++++  ++++  XXX+  ++  +XXX  +++++++++  ++++
	  +  ++++++  +++++  XXX++    ++XXX        +++  ++++
	  ++++++++++++++++++XXX++++++++XXX+++++++++++++++++

	  intercharacter spacing 4 with white space adjustment

	  ++++++++++++++++++XXXX++++++++XXXX++++++++X+++++++++
	  +        ++++++   XXXX  ++++  XXXX  ++++++X        +
	  +  +++++++++++    XXXX  ++++  XXXX  ++++++X+++  ++++
	  +  ++++++++++  +  XXXX  ++++  XXXX  ++++++X+++  ++++
	  +     ++++++  ++  XXXX  ++++  XXXX  ++++++X+++  ++++
	  +  ++++++++       XXXX  ++++  XXXX  ++++++X+++  ++++
	  +  +++++++  ++++  XXXX+  ++  +XXXX  ++++++X+++  ++++
	  +  ++++++  +++++  XXXX++    ++XXXX        X+++  ++++
	  ++++++++++++++++++XXXX++++++++XXXX++++++++X+++++++++
	  FASP, FORTRAN Alphameric Subroutine Package         Page 428
	  DATEXT, FORTRAN Routine for Large Printable Characters


	     A Program Demonstrating the Use of the DATEXT Routine
	     - ------- ------------- --- --- -- --- ------ -------

	  The following program attempts to center in a desired column
	  width the representation of a text string typed by the user.
	  Narrower intervals are tried if the representation will  not
	  fit with the desired interval.  If the representation of the
	  text string will not fit with an interval of 1, then  larger
	  output widths are tried until either all characters typed by
	  the user are shown or the entire output buffer is used.

	        DATA IDISK,ITTY,JTTY,MAXLTR,MAXBFR/1,5,5,20,132/
	        DIMENSION LTTR(20),IBUFFR(132)
	        CALL TEXT4
	        WRITE(JTTY,1)
	      1 FORMAT(32H CENTER IN WHAT WIDTH (MAX 132) ,$)
	        READ(ITTY,2)IDEAL
	      2 FORMAT(I)
	        WRITE(JTTY,3)
	      3 FORMAT(33H DESIRED SPACING BETWEEN LETTERS ,$)
	        READ(ITTY,2)INITAL
	      4 WRITE(JTTY,5)
	      5 FORMAT(8H STRING ,$)
	        READ(ITTY,11)LTTR
	        LTREND=MAXLTR+1
	      6 LTREND=LTREND-1
	        IF(LTREND.EQ.0)GO TO 12
	        IF(LTTR(LTREND).EQ.1H )GO TO 6
	        LINE=1
	        INTRVL=INITAL
	        IWIDTH=IDEAL
	      7 CALL DATEXT(LINE,0,0,INTRVL,1,
	       10,LTTR,1,LTREND,0,IWIDTH,MAXBFR,
	       2IBUFFR,MAXUSD,MAXLIN,LTRNXT)
	        IF(LINE.GT.1)GO TO 9
	        IF(LTRNXT.GT.LTREND)GO TO 9
	        IF(INTRVL.LE.1)GO TO 8
	        INTRVL=INTRVL-1
	        GO TO 7
	      8 IF(IWIDTH.GE.MAXBFR)GO TO 9
	        IWIDTH=IWIDTH+1
	        GO TO 7
	      9 WRITE(JTTY,10)(IBUFFR(I),I=1,MAXUSD)
	     10 FORMAT(1X,132A1)
	        WRITE(IDISK,11)(IBUFFR(I),I=1,MAXUSD)
	     11 FORMAT(132A1)
	        LINE=LINE+1
	        IF(LINE.LE.MAXLIN)GO TO 7
	        WRITE(JTTY,10)
	        WRITE(IDISK,10)
	        GO TO 4
	     12 STOP
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 429
	  DATEXT, FORTRAN Routine for Large Printable Characters


	                    The DATURN Argument List
	                    --- ------ -------- ----

	  The argument list of routine DATURN is

	        SUBROUTINE DATURN(INTRVL,MOVE  ,ISPACE,LTTR  ,LTRBGN,
	       1    LTREND,LFTCOL,MAXBFR,IBUFFR,MAXUSD,MAGNFY,INISTR,
	       2    MAXSTR,KIND  ,ISTORE)

	  with the associated DIMENSION statement

	        DIMENSION LTTR(LTREND),IBUFFR(MAXBFR),ISTORE(MAXSTR)

	  The DATURN argument list  does  not  include  the  following
	  DATEXT arguments

	    LINE which selects the line number,

	  JSTIFY which selects the justification,

	   IFILL which selects whether the buffer is to be filled with
	         spaces to the right of the lettering,

	  IWIDTH which specifies the field width,

	  MAXLIN which returns the maximum line count, and

	  LTRNXT which identifies the first character which could  not
	         be represented.

	  Also, since the lettering produced by  DATURN  tends  to  be
	  rather  large,  rightmost spaces are ignored if found in the
	  text being represented so that ISPACE values of -1 and 0 are
	  equivalent.   Instead,  if  two  or  more parallel strips of
	  lettering are being generated, then a line of spaces will be
	  returned  if  DATURN  is  called  after  all of the printing
	  characters in a particular strip have been represented.

	  The final 5 DATURN arguments are not included in the  DATEXT
	  argument  list.  MAGNFY, INISTR and MAXSTR are used only for
	  input and are returned unchanged.  KIND must be set to  zero
	  by  the  calling program before this routine is first called
	  to represent a particular line of text,  and  the  value  of
	  KIND  which  is  returned is then supplied to the subsequent
	  call of this routine which continues the  representation  of
	  the  same  line  of  text.  ISTORE is an array the values of
	  which need not be defined by the calling program.  ISTORE is
	  used  by  each  call of this routine to transfer information
	  about the current state of the lettering to  the  subsequent
	  call  to this routine which is continuing the representation
	  of the same line of text.  These arguments  are  defined  as
	  follows.

	  MAGNFY = input containing a magnification  factor  which  is
	  FASP, FORTRAN Alphameric Subroutine Package         Page 430
	  DATEXT, FORTRAN Routine for Large Printable Characters


	           applied  to the height of the lettering.  If MAGNFY
	           has the value 2, then each character which would be
	           generated  to  form  the  shape  is repeated twice.
	           Since the fonts are designed for a 6 lines per inch
	           and  10  characters per inch format, the lettering,
	           when  turned  90  degrees,  will  appear  extremely
	           elongated unless the height is magnified.  A MAGNFY
	           value of 3  would  produce  approximately  normally
	           proportioned  lettering.   If each line returned by
	           DATURN  is  printed  twice,  then  extremely  large
	           lettering  can  be produced by setting MAGNFY to 5.
	           It is of course necessary that the IBUFFR array  be
	           large  enough to contain the magnified image of the
	           lettering.

	  INISTR = input  containing  the  subscript  of   the   first
	           location  in  the ISTORE array which can be used to
	           transfer information about the current state of the
	           lettering  process  to  the subsequent call of this
	           routine which is to continue the representation  of
	           the same line of text.

	  MAXSTR = input  containing  the  subscript  of   the   final
	           location  in  the ISTORE array which can be used to
	           transfer information about the current state of the
	           lettering  process  to  the subsequent call of this
	           routine which is to continue the representation  of
	           the  same  line  of text.  At least 18 locations in
	           the ISTORE array are needed for this  purpose,  but
	           it  is  requested  that  at  least  24 locations be
	           reserved to allow for  future  enhancement  of  the
	           routine.

	  KIND   = must be input containing zero when this routine  is
	           first  called  to  represent  a  particular line of
	           text.  Thereafter, the value of  KIND  returned  by
	           this  routine  should be supplied to the subsequent
	           call which is continuing the representation of  the
	           same line of text.  KIND is returned containing one
	           of the following values.
	         = 1, returned if the line of text has been completely
	           represented.     IBUFFR(LFTCOL+1)    through    and
	           including  IBUFFR(MAXUSD)  is  returned  containing
	           spaces.   This  portion  of  the  IBUFFR array will
	           again be returned containing spaces  if  DATURN  is
	           subsequently  called  with  the value of KIND being
	           unchanged.
	         = 2,  returned  if   IBUFFR(LFTCOL+1)   through   and
	           including  IBUFFR(MAXUSD)  is returned containing a
	           portion  of  the   representation   of   a   single
	           character.
	         = 3, returned if the available portion of the  IBUFFR
	           array    was    insufficient    to    contain   the
	           representation of the lettering.  MAXBFR-LFTCOL  is
	  FASP, FORTRAN Alphameric Subroutine Package         Page 431
	  DATEXT, FORTRAN Routine for Large Printable Characters


	           less than MAGNFY times the character height.
	         = 4, returned if the available portion of the  ISTORE
	           array  was  insufficient to contain the description
	           of the current state of the lettering  process  for
	           transfer  to  the  subsequent  call to this routine
	           which is to continue the lettering of the same line
	           of text.
	         = 5, returned if a font was not loaded.

	  ISTORE = array used to transfer a description of the current
	           state  of  the  lettering process to the subsequent
	           call of this  routine  which  is  to  continue  the
	           representation  of  the  same  line  of  text.  The
	           original contents of the ISTORE array  are  ignored
	           and are destroyed.



	     A Program Demonstrating the Use of the DATURN Routine
	     - ------- ------------- --- --- -- --- ------ -------

	  The program  listed  below  constructs  a  large  multi-page
	  banner  which  can  be  printed  on  the line-printer.  Each
	  banner can contain up to 10  parallel  lines  of  lettering.
	  Each  line  in  the  input  file  should  contain the height
	  magnification factor, the width  magnification  factor,  the
	  intercharacter  spacing  (before  application  of  the width
	  magnification factor), and the number of extra  blank  lines
	  to  be  included  in the banner prior lettering for possible
	  centering, followed on the same line by a  single  character
	  which is ignored and then by the text to be represented as a
	  single line in the banner.  The  numbers  are  specified  as
	  integers.   A  line  containing a single zero terminates the
	  description of a single banner.  Additional groups of  lines
	  containing  numbers  and  text  can follow.  two consecutive
	  lines each containing a  single  zero  terminate  execution.
	  The  contents  of  a  typical  input file describing a first
	  banner containing 3 lines, and a second containing  2  lines
	  are shown below

	            3 1 2 0 TOP LINE, 1ST BANNER
	            3 1 2 0 MIDDLE LINE, 1ST BANNER
	            3 1 2 0 BOTTOM LINE, 1ST BANNER
	            3 1 2 0 LINE REJECTED BECAUSE WON'T FIT
	            0
	            5 2 2 0 TOP LINE, 2ND BANNER
	            5 2 2 0 BOTTOM LINE, 2ND BANNER
	            0
	            0

	  The characters  produced  by  this  program  are  turned  90
	  degrees  from  the orientation for which they were designed.
	  If TEXT5  is  used,  then  height  and  width  magnification
	  factors  of 1 will give letters which are 9 columns high and
	  FASP, FORTRAN Alphameric Subroutine Package         Page 432
	  DATEXT, FORTRAN Routine for Large Printable Characters


	  14 lines wide.  The lettering can extend across the full 132
	  column  width of the line-printer paper.  Two parallel lines
	  of lettering can be  generated  if  a  height  magnification
	  factor  of  5  and width magnification factor of 2 are used.
	  Three parallel lines can be generated if a height factor  of
	  3  and  width  factor  of  1  are  used.  The intercharacter
	  spacing should be about 2.

	  C     RENBR(BANNER/CONSTRUCT LETTERING ALONG FANFOLD PAPER)
	        DIMENSION LTTR(1000),IBUFFR(132),ISTORE(240),
	       1LINKND(10),LINLNG(10),LINHIH(10),NEEDED(10),
	       2LINWID(10),LINUSD(10),LINSPC(10),INITAL(10),
	       3MULTPL(4)
	        DATA IDISK,JDISK,ITTY,JTTY,MAXBFR,MAXSTR/
	       11,20,5,5,132,240/
	        DATA IBLANK,IONE,ISTAR,IPLUS/1H ,1H1,1H*,1H+/
	        DATA MOVE,ISPACE/1,0/
	        DATA MULTPL/1HH,1HI,1HO,1HX/
	        CALL TEXT5
	        LONGST=0
	        WRITE(JTTY,1)
	      1 FORMAT(39H NUMBER OF IMPRESSIONS (- FOR DARKEST) ,$)
	        READ(ITTY,2)KOPIES
	      2 FORMAT(I)
	        IF(KOPIES.LT.-4)KOPIES=-4
	        IF(KOPIES.GT.8)KOPIES=8
	  C
	  C     READ HEIGHT, WIDTH, SPACING AND TEXT TO REPRESENT
	        IEOF=0
	      3 KNTLIN=0
	        LTREND=0
	      4 KNTLIN=KNTLIN+1
	        IF(KNTLIN.GT.10)GO TO 12
	        READ(IDISK,5,END=11)IBUFFR
	      5 FORMAT(132A1)
	        LOWBFR=1
	        LINHIH(KNTLIN)=3
	        LINWID(KNTLIN)=1
	        LINSPC(KNTLIN)=2
	        INITAL(KNTLIN)=0
	        NEEDED(KNTLIN)=0
	        LINLNG(KNTLIN)=-1
	        LINKND(KNTLIN)=0
	        DO 7 INDEX=1,4
	        CALL DAIHFT(0,0,0,IBUFFR,MAXBFR,
	       1LOWBFR,KIND,ISHIFT,JSHIFT,KSHIFT,LSHIFT,IVALUE)
	        GO TO(12,8,6),KIND
	      6 IF(INDEX.EQ.1)LINHIH(KNTLIN)=IVALUE
	        IF(INDEX.EQ.2)LINWID(KNTLIN)=IVALUE
	        IF(INDEX.EQ.3)LINSPC(KNTLIN)=IVALUE
	      7 CONTINUE
	        IF(IVALUE.LE.0)GO TO 9
	        INITAL(KNTLIN)=IVALUE
	        LINKND(KNTLIN)=1
	  FASP, FORTRAN Alphameric Subroutine Package         Page 433
	  DATEXT, FORTRAN Routine for Large Printable Characters


	        GO TO 9
	      8 LOWBFR=LOWBFR-1
	      9 LTRBGN=LTREND
	        LTREND=LTREND+100
	     10 LTRBGN=LTRBGN+1
	        IF(LTRBGN.GT.LTREND)GO TO 4
	        LOWBFR=LOWBFR+1
	        LTTR(LTRBGN)=IBLANK
	        IF(LOWBFR.LE.MAXBFR)LTTR(LTRBGN)=IBUFFR(LOWBFR)
	        GO TO 10
	     11 IEOF=1
	     12 KNTLIN=KNTLIN-1
	        IF(KNTLIN.LE.0)GO TO 45
	  C
	  C     PRODUCE EACH LINE OF LETTERING UNTIL ALL LINES DONE
	        IF(LONGST.GT.0)WRITE(JDISK,13)
	     13 FORMAT(1X/1X/1X/1X/1X/1X/1X/1X)
	        LONGST=0
	        KONTRL=IONE
	     14 NOWLIN=KNTLIN
	        MAXUSD=0
	        GO TO 17
	  C
	  C     INSERT SEPARATION BETWEEN COLUMNS OF TEXT
	     15 IF(MAGNFY.LT.LINHIH(NOWLIN))MAGNFY=LINHIH(NOWLIN)
	     16 IF(MAXUSD.GE.MAXBFR)GO TO 37
	        MAGNFY=MAGNFY-1
	        MAXUSD=MAXUSD+1
	        IBUFFR(MAXUSD)=IBLANK
	        IF(MAGNFY.GT.0)GO TO 16
	  C
	  C     REPRESENT CURRENT LINE OF CURRENT COLUMN OF TEXT
	     17 MAGNFY=LINHIH(NOWLIN)
	        NEEDED(NOWLIN)=NEEDED(NOWLIN)-1
	        IF(NEEDED(NOWLIN).GT.0)GO TO 21
	        NEEDED(NOWLIN)=LINWID(NOWLIN)
	        LFTCOL=MAXUSD
	        LTREND=100*NOWLIN
	        LTRBGN=LTREND-99
	        INISTR=(24*NOWLIN)-23
	        KIND=LINKND(NOWLIN)
	        INTRVL=LINSPC(NOWLIN)
	        CALL DATURN(INTRVL,MOVE  ,ISPACE,LTTR  ,LTRBGN,
	       1LTREND,LFTCOL,MAXBFR,IBUFFR,MAXUSD,MAGNFY,INISTR,
	       2MAXSTR,KIND  ,ISTORE)
	        IF(INITAL(NOWLIN).LE.0)GO TO 18
	        IF(KIND.NE.1)GO TO 20
	        NEEDED(NOWLIN)=INITAL(NOWLIN)
	        INITAL(NOWLIN)=-INITAL(NOWLIN)
	        LINKND(NOWLIN)=0
	        KIND=2
	        GO TO 19
	     18 LINKND(NOWLIN)=KIND
	     19 LINUSD(NOWLIN)=MAXUSD
	  FASP, FORTRAN Alphameric Subroutine Package         Page 434
	  DATEXT, FORTRAN Routine for Large Printable Characters


	     20 GO TO(23,22,37,41,43),KIND
	     21 MAXUSD=LINUSD(NOWLIN)
	     22 NOWLIN=NOWLIN-1
	        IF(NOWLIN.GT.0)GO TO 15
	        GO TO 25
	  C
	  C     DONE WITH THIS COLUMN OF TEXT, CHECK IF DONE WITH ALL
	     23 IF(LINLNG(NOWLIN).LT.0)LINLNG(NOWLIN)=LONGST
	        NOWLIN=NOWLIN-1
	        IF(NOWLIN.GT.0)GO TO 15
	        NOWLIN=KNTLIN
	     24 IF(NOWLIN.LE.0)GO TO 33
	        IF(LINLNG(NOWLIN).LT.0)GO TO 25
	        NOWLIN=NOWLIN-1
	        GO TO 24
	  C
	  C     OUTPUT CURRRENT LINE
	     25 LONGST=LONGST+1
	        IF(KOPIES.LT.0)GO TO 28
	        J=KOPIES
	     26 WRITE(JDISK,27)KONTRL,(IBUFFR(I),I=1,MAXUSD)
	     27 FORMAT(133A1)
	        KONTRL=IPLUS
	        J=J-1
	        IF(J.GT.0)GO TO 26
	        GO TO 32
	     28 DO 31 K=1,4
	        LETTER=MULTPL(K)
	        DO 29 I=1,MAXUSD
	        IF(IBUFFR(I).NE.IBLANK)IBUFFR(I)=LETTER
	     29 CONTINUE
	        J=KOPIES
	     30 WRITE(JDISK,27)KONTRL,(IBUFFR(I),I=1,MAXUSD)
	        KONTRL=IPLUS
	        J=J+1
	        IF(J.LT.0)GO TO 30
	     31 CONTINUE
	     32 KONTRL=ISTAR
	        GO TO 14
	  C
	  C     ERROR MESSAGES AND SUMMATION
	     33 WRITE(JTTY,34)(LINLNG(I),I=1,KNTLIN)
	     34 FORMAT(18H LENGTHS (TOP 1ST),10I5)
	        DO 35 I=1,KNTLIN
	     35 LINLNG(I)=(LONGST-LINLNG(I)-INITAL(I))/2
	        WRITE(JTTY,36)(LINLNG(I),I=1,KNTLIN)
	     36 FORMAT(18H NEEDED TO CENTER ,10I5)
	        GO TO 40
	     37 WRITE(JTTY,38),KNTLIN
	     38 FORMAT(36H LETTERS TOO HIGH TO REPRESENT LINE ,I3)
	        DO 39 I=1,KNTLIN
	        NEEDED(I)=0
	        LINKND(I)=0
	        IF(INITAL(I).EQ.0)GO TO 39
	  FASP, FORTRAN Alphameric Subroutine Package         Page 435
	  DATEXT, FORTRAN Routine for Large Printable Characters


	        IF(INITAL(I).LT.0)INITAL(I)=-INITAL(I)
	        LINKND(I)=1
	     39 CONTINUE
	        IF(KNTLIN.GT.1)GO TO 12
	     40 IF(IEOF.EQ.0)GO TO 3
	        GO TO 45
	  C
	  C     SERIOUS ERROR CONDITIONS
	     41 WRITE(JTTY,42)
	     42 FORMAT(21H INSUFFICIENT STORAGE)
	        GO TO 45
	     43 WRITE(JTTY,44)
	     44 FORMAT(16H FONT NOT LOADED)
	     45 ENDFILE JDISK
	        STOP
	  C251676520779$
	        END


	                       Font Style Samples
	                       ---- ----- -------

	  The designs of the numerals shown below are typical  of  the
	  designs  of  the characters in the corresponding fonts TEXT1
	  through TEXT5 respectively.

	                       333333
	                     33      33                 55555555555555
	                    33        33        4444    5555
	    111    2222               33       44 44    5555
	  11111        2             33       44  44    5555555555
	    111     222         33333        44   44            55555
	    111    2                 33     44444444              5555
	    111    22222              33          44              5555
	                    33        33          44            55555
	                     33      33                 5555555555
	                       333333
	  FASP, FORTRAN Alphameric Subroutine Package         Page 436
	  DATEXT, FORTRAN Routine for Large Printable Characters


	             Typical Lettering using the TEXT1 Font
	             ------- --------- ----- --- ----- ----

	  The only punctuation marks in this font are ()*/+-=:., and '

	      AAA      BBBBBBBBB   CCCCCCCCC   DDDDDDD     EEEEEEEEE
	    AAA AAA    BBB   BBB   CCC         DDD   DDD   EEE
	   AAA   AAA   BBBBBBB     CCC         DDD   DDD   EEEEEE
	   AAAAAAAAA   BBB   BBB   CCC         DDD   DDD   EEE
	   AAA   AAA   BBBBBBBBB   CCCCCCCCC   DDDDDDD     EEEEEEEEE

	   FFFFFFFFF   GGGGGGGGG   HHH   HHH    IIIIIII          JJJ
	   FFF         GGG         HHH   HHH      III            JJJ
	   FFFFFF      GGG  GGGG   HHHHHHHHH      III            JJJ
	   FFF         GGG   GGG   HHH   HHH      III      JJJ   JJJ
	   FFF         GGGGGGGGG   HHH   HHH    IIIIIII    JJJJJJJJJ

	   KKK   KKK   LLL        MMM     MMM  NNN   NNN   OOOOOOOOO
	   KKK  KKK    LLL        MMMM   MMMM  NNNN  NNN   OOO   OOO
	   KKKKKKK     LLL        MMM M M MMM  NNN N NNN   OOO   OOO
	   KKK  KKK    LLL        MMM  M  MMM  NNN  NNNN   OOO   OOO
	   KKK   KKK   LLLLLLLLL  MMM     MMM  NNN   NNN   OOOOOOOOO

	   PPPPPPPPP  QQQQQQQQQ    RRRRRRRRR    SSSSSSS    TTTTTTTTT
	   PPP   PPP  QQQ   QQQ    RRR   RRR   SSS            TTT
	   PPPPPPPPP  QQQ   QQQ    RRRRRRR      SSSSSSS       TTT
	   PPP        QQQ   QQQ    RRR  RRR          SSS      TTT
	   PPP        QQQQQQQQQQQ  RRR   RRR   SSSSSSSS       TTT

	   UUU   UUU   VVV   VVV  WWW     WWW  XXX   XXX   YYY   YYY
	   UUU   UUU   VVV   VVV  WWW  W  WWW   XXX XXX     YYY YYY
	   UUU   UUU    VVV VVV   WWW W W WWW     XXX         YYY
	   UUU   UUU     VVVVV    WWWW   WWWW   XXX XXX       YYY
	   UUUUUUUUU      VVV     WWW     WWW  XXX   XXX      YYY

	   ZZZZZZZZZ   000000000       111     222222222   333333333
	        ZZZ    000   000     11111           222         333
	      ZZZ      000   000       111       2222222       333
	    ZZZ        000   000       111     222               333
	   ZZZZZZZZZ   000000000       111     222222222   333333333

	     444 444   555555555     666       777777777   888888888
	    444  444   555          666             777    888   888
	   444444444   5555555     666666666       777       88888
	         444         555   666   666      777      888   888
	         444   555555555   666666666     777       888888888

	   999999999       (((      *** ***         ///       +++
	   999   999     (((          ***          ///        +++
	   999999999     (((       *********      ///      +++++++++
	        999      (((          ***        ///          +++
	       999         (((      *** ***     ///           +++
	  FASP, FORTRAN Alphameric Subroutine Package         Page 437
	  DATEXT, FORTRAN Routine for Large Printable Characters


	             Typical Lettering using the TEXT2 Font
	             ------- --------- ----- --- ----- ----

	    A    BBBB    CCCC  DDDD   EEEEE  FFFFF   GGGG  H   H
	   A A   B   B  C      D   D  E      F      G      H   H
	  A   A  BBBB   C      D   D  EEEE   FFFF   G  GG  HHHHH
	  AAAAA  B   B  C      D   D  E      F      G   G  H   H
	  A   A  BBBB    CCCC  DDDD   EEEEE  F       GGGG  H   H

	   III       J  K   K  L      M   M  N   N   OOO   PPPP
	    I        J  K  K   L      MM MM  NN  N  O   O  P   P
	    I        J  KKK    L      M M M  N N N  O   O  PPPP
	    I    J   J  K  K   L      M   M  N  NN  O   O  P
	   III    JJJ   K   K  LLLLL  M   M  N   N   OOO   P

	   QQQ   RRRR    SSSS  TTTTT  U   U  V   V  W   W  X   X
	  Q   Q  R   R  S        T    U   U  V   V  W   W   X X
	  Q Q Q  RRRR    SSS     T    U   U  V   V  W W W    X
	  Q  Q   R  R       S    T    U   U   V V   WW WW   X X
	   QQ Q  R   R  SSSS     T     UUU     V    W   W  X   X

	  Y   Y  ZZZZZ   000    11    2222   3333   4   4  55555
	   Y Y      Z   0   0    1        2      3  4   4  5
	    Y      Z    0   0    1     222     33   44444  5555
	    Y     Z     0   0    1    2          3      4      5
	    Y    ZZZZZ   000    111   22222  3333       4  5555

	    6    77777   888    999     ((    ))
	   6        7   8   8  9   9   (        )     +
	  6666     7     888    9999   (        )   +++++  -----
	  6   6   7     8   8     9    (        )     +
	   666   7       888     9      ((    ))

	             /                 ''     ::      ^    "" ""
	   ***      /                  ''     ::     ^ ^   "" ""
	  *****    /            ,,      '           ^   ^   "  "
	   ***    /      ..     ,,            ::
	         /       ..      ,            ::

	   # #    $$$$  %%  %  &&&              <    >     ????
	  ## ##  $ $    %% %    &     =====    <      >        ?
	          $$$     %    & & &          <        >     ??
	  ## ##    $ $   % %%  &  &   =====    <      >
	   # #   $$$$   %  %%   && &            <    >       ?

	   @@@     !
	  @   @    !
	  @  @@    !
	  @  @@
	   @       !
	  FASP, FORTRAN Alphameric Subroutine Package         Page 438
	  DATEXT, FORTRAN Routine for Large Printable Characters


	             Typical Lettering using the TEXT3 Font
	             ------- --------- ----- --- ----- ----

	       AA         BBBBBBBBB          CCCCCC       DDDDDDDD
	      AAAA        BB       BB      CC      CC     DD      DD
	     AA  AA       BB        BB    CC        CC    DD       DD
	    AA    AA      BB        BB    CC              DD        DD
	   AA      AA     BB       BB     CC              DD        DD
	  AA        AA    BBBBBBBBB       CC              DD        DD
	  AA        AA    BB       BB     CC              DD        DD
	  AAAAAAAAAAAA    BB        BB    CC              DD        DD
	  AA        AA    BB        BB    CC        CC    DD       DD
	  AA        AA    BB       BB      CC      CC     DD      DD
	  AA        AA    BBBBBBBBB          CCCCCC       DDDDDDDD

	  EEEEEEEEEEEE    FFFFFFFFFFFF       GGGGGG       HH        HH
	  EE              FF               GG      GG     HH        HH
	  EE              FF              GG        GG    HH        HH
	  EE              FF              GG              HH        HH
	  EE              FF              GG              HH        HH
	  EEEEEEEE        FFFFFFFF        GG              HHHHHHHHHHHH
	  EE              FF              GG     GGGGG    HH        HH
	  EE              FF              GG        GG    HH        HH
	  EE              FF              GG        GG    HH        HH
	  EE              FF               GG       GG    HH        HH
	  EEEEEEEEEEEE    FF                 GGGGGGGGG    HH        HH

	     IIIIII                 JJ    KK      KK      LL
	       II                   JJ    KK     KK       LL
	       II                   JJ    KK    KK        LL
	       II                   JJ    KK   KK         LL
	       II                   JJ    KK  KK          LL
	       II                   JJ    KK KKKK         LL
	       II                   JJ    KKKK  KK        LL
	       II                   JJ    KKK    KK       LL
	       II         JJ        JJ    KK      KK      LL
	       II          JJ      JJ     KK       KK     LL
	     IIIIII          JJJJJJ       KK        KK    LLLLLLLLLLLL

	  MM        MM    NN        NN       OOOOOO       PPPPPPPPP
	  MMM      MMM    NNN       NN     OO      OO     PP       PP
	  MMMM    MMMM    NNNN      NN    OO        OO    PP        PP
	  MM MM  MM MM    NN NN     NN    OO        OO    PP        PP
	  MM  MMMM  MM    NN  NN    NN    OO        OO    PP       PP
	  MM   MM   MM    NN   NN   NN    OO        OO    PPPPPPPPP
	  MM        MM    NN    NN  NN    OO        OO    PP
	  MM        MM    NN     NN NN    OO        OO    PP
	  MM        MM    NN      NNNN    OO        OO    PP
	  MM        MM    NN       NNN     OO      OO     PP
	  MM        MM    NN        NN       OOOOOO       PP
	  FASP, FORTRAN Alphameric Subroutine Package         Page 439
	  DATEXT, FORTRAN Routine for Large Printable Characters


	                     TEXT3 Font (continued)
	                     ----- ----  ---------

	     QQQQQQ       RRRRRRRRR          SSSSSS       TTTTTTTTTTTT
	   QQ      QQ     RR       RR      SS      SS          TT
	  QQ        QQ    RR        RR    SS        SS         TT
	  QQ        QQ    RR        RR    SS                   TT
	  QQ        QQ    RR       RR      SS                  TT
	  QQ        QQ    RRRRRRRRR          SSSSSS            TT
	  QQ        QQ    RR    RR                 SS          TT
	  QQ     QQ  Q    RR     RR                 SS         TT
	  QQ      QQ      RR      RR      SS        SS         TT
	   QQ      QQ     RR       RR      SS      SS          TT
	     QQQQQ  QQ    RR        RR       SSSSSS            TT

	  UU        UU    VV        VV    WW        WW    XX        XX
	  UU        UU    VV        VV    WW        WW     XX      XX
	  UU        UU    VV        VV    WW        WW      XX    XX
	  UU        UU    VV        VV    WW        WW       XX  XX
	  UU        UU    VV        VV    WW        WW        XXXX
	  UU        UU    VV        VV    WW   WW   WW         XX
	  UU        UU     VV      VV     WW  WWWW  WW        XXXX
	  UU        UU      VV    VV      WW WW  WW WW       XX  XX
	  UU        UU       VV  VV       WWWW    WWWW      XX    XX
	   UU      UU         VVVV        WWW      WWW     XX      XX
	     UUUUUU            VV         WW        WW    XX        XX

	  YY        YY    ZZZZZZZZZZZZ       000000            11
	   YY      YY              ZZ      00      00         111
	    YY    YY              ZZ      00        00       1111
	     YY  YY              ZZ       00        00         11
	      YYYY              ZZ        00        00         11
	       YY              ZZ         00        00         11
	       YY             ZZ          00        00         11
	       YY            ZZ           00        00         11
	       YY           ZZ            00        00         11
	       YY          ZZ              00      00          11
	       YY         ZZZZZZZZZZZZ       000000          111111

	     222222          333333             44        555555555555
	   22      22      33      33          44         55
	  22        22    33        33        44          55
	            22              33       44     44    55
	           22              33       44      44    55
	         22           33333        44       44    555555555
	       22                  33     444444444444             55
	     22                     33              44              55
	   22             33        33              44              55
	  22               33      33               44             55
	  222222222222       333333                 44    555555555
	  FASP, FORTRAN Alphameric Subroutine Package         Page 440
	  DATEXT, FORTRAN Routine for Large Printable Characters


	                     TEXT3 Font (continued)
	                     ----- ----  ---------

	         66       777777777777       888888          999999
	        66                 77      88      88      99      99
	       66                 77      88        88    99        99
	      66                 77       88        88    99        99
	     66                 77         88      88      99      99
	    6666666            77            888888          9999999
	   66      66          77          88      88            99
	  66        66         77         88        88          99
	  66        66         77         88        88         99
	   66      66          77          88      88         99
	     666666            77            888888          99

	                                   %%%      %%         $$
	           <<      >>             %   %    %%          $$
	         <<          >>           %   %   %%        $$$$$$$$$$
	       <<              >>          %%%   %%       $$   $$
	     <<                  >>             %%        $$   $$
	   <<                      >>          %%           $$$$$$$$
	     <<                  >>           %%               $$   $$
	       <<              >>            %%   %%%          $$   $$
	         <<          >>             %%   %   %    $$$$$$$$$$
	           <<      >>              %%    %   %         $$
	                                  %%      %%%          $$

	  ?????????            ^^              !!            ##  ##
	           ??         ^^^^             !!            ##  ##
	            ??       ^^  ^^            !!            ##  ##
	            ??      ^^    ^^           !!         #####  #####
	           ??      ^^      ^^          !!
	     ??????       ^^        ^^         !!
	     ??                                !!
	                                                  #####  #####
	     ??                                !!            ##  ##
	    ????                              !!!!           ##  ##
	     ??                                !!            ##  ##

	     &&&&            @@@@@@                 //
	    &&  &&         @@      @@              //
	    &&  &&        @@        @@            //           ++
	     &&&&         @@   @@   @@           //            ++
	      &&          @@  @  @  @@          //             ++
	     &&&&         @@  @  @  @@         //         ++++++++++++
	    &&  &&        @@  @  @  @@        //               ++
	   &&    && &&    @@   @@@@@@        //                ++
	  &&      &&      @@                //                 ++
	  &&    && &&      @@              //
	   &&&&&    &&       @@@@@@@@@    //
	  FASP, FORTRAN Alphameric Subroutine Package         Page 441
	  DATEXT, FORTRAN Routine for Large Printable Characters


	                     TEXT3 Font (continued)
	                     ----- ----  ---------

	                                                        ((((
	                                                      (((
	    **    **                                         ((
	     **  **                       ============      ((
	      ****                                          ((
	  ************    ------------                      ((
	      ****                                          ((
	     **  **                       ============      ((
	    **    **                                         ((
	                                                      (((
	                                                        ((((

	      ''               ::          ""    ""            ;;
	      '''             ::::         """   """          ;;;;
	       ''              ::           ""    ""           ;;
	      ''                           ""    ""



	                                                       ;;
	                       ::                              ;;;
	                      ::::                              ;;
	                       ::                              ;;

	                                    ))))
	                                       )))
	                                         ))
	                                          ))
	                                          ))
	                                          ))
	                                          ))
	                      ,,                  ))
	       ..             ,,,                ))
	      ....             ,,              )))
	       ..             ,,            ))))
	  FASP, FORTRAN Alphameric Subroutine Package         Page 442
	  DATEXT, FORTRAN Routine for Large Printable Characters


	             Typical Lettering using the TEXT4 Font
	             ------- --------- ----- --- ----- ----

	        AAA  BBBBBB       CCCCC  DDDDD     EEEEEEEE  FFFFFFFF
	       AAAA  BB    BB   CC       DD   DD   EE        FF
	      AA AA  BB    BB  CC        DD    DD  EE        FF
	     AA  AA  BBBBBB    CC        DD    DD  EEEEE     FFFFF
	    AAAAAAA  BB    BB  CC        DD    DD  EE        FF
	   AA    AA  BB    BB   CC       DD   DD   EE        FF
	  AA     AA  BBBBBB       CCCCC  DDDDD     EEEEEEEE  FF

	      GGGGG  HH    HH   IIIIII         JJ  KK   KK   LL
	    GG       HH    HH     II           JJ  KK  KK    LL
	   GG        HH    HH     II           JJ  KK KK     LL
	   GG  GGGG  HHHHHHHH     II           JJ  KKKKK     LL
	   GG    GG  HH    HH     II     JJ    JJ  KKK KK    LL
	    GG   GG  HH    HH     II      JJ  JJ   KK   KK   LL
	      GGGGG  HH    HH   IIIIII     JJJJ    KK    KK  LLLLLLLL

	  MM      MM NN    NN   OOOOO    PPPPPP     QQQQQ    RRRRRR
	  MMM    MMM NNN   NN  OO   OO   PP    PP  QQ   QQ   RR    RR
	  MMMM  MMMM NNNN  NN OO     OO  PP    PP QQ     QQ  RR    RR
	  MM MMMM MM NN NN NN OO     OO  PPPPPP   QQ  QQ QQ  RRRRRR
	  MM  MM  MM NN  NNNN OO     OO  PP       QQ   QQ Q  RR  RR
	  MM      MM NN   NNN  OO   OO   PP        QQ   QQ   RR   RR
	  MM      MM NN    NN   OOOOO    PP         QQQQ QQ  RR    RR

	     SSSSSS  TTTTTTTT  UU    UU  VV    VV WW      WW YY    YY
	   SS           TT     UU    UU  VV   VV  WW      WW  YY  YY
	   SS           TT     UU    UU  VV  VV   WW  WW  WW   YYYY
	     SSSS       TT     UU    UU  VV VV    WW WWWW WW    YY
	         SS     TT     UU    UU  VVVV     WWWW  WWWW    YY
	         SS     TT      UU  UU   VVV      WWW    WWW    YY
	   SSSSSS       TT       UUUU    VV       WW      WW    YY

	   XX    XX  ZZZZZZZZ    0000        11    222222    333333
	    XX  XX        ZZ    00  00     1111          22        33
	     XXXX        ZZ    00    00      11          22        33
	      XX        ZZ     00    00      11      2222      3333
	     XXXX      ZZ      00    00      11    22              33
	    XX  XX    ZZ        00  00       11    22              33
	   XX    XX  ZZZZZZZZ    0000        11    22222222  333333

	       4444  55555555      66    77777777    8888      9999
	      44 44  55           66           77  88    88  99    99
	     44  44  55          66           77   88    88  99    99
	    44   44  555555     66666        77      8888      99999
	   44444444        55  66    66     77     88    88      99
	         44        55  66    66     77     88    88     99
	         44  555555      6666       77       8888      99
	  FASP, FORTRAN Alphameric Subroutine Package         Page 443
	  DATEXT, FORTRAN Routine for Large Printable Characters


	                     TEXT4 Font (continued)
	                     ----- ----  --------- 

	       ((                                        //
	     ((         ++                **  **        //
	    ((          ++                 ****        //    ========
	    ((       ++++++++  --------  ********     //
	    ((          ++                 ****      //      ========
	     ((         ++                **  **    //
	       ((                                  //

	                         '''      ))          ^^     ??????
	                          ''        ))       ^^^^          ??
	                         ''          ))     ^^  ^^         ??
	                                     ))    ^^    ^^     ???
	               ,,,                   ))
	      ..        ,,                  ))                  ??
	      ..       ,,                 ))                    ??

	                        ##  ##      ::        ;;        !!
	        <<    >>        ##  ##      ::        ;;        !!
	      <<        >>     ###  ###                         !!
	    <<            >>                                    !!
	      <<        >>     ###  ###              ;;;
	        <<    >>        ##  ##      ::        ;;        !!
	                        ##  ##      ::       ;;         !!
	  FASP, FORTRAN Alphameric Subroutine Package         Page 444
	  DATEXT, FORTRAN Routine for Large Printable Characters


	             Typical Lettering using the TEXT5 Font
	             ------- --------- ----- --- ----- ----

	        AA       BBBBBBBBBB         CCCCCCCCCC DDDDDDDD
	       AAAA      BBBB    BBBBB   CCCCC         DDDD  DDDDD
	      AAAAAA     BBBB      BBBB CCCC           DDDD     DDDD
	     AA  AAAA    BBBB    BBBBB  CCCC           DDDD      DDDD
	    AA    AAAA   BBBBBBBBBB     CCCC           DDDD      DDDD
	   AA      AAAA  BBBB    BBBBB  CCCC           DDDD      DDDD
	  AAAAAAAAAAAAAA BBBB      BBBB CCCC           DDDD     DDDD
	  AA        AAAA BBBB    BBBBB   CCCCC         DDDD  DDDDD
	  AA        AAAA BBBBBBBBBB         CCCCCCCCCC DDDDDDDD

	  EEEEEEEEEEEEEE FFFFFFFFFFFFFF     GGGGGGGGGG HHHH      HHHH
	  EEEE           FFFF            GGGGG         HHHH      HHHH
	  EEEE           FFFF           GGGG           HHHH      HHHH
	  EEEE           FFFF           GGGG           HHHH      HHHH
	  EEEEEEEEE      FFFFFFFFF      GGGG           HHHHHHHHHHHHHH
	  EEEE           FFFF           GGGG    GGGGGG HHHH      HHHH
	  EEEE           FFFF           GGGG      GGGG HHHH      HHHH
	  EEEE           FFFF            GGGGG    GGGG HHHH      HHHH
	  EEEEEEEEEEEEEE FFFF               GGGGGGGGGG HHHH      HHHH

	  IIIIIIII             JJJJ   KKKK       KKK   LLLL
	    IIII               JJJJ   KKKK     KKK     LLLL
	    IIII               JJJJ   KKKK   KKK       LLLL
	    IIII               JJJJ   KKKK KKK         LLLL
	    IIII               JJJJ   KKKKKK           LLLL
	    IIII     JJJJ      JJJJ   KKKKKKKK         LLLL
	    IIII     JJJJ      JJJJ   KKKK  KKKK       LLLL
	    IIII      JJJJJ  JJJJJ    KKKK    KKKK     LLLL
	  IIIIIIII       JJJJJJJ      KKKK      KKKK   LLLLLLLLLLLLLL

	  MM        MMMM NNNNN       NN     OOOOOO     PPPPPPPPPP
	  MMM      MMMMM NNNNNN      NN  OOOOO  OOOOO  PPPP    PPPPP
	  MMMM    MMMMMM NN NNNN     NN OOOO      OOOO PPPP      PPPP
	  MMMMM  MM MMMM NN  NNNN    NN OOOO      OOOO PPPP      PPPP
	  MM MMMMM  MMMM NN   NNNN   NN OOOO      OOOO PPPP    PPPPP
	  MM  MMM   MMMM NN    NNNN  NN OOOO      OOOO PPPPPPPPPP
	  MM   M    MMMM NN     NNNN NN OOOO      OOOO PPPP
	  MM        MMMM NN      NNNNNN  OOOOO  OOOOO  PPPP
	  MM        MMMM NN       NNNNN     OOOOOO     PPPP

	      QQQQQQ     RRRRRRRRRR         SSSSSSSSSS TTTTTTTTTTTTTT
	   QQQQQ  QQQQQ  RRRR    RRRRR   SSSSS              TTTT
	  QQQQ      QQQQ RRRR      RRRR SSSS                TTTT
	  QQQQ      QQQQ RRRR      RRRR  SSSSS              TTTT
	  QQQQ      QQQQ RRRR    RRRRR      SSSSSS          TTTT
	  QQQQ QQQ   QQQ RRRRRRRRRRR            SSSSS       TTTT
	  QQQQ   QQQ   Q RRRR    RRRR             SSSS      TTTT
	   QQQQQ   QQQ   RRRR     RRRR          SSSSS       TTTT
	     QQQQQ   QQQ RRRR      RRRR SSSSSSSSSS          TTTT
	  FASP, FORTRAN Alphameric Subroutine Package         Page 445
	  DATEXT, FORTRAN Routine for Large Printable Characters


	                     TEXT5 Font (continued)
	                     ----- ----  --------- 
	  UUUU        UU VVVV        VV WWWW        WW XXXX       XX
	  UUUU        UU VVVV        VV WWWW        WW  XXXX     XX
	  UUUU        UU VVVV        VV WWWW    W   WW   XXXX   XX
	  UUUU        UU  VVVV      VV  WWWW   WWW  WW    XXXX XX
	  UUUU        UU   VVVV    VV   WWWW  WWWWW WW     XXXXXX
	  UUUU        UU    VVVV  VV    WWWW WW  WWWWW     XX XXXX
	  UUUU        UU     VVVVVV     WWWWWW    WWWW    XX   XXXX
	   UUUUU   UUUU       VVVV      WWWWW      WWW   XX     XXXX
	      UUUUUUU          VV       WWWW        WW  XX       XXXX

	   YYYY        YY  ZZZZZZZZZZZZZZ                BBBB
	    YYYY      YY           ZZZZ                  BBBB
	     YYYY    YY           ZZZZ                   BBBB
	      YYYY  YY           ZZZZ       AAAAAAAAA    BBBBBBBBB
	       YYYYYY           ZZZZ               AAAA  BBBB   BBBB
	        YYYY           ZZZZ          AAAAAAAAAA  BBBB    BBBB
	        YYYY          ZZZZ         AAAA    AAAA  BBBB    BBBB
	        YYYY         ZZZZ          AAAA    AAAA  BBBB   BBBB
	        YYYY       ZZZZZZZZZZZZZZ    AAAAAAAAAA  BBBBBBBBB

	                          DDDD                           FFFFF
	                          DDDD                         FFFF
	                          DDDD                        FFFF
	     CCCCCCCCC       DDDDDDDDD       EEEEEE       FFFFFFFFFFFF
	   CCCC            DDDD   DDDD     EEEE  EEEE         FFFF
	  CCCC            DDDD    DDDD    EEEE    EEEE        FFFF
	  CCCC            DDDD    DDDD    EEEEEEEEEEEE        FFFF
	   CCCC            DDDD   DDDD     EEEE               FFFF
	     CCCCCCCCC       DDDDDDDDD       EEEEEEEEE        FFFF

	                HHHH           II      JJ   KKKK          LLLL
	                HHHH          IIII    JJJJ  KKKK          LLLL
	                HHHH           II      JJ   KKKK          LLLL
	     GGGGGGGGG  HHHH  HHHH                  KKKK   KKK    LLLL
	   GGGG   GGGG  HHHH HHHHHH   IIII    JJJJ  KKKK KKK      LLLL
	  GGGG    GGGG  HHHHHH  HHHH  IIII    JJJJ  KKKKKK        LLLL
	  GGGG    GGGG  HHHHH   HHHH  IIII    JJJJ  KKKKKKKK      LLLL
	   GGGG   GGGG  HHHH    HHHH  IIII    JJJJ  KKKK  KKKK    LLLL
	     GGGGGGGGG  HHHH    HHHH  IIII    JJJJ  KKKK    KKKK  LLLL
	          GGGG                        JJJJ
	         GGGG                        JJJJ
	   GGGGGGGG                       JJJJJ

	  MMMM  MMMM    MMMM   NNNN  NNNN      OOOOOO    PPPPPPPPP
	  MMMM MMMMMM  MMMMMM  NNNN NNNNNN   OOOO  OOOO  PPPP   PPPP
	  MMMMMM  MMMMMM  MMMM NNNNNN  NNNN OOOO    OOOO PPPP    PPPP
	  MMMMM   MMMMM   MMMM NNNNN   NNNN OOOO    OOOO PPPP    PPPP
	  MMMM    MMMM    MMMM NNNN    NNNN  OOOO  OOOO  PPPP   PPPP
	  MMMM    MMMM    MMMM NNNN    NNNN    OOOOOO    PPPPPPPPP
	                                                 PPPP
	                                                 PPPP
	                                                 PPPP
	  FASP, FORTRAN Alphameric Subroutine Package         Page 446
	  DATEXT, FORTRAN Routine for Large Printable Characters


	                     TEXT5 Font (continued)
	                     ----- ----  --------- 
	                                                      TTTT
	                                                      TTTT
	                                                      TTTT
	     QQQQQQQQQ    RRRR   RRRRR      SSSSSSSSSS    TTTTTTTTTTTT
	   QQQQ   QQQQ    RRRR RRRR       SSSS                TTTT
	  QQQQ    QQQQ    RRRRRR           SSSSSSS            TTTT
	  QQQQ    QQQQ    RRRR                SSSSSSS         TTTT
	   QQQQ   QQQQ    RRRR                    SSSS        TTTT
	     QQQQQQQQQ    RRRR            SSSSSSSSSS          TTTT
	          QQQQ
	          QQQQ
	          QQQQ

	  UUUU    UUUU VVVV      VV WWWW      WW      WW XXXX     XXX
	  UUUU    UUUU  VVVV    VV   WWWW    WWWW    WW   XXXX  XXX
	  UUUU   UUUUU   VVVV  VV     WWWW  WWWWWW  WW      XXXXX
	  UUUU  UUUUUU    VVVVVV       WWWWWW  WWWWWW        XXXXX
	   UUUUUU UUUU     VVVV         WWWW    WWWW       XXX  XXXX
	    UUUU  UUUU      VV           WW      WW      XXX     XXXX

	                                        000000              11
	                                     00000  00000         1111
	                                    0000      0000     1111111
	  YYYY      YY     ZZZZZZZZZZZZ     0000      0000        1111
	   YYYY    YY             ZZZZ      0000      0000        1111
	    YYYY  YY            ZZZZ        0000      0000        1111
	     YYYYYY           ZZZZ          0000      0000        1111
	      YYYY          ZZZZ             00000  00000         1111
	       YY          ZZZZZZZZZZZZ         000000            1111
	      YY
	    YYY
	  YYY

	  2222222222     3333333333          4444444   55555555555555
	          22222          33333      44  4444   5555
	            2222           3333    44   4444   5555
	          22222          33333    44    4444   5555555555
	      222222         333333      44     4444           55555
	   22222                 33333  44444444444444           5555
	  2222                     3333 44444444444444           5555
	  2222                   33333          4444           55555
	  22222222222222 3333333333             4444   5555555555

	          6666  77777777777777     88888888         999999
	       6666               7777   8888     888    99999  99999
	     6666                 7777  8888       888  9999      9999
	   6666                  7777    88888    888    99999    9999
	  6666666666            7777        888888          9999999999
	  6666    66666        7777      888    8888             9999
	  6666      6666      7777      888       8888         9999
	   66666  66666      7777        888     8888        9999
	      666666        7777           88888888       9999
	  FASP, FORTRAN Alphameric Subroutine Package         Page 447
	  DATEXT, FORTRAN Routine for Large Printable Characters


	                     TEXT5 Font (continued)
	                     ----- ----  --------- 

	   ;;        ::  !!!!    ""     ""         ////
	  ;;;;      :::: !!!!    """    """       ////      ++++
	   ;;        ::  !!!!     ""     ""      ////       ++++
	                 !!!!    ""     ""      ////        ++++
	                 !!!!                  ////    ++++++++++++++
	   ;;                 ,,              ////     ++++++++++++++
	   ;;;  ..   ::   !!  ,,,            ////           ++++
	    ;; .... :::: !!!!  ,,           ////            ++++
	   ;;   ..   ::   !!  ,,           ////             ++++

	                                  ''   )))))            (((((
	    ***    ***                    '''     )))))      (((((
	     ***  ***                      ''       ))))    ((((
	      ******                      ''         ))))  ((((
	  **************  --------------             ))))  ((((
	  **************  --------------             ))))  ((((
	      ******                                ))))    ((((
	     ***  ***                             )))))      (((((
	    ***    ***                         )))))            (((((

	                     ###    ###          ^^
	   ==============    ###    ###        ^^^^^^            <<<<
	   ==============  ##############    ^^^^  ^^^^        <<<<
	                     ###    ###    ^^^^      ^^^^    <<<<
	                     ###    ###                    <<<<
	                     ###    ###                      <<<<
	   ==============  ##############                      <<<<
	   ==============    ###    ###                          <<<<
	                     ###    ###

	              ??????????           &&&&&&&      %%%     %%%%
	   >>>>               ?????     &&&&           %% %%   %%%%
	     >>>>               ????    &&&&           %% %%  %%%%
	       >>>>           ?????       &&&&&&        %%%  %%%%
	         >>>>    ???????        &&&&                %%%%
	       >>>>                    &&&&    &&&&&&      %%%%  %%%
	     >>>>         ??           &&&&      &&&      %%%%  %% %%
	   >>>>          ????           &&&&    &&&      %%%%   %% %%
	                  ??              &&&&&&&       %%%%     %%%

	                     $$              @@@@@@@@
	                     $$            @@@      @@@
	                 $$$$$$$$$$$$     @@   @@@@   @@
	               $$$$               @@  @@  @@  @@
	                 $$$$$$$$$$       @@  @@  @@  @@
	                         $$$$     @@  @@  @@  @@
	               $$$$$$$$$$$$       @@   @@@@@@@@
	                     $$            @@@
	                     $$              @@@@@@@@@@@
	  FASP, FORTRAN Alphameric Subroutine Package         Page 448
	  DATEXT, FORTRAN Routine for Large Printable Characters


	           User Specification of New Character Fonts
	           ---- ------------- -- --- --------- -----

	  The SUBROUTINE or the BLOCK DATA routine which  defines  the
	  character  shapes constructed by DATEXT is itself written by
	  another program named DAFONT which reads a file  written  by
	  the  user  containing  the characters drawn as they would be
	  constructed by DATEXT.  DAFONT asks the user to specify  the
	  SUBROUTINE  name  which  is to be included in the SUBROUTINE
	  statement and will generate a BLOCK DATA routine instead  if
	  no name is supplied.

	  The rules governing the construction of  the  template  file
	  which DAFONT reads as input are as follow.

	    1. Each  character  shape  is  constructed  only  of   the
	       character  which  it is to represent.  Since DATEXT can
	       select the N'th shape by which a particular  letter  is
	       represented,  both  upper and lower case characters can
	       be constructed if it  is  not  objectionable  that  the
	       lower  case shapes are constructed of, and selected by,
	       the corresponding  upper  case  characters.   The  only
	       precaution  which  must  be  observed if both upper and
	       lower case shapes are to be available  but  constructed
	       of  the  upper  case letters is that both the lower and
	       upper case shapes for a  particular  letter  cannot  be
	       defined on the same row of shapes in the template file.
	       Also, if the second row  of  character  shapes  in  the
	       template  file  defines  the  alternate case shape of a
	       character in the first row, then the first  and  second
	       rows  of character shapes should be separated by one or
	       more blank lines.  Of course, if the  FORTRAN  compiler
	       and  runtime  system both allow lower case letters, and
	       neither translates such to upper case, then  the  lower
	       case  letters can be selected by, and be formed, of the
	       lower case letters being represented.
	    2. The first row of character shapes in the template  file
	       begins  on  the  next nonblank line following the first
	       line, and extends to either the next blank line in  the
	       file,  or  to the next line which contains no character
	       already found in the previous lines.  The first row  of
	       character  shape  specifications  must  be  of  maximum
	       height.  The contents of the first line  of  the  input
	       file  is  written directly into the output as a comment
	       line.  The letter C is placed  at  the  start  of  this
	       output  line  to  cause it to be ignored by the FORTRAN
	       compiler.  It  is  suggested  that  this  comment  line
	       contain  a  short  description of the matrix upon which
	       the letters are designed.
	    3. Subsequent rows of character shapes start at  the  next
	       nonblank  line  and  extend through the number of lines
	       established by the first row  as  being  the  character
	       shape  height, or extend to but do not include the next
	       line which begins the specification of the shape  of  a
	  FASP, FORTRAN Alphameric Subroutine Package         Page 449
	  DATEXT, FORTRAN Routine for Large Printable Characters


	       different  character  or  characters but which does not
	       contain any of the  characters  being  defined  in  the
	       current  row  of  shapes.  A row of character shapes is
	       top justified if the row  (as  opposed  to  the  shapes
	       within  the row) is shorter than the height established
	       by the first row of shapes.
	    4. Character  shapes  can  contain  horizontal  rows   and
	       vertical columns of spaces.  Character shapes specified
	       on the same row can  be  separated  by  spaces  or  can
	       touch, but cannot overlap.
	    5. If the shape of a character has already been  found  on
	       the  current row of character shape specifications, the
	       new (right) definition of the shape is ignored.
	    6. If the FORTRAN system does not allow end-of-file  tests
	       in  READ  statements,  then  the  template file must be
	       terminated by the letters END on a final line not  part
	       of the preceding row of character shape specifications.
	    7. Unless the limits and dimensions in the DAFONT  program
	       are changed, only the first 80 characters on a line are
	       read, a character shape can be no more  than  30  lines
	       high, and at most 96 shapes can be defined.
	    8. The maximum width of any character  is  the  number  of
	       bits,  excluding  the  sign  bit,  in a single computer
	       word.  This means that letter shapes up to 31 bits wide
	       can be represented on an IBM 360 or 370 computer.



	                     A Sample Template File
	                     - ------ -------- ----

	  On the following page is shown a sample template file.   The
	  shapes  of  only  a  few  of the letters are defined in this
	  template file.  As long  as  the  character  shapes  do  not
	  overlap,  the horizontal spacing between shapes is optional.
	  Similarly, extra  blank  lines  can  separate  the  rows  of
	  shapes.   On  the PDP-10 computer, a blank line must contain
	  at least 1 space to be  recognized  by  a  FORTRAN  program.
	  This  means  that  the  blank  line in the definition of the
	  shape of the number sign contains at least one space.

	  It should be noted that in  this  sample  template  file,  a
	  second  specification of the shape of the character S on the
	  same row of shapes as the first has been used to  force  the
	  correct  vertical  position  of the lower case shapes of the
	  letters S and A.  The second specification of the letter  S,
	  in  this  case  a  vertical  line, is ignored for other than
	  determination of the  first  line  of  the  row  of  shapes.
	  However, if the vertical line formed of the letter S was not
	  separated from the first shape of the letter S by the  shape
	  of  some  other  character, then the 2 parts would have been
	  taken together as the specification  of  the  shape  of  the
	  letter.   This  is necessary if characters are to be allowed
	  to be formed from more than 1 group of  characters,  and  is
	  FASP, FORTRAN Alphameric Subroutine Package         Page 450
	  DATEXT, FORTRAN Routine for Large Printable Characters


	  necessary for specification of the shape of the character #.

	  The sample template  file  defines  the  lower  case  letter
	  shapes g l i s and a, the character shapes :  and #, and the
	  upper case letter shapes S  A  I  and  L.   The  first  line
	  contains  a  comment to be written into the output file on a
	  line containing the letter C in column 1.   The  final  line
	  containing  the  word END signals the end of the file and is
	  otherwise ignored.

	  SAMPLE TEMPLATE FILE, THIS LINE CONTAINS A COMMENT
	       LLL      II
	         L      II
	      G  L
	   GGG   L     III
	  G   G  L       I
	  G   G  L       I
	   GGG LLLLL   IIIII
	      G
	  GGGG
	               S
	               S
	   SSS AAAA    S
	  S        A   S
	   SSS  AAAA   S
	      SA   A   S
	  SSSS  AAA A  S
	               S
	               S
	  ::  # #
	  ::  # #
	    ### ###
	   
	    ### ###
	  ::  # #
	  ::  # #
	   SSSSS    A   IIIIIIIL
	  S        A A     I   L
	  S       A   A    I   L
	   SSSSS A     A   I   L
	        SAAAAAAA   I   L
	        SA     A   I   L
	  SSSSSS A     AIIIIIIILLLLLLL
	  END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 451
	  DATEXT, FORTRAN Routine for Large Printable Characters


	       A Sample BLOCK DATA Routine Defining a Short Font
	       - ------ ----- ---- ------- -------- - ----- ----

	  DAFONT produced the following FORTRAN BLOCK DATA routine  as
	  output when it read the template file shown on the preceding
	  page.

	        BLOCK DATA
	  CSAMPLE TEMPLATE FILE, THIS LINE CONTAINS A COMMENT
	        COMMON/FASPG/KNTLTR,IHIGH,IWIDE,JWIDE,LOCK,
	       1LETTER(96),LENGTH(96),IPACKD( 672)
	        DIMENSION JLETTR( 11)
	        DATA JLETTR/
	       11HG,1HL,1HI,1HS,1HA,1H:,1H#,1HS,1HA,1HI,
	       11HL/
	        DIMENSION JLNGTH(11),JLNGT1(11)
	        EQUIVALENCE (JLNGT1(1),JLNGTH(1))
	        DATA JLNGT1/5,5,5,5,6,2,7,7,7,7,7/
	        DIMENSION JPACKD(99),JPACK1(99)
	        EQUIVALENCE (JPACK1(1),JPACKD(1))
	        DATA JPACK1/  0,  0,  1, 14, 17, 17, 14,  1, 30, 28,
	       1              4,  4,  4,  4,  4, 31,  0,  0, 12, 12,
	       2              0, 28,  4,  4, 31,  0,  0,  0,  0, 14,
	       3             16, 14,  1, 30,  0,  0,  0,  0, 60,  2,
	       4             30, 34, 29,  0,  0,  3,  3,  0,  0,  0,
	       5              3,  3,  0,  0, 20, 20,119,  0,119, 20,
	       6             20,  0,  0, 62, 64, 64, 62,  1,  1,126,
	       7              0,  0,  8, 20, 34, 65,127, 65, 65,  0,
	       8              0,127,  8,  8,  8,  8,  8,127,  0,  0,
	       9             64, 64, 64, 64, 64, 64,127,  0,  0/
	        DATA KNTLTR,IHIGH,IWIDE,JWIDE,LOCK/ 11, 9, 7, 7,999/
	        EQUIVALENCE           (LETTER(1),JLETTR(1)),
	       1(LENGTH(1),JLNGTH(1)),(IPACKD(1),JPACKD(1))
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 452
	  DATEXT, FORTRAN Routine for Large Printable Characters


	   Demonstration Program to Display Entire Contents of a Font
	   ------------- ------- -- ------- ------ -------- -- - ----

	  The program listed below was used to generate  most  of  the
	  font  illustrations  presented  earlier  in  this  document.
	  Since all of the shapes for each character  must  be  shown,
	  yet  each  line  of constructed character shapes can contain
	  only a  small  portion  of  the  total  available  character
	  shapes,  the  program  first  inserts a dollar sign and case
	  identification digit in front of each character so that each
	  of  the alternative shapes for any character can be selected
	  independently.  An extra dollar sign is also inserted before
	  each  dollar  sign  for  which the shape is described in the
	  font so that  DATEXT  does  not  incorrectly  interpret  the
	  original  dollar  sign  as  the start of a command character
	  pair.  Once a line of character shapes has been constructed,
	  the   following   dollar  sign-digit  pair  will  have  been
	  processed, so the program backs up to  the  previous  dollar
	  sign-digit  pair  prior  to  constructing  the  next line of
	  character   shapes.    The   program   uses   the    largest
	  intercharacter  spacing  which will not reduce the number of
	  character   shapes   included   on   the   line.    A   zero
	  intercharacter  spacing is allowed only if the characters on
	  the line are extremely large.

	  C     RENBR(LTRALL/DISPLAY ALL CHARACTERS IN A FONT)
	        DIMENSION IBUFFR(60),LTTR(300),KASE(300),IDIGIT(10)
	        COMMON/FASPG/KNTLTR,IHIGH,IWIDE,JWIDE,LOCK,
	       1LETTER(96),LENGTH(96),IPACKD(672)
	  C
	  C     KOLUMN = 0, PACK AS MANY CHARACTERS  AS  POSSIBLE  ON
	  C              EACH  LINE.   THIS  OPTION  IS  BEST IF MOST
	  C              COMMON WIDTH IS CONSIDERABLY  NARROWER  THAN
	  C              WIDEST CHARACTER.
	  C            = 1, ARRANGE CHARACTERS IN COLUMNS AS WIDE  AS
	  C              WIDEST  CHARACTER.   THIS  OPTION IS BEST IF
	  C              MOST COMMON WIDTH IS ONLY SLIGHTLY LESS THAN
	  C              WIDEST CHARACTER.
	        DATA KOLUMN/0/
	        DATA IDIGIT/1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,1H0/
	        DATA IDISK/5/
	        DATA KOMAND,ISPACE/1H$,1H /
	        IF(LOCK.NE.999)GO TO 23
	  C
	  C     KASE ARRAY HOLDS WIDTHS AND MARKS CHARACTER LOCATIONS
	        DO 1 I=1,300
	      1 KASE(I)=0
	  C
	  C     INSERT CASE NUMBER BEFORE EACH LETTER AND $ BEFORE $
	        LTREND=0
	        DO 3 INDEX=1,KNTLTR
	        ISAME=0
	        DO 2 I=1,INDEX
	        IF(LETTER(INDEX).EQ.LETTER(I))ISAME=ISAME+1
	  FASP, FORTRAN Alphameric Subroutine Package         Page 453
	  DATEXT, FORTRAN Routine for Large Printable Characters


	      2 CONTINUE
	        IF(ISAME.GT.10)ISAME=10
	        LTREND=LTREND+3
	        KASE(LTREND-2)=LENGTH(INDEX)
	        LTTR(LTREND-2)=KOMAND
	        LTTR(LTREND-1)=IDIGIT(ISAME)
	        LTTR(LTREND)=LETTER(INDEX)
	        IF(LETTER(INDEX).NE.KOMAND)GO TO 3
	        LTREND=LTREND+1
	        LTTR(LTREND)=KOMAND
	      3 CONTINUE
	        LTRBGN=1
	        MAXMUM=0
	  C
	  C     DETERMINE INTERCHARACTER SPACING AND IF TAILS USED.
	  C     ALLOW 0 SPACING IF NEXT 3 CHARACTERS USE FULL WIDTH
	      4 LINE=IHIGH
	        IDONE=-1
	        JSTIFY=-1
	        IF(KOLUMN.NE.0)GO TO 7
	        MOVE=1
	        J=0
	        K=-1
	        DO 5 I=LTRBGN,LTREND
	        IF(KASE(I).EQ.0)GO TO 5
	        J=J+1
	        K=K+KASE(I)+1
	        IF(K.GT.60)GO TO 8
	        IF(J.GE.3)GO TO 6
	      5 CONTINUE
	      6 INTRVL=1
	        GO TO 9
	      7 MOVE=-2
	        IF(IWIDE.NE.JWIDE)GO TO 8
	        IF(JWIDE.LT.20)GO TO 6
	      8 INTRVL=0
	      9 MAXUSD=0
	        CALL DATEXT(LINE,JSTIFY,0,INTRVL,MOVE,
	       11,LTTR,LTRBGN,LTREND,0,60,60,
	       2IBUFFR,MAXUSD,MAXLIN,LTRNXT)
	        IF(IDONE.EQ.0)GO TO 12
	        IF(IDONE.GT.0)GO TO 15
	        DO 10 I=1,MAXUSD
	        IF(IBUFFR(I).NE.ISPACE)GO TO 11
	     10 CONTINUE
	        LINE=LINE-1
	        IF(LINE.GT.1)GO TO 9
	     11 IDONE=0
	        NEEDED=LTRNXT
	        LSTUSD=MAXUSD
	        GO TO 13
	     12 IF(MAXUSD.LE.LSTUSD)GO TO 14
	        IF(NEEDED.NE.LTRNXT)GO TO 14
	     13 INTRVL=INTRVL+1
	  FASP, FORTRAN Alphameric Subroutine Package         Page 454
	  DATEXT, FORTRAN Routine for Large Printable Characters


	        IF(LTRNXT.LE.LTREND)GO TO 9
	        IF(INTRVL.LE.MAXMUM)GO TO 9
	  C
	  C     GENERATE LETTERS WITHOUT WHITE ADJUSTMENT IF POSSIBLE
	     14 INTRVL=INTRVL-1
	        IF(MAXMUM.LT.INTRVL)MAXMUM=INTRVL
	        IDONE=1
	        LIMIT=LINE
	        LINE=1
	        IF(KOLUMN.NE.0)GO TO 9
	        MOVE=0
	        JSTIFY=0
	        GO TO 9
	     15 IF(LTRNXT.EQ.NEEDED)GO TO 17
	        MOVE=1
	        GO TO 9
	     16 IF(IBUFFR(MAXUSD).NE.ISPACE)GO TO 19
	        MAXUSD=MAXUSD-1
	     17 IF(MAXUSD.GT.0)GO TO 16
	        IF(IDONE.EQ.1)GO TO 21
	        WRITE(IDISK,18)
	     18 FORMAT(1X)
	        GO TO 21
	     19 IDONE=2
	        WRITE(IDISK,20)(IBUFFR(I),I=1,MAXUSD)
	     20 FORMAT(1X,132A1)
	     21 LINE=LINE+1
	        IF(LINE.LE.LIMIT)GO TO 9
	        IF(LTRNXT.GT.LTREND)GO TO 25
	        WRITE(IDISK,18)
	        LTRBGN=LTRNXT
	     22 IF(KASE(LTRBGN).NE.0)GO TO 4
	        LTRBGN=LTRBGN-1
	        GO TO 22
	     23 WRITE(IDISK,24)
	     24 FORMAT(16H FONT NOT LOADED)
	     25 STOP
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 455
	  DATREE Returns Next Line in Representation of Tree Structure


	   DDDDD          AAA  TTTTTTTT  RRRRRR    EEEEEEEE  EEEEEEEE
	   DD   DD       AAAA     TT     RR    RR  EE        EE
	   DD    DD     AA AA     TT     RR    RR  EE        EE
	   DD    DD    AA  AA     TT     RRRRRR    EEEEE     EEEEE
	   DD    DD   AAAAAAA     TT     RR  RR    EE        EE
	   DD   DD   AA    AA     TT     RR   RR   EE        EE
	   DDDDD    AA     AA     TT     RR    RR  EEEEEEEE  EEEEEEEE


	  DATREE Returns Next Line in Representation of Tree Structure
	  ------ ------- ---- ---- -- -------------- -- ---- ---------

	  Simple tree structures, such as the calling sequences of the
	  subroutines within a computer program, can be represented by
	  a typed (or printed) notation in which the root is placed in
	  the left column, those nodes which lie immediately above the
	  root are placed in the second column, those which are  above
	  the  nodes  in  the  second  column  are placed in the third
	  column, and so  on.   As  a  typical  example,  the  calling
	  hierarchy  of  the  demonstration  program  presented in the
	  DALOAD documentation in this manual can  be  represented  by
	  the  following  conventionally drawn representation in which
	  references to routines not in FASP have been excluded

	                                        DAHEFT
	                                           *
	                                           *
	                                        DASPAN
	  DANUMB                                   *
	    *                                      *
	    *                                   DANEXT  DANUMB  DARITE
	  DALONE          DANUMB                     **     *     **
	    *               *                          **   *   **
	    *               *                            ** * **
	  DALIST  DALOAD  DALONE  DAPICK  DAROLL  DASITE  DAVARY
	      ***      **     *     *     *     **      ***
	         ***     **    *    *    *    **     ***
	            ***    **   *   *   *   **    ***
	               ***   **  *  *  *  **   ***
	                  DEMONSTRATION PROGRAM

	  If this tree is rotated clockwise 90  degrees,  the  calling
	  hierarchy of the program can be represented as shown below

	         MAIN      DALIST    DALONE    DANUMB
	         MAIN      DALOAD
	         MAIN      DALONE    DANUMB
	         MAIN      DAPICK
	         MAIN      DAROLL
	         MAIN      DASITE
	         MAIN      DAVARY    DANEXT    DASPAN    DAHEFT
	         MAIN      DAVARY    DANUMB
	         MAIN      DAVARY    DARITE
	  FASP, FORTRAN Alphameric Subroutine Package         Page 456
	  DATREE Returns Next Line in Representation of Tree Structure


	  An array prepared by the calling program and input to DATREE
	  as  an argument describes the tree structure either in terms
	  of which items are connected to and lie above  which  items,
	  or  else  in  terms  of which items are connected to and lie
	  below which items.  Each different item in the tree must  be
	  identified  in  this array by a unique number.  For the tree
	  shown on the previous page, each appearance of DALONE  would
	  be identified by the same number, perhaps 4, but this number
	  would be different from that used for any other item in  the
	  tree.    Whether   the  numbers  employed  represent  packed
	  character codes or are subscripts in some  other  array,  or
	  whatever,  will  depend  upon how these are used by the main
	  program.  It is only necessary that DATREE,  treating  these
	  numbers as single precision integers, be able to compare the
	  item identifiers to find which refer to the same item.

	  For each item which extends the tree, the  array  describing
	  the  tree  contains  the  item  identifier  followed  by the
	  identifiers of all those items which are either connected to
	  it and lie above it in the tree or which are connected to it
	  and lie below it in the tree.  Regardless of which  notation
	  is  employed,  each group of item identifiers is preceded by
	  the number of items included within the group.  For example,
	  if the following numeric assignments are made
	                                                     0=MAIN
	   1=DAHEFT  2=DALIST  3=DALOAD  4=DALONE  5=DANEXT  6=DANUMB
	   7=DAPICK  8=DARITE  9=DAROLL 10=DASITE 11=DASPAN 12=DAVARY

	  then the input array might  contain  the  following  if  the
	  first item in each group is below (to the left of) the rest

	   8, 0(MAIN  ), 2(DALIST), 3(DALOAD), 4(DALONE), 7(DAPICK),
	      9(DAROLL),10(DASITE),12(DAVARY)
	   2, 2(DALIST), 4(DALONE)
	   2, 4(DALONE), 6(DANUMB)
	   4,12(DAVARY), 5(DANEXT), 6(DANUMB), 8(DARITE)
	   2, 5(DANEXT),11(DASPAN)
	   2,11(DASPAN), 1(DAHEFT)

	  or else the input array might contain the following  if  the
	  first item in each group is above (to the right of) the rest

	   2, 1(DAHEFT),11(DASPAN)
	   2, 2(DALIST), 0(MAIN  )
	   2, 3(DALOAD), 0(MAIN  )
	   3, 4(DALONE), 0(MAIN  ), 2(DALIST)
	   2, 5(DANEXT),12(DAVARY)
	   3, 6(DANUMB), 4(DALONE),12(DAVARY)
	   2, 7(DAPICK), 0(MAIN  )
	   2, 8(DARITE),12(DAVARY)
	   2, 9(DAROLL), 0(MAIN  )
	   2,10(DASITE), 0(MAIN  )
	   2,11(DASPAN), 5(DANEXT)
	   2,12(DAVARY), 0(MAIN  )
	  FASP, FORTRAN Alphameric Subroutine Package         Page 457
	  DATREE Returns Next Line in Representation of Tree Structure


	  Each successive call to DATREE  identifies  to  the  calling
	  program  which items are to appear upon the next line of the
	  typed representation of the  tree.   DATREE  also  specifies
	  which  item  within  the line is the leftmost item which did
	  not appear within the previous line of the representation of
	  the tree.  The tree display is more legible if the duplicate
	  appearances of the items at the left side of  the  tree  are
	  removed as in the illustration shown below

	         MAIN      DALIST    DALONE    DANUMB
	         .         DALOAD
	         .         DALONE    DANUMB
	         .         DAPICK
	         .         DAROLL
	         .         DASITE
	         .         DAVARY    DANEXT    DASPAN    DAHEFT
	         .         .         DANUMB
	         .         .         DARITE


	                    The DATREE Argument List
	                    --- ------ -------- ----

	  The argument list of routine DATREE is

	        SUBROUTINE DATREE(KLIMB ,KOMPAR,ITYPE ,MINNOD,MAXNOD,
	       1    NODES ,MINCLM,MAXCLM,NOWCLM,KOLUMN,INITAL,KIND  ,
	       2    NEWCLM)

	  with the associated DIMENSION statement

	        DIMENSION NODES(MAXNOD),KOLUMN(MAXCLM),INITAL(MAXCLM)

	  The following arguments are used for input to  this  routine
	  and are returned unchanged.

	  KLIMB  = 0, the entire tree is  to  be  represented  by  the
	           current series of calls to this routine.
	         = 1, only the portion of the  tree  starting  at  the
	           item  having  an identification number in the NODES
	           array which is equal to the input value  of  KOMPAR
	           is to be represented.

	  KOMPAR = if KLIMB=1, then KOMPAR is equal to the  number  in
	           the  NODES  array  which identifies the item at the
	           bottom (left end) of the portion of the tree  which
	           is  to  be  represented.  Any items which are below
	           (to the left of) this item will not be included  in
	           the representation.

	  ITYPE  = 0, each group in the NODES array  consists  of  the
	           number  of  items which are identified in the group
	           followed by a number which uniquely  identifies  an
	           item  and  then  by numbers which uniquely identify
	  FASP, FORTRAN Alphameric Subroutine Package         Page 458
	  DATREE Returns Next Line in Representation of Tree Structure


	           some or all of the items above (to  the  right  of)
	           and  connected  to the first item.  The NODES array
	           is terminated by a group containing only  a  single
	           zero.   If  item  10  is below (to the left of) and
	           connected to 11 and 12, and item 11  is  below  (to
	           the  left  of)  and connected to 12 and 13, so that
	           the tree might be represented as

	                                                  13
	                                                 *
	           13        12                         *
	             *      *                          *
	              *    *                         11
	               *  *                         *  *
	                11        12     or        *    *
	                  *      *                *      *
	                   *    *               10        12
	                    *  *                  *
	                     10                    *
	                                            *
	                                             12

	           then the NODES array would contain

	                3, 10, 11, 12, 3, 11, 12, 13, 0

	           or even

	                2, 10, 11, 2, 11, 12, 2, 10, 12, 2, 11, 13, 0

	           and  the  KOLUMN  array  would  then  be   returned
	           containing   the  subscripts  of  the  NODES  array
	           locations  which  in  turn  contain  the  following
	           values

	                10, 11, 12 after the 1st call to this routine
	                10, 11, 13 after the 2nd call to this routine
	                10, 12     after the 3rd call to this routine

	           It should be noted  that  if  the  applications  of
	           ITYPE=0  and  1  are  reversed,  then  this routine
	           returns  the  routes  by  which  the  tips  of  the
	           branches  of  the tree are reached, rather than the
	           routes extending from the root.   For  example,  if
	           the  above  NODES  array  contents were interpreted
	           with ITYPE=1 rather  than  0,  then  the  following
	           values would be returned instead

	                12, 10     after the 1st call to this routine
	                12, 11, 10 after the 2nd call to this routine
	                13, 11, 10 after the 3rd call to this routine

	         = 1, each group in the NODES array  consists  of  the
	           number of items identified in the group followed by
	  FASP, FORTRAN Alphameric Subroutine Package         Page 459
	  DATREE Returns Next Line in Representation of Tree Structure


	           a number which uniquely identifies an item and then
	           by  numbers  which uniquely identify some or all of
	           items below (to the left of) and connected  to  the
	           first  item.   The  NODES  array is terminated by a
	           group containing only a single zero.  For the above
	           example  in which 12 is above and connected to both
	           10 and 11, in which 11 is above and connected to 10
	           and  in  which  13  above  and connected to 11, the
	           nodes array would contain

	                3, 12, 10, 11, 2, 11, 10, 2, 13, 11, 0

	  MINNOD = subscript of the location in the NODES array  which
	           contains  the  start of the description of the tree
	           or trees which are to be represented.

	  MAXNOD = dimension of the NODES array.

	  NODES  = array containing the description of which items are
	           linked to which in the tree.

	  MINCLM = subscript of the first  of  the  locations  in  the
	           KOLUMN  array  in  which  are  to  be  returned the
	           subscripts of the NODES array  locations  which  in
	           turn  contain  the  numbers which uniquely identify
	           the items in the next line in the representation of
	           the tree.

	  MAXCLM = subscript of the final location in the KOLUMN array
	           which is available for use.

	  The following argument must be set by  the  calling  program
	  before  this  routine is first called, but thereafter should
	  not be changed by the calling program since this argument is
	  used  to  transfer information from one call of this routine
	  to the next.

	  NOWCLM = must be set to less than the value of  MINCLM  (the
	           actual  value  doesn't  matter  since  it  is reset
	           inside the routine  to  MINCLM-1)  by  the  calling
	           program  before  this  routine  is  first called to
	           represent the tree or trees described by the  NODES
	           array.   If  NOWCLM  is  input set to less than the
	           value  of  MINCLM,  then  the  first  line  in  the
	           description  of  the  first  tree  (or  of the tree
	           starting at a item having an identification  number
	           equal  to  the value of KOMPAR if KLIMB=1) is to be
	           returned  to  the  calling  program.    NOWCLM   is
	           returned  containing  the highest subscript used in
	           the KOLUMN array to represent the current line  and
	           must be sent to the subsequent call of this routine
	           unchanged.  If NOWCLM is input set greater than  or
	           equal   to  MINCLM,  then  the  next  line  in  the
	           description of the tree currently being represented
	  FASP, FORTRAN Alphameric Subroutine Package         Page 460
	  DATREE Returns Next Line in Representation of Tree Structure


	           is  to be returned to the calling program, or else,
	           if KLIMB is equal to zero and if the previous  call
	           to this routine has completed the representation of
	           the current  tree,  then  the  first  line  of  the
	           representation  of  the next tree is to be returned
	           to the calling program.

	  The first of the following  arrays  is  used  for  returning
	  information   to   the  calling  program.   The  information
	  returned in both of these arrays must be supplied  unchanged
	  to the subsequent call of this routine.  The values in these
	  arrays are ignored when this  routine  is  first  called  to
	  represent the trees described in the NODES array.

	  KOLUMN = array returned containing  the  subscripts  of  the
	           locations  in  the NODES array which identify those
	           items on the current line.  The  contents  of  this
	           array  must  not  be  changed between calls to this
	           routine  until  KIND  is  returned   containing   1
	           indicating  that the representation of the tree has
	           been completed.  The contents of the  KOLUMN  array
	           are ignored when this routine is called with NOWCLM
	           less than MINCLM.

	  INITAL = array dimensioned the same as the KOLUMN array, but
	           which  is used only for the transfer of values from
	           one call of this routine to the next.  The contents
	           of  this array must not be changed between calls to
	           this routine until KIND is  returned  containing  1
	           indicating  that the representation of the tree has
	           been completed.

	  The  following  arguments  are  used  only   for   returning
	  information  to the calling program.  Their input values are
	  ignored.

	  KIND   = 1, returned if the representation of the  tree  had
	           been finished by the previous call to this routine.
	         = 2, returned if a  line  in  the  representation  is
	           being   returned   in  KOLUMN(MINCLM)  through  and
	           including KOLUMN(NOWCLM).
	         = 3, same as KIND=2 except that the representation is
	           terminated  after  the  second appearance of a item
	           which has already appeared in the line.
	         = 4, same as KIND=2 except that there was not  enough
	           space  in  the KOLUMN array to represent all of the
	           items which should be within the current line.
	         = 5,  KLIMB  was  input  containing  1   and   NOWCLM
	           containing less than the value of MINCLM indicating
	           that the  representation  of  a  partial  tree  was
	           desired,  but  the  item identified by KOMPAR could
	           not be found in the  NODES  array.   No  items  are
	           being  returned  in  KOLUMN  array,  and  NOWCLM is
	           returned containing MINCLM-1.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 461
	  DATREE Returns Next Line in Representation of Tree Structure


	  NEWCLM = returned containing the  subscript  of  the  lowest
	           location   in  the  KOLUMN  array  which  has  been
	           returned  changed  by  the  current  call  to  this
	           routine.  The input value of NEWCLM is ignored.


	       Demonstration Program to Interactively Test DATREE
	       ------------- ------- -- ------------- ---- ------

	  The program listed below interprets each line of text  typed
	  by  the user as a list of one or more single-letter names of
	  those items which are to be included within a  single  group
	  in  the description of the tree structure.  The typing of an
	  empty line, rather than a list of the names of the items  to
	  be  placed  into the tree, causes the program to display the
	  trees  which  would  result  if  the  tree  description   is
	  interpreted first with ITYPE=0, then with ITYPE=1.  The user
	  can then request the display of sub-trees,  again  for  both
	  values  of  ITYPE,  by specifying, one per line, the letters
	  identifying the nodes to be used as roots of the  sub-trees.
	  Typing of an empty line, instead of the letter identifying a
	  root, signals that the user is going to specify an  entirely
	  new tree structure.

	  C     PROGRAM TO DEMONSTRATE DATREE ROUTINE
	        DIMENSION IBUFFR(72),NODES(500),KODES(100),
	       1INITAL(100),KOLUMN(100)
	        DATA ITTY,JTTY/5,5/
	  C     MAXKNO = DIMENSION OF KODES ARRAY AND MAXIMUM OF
	  C              DIFFERENT LETTERS WHICH CAN BE RECOGNIZED.
	        DATA MAXKNO/100/
	        DATA MINCLM,MAXCLM,MINNOD,MAXNOD/12,100,20,500/
	        DATA IDOT,ISPACE/1H.,1H /
	  C
	  C     ASK USER FOR DESCRIPTION OF TREE
	        NOWCLM=MINCLM-1
	      1 NODUSD=MINNOD-1
	        KNOWN=0
	      2 WRITE(JTTY,3)
	      3 FORMAT(2H *,$)
	        READ(ITTY,4)IBUFFR
	      4 FORMAT(100A1)
	  C
	  C     INSERT SINGLE GROUP INTO NODES ARRAY
	        LOCAL=0
	        DO 8 I=1,72
	        IF(IBUFFR(I).EQ.ISPACE)GO TO 8
	        KOMPAR=0
	      5 KOMPAR=KOMPAR+1
	        IF(KOMPAR.GT.KNOWN)GO TO 6
	        IF(IBUFFR(I).NE.KODES(KOMPAR))GO TO 5
	        GO TO 7
	      6 IF(KNOWN.LT.MAXKNO)KNOWN=KNOWN+1
	        KOMPAR=KNOWN
	  FASP, FORTRAN Alphameric Subroutine Package         Page 462
	  DATREE Returns Next Line in Representation of Tree Structure


	        KODES(KNOWN)=IBUFFR(I)
	      7 IF(LOCAL.EQ.0)NODUSD=NODUSD+1
	        LOCAL=LOCAL+1
	        NODUSD=NODUSD+1
	        NODES(NODUSD)=KOMPAR
	      8 CONTINUE
	        IF(LOCAL.LE.0)GO TO 9
	        I=NODUSD-LOCAL
	        NODES(I)=LOCAL
	        GO TO 2
	  C
	  C     ADD TERMINAL ZERO TO NODES ARRAY
	      9 NODUSD=NODUSD+1
	        NODES(NODUSD)=0
	  C
	  C     CYCLE THROUGH DISPLAY FOR ITYPE=0 AND 1
	        KLIMB=0
	     10 DO 15 JTYPE=1,2
	        NOWCLM=MINCLM-1
	        ITYPE=JTYPE-1
	     11 CALL DATREE(KLIMB,KOMPAR,ITYPE,MINNOD,MAXNOD,
	       1NODES,MINCLM,MAXCLM,NOWCLM,KOLUMN,INITAL,KIND,
	       2NEWCLM)
	        IF(KIND.EQ.1)GO TO 14
	        IF(KIND.EQ.5)GO TO 14
	        K=0
	        DO 12 I=MINCLM,NOWCLM
	        K=K+1
	        IBUFFR(K)=IDOT
	        J=KOLUMN(I)
	        J=NODES(J)
	     12 IF(I.GE.NEWCLM)IBUFFR(K)=KODES(J)
	        WRITE(JTTY,13)KIND,NEWCLM,NOWCLM,(IBUFFR(I),I=1,K)
	     13 FORMAT(1X,I1,2I3,1X,100A1)
	        GO TO 11
	     14 WRITE(JTTY,13)KIND,NEWCLM,NOWCLM
	     15 CONTINUE
	  C
	  C     ASK USER FOR ORIGIN OF PARTIAL DISPLAY
	        WRITE(JTTY,16)
	     16 FORMAT(11H DETAIL OF ,$)
	        READ(ITTY,4)LETTER
	        IF(LETTER.EQ.ISPACE)GO TO 1
	        KLIMB=1
	        KOMPAR=0
	     17 KOMPAR=KOMPAR+1
	        IF(KOMPAR.GT.KNOWN)GO TO 10
	        IF(LETTER.EQ.KODES(KOMPAR))GO TO 10
	        GO TO 17
	        END


	  FASP, FORTRAN Alphameric Subroutine Package         Page 463
	  DATREE Returns Next Line in Representation of Tree Structure


	  Typical Dialog Between DATREE Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  *ABCD
	  *BGI
	  *CIB
	  *DM
	  *MN
	  *IJK
	  *GHI
	  *
	  2 12 15 ABGH        The values of KIND,  NEWCLM  and  NOWCLM
	  2 15 16 ...IJ       are   displayed   to  the  left  of  the
	  2 16 16 ....K       representation of the  contents  of  the
	  2 14 15 ..IJ        tree itself.  KIND is returned twice set
	  2 15 15 ...K        to 1, first when the representation with
	  2 13 15 .CIJ        ITYPE=0  has  been  completed, then when
	  2 15 15 ...K        the representation with ITYPE=1 has been
	  2 14 16 ..BGH       completed.
	  2 16 17 ....IJ
	  2 17 17 .....K
	  2 15 16 ...IJ
	  2 16 16 ....K
	  2 13 15 .DMN
	  1 12 11
	  2 12 15 NMDA
	  2 12 15 JIBA
	  2 15 16 ...CA
	  2 14 15 ..CA
	  2 14 16 ..GBA
	  2 16 17 ....CA
	  2 12 15 KIBA
	  2 15 16 ...CA
	  2 14 15 ..CA
	  2 14 16 ..GBA
	  2 16 17 ....CA
	  2 12 15 HGBA
	  2 15 16 ...CA
	  1 12 11
	  DETAIL OF C
	  2 12 14 CIJ
	  2 14 14 ..K
	  2 13 15 .BGH
	  2 15 16 ...IJ
	  2 16 16 ....K
	  2 14 15 ..IJ
	  2 15 15 ...K
	  1 12 11
	  2 12 13 CA
	  1 12 11
	  DETAIL OF
	  FASP, FORTRAN Alphameric Subroutine Package         Page 464
	  DATREE Returns Next Line in Representation of Tree Structure


	  *JI                 This is the same tree  structure  as  is
	  *KI                 shown   above,  but  with  the  linkages
	  *GB                 reversed so that  now  ITYPE=1  produces
	  *NM                 the same representation as was generated
	  *MD                 above for ITYPE=0.
	  *CA
	  *BAC
	  *DA
	  *IBCG
	  *HG
	  *
	  2 12 15 JIBA
	  2 15 16 ...CA
	  2 14 15 ..CA
	  2 14 16 ..GBA
	  2 16 17 ....CA
	  2 12 15 KIBA
	  2 15 16 ...CA
	  2 14 15 ..CA
	  2 14 16 ..GBA
	  2 16 17 ....CA
	  2 12 15 NMDA
	  2 12 15 HGBA
	  2 15 16 ...CA
	  1 12 11
	  2 12 17 ACBGIJ
	  2 17 17 .....K
	  2 16 16 ....H
	  2 15 16 ...IJ
	  2 16 16 ....K
	  2 14 15 ..IJ
	  2 15 15 ...K
	  2 13 16 .BGIJ
	  2 16 16 ....K
	  2 15 15 ...H
	  2 14 15 ..IJ
	  2 15 15 ...K
	  2 13 15 .DMN
	  1 12 11
	  DETAIL OF C
	  2 12 13 CA
	  1 12 11
	  2 12 16 CBGIJ
	  2 16 16 ....K
	  2 15 15 ...H
	  2 14 15 ..IJ
	  2 15 15 ...K
	  2 13 14 .IJ
	  2 14 14 ..K
	  1 12 11
	  DETAIL OF
	  FASP, FORTRAN Alphameric Subroutine Package         Page 465
	  DATREE Returns Next Line in Representation of Tree Structure


	  *AB                 This cyclic structure has  no  root  for
	  *BC                 ITYPE=0,  but  nodes  O  and  N are both
	  *CDH                roots for ITYPE=1.   N           O
	  *DE                                       <         >
	  *EF                                        <       >
	  *FA                       A > > B           I > > J
	  *HI                      >       >         >       >
	  *IJN                    >         >       >         >
	  *JKO                   F           C > > H           K
	  *KL                     <         <       <         <
	  *LM                      <       <         <       <
	  *MH                       E < < D           M < < L
	  *
	  1 12 11             Effective structure for ITYPE=0 and node
	  3 12 21 NIHCBAFEDC  F  as  root  is  shown below.  Rings are
	  3 15 19 ...MLKJI    terminated when they return to  starting
	  3 12 22 OJIHCBAFEDC nodes F and H.       N           O
	  3 16 19 ....MLKJ                          <         >
	  1 12 11                                    <       >
	  DETAIL OF F               A > > B           I > > J
	  3 12 18 FABCDEF          >       >         >       >
	  3 16 22 ....HIJKLMH   ***         >       >         >
	  2 19 19 .......O      *F*          C > > H           K
	  2 18 18 ......N       ***         <                 <
	  1 12 11                          <                 <
	  3 12 18 FEDCBAF     F < < E < < D     H < < M < < L
	  1 12 11
	  DETAIL OF C         F > > A > > B     Right ring is not
	  3 12 18 CDEFABC                  >    included when ITYPE=1
	  3 13 19 .HIJKLMH      ***         >   and root is in left
	  2 16 16 ....O         *F*          C  ring.
	  2 15 15 ...N          ***         <
	  1 12 11                  <       <
	  3 12 18 CBAFEDC           E < < D
	  1 12 11
	  DETAIL OF H         Both rings are included if  ITYPE=0  and
	  3 12 18 HIJKLMH     node C is root.      N           O
	  2 15 15 ...O                              <         >
	  2 14 14 ..N                                <       >
	  1 12 11                   A > > B > > C     I > > J
	  3 12 19 HCBAFEDC         >                 >       >
	  3 13 18 .MLKJIH         >         ***     >         >
	  1 12 11                F          *C*> > H           K
	  DETAIL OF K             <         ***               <
	  3 12 18 KLMHIJK          <       <                 <
	  2 18 18 ......O           E < < D     H < < M < < L
	  2 17 17 .....N
	  1 12 11                   A > > B     Right ring is not
	  3 12 22 KJIHCBAFEDC      >       >    included if ITYPE=1
	  3 16 18 ....MLK         >         *** and root is in left
	  1 12 11                F          *C* ring.
	  DETAIL OF               <         ***
	                           <
	                            E < < D < < C
	  FASP, FORTRAN Alphameric Subroutine Package         Page 466
	  DATREK, Routine to Evaluate Integer Sequence of Form 1.2.3


	   DDDDD          AAA  TTTTTTTT  RRRRRR    EEEEEEEE  KK   KK
	   DD   DD       AAAA     TT     RR    RR  EE        KK  KK
	   DD    DD     AA AA     TT     RR    RR  EE        KK KK
	   DD    DD    AA  AA     TT     RRRRRR    EEEEE     KKKKK
	   DD    DD   AAAAAAA     TT     RR  RR    EE        KKK KK
	   DD   DD   AA    AA     TT     RR   RR   EE        KK   KK
	   DDDDD    AA     AA     TT     RR    RR  EEEEEEEE  KK    KK



	   DATREK, Routine to Evaluate Integer Sequence of Form 1.2.3
	   ------  ------- -- -------- ------- -------- -- ---- -----

	  DATREK  evaluates   a   sequence   of   unsigned   integers,
	  represented  by groups of digits separated by periods, typed
	  by the user and read by the calling program with a  multiple
	  of  an  A1  format.  Each integer returns a value of zero or
	  larger.  The value -1 is returned for each integer indicated
	  as missing by an initial period, by a trailing period, or by
	  2 adjacent periods.  Signs and exponents are not recognized.



	                    The DATREK Argument List
	                    --- ------ -------- ----

	  The argument list of routine DATREK is

	        SUBROUTINE DATREK(LOWVLU,MAXVLU,MAXBFR,IBUFFR,LOWBFR,
	       1    KIND  ,IVALUE,KNTVLU)

	  with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR),IVALUE(MAXVLU)

	  The following arguments are used  for  input  only  and  are
	  returned unchanged.

	  LOWVLU = subscript of the  lowest  location  in  the  IVALUE
	           array which can be used to return the values of the
	           integers in the sequence.  If the input text buffer
	           is  empty  or if the first printing character at or
	           to the right of IBUFFR(LOWBFR) is neither  a  digit
	           nor a period, then the IVALUE array is not used and
	           KNTVLU which is returned pointing  to  the  highest
	           location  used  in  the  IVALUE  array  is  instead
	           returned containing the value LOWVLU-1.

	  MAXVLU = subscript of the highest  location  in  the  IVALUE
	           array which can be used to return the values of the
	           integers in the sequence.  If the integer  sequence
	           contains   more   values  than  can  be  stored  in
	           IVALUE(LOWVLU)  through  IVALUE(MAXVLU),  then  the
	           evaluation  of  the  sequence continues through the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 467
	  DATREK, Routine to Evaluate Integer Sequence of Form 1.2.3


	           terminal digit or period, but the rightmost  values
	           are  not  stored in the IVALUE array, and KNTVLU is
	           returned containing MAXVLU.

	  MAXBFR = subscript of the final (rightmost) location in  the
	           IBUFFR   array   which  can  be  searched  for  the
	           characters which represent the integer sequence.

	  IBUFFR = input buffer containing  characters  typed  by  the
	           user, read by a multiple of an A1 format, which are
	           to  be  searched  for  the  representation  of  the
	           integer sequence.  IBUFFR then contains 1 character
	           per computer storage location.

	  The following argument must be set by  the  calling  program
	  before  this  routine  is  first called, then is returned by
	  this routine describing the location of the first  character
	  not yet processed in the input buffer.

	  LOWBFR = subscript within the  IBUFFR  array  of  the  first
	           (leftmost)  character  which  can be scanned for an
	           integer sequence.  If an integer sequence is found,
	           then  LOWBFR will be returned pointing to the first
	           character which is beyond the sequence,  and  which
	           could  not  be part of the sequence.  If an integer
	           sequence is not found, then LOWBFR will be returned
	           pointing  to  the  first  printing  character which
	           would be neither a digit nor a period, or  will  be
	           returned  pointing  beyond the end of the buffer if
	           the buffer does not contain any printing characters
	           at  or to the right of IBUFFR(LOWBFR).  LOWBFR must
	           be set by the calling program before  this  routine
	           is  first  called  to  process  the contents of the
	           buffer, and should not be changed  by  the  calling
	           program   if   this   routine  locates  an  integer
	           sequence.  If  an  initial  printing  character  is
	           found  which  is neither a digit nor a period, then
	           the contents of the buffer should be  processed  by
	           some  other  FASP  routine, or at least the calling
	           program should increment the value of LOWBFR  by  1
	           before again calling this routine.

	  The following arguments are used for  returning  information
	  to the calling program.  Their input values are ignored.

	  KIND   = returned describing the kind of item located in the
	           IBUFFR array.
	         = 1,  nothing  was  found  at  or  to  the  right  of
	           IBUFFR(LOWBFR).   The calling program should read a
	           new line into the IBUFFR array and reset LOWBFR  to
	           point to the first character in this array.  KNTVLU
	           is returned containing LOWVLU-1.
	         = 2,  an  integer  sequence  was  not  found,  but  a
	           printing  character  which is neither a digit nor a
	  FASP, FORTRAN Alphameric Subroutine Package         Page 468
	  DATREK, Routine to Evaluate Integer Sequence of Form 1.2.3


	           period  was  found  at   or   to   the   right   of
	           IBUFFR(LOWBFR).   LOWBFR  will be returned pointing
	           to this printing character.   The  calling  program
	           must  increment  the  value  of LOWBFR before again
	           calling  this  routine  since  supplying  the  same
	           initial  character would produce identical results.
	           KNTVLU is returned containing LOWVLU-1.
	         = 3, an integer sequence  was  found  which  did  not
	           contain  more  values,  or  indications  of missing
	           values, than could be returned in the IVALUE array.
	           LOWBFR  is  returned pointing to the next character
	           beyond the end of the sequence.
	         = 4, an integer sequence was  found  which  contained
	           more values, or indications of missing values, than
	           could  be  returned  in  the  IVALUE  array.    The
	           evaluation  of  the  sequence continues through the
	           terminal digit or period, but the rightmost  values
	           are  not  stored in the IVALUE array, and KNTVLU is
	           returned containing  MAXVLU.   LOWBFR  is  returned
	           pointing  to  the  next character beyond the end of
	           the sequence.

	  IVALUE = array in which  the  values  of  the  integers  are
	           returned.   If  an  integer  is  indicated as being
	           missing by an initial period, by a trailing period,
	           or  by  2  adjacent  periods,  then the value -1 is
	           instead stored in the corresponding location in the
	           IVALUE array.

	  KNTVLU = returned containing the subscript  of  the  highest
	           location  in  the IVALUE array used either to store
	           the value of an integer  in  the  sequence,  or  to
	           indicate  a missing integer.  If the first printing
	           character in the input buffer is  neither  a  digit
	           nor  a  period,  then KNTVLU is returned containing
	           LOWVLU-1.  If the integer  sequence  contains  more
	           values than can be stored in IVALUE(LOWVLU) through
	           IVALUE(MAXVLU), then the evaluation of the sequence
	           continues through the terminal digit or period, but
	           the rightmost values are not stored in  the  IVALUE
	           array, and KNTVLU is returned containing MAXVLU.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 469
	  DATREK, Routine to Evaluate Integer Sequence of Form 1.2.3


	                An Example of the Use of DATREK
	                -- ------- -- --- --- -- ------

	  C     PROGRAM TO DEMONSTRATE DATREK ROUTINE
	  C
	        DATA ITTY,JTTY/5,5/
	        DATA LOWVLU,MAXVLU,MAXBFR/1,5,60/
	        DIMENSION IBUFFR(60),IVALUE(5)
	  C
	  C     ASK FOR AND ACCEPT USER RESPONSE
	      1 LOWBFR=1
	        WRITE(ITTY,2)
	      2 FORMAT(2H *$)
	        READ(JTTY,3)IBUFFR
	      3 FORMAT(60A1)
	  C
	  C     EVALUATE NEXT INTEGER SEQUENCE IN USER RESPONSE
	      4 CALL DATREK(LOWVLU,MAXVLU,MAXBFR,IBUFFR,LOWBFR,
	       1    KIND  ,IVALUE,KNTVLU)
	        IF(KIND.EQ.1)GO TO 1
	        IF(KIND.EQ.2)GO TO 7
	  C
	  C     REPORT VALUES IN SEQUENCE
	        IF(KIND.EQ.3)WRITE(ITTY,5)(IVALUE(I),I=1,KNTVLU)
	      5 FORMAT(9H SEQUENCE,10I10)
	        IF(KIND.EQ.4)WRITE(ITTY,6)(IVALUE(I),I=1,KNTVLU)
	      6 FORMAT(9H OVERFLOW,10I10)
	        GO TO 4
	  C
	  C     REPORT UNKNOWN CHARACTER
	      7 WRITE(ITTY,8)IBUFFR(LOWBFR)
	      8 FORMAT(11H UNKNOWN  ',1A1,1H')
	        LOWBFR=LOWBFR+1
	        GO TO 4
	        END

	  Typical Dialog Between User and DATREK Demonstration Program
	  ------- ------ ------- ---- --- ------ ------------- -------

	  *12 12. 12.34 12.0034 12.00340

	  SEQUENCE        12
	  SEQUENCE        12        -1
	  SEQUENCE        12        34
	  SEQUENCE        12        34
	  SEQUENCE        12       340
	  *12..56..90 . .. .34.-0.1.2.3.4.5.6.7.8.9

	  SEQUENCE        12        -1        56        -1        90
	  SEQUENCE        -1        -1
	  SEQUENCE        -1        -1        -1
	  SEQUENCE        -1        34        -1
	  UNKNOWN  '-'
	  OVERFLOW         0         1         2         3         4
	  FASP, FORTRAN Alphameric Subroutine Package         Page 470
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	   DDDDD          AAA  VV    VV      AAA  RRRRRR    YY    YY
	   DD   DD       AAAA  VV   VV      AAAA  RR    RR   YY  YY
	   DD    DD     AA AA  VV  VV      AA AA  RR    RR    YYYY
	   DD    DD    AA  AA  VV VV      AA  AA  RRRRRR       YY
	   DD    DD   AAAAAAA  VVVV      AAAAAAA  RR  RR       YY
	   DD   DD   AA    AA  VVV      AA    AA  RR   RR      YY
	   DDDDD    AA     AA  VV      AA     AA  RR    RR     YY



	  DAVARY, Routine to Display and Assign Values to Named Arrays
	  ------  ------- -- ------- --- ------ ------ -- ----- ------

	  DAVARY is used along with several other routines in the FASP
	  package for the purpose of specifying by name, examining and
	  modifying  the  values  of   multiply   subscripted   arrays
	  equivalenced   with   or  otherwise  loaded  into  a  singly
	  subscripted buffer.  The interaction between these  routines
	  is  described at the start of the DALOAD documentation.  The
	  sample program  at  the  end  of  the  DALOAD  documentation
	  illustrates the use of most of these routines.

	  Prior to passing control to DAVARY, the calling program will
	  have  requested  from  the user a specification of the array
	  locations which the user wants to examine and/or to  modify.
	  The  text  typed  by the user in response to this request is
	  evaluated by the DAPICK routine to identify the  array  name
	  and   its  subscript  ranges,  if  any.   DAVARY  is  called
	  separately to display  each  of  the  values  in  the  array
	  locations  within  the range of array locations indicated by
	  the user.  If DAPICK found that the  user  typed  an  equals
	  sign  to the right of the original array specification, then
	  the  calling  program  should  request  that  DAVARY  is  to
	  evaluate  the  numbers  and/or  number  range specifications
	  typed to the right of the equals sign and  assign  these  as
	  the  new  values  of the array locations within the range of
	  array locations indicated by the user.  If  too  few  values
	  were typed right of the equals sign to define new values for
	  all of the array locations within the total range  of  array
	  locations  indicated  by  the user, then, when the supply of
	  typed values has been exhausted, DAVARY will ask the user to
	  specify  the  value of each of the remaining array locations
	  as the calling program steps  through  the  range  of  array
	  locations.  When the user is asked to specify the new value,
	  the user has the option of specifying no value in which case
	  the  former value will be retained, of specifying a range of
	  values in which case DAVARY will upon each  successive  call
	  select  values  from the range until the range is completed,
	  of specifying that some number of array locations are to  be
	  skipped  over  retaining their former values in the process,
	  or of abandoning the interaction altogether for the  current
	  range of array locations.

	  The text typed by the user,  either  to  the  right  of  the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 471
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	  equals  sign  in  the  buffer evaluated by DAPICK, or in the
	  text read  directly  by  the  DAVARY  routine,  consists  of
	  numbers and/or number range specifications.  If the user has
	  typed several numbers and/or  range  specifications  on  the
	  same  line,  then DAVARY will evaluate each of these in turn
	  when the previous calls to DAVARY  have  used  the  previous
	  value  or  have  used  all of the values within the previous
	  range.  Any number of spaces and/or tab characters,  but  at
	  most  a  single  comma,  can  separate  two adjacent numbers
	  and/or number range specifications.   Two  adjacent  commas,
	  possibly  separated by spaces and/or tabs, indicate that the
	  array   location   being   assigned   a   value   when   the
	  interpretation of the buffer has proceeded to the evaluation
	  of the missing number  between  the  commas  is  to  instead
	  retain  its  former value.  If a comma is the first printing
	  character to the right  of  the  equals  sign  in  the  text
	  evaluated  by  DAPICK,  then the first array location in the
	  range of array locations indicated by the user, is to retain
	  its  former  value.   Similarly,  if  a  comma  is the first
	  printing character in the buffer read by DAVARY itself, then
	  the  array location currently being defined is to retain its
	  former value.  A  comma  which  is  the  rightmost  printing
	  character  in  the  buffer  (except  possibly for semicolons
	  and/or an exclamation point and its following comment or  an
	  ampersand  and  its  following  comment)  indicates that the
	  array   location   being   assigned   a   value   when   the
	  interpretation of the buffer has proceeded to the evaluation
	  of the text to the right of the comma is instead  to  retain
	  its  former  value.   A  single comma with no other printing
	  characters  to  its  left   (except   possibly   the   array
	  specification  and the equals sign found by DAPICK) and with
	  no printing characters to its  right  (except  possibly  for
	  semicolons  and/or  an  exclamation  point and its following
	  comment  or  an  ampersand  and  its   following   comment),
	  indicates  two  array  locations  which  are to retain their
	  former values.

	  Numbers, whether used to specify single  values  or  ranges,
	  can  be  typed  by the user in either floating point form or
	  scientific notation.  If scientific notation is used for the
	  specification  of  octal  numbers,  then the exponent to the
	  right of the letter E (which must be typed in upper case) is
	  evaluated  as  the  decimal  number  of  octal  digits to be
	  shifted.   If  an  integer  (either  octal  or  decimal)  is
	  specified with a decimal point and/or with an exponent, then
	  the value is first obtained as though  neither  the  decimal
	  point  nor exponent appeared, and this value is shifted only
	  once by the amount indicated by the combination  of  decimal
	  point  location  and  exponent.   If  the number 1.2345E3 is
	  typed by the user and is evaluated  as  a  decimal  integer,
	  then  the  value  is  calculated  to  be  12345 before being
	  divided by 10 to obtain the returned value of integer 1234.

	  A range of values can be specified  as  the  limits  between
	  FASP, FORTRAN Alphameric Subroutine Package         Page 472
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	  which  and  increment by which the value is to be varied, or
	  can be specified as the repetition of a  single  value.   If
	  the  value is to be varied between limits, then the range is
	  written as the starting value, the increment, and the ending
	  value  separated  by  slashes or by colons (the 2 characters
	  are equivalent).  If the increment is to be  one,  then  the
	  starting  and  ending  values  need  be  separated only by a
	  single slash or by a  single  colon.   If  either  limit  is
	  missing,  it  is  assumed  to  have  the  value  zero.   The
	  effective sign of the increment is changed if  it  does  not
	  agree with the relative values of the limits.

	  If the user wants to specify that a single value  is  to  be
	  assigned  to  several  array  locations  within the range of
	  array locations being defined, then the range of  values  is
	  written  as  the  number  of  times  the value is to be used
	  followed immediately by an asterisk and  the  value.   If  a
	  value  does  not  follow  the  asterisk,  then  the  user is
	  requesting that the stated number of  consecutive  locations
	  starting  with  the  location  currently  being  defined are
	  instead to have their former values kept intact.

	  If an exclamation point or an ampersand is found anywhere in
	  the  text  typed  by the user, then the exclamation point or
	  the ampersand and all characters to its right are  taken  to
	  be a comment and are otherwise ignored.  If in response to a
	  request for a new value, the user types either a  completely
	  blank  line  or  a  line  in  which  the  leftmost  printing
	  character is an exclamation point, then the former value  of
	  the  array  location  will be retained, and the next call to
	  DAVARY will request the value of the  next  array  location.
	  If  in  response  to  a  request  for  a new value, the user
	  instead  types  a  line  in  which  the  leftmost   printing
	  character is an ampersand, then the remainder of the line is
	  similarly taken as a comment, but the user is again asked to
	  specify  the  value.   Use  of the ampersand as the leftmost
	  printing  character  allows  multiple  line   comments   for
	  annotation  of  batch  command files.  The exclamation point
	  and the ampersand are equivalent if any  printing  character
	  is typed to their left.

	  If the user types a semicolon, then DAVARY  signals  to  the
	  calling  program  that  the  user  has  requested  that  the
	  stepping through the array locations  within  the  range  of
	  array locations is to be terminated.

	  The text

	       5.3E3,-0.00728,4*,1E6/1E5/2E6,,12*.7;

	  would, if typed by  the  user  and  interpreted  by  DAVARY,
	  specify

	    A. that the first array location is  to  be  assigned  the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 473
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	       value 5.3E3

	    B. that the second array location is to  be  assigned  the
	       value -7.28E-3

	    C. that the next 4  array  locations  are  to  keep  their
	       former values

	    D. that the next eleven array locations are to be assigned
	       the values 1.0E6, 1.1E6, 1.2E6 through 2.0E6

	    E. that the next array location is retain its former value

	    F. that the next 12 array locations are to all be assigned
	       the value 0.7

	    G. and that the stepping through  array  locations  within
	       the  current  range  of  array  locations is then to be
	       terminated.

	  Spaces and/or tab characters could appear in addition to the
	  commas in the example.  The only commas in the example which
	  could not be replaced by spaces and/or  tab  characters  are
	  the  2 adjacent commas which indicate that the corresponding
	  array location is to retain its former value.


	                    The DAVARY Argument List
	                    --- ------ -------- ----

	  The argument list of routine DAVARY is

	        SUBROUTINE DAVARY(KONTRL,ITTY  ,JTTY  ,LOCATN,NAMUSD,
	       1    NAMMAX,MAXBFR,NOTATN,MINDEC,MAXDEC,MINSIG,MAXSIG,
	       2    IDECML,AARRAY,IARRAY,NAME  ,IBUFFR,LOWBFR,KIND  ,
	       3    MODIFY)

	  with the associated DIMENSION statement

	        DIMENSION NAME(NAMMAX),AARRAY(LOCATN),IARRAY(LOCATN),
	       1IBUFFR(MAXBFR)

	  The following are input arguments left unchanged.

	  KONTRL = indicates the type (octal, integer or real) of  the
	           value to be displayed and possibly modified.
	         = -1,  this  routine  is  to  display  in  octal  and
	           possibly    modify    the    integer    value    in
	           IARRAY(LOCATN).
	         = 0, this  routine  is  to  display  in  decimal  and
	           possibly    modify    the    integer    value    in
	           IARRAY(LOCATN).
	         = greater than zero, this routine is  to  display  in
	           decimal,   using  either  floating  point  form  or
	  FASP, FORTRAN Alphameric Subroutine Package         Page 474
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	           scientific  notation  as  specified  by  the  other
	           arguments  or as necessary, and possibly modify the
	           real value in AARRAY(LOCATN).

	           During interpretation of the values  typed  by  the
	           user,  KONTRL  is  identical to the argument of the
	           same name for the DAHEFT routine, and is defined as
	           follows.
	         = -1, the item typed by the user is an octal  number.
	           The number can be typed with a decimal point and/or
	           with an exponent.  However,  the  number  following
	           the  letter  E  of  the  exponent  is  evaluated in
	           decimal.  It must be noted that  numbers  evaluated
	           as  negative octal integers have the negative octal
	           integer  as  their  value,   not   as   their   bit
	           representation  in  computer storage.  For example,
	           on a 36 bit twos  complement  computer,  the  octal
	           number  -400000000000 (which could also be typed as
	           -4E11 or -4E+11 where the 11  after  the  E  is  in
	           decimal) is represented as bit pattern having octal
	           notation  400000000000   and   the   octal   number
	           -377777777777  is  represented  by  the bit pattern
	           400000000001.
	         = 0, the item typed by the user is an integer decimal
	           number.   The  number  can  be typed with a decimal
	           point (for example 1.23K or  1.23E3  equals  1230),
	           but  is  stored as an integer.  Any decimal integer
	           which the computer can represent can be  evaluated.
	           This  includes,  on  twos complement computers, the
	           largest negative number the absolute value of which
	           cannot be stored.  On the PDP-10, a 36 bit computer
	           with twos complement notation, the range of decimal
	           integers is -34359738368 through 34359738367 (octal
	           notation of bit patterns being 400000000000 through
	           377777777777).
	         = 1 or greater, the item typed by the user is a  real
	           number.   If  possible,  the  real  number  will be
	           accumulated as an integer, then be converted  to  a
	           real  number  and  shifted if necessary.  KONTRL is
	           then the maximum number of digits in  the  integer.
	           If  the  item  has  more  than  KONTRL  digits (not
	           counting  leftmost   zeroes),   then   the   entire
	           evaluation is done as a real number.  The advantage
	           of calculating the real values in integer  as  long
	           as  the precision of the computer is not overflowed
	           is that the  calculation  of  the  portion  of  the
	           number  right  of  the decimal point is more exact.
	           As an example, if KONTRL is greater than  or  equal
	           to  4,  then  the number 33.33 can be stored as the
	           integer 3333, then be converted to the  real  value
	           3333.0  and  divided  by  100.0 to obtain the final
	           answer.  If it  makes  no  difference  whether  the
	           number   typed   as   33.33   has  value  33.33  or
	           33.32999...  then KONTRL can be given the value 1.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 475
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	  ITTY   = number of the unit from which this  routine  is  to
	           read  the  user's  specification of new values.  On
	           the PDP-10 computer, ITTY should have the value 5.

	  JTTY   = number of the unit to  which  this  routine  is  to
	           write  the representation of the value currently in
	           AARRAY(LOCATN)  or  IARRAY(LOCATN),  and  to  which
	           error  messages  are  to  be  sent.   On the PDP-10
	           computer, JTTY should have the value 5.

	  LOCATN = subscript of the array location (within either  the
	           AARRAY  or  IARRAY arrays, whichever is selected by
	           the value of KONTRL) of which the value  is  to  be
	           shown to the user and possibly modified.

	  NAMUSD = subscript of the NAME array location containing the
	           rightmost  character  of  the representation of the
	           name and  associated  subscripts  of  the  multiply
	           subscripted  array  being  simulated  in the singly
	           subscripted   buffer   AARRAY   or   IARRAY.    The
	           representation  of  the name starts at NAME(1).  If
	           the  current  call  to  DAVARY  is  displaying  and
	           possibly  modifying  the  contents  of  the  doubly
	           subscripted simulated array named ABC, and  if  the
	           subscripts  of  the simulated array ABC which would
	           correspond to the subscript LOCATN  in  the  singly
	           subscripted  buffer  would  be  3  and  7, then the
	           contents  of  the  NAME(1)  through  and  including
	           NAME(NAMUSD)  where  NAMUSD is 8 would be identical
	           to that assigned by the statement

	                 DATA (NAME(I),I=1,8)/1HA,1HB,1HC,
	                11H(,1H3,1H,,1H7,1H)/

	           When DAVARY is used with the other routines in  the
	           FASP  package, the contents of the NAME array would
	           be defined by calling the DALONE routine  prior  to
	           each  call  to  DAVARY.   The dimension of the NAME
	           array, or at least the maximum usable  area  within
	           this  array,  is given by the argument NAMMAX.  The
	           NAME  array   locations   starting   at   subscript
	           NAMUSD+1,  and  extending through subscript NAMMAX,
	           are used for  storing  the  representation  of  the
	           value in the currently selected location within the
	           AARRAY  or  IARRAY  array,  and  for  storing   the
	           representation  of  the new value if this new value
	           is based upon the user's response read prior to the
	           current  call to DAVARY.  NAMMAX should be at least
	           30 to 40 greater than NAMUSD.

	  NAMMAX = subscript of the highest location within  the  NAME
	           array  which  can be used as a scratch area for the
	           construction of the character representation of the
	           value in the currently selected location within the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 476
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	           AARRAY or IARRAY array, and for the construction of
	           the  representation  of  the  new value if this new
	           value is based upon the user's response read  prior
	           to the current call to DAVARY.  NAMMAX should be at
	           least 30 to 40 greater than NAMUSD.

	  MAXBFR = subscript of the highest location within the IBUFFR
	           array  into which the calling program or a previous
	           call to this routine has read characters  typed  by
	           the user.  If this routine must read a new response
	           from the user, then the characters of the  response
	           are  read  into  IBUFFR(1)  through IBUFFR(MAXBFR).
	           Since  the  format  used  by  DAVARY  to  read  the
	           response is 100A1, MAXBFR should not exceed 100.

	  The following arguments are sent to the  DARITE  routine  to
	  control the display of the former value in AARRAY(LOCATN) or
	  IARRAY(LOCATN) and of the new value if  this  new  value  is
	  based  upon  the  user's  response read prior to the current
	  call to DAVARY.  All of these arguments  correspond  to  the
	  DARITE  arguments  of  the  same  name, and all are returned
	  unchanged.  These arguments are ignored if  KONTRL  is  less
	  than  or  equal  to zero.  It should be noted that where the
	  following descriptions speak of the display of a  particular
	  number of characters, this is the number of characters which
	  could be displayed if all are nonzero.  After  rounding  and
	  prior  to  actual  display, rightmost zeroes to the right of
	  the decimal point are discarded  as  is  the  decimal  point
	  itself if no nonzero digits appear to its right.

	  NOTATN = -1, represent the  value  in  scientific  notation.
	           The value 1234 would be represented as 1.234E3
	         = 0, represent the value in floating point form.  The
	           value  1234.56  would be displayed as it is written
	           if the number of  digits  requested  right  of  the
	           decimal  point  is  2 and if at least 6 significant
	           digits are allowed.
	         = 1, multiply the value by 100 and insert the percent
	           sign  following  the  digits of the number.  MINDEC
	           and MAXDEC refer to the  displayed  decimal  point.
	           To print tenths of a percent, MAXDEC would be given
	           the value 1, and MINDEC would be 1 or less.
	         = 2, if the value is in the range  1000  to  1000000,
	           then divide the value by 1000 and insert the letter
	           K following the digits.  If the value is 1000000 or
	           greater,  then  divide  the  value  by  1000000 and
	           insert the letter M following the  digits.   MINDEC
	           and  MAXDEC  refer  to the displayed decimal point.
	           MINDEC and MAXDEC both set at 2 would represent the
	           value 1234 as 1.23K.
	         = 3, same as NOTATN=2 except that MINDEC  and  MAXDEC
	           refer  to  the decimal point in the original value,
	           not to the decimal point in the  displayed  number.
	           If  a K or M is displayed right of the number, then
	  FASP, FORTRAN Alphameric Subroutine Package         Page 477
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	           MINDEC and MAXDEC values of -1  are  equivalent  to
	           values  of 0.  MINDEC=-2 indicates that there is no
	           lower limit to the number of digits to the right of
	           the  displayed  decimal  point, and is probably the
	           appropriate value unless it is absolutely necessary
	           to  display  the digits which would be to the right
	           of the decimal point in the original value, as  for
	           example  if  the  amounts  are  dollars and must be
	           displayed always including the cents  digits.   The
	           value  1234.56 would be represented as 1.23456K for
	           NOTATN=3 and MAXDEC=2.

	  MINDEC = minimum number of digits  right  of  the  displayed
	           decimal  point  in  numbers  which are displayed in
	           floating point form.  If it would be  necessary  to
	           represent  less  digits  right of the decimal point
	           than indicated by MINDEC, then the  value  will  be
	           represented  in  scientific  notation instead.  The
	           maximum number of digits right of the decimal point
	           is  determined  by  the  combination  of MAXDEC and
	           MAXSIG.
	         = -2, there is no lower limit to the number of digits
	           which  must  be  represented  right  of the decimal
	           point, and even the decimal point itself  need  not
	           be   represented.    MINDEC=-1   is  equivalent  to
	           MINDEC=-2 unless NOTATN=3 while the value  is  1000
	           or greater.
	         = -1, if NOTATN is not 3, or if NOTATN is 3  but  the
	           value  being  represented  is  less than 1000, then
	           MINDEC=-1 is  equivalent  to  MINDEC=-2  such  that
	           there  is  no  lower  limit to the number of digits
	           which must be  represented  right  of  the  decimal
	           point,  and  even the decimal point itself need not
	           be represented.

	           If NOTATN=3 and the value is 1000 or greater,  then
	           MINDEC=-1  would  have  the same effect as MINDEC=0
	           such that all digits to the  left  of  the  decimal
	           point   in   the   original   unshifted  value  (as
	           represented without K or M) must be included in the
	           actual  representation of the value even when the K
	           or M is included.  MINDEC should have the value  -2
	           if,  in  order  to  fit the representation into the
	           available field width while NOTATN=3, it is  to  be
	           possible  that a value which is equal to or greater
	           than 1000 be represented without all of the  digits
	           which  would be to the left of the decimal point in
	           the original value, or  even  without  the  decimal
	           point.
	         = equal or greater than zero, if NOTATN is not 3,  or
	           if  NOTATN  is 3 but the value being represented is
	           less than 1000, then MINDEC is the  minimum  number
	           of  digits  which  can  be  displayed  right of the
	           decimal point in a floating point number.  If  less
	  FASP, FORTRAN Alphameric Subroutine Package         Page 478
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	           than  MINDEC digits would be displayed right of the
	           decimal point, then the value will  be  represented
	           in  scientific notation instead.  If MINDEC=0, then
	           it is not necessary that any  digits  be  displayed
	           right  of  the decimal point, but the decimal point
	           itself must be displayed.

	           If NOTATN=3 and the value is 1000 or greater,  then
	           MINDEC is the minimum number of digits to the right
	           of the decimal point in the  original  value  which
	           must  be  displayed.   If the value is between 1000
	           and 1000000, then at least MINDEC+3 digits must  be
	           displayed right of the decimal point.  If the value
	           is 1000000  or  greater,  then  at  least  MINDEC+6
	           digits  must  be  displayed  right  of  the decimal
	           point.

	           For example, the value 1234.56 would be represented
	           as follows for various values of MINDEC and NOTATN.
	           It should be noted that when the digit 5  right  of
	           the  decimal  point  in  the  original value is not
	           represented, then the digit 4 left of  the  decimal
	           point is rounded upwards to 5.

	                                  NOTATN=0  NOTATN=2  NOTATN=3
	             for MINDEC=MAXDEC=0      1235        1K    1.235K
	                 MINDEC=MAXDEC=1    1234.6      1.2K   1.2346K
	                 MINDEC=MAXDEC=2   1234.56     1.23K  1.23456K

	  MAXDEC = maximum number of digits  right  of  the  displayed
	           decimal  point  in  numbers  displayed  in floating
	           point form.
	         = -2, represent as many digits right of  the  decimal
	           point as the field will hold (up to a maximum total
	           number of digits specified by MAXSIG).
	         = -1, if NOTATN is not 3, or if NOTATN is 3  but  the
	           value   being   represented   is  less  than  1000,
	           represent only digits left of  the  decimal  point.
	           The  decimal  point itself will not be represented.
	           If more than MAXSIG digits would appear left of the
	           decimal  point, then the number will be represented
	           in scientific notation.

	           If NOTATN=3 and the value is 1000 or greater,  then
	           MAXDEC=-1  would  have  the same effect as MAXDEC=0
	           such that all digits which would be to the left  of
	           the   decimal  point  in  the  original  value  (as
	           represented without K or M)  will  if  possible  be
	           included in the representation of the value shifted
	           for the K or M notation.  If MINDEC is greater than
	           -2, and if not all of the digits to the left of the
	           decimal point in the original unshifted  value  can
	           be  included  in the supplied field width, then the
	           value will instead  be  represented  in  scientific
	  FASP, FORTRAN Alphameric Subroutine Package         Page 479
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	           notation.
	         = greater than or equal to zero, if NOTATN is not  3,
	           or  if  NOTATN is 3 but the value being represented
	           is less than 1000, represent the value with  MAXDEC
	           digits   right   of   decimal   point.    If   this
	           representation of the value will not fit  into  the
	           field  size  indicated  by  MAXSIG, then reduce the
	           number of digits represented right of  the  decimal
	           point  so  that  the  representation  will  fit, or
	           represent the value in scientific notation if there
	           are  more  than  MAXSIG  digits left of the decimal
	           point.

	           If NOTATN=3 and the value is 1000 or greater,  then
	           MAXDEC  is the number of digits to the right of the
	           decimal point in the original unshifted value which
	           can  be displayed if there is room for these in the
	           supplied field width.  If the value is between 1000
	           and  1000000,  then  at most MAXDEC+3 digits can be
	           displayed right of the displayed decimal point.  If
	           the  value  is  1000000  or  greater,  then at most
	           MAXDEC+6 digits  can  be  displayed  right  of  the
	           decimal point.

	  MINSIG = minimum  number  of  significant  digits   in   the
	           floating point representation of the value.  If the
	           floating point representation of  the  value  would
	           contain  less  than MINSIG significant digits, then
	           the  value  will  be  represented   in   scientific
	           notation.   If  the  value  being displayed has the
	           value zero, then MINSIG is ignored.

	  MAXSIG = maximum  number  of  significant  digits   in   the
	           floating point representation of the value.  MAXSIG
	           is the  maximum  number  of  digits  which  can  be
	           displayed starting with the leftmost nonzero digit,
	           counting it and all digits to  its  right.   MAXSIG
	           does  not  include  the  decimal  point,  does  not
	           include the minus sign if the  value  is  negative,
	           and  does  not  include the percent sign, K or M if
	           NOTATN is greater than zero.  The number of  digits
	           displayed  right of the decimal point is reduced if
	           necessary so that the number of digits starting  at
	           the  leftmost  nonzero displayed digit and counting
	           it and all digits displayed to its right  does  not
	           exceed  MAXSIG.   If  MAXSIG would be less than the
	           number of digits left of the decimal point  in  the
	           representation of the value, then the value will be
	           represented in scientific notation.

	  IDECML = same as MAXDEC except that IDECML applies  only  to
	           values displayed in scientific notation.  Note that
	           if the value is  being  represented  in  scientific
	           notation, then a nonzero digit will be used left of
	  FASP, FORTRAN Alphameric Subroutine Package         Page 480
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	           the decimal point unless the value is itself  zero.
	           Therefore,  if  IDECML  is greater than or equal to
	           zero, then the maximum number of significant digits
	           which  can  be  displayed in scientific notation is
	           IDECML+1.

	  The following arguments are  used  for  both  input  to  and
	  output from this routine.

	  AARRAY = singly subscripted array of real numbers with which
	           the   simulated   multiply   subscripted  array  is
	           equivalenced and which contains the  values  to  be
	           displayed  and  possibly  modified.   This array is
	           used only if KONTRL is input greater than zero.  It
	           is  assumed  that  the  calling  program  will have
	           equivalenced AARRAY and IARRAY  so  that  no  extra
	           space is required to allow the manipulation of both
	           real and integer values.

	  IARRAY = singly subscripted array of  integer  numbers  with
	           which  the  simulated multiply subscripted array is
	           equivalenced and which contains the  values  to  be
	           displayed  and  possibly  modified.   This array is
	           used only if KONTRL is input less than or equal  to
	           zero.

	  NAME   = array which  is  input  containing  the  characters
	           which  form  the name and the representation of the
	           current subscripts of the  simulated  array.   This
	           name  representation  and  subscript representation
	           are contained in NAME(1) through NAME(NAMUSD),  one
	           character  per array location as read by a multiple
	           of an A1 format or defined by  several  1H  fields.
	           The  dimension  of  the  NAME  array, stated as the
	           argument NAMMAX, should be 30 to  40  greater  than
	           NAMUSD  since  the  area above NAME(MAXUSD) is used
	           for  construction  of  the  representation  of  the
	           former value and, if necessary, of the new value.

	  IBUFFR = array originally input  containing  the  characters
	           typed  by  the  user as read by a multiple of an A1
	           format, and which are to the right of the name  and
	           subscript  specification  evaluated  by DAPICK.  If
	           the user typed an equal sign to the  right  of  the
	           name and subscripts, then the values represented at
	           or to the right of IBUFFR(LOWBFR) are evaluated, or
	           if  more  values are needed than are represented in
	           the  remainder  of  the  IBUFFR  array,  then   the
	           representations  of additional values are requested
	           from the  user  and  read  into  IBUFFR(1)  through
	           IBUFFR(MAXBFR).

	  LOWBFR = input containing the location in the  IBUFFR  array
	           of  the  first  character to be interpreted by this
	  FASP, FORTRAN Alphameric Subroutine Package         Page 481
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	           routine to determine the next user specified value.
	           LOWBFR  is  ignored if KIND is not originally input
	           containing the value  2.   If  KIND  is  originally
	           input  containing  the  value  2,  then  LOWBFR  is
	           returned pointing to the leftmost character in  the
	           buffer which has not yet been interpreted.

	  KIND   = when this routine is called to  process  the  first
	           location   within  the  range  of  array  locations
	           specified  by  the  user,  KIND  should  be   input
	           containing  the  value  of the argument of the same
	           name as defined by the DAPICK routine.
	         = initially input containing 1, an  equals  sign  was
	           not  found  by  the  DAPICK  routine.  DAVARY is to
	           report the value  currently  in  AARRAY(LOCATN)  or
	           IARRAY(LOCATN),  but  is not to modify the contents
	           of this array  location.   Since  DAVARY  does  not
	           evaluate  the  contents  of  the  buffer,  KIND  is
	           returned unchanged.
	         = initially input containing 2, an  equals  sign  was
	           found  by  the DAPICK routine.  DAVARY is to report
	           the   value   currently   in   AARRAY(LOCATN)    or
	           IARRAY(LOCATN),  then  is to obtain the next number
	           represented by the characters in the  IBUFFR  array
	           and  is to assign this value to the array location.
	           If the value  cannot  be  obtained  as  part  of  a
	           previously  specified  range,  and if the character
	           buffer is empty (except for  possibly  a  comment),
	           then  DAVARY is to ask the user for a specification
	           of the new value of the array location.

	           Each call to DAVARY will use KIND to specify to the
	           subsequent call to DAVARY whether the generation of
	           values  within  a  range  of   values   should   be
	           continued,  or  whether the next number represented
	           within the buffer should be evaluated.   KIND  will
	           be  returned  greater than zero unless the user has
	           typed a semicolon which is found instead of a value
	           by  the current call to this routine, in which case
	           KIND is returned containing zero to signal  to  the
	           calling  program  that  the user has requested that
	           the stepping through the current range of locations
	           be  terminated.   Except for the case in which KIND
	           is returned zeroed, the calling  program  must  not
	           modify  the  returned  value  of  KIND  during  the
	           processing of the locations which  are  within  the
	           range of locations indicated by the user.

	  MODIFY = when this routine is called to process new contents
	           of  the  singly  subscripted  buffer, MODIFY should
	           first have been set to zero by the calling program.
	           MODIFY  is  incremented  by  one  each time a value
	           within any  simulated  array  is  changed  by  this
	           routine.   MODIFY  might then be checked at the end
	  FASP, FORTRAN Alphameric Subroutine Package         Page 482
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	           of processing of the  contents  of  the  buffer  to
	           determine  whether  the  calling  program  needs to
	           write out the new values in the buffer.



	                  Use of DAVARY With Overlays
	                  --- -- ------ ---- --------

	  The six values in the labeled COMMON block named  FASPH  are
	  required by the subsequent call to DAVARY for the generation
	  of the next value within a range of values, if any.   If  an
	  equals  sign was found by the DAPICK routine, then these six
	  values in FASPH must be preserved during the  processing  of
	  locations  within  the range of array locations specified by
	  the user.  The values in  FASPH  are  not  necessary  if  an
	  equals  sign  was  not  found,  and are not needed after all
	  locations within the range of array locations  specified  by
	  the user have been processed.



	                An Example of the Use of DAVARY
	                -- ------- -- --- --- -- ------

	  The sample program listed on the following page demonstrates
	  both  DAPICK  and DAVARY since these 2 routines are designed
	  to cooperate in the evaluation of  the  text  typed  by  the
	  user.   DATA  statements  at  the start of the demonstration
	  program define a dictionary describing the simulated  arrays
	  named   REAL,   OCTAL  and  INTEGER,  each  simulated  array
	  containing values of the type indicated  by  its  name.   To
	  allow  construction  of the alphameric representation of the
	  subscripts of the simulated arrays without  having  to  take
	  into  consideration the number of digits in the numbers, but
	  yet without calling either the DALONE  or  DANUMB  routines,
	  each  simulated subscript can only have the values 1 through
	  9.   The  simulated  arrays  named  OCTAL  and  INTEGER  are
	  contained  in  a  buffer  separate  from that containing the
	  simulated array named REAL.  Initially, each simulated array
	  location  has  the  corresponding  buffer  subscript  as its
	  value.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 483
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	        DIMENSION NAME(60),IBUFFR(72),AARRAY(9),IARRAY(18),
	       1LTRSTR(16),NUMSTR(21),INISUB(7),LMTSUB(7),IDIGIT(9)
	        DATA IDIGIT/1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9/
	        DATA LTRSTR,ILEFT,IRIGHT/1HR,1HE,1HA,1HL,1HO,1HC,1HT,
	       11HA,1HL,1HI,1HN,1HT,1HE,1HG,1HE,1HR,1H(,1H)/
	        DATA MAXSUB,NAMMAX,MAXBFR,ITTY,JTTY/7,60,72,5,5/,
	       1NUMSTR/0,9,0,4,1,1,1,9,0,18,0,5,-1,1,1,9,7,0,1,1,9/,
	       2AARRAY/1.,2.,3.,4.,5.,6.,7.,8.,9./,
	       3IARRAY/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18/
	      1 WRITE(JTTY,2)
	      2 FORMAT(' *'$)
	        READ(ITTY,3)IBUFFR
	      3 FORMAT(72A1)
	        LOWBFR=1
	        KIND=-1
	        MODIFY=0
	  C                               EVALUATE NAME AND SUBSCRIPTS
	      4 CALL DAPICK(MAXBFR,IBUFFR,1,16,LTRSTR,
	       11,21,NUMSTR,MAXSUB,LOWBFR,KIND,LRGLTR,
	       2LRGNUM,LRGKNT,INITAL,KOUNT,LTRINI,NUMINI,KNTSUB,
	       3INISUB,LMTSUB)
	        GO TO(13,13,1,1,5,7,9,11),KIND
	      5 WRITE(JTTY,6)
	      6 FORMAT(' INCORRECT NUMBER OF SUBSCRIPTS')
	        GO TO 1
	      7 WRITE(JTTY,8)
	      8 FORMAT(' SUBSCRIPTS OUT OF RANGE')
	        GO TO 1
	      9 WRITE(JTTY,10)
	     10 FORMAT(' UNKNOWN NAME')
	        GO TO 1
	     11 WRITE(JTTY,12)
	     12 FORMAT(' SEMICOLON REQUIRED')
	        GO TO 1
	  C                               LOOP THROUGH ARRAY LOCATIONS
	     13 NAMUSD=NUMSTR(NUMINI)+3
	        DO 14 I=4,NAMUSD
	        NAME(I-3)=LTRSTR(LTRINI)
	     14 LTRINI=LTRINI+1
	        KONTRL=NUMSTR(NUMINI+1)
	        INCRMT=1
	        INDEX=INISUB(1)
	        IF(INDEX.GT.LMTSUB(1))INCRMT=-1
	        NAME(NAMUSD-2)=ILEFT
	        NAME(NAMUSD)=IRIGHT
	     15 NAME(NAMUSD-1)=IDIGIT(INDEX)
	        LOCATN=INDEX+INITAL-1
	        CALL DAVARY(KONTRL,ITTY,JTTY,LOCATN,NAMUSD,
	       1NAMMAX,MAXBFR,0,-1,8,6,6,
	       25,AARRAY,IARRAY,NAME,IBUFFR,LOWBFR,KIND,MODIFY)
	        IF((KIND.EQ.0).OR.(INDEX.EQ.LMTSUB(1)))GO TO 4
	        INDEX=INDEX+INCRMT
	        GO TO 15
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 484
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	   Portion of Dialog Text Shown Below Which Was Typed by User
	   ------- -- ------ ---- ----- ----- ----- --- ----- -- ----

	  In the dialog, the user typed all text to  the  right  of  a
	  leading  asterisk.   A  few of the lines typed by DAVARY are
	  also requests for additional data.  The text  typed  by  the
	  user  is  shown immediately below without any of the prompts
	  generated by the demonstration program.

	  OCTAL();INTEGER(9/1)!INITIAL VALUES
	  REAL(/3);REAL(4/6);REAL(7/)!VARIOUS SUBSCRIPT FORMS
	  REAL(1)=1.5;REAL(2/4)=2.5E-9/.5E-12/10;REAL(5/)=
	  ,6.5,,8.5;REAL(/)
	  OCTAL(3/)=-5K 2*-0.005M!VARIOUS FORMS OF -5*8*8*8

	  &DAVARY WILL REPEAT REQUEST
	  &WHEN IT FINDS LEADING AMPERSAND
	  -500000E-2-0.05E5;!TERMINATE THIS EARLY
	  OCTAL()
	  INTEGER()=20/10/40,3*-22,2*,1234;INTEGER()


	  Typical Dialog Between DAVARY Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  *OCTAL();INTEGER(9/1)!INITIAL VALUES
	  OCTAL(1) = 1
	  OCTAL(2) = 2
	  OCTAL(3) = 3
	  OCTAL(4) = 4
	  OCTAL(5) = 5
	  OCTAL(6) = 6
	  OCTAL(7) = 7
	  OCTAL(8) = 10
	  OCTAL(9) = 11
	  INTEGER(9) = 18
	  INTEGER(8) = 17
	  INTEGER(7) = 16
	  INTEGER(6) = 15
	  INTEGER(5) = 14
	  INTEGER(4) = 13
	  INTEGER(3) = 12
	  INTEGER(2) = 11
	  INTEGER(1) = 10
	  *REAL(/3);REAL(4/6);REAL(7/)!VARIOUS SUBSCRIPT FORMS
	  REAL(1) = 1
	  REAL(2) = 2
	  REAL(3) = 3
	  REAL(4) = 4
	  REAL(5) = 5
	  REAL(6) = 6
	  REAL(7) = 7
	  REAL(8) = 8
	  REAL(9) = 9
	  FASP, FORTRAN Alphameric Subroutine Package         Page 485
	  DAVARY, Routine to Display and Assign Values to Named Arrays


	  *REAL(1)=1.5;REAL(2/4)=2.5E-9/.5E-12/10;REAL(5/)=
	  REAL(1) = 1 = 1.5
	  REAL(2) = 2 = 2.5E-9
	  REAL(3) = 3 = 2.5005E-9
	  REAL(4) = 4 = 2.501E-9
	  REAL(5) = 5 = ,6.5,,8.5;REAL(/)
	  REAL(6) = 6 = 6.5
	  REAL(8) = 8 = 8.5
	  REAL(1) = 1.5
	  REAL(2) = 2.5E-9
	  REAL(3) = 2.5005E-9
	  REAL(4) = 2.501E-9
	  REAL(5) = 5
	  REAL(6) = 6.5
	  REAL(7) = 7
	  REAL(8) = 8.5
	  REAL(9) = 9
	  *OCTAL(3/)=-5K 2*-0.005M!VARIOUS FORMS OF -5*8*8*8
	  OCTAL(3) = 3 = -5000
	  OCTAL(4) = 4 = -5000
	  OCTAL(5) = 5 = -5000
	  OCTAL(6) = 6 =
	  OCTAL(7) = 7 = &DAVARY WILL REPEAT REQUEST
	  OCTAL(7) = 7 = &WHEN IT FINDS LEADING AMPERSAND
	  OCTAL(7) = 7 = -500000E-2-0.05E5;!TERMINATE THIS EARLY
	  OCTAL(8) = 10 = -5000
	  *OCTAL()
	  OCTAL(1) = 1
	  OCTAL(2) = 2
	  OCTAL(3) = -5000
	  OCTAL(4) = -5000
	  OCTAL(5) = -5000
	  OCTAL(6) = 6
	  OCTAL(7) = -5000
	  OCTAL(8) = -5000
	  OCTAL(9) = 11
	  *INTEGER()=20/10/40,3*-22,2*,1234;INTEGER()
	  INTEGER(1) = 10 = 20
	  INTEGER(2) = 11 = 30
	  INTEGER(3) = 12 = 40
	  INTEGER(4) = 13 = -22
	  INTEGER(5) = 14 = -22
	  INTEGER(6) = 15 = -22
	  INTEGER(9) = 18 = 1234
	  INTEGER(1) = 20
	  INTEGER(2) = 30
	  INTEGER(3) = 40
	  INTEGER(4) = -22
	  INTEGER(5) = -22
	  INTEGER(6) = -22
	  INTEGER(7) = 16
	  INTEGER(8) = 17
	  INTEGER(9) = 1234
	  FASP, FORTRAN Alphameric Subroutine Package         Page 486
	  DAVERB, Routine to Identify Words and Word Abbreviations


	   DDDDD          AAA  VV    VV  EEEEEEEE  RRRRRR    BBBBBB
	   DD   DD       AAAA  VV   VV   EE        RR    RR  BB    BB
	   DD    DD     AA AA  VV  VV    EE        RR    RR  BB    BB
	   DD    DD    AA  AA  VV VV     EEEEE     RRRRRR    BBBBBB
	   DD    DD   AAAAAAA  VVVV      EE        RR  RR    BB    BB
	   DD   DD   AA    AA  VVV       EE        RR   RR   BB    BB
	   DDDDD    AA     AA  VV        EEEEEEEE  RR    RR  BBBBBB



	    DAVERB, Routine to Identify Words and Word Abbreviations
	    ------  ------- -- -------- ----- --- ---- -------------

	  DAVERB interprets an array read by the calling program  with
	  a multiple of an A1 format and identifies the words and word
	  abbreviations  contained  in  this  array.   The  words  are
	  recognized   by   being   matched  against  a  user  defined
	  dictionary.  If the array contains abbreviations of words in
	  the  dictionary,  then  DAVERB  also  specifies  whether the
	  abbreviations are ambiguous.

	  All alphabetic letters within the dictionary supplied by the
	  calling  program  must be specified in upper case.  However,
	  this routine treats as equivalent the upper and  lower  case
	  forms of the same alphabetic letter in the array read by the
	  calling program.  DAVERB contains a list of the  lower  case
	  letters  and a list of the corresponding upper case letters.
	  The lower case letters are defined by a DATA statement to be
	  in  the  order  1Ha  through 1Hz which on the PDP10 computer
	  results in the associated integer values being  sorted  into
	  an  increasing  order.   Each lower case letter in the input
	  text buffer is identified by a ternary search  for  a  match
	  within  the  sorted  list  of  lower  case letters.  If this
	  routine  is  used  upon  a  computer  system  in  which  the
	  alphabetical  order  of the letters 1Ha through 1Hz does not
	  result in an increasing order  for  the  associated  integer
	  values,  then  the  DATA  statement  which defines the array
	  which contains the lower case letters should be rewritten so
	  that  the  values  associated  with  the  letters will be in
	  increasing numerical order,  and  then  the  DATA  statement
	  which  defines  the corresponding upper case letters must be
	  rewritten so that the lower and upper case versions of  each
	  letter  appear  in locations in the respective arrays having
	  the same  subscripts.   If  the  computer  upon  which  this
	  routine  is  used  does not support lower case letters, then
	  the array which would otherwise contain the  list  of  lower
	  case letters as well as the array which contains the list of
	  upper case letters can each contain the upper  case  letters
	  1HA  through 1HZ in alphabetical order even if this order is
	  not the numerically sorted order.



	  FASP, FORTRAN Alphameric Subroutine Package         Page 487
	  DAVERB, Routine to Identify Words and Word Abbreviations


	                    The DAVERB Argument List
	                    --- ------ -------- ----

	  The argument list of routine DAVERB is

	        SUBROUTINE DAVERB(LOWWRD,MAXWRD,IWORD ,LOWKNT,MAXKNT,
	       1    KNTLTR,IBUFFR,MAXBFR,LOWBFR,KIND  ,MATCH ,LCNWRD,
	       2    LCNKNT,LCNBFR)

	  with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR),IWORD(MAXWRD),KNTLTR(MAXKNT)

	  Original values of LOWWRD, MAXWRD,  IWORD,  LOWKNT,  MAXKNT,
	  KNTLTR, IBUFFR and MAXBFR are not changed.

	  LOWBFR, KIND, MATCH, LCNWRD, LCNKNT and LCNBFR are  returned
	  describing the word or word abbreviation.

	  LOWBFR is used for  both  input  to  and  output  from  this
	  routine.

	  LOWWRD = subscript of the location in the IWORD array  which
	           contains  the  first character of the first word in
	           the dictionary.  Note  that  if  KNTLTR(LOWKNT)  is
	           less   than  or  equal  to  zero,  then  the  first
	           character of the first word is instead contained in
	           IWORD(LOWWRD-KNTLTR(LOWKNT)).

	  MAXWRD = maximum dimension of the IWORD array.

	  IWORD  = dictionary array containing the characters  of  the
	           words  which  are to be recognized, 1 character per
	           array location as read by  an  A1  format  or  else
	           defined by 1H field.  All alphabetic letters within
	           the IWORD array must be  supplied  in  upper  case.
	           The  word typed by the user and read into the input
	           buffer array IBUFFR can be split  into  2  or  more
	           portions  any  of  which  can be abbreviated and/or
	           separated by spaces or tabs  if  the  word  in  the
	           IWORD array contains a single space at the location
	           at which the split is allowed, and  if  the  length
	           stored  in  the  KNTLTR  array is 100 more than the
	           number of characters including the space or  spaces
	           which  form  the  word  in  the  IWORD  array.  For
	           example, if the IWORD array contains

	                1HN,1HO,1H ,1HL,1HI,1HM,1HI,1HT

	           and if the KNTLTR array contains the  corresponding
	           length  of 108, then this word could be selected by
	           any of the letter sequences

	                N, NO, N L, NL, NO L, NOL, N LI or NLI
	  FASP, FORTRAN Alphameric Subroutine Package         Page 488
	  DAVERB, Routine to Identify Words and Word Abbreviations


	           providing in each case that  the  sequence  is  not
	           ambiguous.

	  LOWKNT = subscript of the KNTLTR array  location  containing
	           the  length  of the first word which can be matched
	           in the IWORD array.  This first word will start  at
	           IWORD(LOWWRD).   If  no words are to be recognized,
	           then either MAXKNT should be less than  LOWKNT,  or
	           else  both  LOWKNT and MAXKNT can point to the same
	           zero entry in the KNTLTR array.

	  MAXKNT = subscript of the KNTLTR array  location  containing
	           the  length  of the final word which can be matched
	           in the IWORD array.

	  KNTLTR = array containing the numbers of characters  in  the
	           words in the IWORD array.  A zero or negative value
	           in the KNTLTR array offsets the next possible  word
	           which  can  be  matched  in  the IWORD array by the
	           number of letters given by the  absolute  value  of
	           the  negative  number  in  the  KNTLTR  array.  The
	           dimension of KNTLTR  must  at  least  be  equal  to
	           MAXKNT.  For example to recognize the words

	                YES, NO, MAYBE

	           the contents of the IWORD array would be

	                1HY,1HE,1HS,1HN,1HO,1HM,1HA,1HY,1HB,1HE

	           and contents of the KNTLTR array would be

	                3,2,5

	           If the corresponding word stored in the IWORD array
	           contains one or more spaces, then the length stored
	           in the KNTLTR array  must  be  100  more  than  the
	           actual  number  of characters in the word including
	           the spaces.  The values  101  through  199  in  the
	           KNTLTR  array  thus  indicate  words  of  length  1
	           through 99 which could contain spaces.   The  value
	           100  in  the  KNTLTR array is treated the same as a
	           zero.   Although   word   and   word   abbreviation
	           recognition  will  proceed  properly even if 100 is
	           added to all of the lengths stored  in  the  KNTLTR
	           array,  more  effort  is  required  to recognize an
	           abbreviation  of  a  word  which   is   marked   as
	           containing a space.

	  IBUFFR = input buffer array containing characters  typed  by
	           the user, read by a multiple of an A1 format, which
	           is to be searched for words and word abbreviations.
	           IBUFFR  then contains 1 letter per computer storage
	           location.  All lower case alphabetic letters in the
	  FASP, FORTRAN Alphameric Subroutine Package         Page 489
	  DAVERB, Routine to Identify Words and Word Abbreviations


	           IBUFFR   array   are   treated   as  being  exactly
	           equivalent  to  the  upper  case  forms  of   these
	           letters.

	  MAXBFR = maximum subscript of IBUFFR array to be searched

	  LOWBFR = subscript within the  IBUFFR  array  of  the  first
	           (leftmost) character which can be scanned for words
	           or word abbreviations.   LOWBFR  will  be  returned
	           pointing  to  the  next  character beyond a matched
	           word if a word is found.  If there are no  printing
	           characters at or to right of the location indicated
	           by LOWBFR, then LOWBFR will be returned  containing
	           MAXBFR+1  and KIND will be returned containing one.
	           LOWBFR must be set by the  calling  program  before
	           anything  is  processed  in the current contents of
	           the IBUFFR array, but then should not  be  modified
	           by the calling program until the entire contents of
	           the IBUFFR array have been processed.


	  KIND   = returned describing the kind of item located in the
	           IBUFFR array.
	         = 1, no printing character was found  at  or  to  the
	           right  of  the  location  indicated by LOWBFR.  The
	           calling program should read a new line into  IBUFFR
	           and  should  reset  LOWBFR  to  point  to the first
	           character in the new contents of the buffer.
	         = 2, a word or word abbreviation was not found, but a
	           non-space non-tab printing character which does not
	           start a word in the dictionary was  found.   LOWBFR
	           is  returned  pointing  to this printing character.
	           It  is  expected  that  the  calling  program  will
	           otherwise  process  this  printing  character since
	           DAVERB would return  the  same  results  if  called
	           again  with the same value of LOWBFR, with the same
	           dictionary and with the same buffer contents.
	         = returned containing 3, 4 or 5  if  a  word  in  the
	           dictionary   was   matched   even  partially.   For
	           example, if the dictionary contained  both  of  the
	           words NO and NONE, then

	           A) initial letter N in the buffer followed by  some
	              character  other  than  the letter O would be an
	              ambiguous abbreviation  and  the  pointer  named
	              MATCH  would be returned pointing to (containing
	              the sequence number within  the  dictionary  of)
	              whichever  word NO or NONE appeared first in the
	              dictionary.
	           B) initial  letters  N  and  O  followed  by   some
	              character  other  than  the letter N would be an
	              exact match with the word NO.
	           C) initial letters N and O and N would be a partial
	              but nonambiguous match with the word NONE.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 490
	  DAVERB, Routine to Identify Words and Word Abbreviations


	           Leading spaces and/or tabs are ignored.   A  string
	           of  characters  containing  embedded  spaces and/or
	           tabs can match a word in the dictionary only if the
	           word  in  the dictionary contains a single space at
	           the position at which the spaces  and/or  tabs  are
	           allowed  (but  not  necessary),  and  only  if  the
	           corresponding value in the KNTLTR array is 100 more
	           than   the   number  of  characters  including  the
	           embedded spaces  which  are  stored  in  the  IWORD
	           array.
	         = 3, a word in the IWORD array was  matched  exactly.
	           MATCH is returned containing the sequence number of
	           the word matched in the IWORD array.
	         = 4, a nonambiguous abbreviation of  a  word  in  the
	           IWORD   array   was   found.    MATCH  is  returned
	           containing the sequence number of the word  in  the
	           IWORD array.
	         = 5, an ambiguous abbreviation of a word  was  found.
	           MATCH is returned containing the sequence number of
	           the first word matched in the IWORD array.

	  MATCH  = returned containing the sequence number of  a  word
	           matched  in  the  IWORD  array  if KIND is returned
	           containing 3, 4 or 5.  For example, if  the  second
	           word  is  matched,  then  MATCH  would  be returned
	           containing 2.  The sequence number of the  word  in
	           the  IWORD  array  does  not  include  the  letters
	           skipped over by the value of LOWWRD  being  greater
	           than  1,  and  does not include the letters skipped
	           over by negative values encountered in  the  KNTLTR
	           array.   If  a  word in the IWORD array is matched,
	           KIND being returned with one of the values 3, 4  or
	           5, then MATCH is the number of values in the KNTLTR
	           array which  are  greater  than  zero  starting  at
	           KNTLTR(LOWKNT)  up  to  and  including  the  KNTLTR
	           location which contains the number  of  letters  in
	           the word which is successfully matched.

	           MATCH is returned  containing  KIND-2  if  KIND  is
	           returned less than or equal to 2 indicating that no
	           word in the  IWORD  array  could  be  matched  even
	           partially.   This means that if the calling program
	           tests for KIND=5 after the return from DAVERB,  and
	           if  KIND=4  is to be taken as equivalent to KIND=3,
	           then the calling program can add 2 to the value  of
	           MATCH  and use this sum as the index for a computed
	           GO TO statement.

	  LCNWRD = if KIND is returned containing 3 or greater, LCNWRD
	           is  returned  containing the subscript of the IWORD
	           array location which contains the  first  character
	           of the word matched in the dictionary.

	  LCNKNT = if KIND is returned containing 3 or greater, LCNKNT
	  FASP, FORTRAN Alphameric Subroutine Package         Page 491
	  DAVERB, Routine to Identify Words and Word Abbreviations


	           is  returned containing the subscript of the KNTLTR
	           array  location  which  contains  the   number   of
	           characters  in  the word matched in the dictionary.
	           If there are no zero or  negative  entries  in  the
	           KNTLTR  array,  then  LCNKNT  is  returned equal to
	           LOWKNT+MATCH-1.

	  LCNBFR = if KIND is returned containing 3 or greater, LCNBFR
	           is  returned containing the subscript of the IBUFFR
	           array location which contains the  first  character
	           of the word or its abbreviation.

	           If KIND is returned containing 2, then both  LCNBFR
	           and LOWBFR are returned containing the subscript of
	           the  IBUFFR  array  location  which  contains   the
	           printing character which could not be identified.


	                An Example of the Use of DAVERB
	                -- ------- -- --- --- -- ------

	  The dictionary in the sample program listed  below  contains
	  both  of  the  character  sequences  'CANNOT' and 'CAN NOT'.
	  Since a space within a word in the  dictionary  indicates  a
	  location at which the buffer can optionally contain a space,
	  the buffer contents 'CANNOT' could match either entry in the
	  dictionary   and   are   ambiguous.    The  buffer  contents
	  'CAN NOT', or the abbreviation 'C N', would not be ambiguous
	  since  only  one  of  the dictionary entries permits a space
	  between the adjacent appearances of the letter N.

	  A  sample  dialog  between  the  program  and  the  user  is
	  presented following the listing of the program.



	  C     PROGRAM TO DEMONSTRATE DAVERB ROUTINE
	  C
	  C     FOLLOWING LINES LIST WORDS IN DICTIONARY.
	  C     WORDS NOT PRECEDED BY NUMBERS CANNOT BE MATCHED.
	  C
	  C       'DUMMY'       'IGNORE'   12 'NONE'
	  C     1 'NO'        6 'YES'      13 'NOT LONG'
	  C     2 'NO LIMIT'  7 'CAN'      14 'NOT LARGE'
	  C     3 'MAYBE'     8 'CAN NOT'  15 'NO LONGER'
	  C     4 'MAY BE'    9 'CANNOT'   16 'HAS MANY SPACES'
	  C     5 'MAY'      10 'NO NEED'  17 'HASNOSPACES'
	  C       'EMPTY'    11 'NO LARGER'
	  C
	        DIMENSION IBUFFR(72),IWORD(131),KNTLTR(22)
	        DATA IWORD/1HD,1HU,1HM,1HM,1HY,1HN,1HO,1HN,1HO,1H ,
	       1           1HL,1HI,1HM,1HI,1HT,1HM,1HA,1HY,1HB,1HE,
	       2           1HM,1HA,1HY,1H ,1HB,1HE,1HM,1HA,1HY,1HE,
	       3           1HM,1HP,1HT,1HY,1HI,1HG,1HN,1HO,1HR,1HE,
	  FASP, FORTRAN Alphameric Subroutine Package         Page 492
	  DAVERB, Routine to Identify Words and Word Abbreviations


	       4           1HY,1HE,1HS,1HC,1HA,1HN,1HC,1HA,1HN,1H ,
	       5           1HN,1HO,1HT,1HC,1HA,1HN,1HN,1HO,1HT,1HN,
	       6           1HO,1H ,1HN,1HE,1HE,1HD,1HN,1HO,1H ,1HL,
	       7           1HA,1HR,1HG,1HE,1HR,1HN,1HO,1HN,1HE,1HN,
	       8           1HO,1HT,1H ,1HL,1HO,1HN,1HG,1HN,1HO,1HT,
	       9           1H ,1HL,1HA,1HR,1HG,1HE,1HN,1HO,1H ,1HL,
	       1           1HO,1HN,1HG,1HE,1HR,1HH,1HA,1HS,1H ,1HM,
	       2           1HA,1HN,1HY,1H ,1HS,1HP,1HA,1HC,1HE,1HS,
	       3           1HH,1HA,1HS,1HN,1HO,1HS,1HP,1HA,1HC,1HE,
	       4           1HS/
	        DATA KNTLTR/ 99, 99, -3,  2,108,  5,106,  3, -5, -6,
	       1              3,  3,107,  6,107,109,  4,108,109,109,
	       2            115, 11/
	        DATA LOWWRD,MAXWRD,LOWKNT,MAXKNT,MAXBFR/3,131,3,22,72/
	        DATA IGREAT,IBLANK/1H>,1H /
	  C
	  C     ASK FOR AND ACCEPT USER RESPONSE
	      1 TYPE 2
	      2 FORMAT(1X,1H*,$)
	        ACCEPT 3,IBUFFR
	      3 FORMAT(100A1)
	        LOWBFR=1
	  C
	  C     IDENTIFY NEXT WORD IN USER RESPONSE
	      4 CALL DAVERB(LOWWRD,MAXWRD,IWORD ,LOWKNT,MAXKNT,
	       1     KNTLTR,IBUFFR,MAXBFR,LOWBFR,KIND  ,MATCH ,LCNWRD,
	       2     LCNKNT,LCNBFR)
	        IF(KIND.EQ.1)GO TO 1
	        IF(KIND.EQ.2)GO TO 8
	  C
	  C     REPORT USER RESPONSE AND DICTIONARY WORD MATCHED
	        IUSED=LOWBFR-1
	        IEND=KNTLTR(LCNKNT)
	        IF(IEND.GT.100)IEND=IEND-100
	        IEND=LCNWRD+IEND-1
	        IF(KIND.EQ.3)TYPE 5,(IBUFFR(I),I=LCNBFR,IUSED),
	       1IGREAT,IBLANK,(IWORD(I),I=LCNWRD,IEND)
	      5 FORMAT(' EXACT     <',100A1)
	        IF(KIND.EQ.4)TYPE 6,(IBUFFR(I),I=LCNBFR,IUSED),
	       1IGREAT,IBLANK,(IWORD(I),I=LCNWRD,IEND)
	      6 FORMAT(' UNIQUE    <',100A1)
	        IF(KIND.EQ.5)TYPE 7,(IBUFFR(I),I=LCNBFR,IUSED),
	       1IGREAT,IBLANK,(IWORD(I),I=LCNWRD,IEND)
	      7 FORMAT(' AMBIGUOUS <',100A1)
	        GO TO 4
	  C
	  C     REPORT IF NO MATCH
	      8 TYPE 9,IBUFFR(LOWBFR)
	      9 FORMAT(' UNKNOWN   <',1A1,1H>)
	        LOWBFR=LOWBFR+1
	        GO TO 4
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 493
	  DAVERB, Routine to Identify Words and Word Abbreviations


	  Typical Dialog Between DAVERB Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  *N Y NO YE NON YES NONE
	  AMBIGUOUS <N> NO
	  UNIQUE    <Y> YES
	  EXACT     <NO> NO
	  UNIQUE    <YE> YES
	  AMBIGUOUS <NON> NO NEED
	  EXACT     <YES> YES
	  EXACT     <NONE> NONE
	  *N N NN N NE NNE NO NE NONEE
	  UNIQUE    <N N> NO NEED
	  UNIQUE    <NN> NO NEED
	  UNIQUE    <N NE> NO NEED
	  UNIQUE    <NNE> NO NEED
	  UNIQUE    <NO NE> NO NEED
	  UNIQUE    <NONEE> NO NEED
	  *M MA MAY MAYB MAYBE
	  AMBIGUOUS <M> MAYBE
	  AMBIGUOUS <MA> MAYBE
	  EXACT     <MAY> MAY
	  AMBIGUOUS <MAYB> MAYBE
	  AMBIGUOUS <MAYBE> MAYBE
	  *M B MB MA B MAB MAY B MA BE MABE MAY BE
	  UNIQUE    <M B> MAY BE
	  UNIQUE    <MB> MAY BE
	  UNIQUE    <MA B> MAY BE
	  UNIQUE    <MAB> MAY BE
	  UNIQUE    <MAY B> MAY BE
	  UNIQUE    <MA BE> MAY BE
	  UNIQUE    <MABE> MAY BE
	  EXACT     <MAY BE> MAY BE
	  *C CA CAN CANN CANNO CANNOT
	  AMBIGUOUS <C> CAN
	  AMBIGUOUS <CA> CAN
	  EXACT     <CAN> CAN
	  AMBIGUOUS <CANN> CAN NOT
	  AMBIGUOUS <CANNO> CAN NOT
	  AMBIGUOUS <CANNOT> CAN NOT
	  *C N CN CA N CAN N C NO CNO CA NO CAN NO CAN NOT
	  UNIQUE    <C N> CAN NOT
	  UNIQUE    <CN> CAN NOT
	  UNIQUE    <CA N> CAN NOT
	  UNIQUE    <CAN N> CAN NOT
	  UNIQUE    <C NO> CAN NOT
	  UNIQUE    <CNO> CAN NOT
	  UNIQUE    <CA NO> CAN NOT
	  UNIQUE    <CAN NO> CAN NOT
	  EXACT     <CAN NOT> CAN NOT
	  FASP, FORTRAN Alphameric Subroutine Package         Page 494
	  DAVERB, Routine to Identify Words and Word Abbreviations


	  *NO LA NOLA NOTLA NOT LA NO LARGE NOT LARGE NO LARGER
	  AMBIGUOUS <NO LA> NO LARGER
	  AMBIGUOUS <NOLA> NO LARGER
	  UNIQUE    <NOTLA> NOT LARGE
	  UNIQUE    <NOT LA> NOT LARGE
	  AMBIGUOUS <NO LARGE> NO LARGER
	  EXACT     <NOT LARGE> NOT LARGE
	  EXACT     <NO LARGER> NO LARGER
	  *NO LO NOLO NOTLO NOT LO NO LONG NOT LONG NO LONGE NO LONGER
	  AMBIGUOUS <NO LO> NOT LONG
	  AMBIGUOUS <NOLO> NOT LONG
	  UNIQUE    <NOTLO> NOT LONG
	  UNIQUE    <NOT LO> NOT LONG
	  AMBIGUOUS <NO LONG> NOT LONG
	  EXACT     <NOT LONG> NOT LONG
	  UNIQUE    <NO LONGE> NO LONGER
	  EXACT     <NO LONGER> NO LONGER
	  *NOTLONGNOT LONG NOT  LONG  NOT   LONG
	  EXACT     <NOTLONG> NOT LONG
	  EXACT     <NOT LONG> NOT LONG
	  EXACT     <NOT  LONG> NOT LONG
	  EXACT     <NOT   LONG> NOT LONG
	  *HASMANYSPACES HAS MANY SPACES  HAS  MANY  SPACES
	  EXACT     <HASMANYSPACES> HAS MANY SPACES
	  EXACT     <HAS MANY SPACES> HAS MANY SPACES
	  EXACT     <HAS  MANY  SPACES> HAS MANY SPACES
	  *HMS H M S  H  M  S   H   M   S
	  UNIQUE    <HMS> HAS MANY SPACES
	  UNIQUE    <H M S> HAS MANY SPACES
	  UNIQUE    <H  M  S> HAS MANY SPACES
	  UNIQUE    <H   M   S> HAS MANY SPACES
	  *hamasp ha ma sp  ha  ma  sp
	  UNIQUE    <hamasp> HAS MANY SPACES
	  UNIQUE    <ha ma sp> HAS MANY SPACES
	  UNIQUE    <ha  ma  sp> HAS MANY SPACES
	  *HaMaSp hA mA sP  HA  ma  SP
	  UNIQUE    <HaMaSp> HAS MANY SPACES
	  UNIQUE    <hA mA sP> HAS MANY SPACES
	  UNIQUE    <HA  ma  SP> HAS MANY SPACES
	  *HAMASP HA MA SP  HA  MA  SP
	  UNIQUE    <HAMASP> HAS MANY SPACES
	  UNIQUE    <HA MA SP> HAS MANY SPACES
	  UNIQUE    <HA  MA  SP> HAS MANY SPACES
	  *HHAHASHASNHASMHASMSPACES
	  AMBIGUOUS <H> HAS MANY SPACES
	  AMBIGUOUS <HA> HAS MANY SPACES
	  AMBIGUOUS <HAS> HAS MANY SPACES
	  UNIQUE    <HASN> HASNOSPACES
	  UNIQUE    <HASM> HAS MANY SPACES
	  UNIQUE    <HASMSPACES> HAS MANY SPACES
	  FASP, FORTRAN Alphameric Subroutine Package         Page 495
	  DAVERB, Routine to Identify Words and Word Abbreviations


	   DALOSS, Extends DAVERB to Allow Comments and Missing Words
	   ------  ------- ------ -- ----- -------- --- ------- -----

	  If the first printing character found by DAVERB in the  line
	  of  input  text  does not appear at the start of any word in
	  the dictionary supplied by the  calling  program,  then  the
	  character  is  considered  to  be  unknown causing DAVERB to
	  return control  to  the  calling  program.   In  particular,
	  DAVERB does not recognize the punctuation characters allowed
	  by many of the other  routines  in  the  FORTRAN  Alphameric
	  Subroutine  Package.  DALOSS, a short subroutine which calls
	  upon DAVERB for  word  recognition,  allows  commas  between
	  words,  identifies  missing items indicated by extra commas,
	  skips over any text which is  to  the  right  of  either  an
	  exclamation   point   or   an  ampersand,  and  reports  any
	  semicolons found in the text being evaluated.  In  addition,
	  DALOSS  reports whether the character to the right of a word
	  or its abbreviation is a character other than a space, a tab
	  character or an allowed punctuation character.

	  The argument list of routine DALOSS is

	        SUBROUTINE DALOSS(LOWWRD,MAXWRD,IWORD ,LOWKNT,MAXKNT,
	       1    KNTLTR,IBUFFR,MAXBFR,LOWBFR,KIND  ,MATCH ,LCNWRD,
	       1    LCNKNT,LCNBFR,MANY  ,LCNERR)

	  with the associated DIMENSION statement

	        DIMENSION IBUFFR(MAXBFR),IWORD(MAXWRD),
	       1KNTLTR(MAXKNT)

	  The argument lists of DALOSS and DAVERB are identical except
	  for the DALOSS arguments MANY and LCNERR which do not appear
	  in the DAVERB argument list,  and  except  that  DALOSS  can
	  return  the  argument  named  KIND containing the additional
	  values 6 through 11.  The argument named MANY must be set to
	  zero  by  the  calling  program  before  calling either this
	  routine or any of the other routines  in  the  FASP  package
	  (such  as  DAMISS,  DANEXT  and  DASPAN)  which  define this
	  argument in a similar manner.  The arguments named KIND  and
	  LCNERR  are  used only for output to the calling program and
	  their  input  values  are  ignored.   These  arguments   are
	  described  below.   The  documentation  of  DAVERB should be
	  consulted for descriptions of the remaining arguments.

	  KIND   = 1, nothing, except perhaps a comment indicated by a
	           leading  exclamation  point, was found at or to the
	           right  of  IBUFFR(LOWBFR).   The  calling   program
	           should read a new line into the IBUFFR array before
	           again calling this routine if additional words  are
	           required.   LOWBFR  is returned pointing beyond the
	           end of the buffer.  MANY is returned set  to  zero.
	           MATCH is returned undefined.
	         = 2, the  first  printing  character  (other  than  a
	  FASP, FORTRAN Alphameric Subroutine Package         Page 496
	  DAVERB, Routine to Identify Words and Word Abbreviations


	           possible comma if MANY was input greater than zero)
	           in or to right of IBUFFR(LOWBFR) did not match  the
	           first  character  of any word in the dictionary and
	           was  not   a   comma,   semicolon,   ampersand   or
	           exclamation  point.   Both  LCNBFR  and  LOWBFR are
	           returned pointing to this printing  character.   It
	           is expected that the calling program will otherwise
	           process this printing character since DALOSS  would
	           return  the  same  results if called again with the
	           same value of LOWBFR, with the same dictionary  and
	           with  the same buffer contents.  LCNERR is returned
	           pointing to the next space, tab  character,  comma,
	           semicolon,  exclamation  point  or ampersand to the
	           right of the unknown character, or is returned  set
	           to  MAXBFR+1  if none of these characters is found.
	           MANY is returned  containing  one  plus  its  input
	           absolute value.  Match is returned undefined.
	         = 3 or 4 or 5, same  as  when  DAVERB  returns  these
	           values,   except   that  if  there  are  additional
	           characters  to  the  right  of  the  word  or   its
	           abbreviation,  then  the character to the immediate
	           right of the word or its abbreviation is  either  a
	           space, tab character, comma, semicolon, exclamation
	           point or ampersand.  MANY  is  returned  containing
	           one  plus  its  input  absolute  value.   LCNBFR is
	           returned  pointing  in  the  buffer  to  the  first
	           character  of the word or its abbreviation.  LCNERR
	           and LOWBFR are returned pointing to  the  character
	           to the right of the word or its abbreviation.
	         = 3, a word in the IWORD array was  matched  exactly.
	           MATCH is returned containing the sequence number of
	           the word matched in the IWORD array.
	         = 4, a nonambiguous abbreviation of  a  word  in  the
	           IWORD   array   was   found.    MATCH  is  returned
	           containing the sequence number of the word  in  the
	           IWORD array.
	         = 5, an ambiguous abbreviation of a word  was  found.
	           MATCH is returned containing the sequence number of
	           the first word matched in the IWORD array.
	         = 6 or  7  or  8,  same  as  when  KIND  is  returned
	           containing  3 or 4 or 5 respectively, except that a
	           character other than a space, tab character, comma,
	           semicolon,  exclamation point or ampersand appeared
	           to  the  immediate  right  of  the  word   or   its
	           abbreviation.   LCNBFR  is returned pointing in the
	           buffer to the first character of the  word  or  its
	           abbreviation.   LOWBFR  is returned pointing in the
	           buffer to the character to the right of the word or
	           its  abbreviation.   LCNERR is returned pointing in
	           the buffer to the next space, tab character, comma,
	           semicolon,  exclamation  point  or ampersand to the
	           right of  the  word  or  its  abbreviation,  or  is
	           returned  pointing  beyond the end of the buffer if
	           no  space,   tab   character,   comma,   semicolon,
	  FASP, FORTRAN Alphameric Subroutine Package         Page 497
	  DAVERB, Routine to Identify Words and Word Abbreviations


	           exclamation  point  or  ampersand  is  found to the
	           right of the word or  its  abbreviation.   MANY  is
	           returned set to one plus its input absolute value.
	         = 9, a semicolon was  found  as  the  first  printing
	           character  at  or  to  the right of IBUFFR(LOWBFR).
	           LOWBFR is returned pointing to the  next  character
	           beyond  the  semicolon.   It  is  assumed  that the
	           calling program will treat the  appearance  of  the
	           semicolon  as marking the end of a statement.  MANY
	           is  returned  set  to  zero.   MATCH  is   returned
	           undefined.
	         = 10, an ampersand was found as  the  first  printing
	           character  at  or to the right of LOWBFR.  The text
	           to the right of the ampersand is taken as a comment
	           so LOWBFR is returned pointing beyond the right end
	           of the buffer.  It  is  assumed  that  the  calling
	           program  will read in the contents of a new buffer,
	           then again request a new word  identification  from
	           this  routine.   The  value  of  MANY  must  not be
	           changed  by  the  calling  program  prior  to  this
	           following  call.   The effect is not quite the same
	           as if the user had typed  all  of  the  text  on  a
	           single  line  since  a  single word cannot be split
	           across  a  line  boundary.    MATCH   is   returned
	           undefined.
	         = 11, a word was not found, but an  extra  comma  was
	           found  indicating a missing word.  MANY is returned
	           containing  one  plus  its  input  absolute  value.
	           MATCH is returned undefined.

	  MANY   = should be input  containing  zero  each  time  this
	           routine  is  called  to  begin  processing of a new
	           logical  section  of  text,  as  for  example  when
	           beginning  processing of a line of text not tied to
	           the previous line by an ampersand at the end of the
	           previous  line,  or when processing the text to the
	           right of a semicolon.  The initial zeroing of  this
	           argument  must  be done by the calling program, but
	           thereafter the value returned by the previous  call
	           to  this  routine  can  usually  be  used.  MANY is
	           returned set to zero each time a semicolon (KIND=9)
	           is  found, and each time an end of line not tied to
	           the following line  by  an  ampersand  (KIND=1)  is
	           found.   MANY  is  returned containing one plus its
	           input absolute value each time  a  word  is  found,
	           each  time  an  unknown character is found, or each
	           time an indication of  a  missing  word  is  found.
	           KIND  is  returned containing the value 10 and MANY
	           is returned containing the negative of  the  number
	           of  items  found  if  the  next  printing character
	           following a comma is an ampersand.  MANY should not
	           be  changed  by the calling program if an ampersand
	           (KIND being returned=10) is found  indicating  that
	           the  subsequent  call to this routine is to process
	  FASP, FORTRAN Alphameric Subroutine Package         Page 498
	  DAVERB, Routine to Identify Words and Word Abbreviations


	           text which is to be treated as though  it  appeared
	           in place of the ampersand and the characters to its
	           right.  The effect is not quite the same as if  the
	           user  had  typed  all  of the text on a single line
	           since a single word cannot be split across the line
	           boundary.

	           If MANY is input containing zero, then  an  initial
	           comma in the input text buffer is taken to indicate
	           an initial missing item, and MANY is then  returned
	           containing  1.  If MANY is input greater than zero,
	           then an initial comma is ignored if followed  by  a
	           word.   If MANY is input greater than zero, then an
	           initial  comma  followed  by  no   other   printing
	           characters,  by  a  semicolon, or by an exclamation
	           point indicates a missing item.  If MANY  is  input
	           greater  than  zero, then an initial comma followed
	           by an ampersand will cause the remaining characters
	           in  the  buffer  to  be  ignored,  and MANY will be
	           returned  containing  the  negative  of  its  input
	           value.   If  MANY  is  input  negative,  then it is
	           assumed that the contents  of  the  current  buffer
	           continue  a  previous  line which terminated with a
	           comma  followed  by  an  ampersand,  and  MANY   is
	           returned greater than zero.

	  LCNERR = if KIND is returned  containing  a  number  in  the
	           range  3  through  8  indicating that a word or its
	           abbreviation was found,  then  LCNERR  is  returned
	           containing   the  subscript  of  the  IBUFFR  array
	           location  which  contains  the  next   space,   tab
	           character,  comma,  semicolon, exclamation point or
	           ampersand  to  the  right  of  the  word   or   its
	           abbreviation, or else LCNERR is returned containing
	           MAXBFR+1  if  none  of  these   characters   appear
	           anywhere   to   the   right  of  the  word  or  its
	           abbreviation.  If KIND is returned containing 3,  4
	           or  5,  then  LCNERR  and  LOWBFR are both returned
	           pointing to the character to the immediate right of
	           the  word or its abbreviation.  If KIND is returned
	           containing 6, 7  or  8,  then  LOWBFR  is  returned
	           pointing  to  the  unexpected printing character to
	           the  immediate   right   of   the   word   or   its
	           abbreviation.

	           If KIND is returned containing 2, indicating that a
	           printing  character  was  found which did not begin
	           any word in the dictionary and which was not one of
	           the  allowed  punctuation  marks,  then  LCNERR  is
	           returned pointing to the next space, tab character,
	           comma,  semicolon,  exclamation point or ampersand,
	           or else LCNERR is returned containing  MAXBFR+1  if
	           none  of  these  characters  appear anywhere to the
	           right of the initial unexpected character.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 499
	  DAVERB, Routine to Identify Words and Word Abbreviations


	                An Example of the Use of DALOSS
	                -- ------- -- --- --- -- ------

	  The program listed on the following pages is based upon  the
	  program   listed  earlier  as  a  demonstration  the  DAVERB
	  routine.  The major modification  is  that  in  the  program
	  listed  here,  unexpected  characters which follow a word or
	  its abbreviation are typed to the right of a  question  mark
	  which  is  added  to  the  right of the characters which are
	  recognized, and LOWBFR is then advanced to have the value of
	  LCNERR before DALOSS is again called.

	  C     PROGRAM TO DEMONSTRATE DALOSS ROUTINE
	  C
	  C     FOLLOWING LINES LIST WORDS IN DICTIONARY.
	  C     WORDS NOT PRECEDED BY NUMBERS CANNOT BE MATCHED.
	  C
	  C       'DUMMY'       'IGNORE'   12 'NONE'
	  C     1 'NO'        6 'YES'      13 'NOT LONG'
	  C     2 'NO LIMIT'  7 'CAN'      14 'NOT LARGE'
	  C     3 'MAYBE'     8 'CAN NOT'  15 'NO LONGER'
	  C     4 'MAY BE'    9 'CANNOT'   16 'HAS MANY SPACES'
	  C     5 'MAY'      10 'NO NEED'  17 'HASNOSPACES'
	  C       'EMPTY'    11 'NO LARGER'
	  C
	        DIMENSION IBUFFR(72),IWORD(131),KNTLTR(22)
	        DATA IWORD/1HD,1HU,1HM,1HM,1HY,1HN,1HO,1HN,1HO,1H ,
	       1           1HL,1HI,1HM,1HI,1HT,1HM,1HA,1HY,1HB,1HE,
	       2           1HM,1HA,1HY,1H ,1HB,1HE,1HM,1HA,1HY,1HE,
	       3           1HM,1HP,1HT,1HY,1HI,1HG,1HN,1HO,1HR,1HE,
	       4           1HY,1HE,1HS,1HC,1HA,1HN,1HC,1HA,1HN,1H ,
	       5           1HN,1HO,1HT,1HC,1HA,1HN,1HN,1HO,1HT,1HN,
	       6           1HO,1H ,1HN,1HE,1HE,1HD,1HN,1HO,1H ,1HL,
	       7           1HA,1HR,1HG,1HE,1HR,1HN,1HO,1HN,1HE,1HN,
	       8           1HO,1HT,1H ,1HL,1HO,1HN,1HG,1HN,1HO,1HT,
	       9           1H ,1HL,1HA,1HR,1HG,1HE,1HN,1HO,1H ,1HL,
	       1           1HO,1HN,1HG,1HE,1HR,1HH,1HA,1HS,1H ,1HM,
	       2           1HA,1HN,1HY,1H ,1HS,1HP,1HA,1HC,1HE,1HS,
	       3           1HH,1HA,1HS,1HN,1HO,1HS,1HP,1HA,1HC,1HE,
	       4           1HS/
	        DATA KNTLTR/ 99, 99, -3,  2,108,  5,106,  3, -5, -6,
	       1              3,  3,107,  6,107,109,  4,108,109,109,
	       2            115, 11/
	        DATA LOWWRD,MAXWRD,LOWKNT,MAXKNT,MAXBFR/3,131,3,22,72/
	        DATA IGREAT,IWHAT,IBLANK/1H>,1H?,1H /
	  C
	  C     ASK FOR AND ACCEPT USER RESPONSE
	        MANY=0
	      1 TYPE 2
	      2 FORMAT(1X,1H*,$)
	        ACCEPT 3,IBUFFR
	      3 FORMAT(100A1)
	        LOWBFR=1
	  C
	  FASP, FORTRAN Alphameric Subroutine Package         Page 500
	  DAVERB, Routine to Identify Words and Word Abbreviations


	  C     IDENTIFY NEXT WORD IN USER RESPONSE
	      4 CALL DALOSS(LOWWRD,MAXWRD,IWORD ,LOWKNT,MAXKNT,
	       1     KNTLTR,IBUFFR,MAXBFR,LOWBFR,KIND  ,MATCH ,LCNWRD,
	       2     LCNKNT,LCNBFR,MANY,LCNERR)
	        IF(KIND.EQ.1)GO TO 1
	        IF(KIND.EQ.2)GO TO 12
	        IF(KIND.LT.9)GO TO 8
	        IF(KIND.EQ.9)TYPE 5
	        IF(KIND.EQ.10)TYPE 6
	        IF(KIND.EQ.11)TYPE 7
	      5 FORMAT(' SEMICOLON')
	      6 FORMAT(' AMPERSAND')
	      7 FORMAT(' MISSING')
	        IF(KIND.EQ.10)GO TO 1
	        GO TO 4
	  C
	  C     REPORT USER RESPONSE AND DICTIONARY WORD MATCHED
	      8 IUSED=LOWBFR-1
	        JUSED=LCNERR-1
	        IEND=KNTLTR(LCNKNT)
	        IF(IEND.GT.100)IEND=IEND-100
	        IEND=LCNWRD+IEND-1
	        IF(KIND.EQ.3)TYPE 9,(IBUFFR(I),I=LCNBFR,IUSED),
	       1IGREAT,IBLANK,(IWORD(I),I=LCNWRD,IEND)
	      9 FORMAT(' EXACT     <',100A1)
	        IF(KIND.EQ.4)TYPE 10,(IBUFFR(I),I=LCNBFR,IUSED),
	       1IGREAT,IBLANK,(IWORD(I),I=LCNWRD,IEND)
	     10 FORMAT(' UNIQUE    <',100A1)
	        IF(KIND.EQ.5)TYPE 11,(IBUFFR(I),I=LCNBFR,IUSED),
	       1IGREAT,IBLANK,(IWORD(I),I=LCNWRD,IEND)
	        IF(KIND.EQ.6)TYPE 9,(IBUFFR(I),I=LCNBFR,IUSED),
	       1IWHAT,(IBUFFR(I),I=LOWBFR,JUSED),
	       2IGREAT,IBLANK,(IWORD(I),I=LCNWRD,IEND)
	        IF(KIND.EQ.7)TYPE 10,(IBUFFR(I),I=LCNBFR,IUSED),
	       1IWHAT,(IBUFFR(I),I=LOWBFR,JUSED),
	       2IGREAT,IBLANK,(IWORD(I),I=LCNWRD,IEND)
	        IF(KIND.EQ.8)TYPE 11,(IBUFFR(I),I=LCNBFR,IUSED),
	       1IWHAT,(IBUFFR(I),I=LOWBFR,JUSED),
	       2IGREAT,IBLANK,(IWORD(I),I=LCNWRD,IEND)
	     11 FORMAT(' AMBIGUOUS <',100A1)
	        IF(KIND.GT.5)LOWBFR=LCNERR
	        GO TO 4
	  C
	  C     REPORT IF NO MATCH
	     12 JUSED=LCNERR-1
	        TYPE 13,(IBUFFR(I),I=LCNBFR,JUSED),IGREAT
	     13 FORMAT(' UNKNOWN   <',100A1)
	        LOWBFR=LCNERR
	        GO TO 4
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 501
	  DAVERB, Routine to Identify Words and Word Abbreviations


	  Typical Dialog Between DALOSS Demonstration Program and User
	  ------- ------ ------- ------ ------------- ------- --- ----

	  *NO YES,NO,,YELLOW  ,   NO   , ;  ,   YES!SPACES AND COMMAS
	  EXACT     <NO> NO
	  EXACT     <YES> YES
	  EXACT     <NO> NO
	  MISSING
	  UNIQUE    <YE?LLOW> YES
	  EXACT     <NO> NO
	  MISSING
	  SEMICOLON
	  MISSING
	  EXACT     <YES> YES
	  *,NO,
	  MISSING
	  EXACT     <NO> NO
	  MISSING
	  *NOMATCH;WITH NOTHING!ERRORS
	  EXACT     <NO?MATCH> NO
	  SEMICOLON
	  UNKNOWN   <WITH>
	  AMBIGUOUS <NOT?HING> NOT LONG
	  *NO&DEMONSTRATIONS OF COMMAS WITH AMPERSANDS
	  EXACT     <NO> NO
	  AMPERSAND
	  *YES
	  EXACT     <YES> YES
	  *NO&
	  EXACT     <NO> NO
	  AMPERSAND
	  *,YES
	  EXACT     <YES> YES
	  *NO,&
	  EXACT     <NO> NO
	  AMPERSAND
	  *YES
	  EXACT     <YES> YES
	  *NO,&
	  EXACT     <NO> NO
	  AMPERSAND
	  *,YES
	  MISSING
	  EXACT     <YES> YES
	  *NO,&
	  EXACT     <NO> NO
	  AMPERSAND
	  *&
	  AMPERSAND
	  *,YES
	  MISSING
	  EXACT     <YES> YES
	  FASP, FORTRAN Alphameric Subroutine Package         Page 502
	  DAVERB, Routine to Identify Words and Word Abbreviations


	  Simple but Machine Dependent Method of Dictionary Definition
	  ------ --- ------- --------- ------ -- ---------- ----------

	  The numeric codes  by  which  characters  are  stored  in  a
	  computer are much smaller than the maximum size number which
	  the computer can  represent,  so  several  codes  are  often
	  packed   within   a   single   computer   storage  location.
	  Unfortunately, this leads to difficulties in the recognition
	  of these characters unless the character to column alignment
	  remains fixed.  The character strings 'THE  ',  ' THE '  and
	  '  THE'  are  stored  as  different numbers, and can only be
	  matched as  containing  the  same  word  if  the  individual
	  characters are extracted and compared.

	  On the PDP-10  which  is  a  36  bit  computer  with  7  bit
	  character  codes,  5  characters  can  be packed in a single
	  computer storage location, leading to the use of  A5  format
	  specifications,  and  2 storage locations would be needed to
	  contain  the  character   string   represented   either   as
	  10HABCDEFGHIJ  or 'ABCDEFGHIJ'.  If a long string is used in
	  a DATA statement, then the programmer must  still  calculate
	  the  number  of  computer storage locations corresponding to
	  the string and explicitly allocate exactly the correct array
	  length   to  contain  the  string.   However,  the  compiler
	  performs the allocation of  sufficient  space  when  a  long
	  string is used directly within a CALL statement.  The called
	  routine could then convert the input text string  for  which
	  storage  was  allocated  by the compiler into a second array
	  which is returned to  the  calling  program  containing  the
	  characters   of  the  original  string,  but  separated  one
	  character to an array location as though read by a  multiple
	  of an A1 format.

	  The conversion of a string of 20 characters from  A5  to  A1
	  format  could be done by writing the characters to a scratch
	  file with a 4A5 format, then reading them back with  a  20A1
	  format.   The  writing  and  reading  of  a  scratch file is
	  simulated on the PDP-10 in the sample routine  listed  below
	  by  the  DECODE  statement.   This  routine  restructures  a
	  dictionary, specified as a  string  of  words  separated  by
	  spaces,  into the array of single characters (IWORD) and the
	  array of characters counts per word (KNTLTR) required by the
	  DAVERB  routine.   Since  the programmer does not want to be
	  bothered with counting the number of characters  within  the
	  string,  and  certainly does not want to update such a count
	  when the string is later modified, the end of the string  is
	  instead  delimited  by  a  second  appearance of the initial
	  printing  character,  both   appearances   being   otherwise
	  ignored.   This  delimiting  character is actually a part of
	  the string sent to the routine and is  in  addition  to  the
	  number  and letter H or to the apostrophes which delimit the
	  string to the compiler.  The argument LMTPKD does  place  an
	  upper  limit upon the length of the string, but is used only
	  if the programmer forgets to delimit the ends of the string.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 503
	  DAVERB, Routine to Identify Words and Word Abbreviations


	  The arguments of the routine are  defined  as  follow.   The
	  arguments  IPACKD,  LMTPKD,  LMTWRD and LMTKNT are used only
	  for input and are returned unchanged.

	  IPACKD = array containing several characters in  each  array
	           location.   The  number of characters in each array
	           location is indicated by the variable named INEACH,
	           which  is  defined  to  have  the value 5 by a DATA
	           statement  near  the  start  of  the  program.   If
	           INEACH=5,  then  the  array is treated as though it
	           was read with a  multiple  of  an  A5  format.   If
	           INEACH  is equal to the default for the computer on
	           which this routine is used, then the  IPACKD  array
	           can  be  defined  in  the call to this routine as a
	           single long Hollerith string, or as a  text  string
	           quoted with apostrophes.
	  LMTPKD = maximum number of characters which can be contained
	           in the IPACKD array.  It is expected that this will
	           be  set  somewhat  greater  than  the   number   of
	           characters actually contained in the array.
	  LMTWRD = the dimension of  the  IWORD  array  in  which  the
	           characters of words in the dictionary are returned.
	  LMTKNT = the dimension of the  KNTLTR  array  in  which  the
	           numbers   of   characters   in  each  word  in  the
	           dictionary are returned.
	  MAXWRD = input containing the number  of  locations  in  the
	           IWORD  array  which  are currently in use and which
	           must be preserved.  The  characters  added  to  the
	           dictionary  are  stored  in IWORD(MAXWRD+1) through
	           IWORD(LMTWRD).
	         = returned containing the number of locations in  the
	           IWORD array in use after this routine has added the
	           words in the IPACKD array to  the  dictionary.   If
	           more words must be added to the dictionary than can
	           be stored in a single Hollerith  string  or  string
	           quoted  with  apostrophes, then additional calls to
	           this routine can be used to extend the dictionary.
	  MAXKNT = input containing the number  of  locations  in  the
	           KNTLTR  array which are currently in used and which
	           must be preserved.  The number of characters in the
	           words   added  to  the  dictionary  are  stored  in
	           KNTLTR(MAXKNT+1) through KNTLTR(LMTKNT).
	         = returned containing the number of locations in  the
	           KNTLTR  array  in use after this call has added the
	           words in the IPACKD array to the dictionary.
	  IWORD  = array into which the characters of the words in the
	           IPACKD  array are stored as though these characters
	           had been read by a multiple of an A1 format.
	  KNTLTR = array into which the numbers of characters in  each
	           of the words in the IPACKD array are stored.

	  This routine is not included in the FASP package since it is
	  machine  dependent  both in the assumed character packing (5
	  per location) and in the syntax of the DECODE statement.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 504
	  DAVERB, Routine to Identify Words and Word Abbreviations


	        SUBROUTINE A5TOA1(IPACKD,LMTPKD,LMTWRD,LMTKNT,MAXWRD,
	       1    MAXKNT,IWORD ,KNTLTR)
	  C     ROUTINE TO RESTRUCTURE DICTIONARY, SPECIFIED AS WORDS
	  C     SEPARATED   BY   SPACES   CONTAINED  IN  SINGLE  LONG
	  C     HOLLERITH STRING OR IN SINGLE LONG TEXT STRING QUOTED
	  C     WITH   APOSTROPHES,   INTO   IWORD  ARRAY  OF  SINGLE
	  C     CHARACTERS AND INTO KNTLTR ARRAY OF CHARACTER  COUNTS
	  C     PER  WORD  NEEDED  BY  DAVERB.   SECOND APPEARANCE OF
	  C     FIRST PRINTING CHARACTER MARKS END OF STRING.
	  C
	  C     INEACH IS NUMBER OF CHARACTERS IN EACH HOLLERITH WORD
	        DATA INEACH/5/,IBLANK/1H /
	        DIMENSION IPACKD(LMTPKD),KNTLTR(LMTKNT),IWORD(LMTWRD)
	        KNTPKD=0
	        LOCAL=-1
	        LIMIT=LMTPKD
	  C
	  C     GET NEXT GROUP OF CHARACTERS
	      1 NEEDED=LMTWRD-MAXWRD
	        IF(NEEDED.GT.INEACH)NEEDED=INEACH
	        IF(NEEDED.GT.LIMIT)NEEDED=LIMIT
	        IF(NEEDED.LE.0)GO TO 8
	        KNTPKD=KNTPKD+1
	        ISTART=MAXWRD+1
	        IEND=MAXWRD+NEEDED
	        LIMIT=LIMIT-NEEDED
	  C     READ ALPHAMERIC  INFORMATION FROM IPACKD(KNTPKD) INTO
	  C     IWORD(ISTART)  THROUGH IWORD(IEND)  VIA THE INDICATED
	  C     FORMAT.   NEEDED IS THE NUMBER OF CHARACTERS TO READ.
	        DECODE(NEEDED,2,IPACKD(KNTPKD))
	       1(IWORD(I),I=ISTART,IEND)
	      2 FORMAT(100A1)
	  C
	  C     FIND WORDS OR DELIMITER CHARACTERS
	      3 IF(ISTART.GT.IEND)GO TO 1
	        IF(LOCAL.LT.0)GO TO 5
	        IF(IWORD(ISTART).EQ.IFINAL)GO TO 8
	        IF(IWORD(ISTART).EQ.IBLANK)GO TO 6
	        IF(LOCAL.GT.0)GO TO 4
	        IF(MAXKNT.GE.LMTKNT)GO TO 8
	        MAXKNT=MAXKNT+1
	        KNTLTR(MAXKNT)=0
	        LOCAL=1
	      4 KNTLTR(MAXKNT)=KNTLTR(MAXKNT)+1
	        MAXWRD=MAXWRD+1
	        IWORD(MAXWRD)=IWORD(ISTART)
	        GO TO 7
	      5 IF(IWORD(ISTART).EQ.IBLANK)GO TO 7
	        IFINAL=IWORD(ISTART)
	      6 LOCAL=0
	      7 ISTART=ISTART+1
	        GO TO 3
	      8 RETURN
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 505
	  DAVERB, Routine to Identify Words and Word Abbreviations


	  A Typical Wrapper Routine for the DALOSS and A5TOA1 Routines
	  - ------- ------- ------- --- --- ------ --- ------ --------

	  If the calling program requires only a few calls to any  one
	  of  the  routines in FASP, then these routines can be called
	  directly.  However, if the calling program needs to evaluate
	  the  answers  typed  by  the user in a lengthy dialog, it is
	  much more effective to identify the  characteristics  common
	  to  the  evaluation  of several answers and then to write an
	  intermediate level routine having the minimal argument  list
	  which  can  in turn call the routines in FASP and perhaps do
	  some answer verification and issue prompts when an error  is
	  detected.  The GETWRD routine listed below is such a wrapper
	  for the DALOSS routine, but is machine dependent both in the
	  use  of  unit 5 for error messages and in the calling of the
	  A5TOA1 routine.  The  GETWRD  routine  evaluates  the  words
	  and/or abbreviations typed on a single line.  Any characters
	  to the right  of  an  exclamation  point  are  ignored.   An
	  ampersand, if encountered, is treated exactly the same as an
	  exclamation point.  Likewise,  a  semicolon,  if  found,  is
	  treated  the  same  as a comma.  The routine issues an error
	  message and then lists for the user  the  currently  allowed
	  answers if an error is detected in the user's response.

	  The following are input arguments returned unchanged.

	  IPACKD = same as the array of the same name described in the
	           A5TOA1   documentation.    This   is  an  array  of
	           characters specified in the call  to  this  routine
	           either  as  a  Hollerith string or as a text string
	           quoted  with  apostrophes.   The   first   printing
	           character  in the string is ignored, and the string
	           is assumed to continue through the next  appearance
	           of  this  delimiting  character.   Between  the two
	           appearances of this delimiting character should  be
	           specified,  separated  by  spaces, all of the words
	           which  are  to  be  allowed.   At  most  20   words
	           containing  a  total of no more than 100 characters
	           can be defined in this manner.   For  example,  the
	           statement
	                 CALL GETWRD('/YES NO MAYBE/',IBUFFR,MAXBFR,
	                1LOWBFR,KIND)
	           or
	                 CALL GETWRD(14H/YES NO MAYBE/,IBUFFR,MAXBFR,
	                1LOWBFR,KIND)
	           would define a dictionary containing  the  3  words
	           YES, NO and MAYBE.

	  IBUFFR = array containing the text to be evaluated  as  read
	           by  a  multiple  of  an  A1  format.   IBUFFR  then
	           contains 1 character in each array location.

	  MAXBFR = subscript of the highest  (rightmost)  location  in
	           the  IBUFFR  array which contains a character to be
	  FASP, FORTRAN Alphameric Subroutine Package         Page 506
	  DAVERB, Routine to Identify Words and Word Abbreviations


	           evaluated.

	  The following argument is used both for input to and  output
	  from this routine.

	  LOWBFR = should be input set to zero whenever  this  routine
	           is  first  called  to  evaluate  the  contents of a
	           particular line of  text.   Thereafter,  LOWBFR  is
	           returned  containing  the  subscript  of the IBUFFR
	           array  location   which   contains   the   leftmost
	           character   which   has  not  yet  been  evaluated.
	           Setting the initial value of LOWBFR to zero instead
	           of to one signals to this routine that if the first
	           printing character within the buffer is found to be
	           either  a  comma  or  a  semicolon  then an initial
	           missing word is to be assumed.  The returned  value
	           of  LOWBFR  should be transmitted to the subsequent
	           call to this routine unchanged until  the  line  of
	           text has been completely evaluated.

	  The following argument is used only for output.

	  KIND   = 1, returned if the input text buffer  is  empty  or
	           contains  only  a  comment  indicated  by a leading
	           exclamation point or by a leading ampersand.
	         = 2,  returned  if  this   routine   finds   printing
	           characters   which   are  not  allowed  punctuation
	           characters and which either do not uniquely  select
	           a  word  from  the dictionary, or else which select
	           such a word  but  are  followed  by  an  unexpected
	           character.   This  routine informs the user both of
	           the text containing the error and of  the  list  of
	           currently   allowed   words.   LOWBFR  is  returned
	           pointing to the character to the immediate right of
	           the character sequence containing the error.
	         = 3, an extra comma or semicolon indicates a  missing
	           item.
	         = 4 or greater, KIND is 3 plus the sequence number of
	           the   matched  word  in  the  dictionary.   If  the
	           dictionary contains only  the  words  YES,  NO  and
	           MAYBE,  and  if the word NO was detected, then KIND
	           would be returned containing 3+2 or 5.

	  The GETWRD routine is listed below.

	        SUBROUTINE GETWRD(IPACKD,IBUFFR,MAXBFR,LOWBFR,KIND  )
	        DIMENSION IPACKD(100),IBUFFR(MAXBFR),KNTLTR(20),
	       1IWORD(100)
	        DATA ITTY,LMTWRD,LMTKNT/5,100,20/
	        DATA IWHAT/1H?/
	  C
	  C     CONSTRUCT A1 FORMAT DICTIONARY
	        MAXWRD=0
	        MAXKNT=0
	  FASP, FORTRAN Alphameric Subroutine Package         Page 507
	  DAVERB, Routine to Identify Words and Word Abbreviations


	        CALL A5TOA1(IPACKD,100,LMTWRD,LMTKNT,MAXWRD,MAXKNT,
	       1IWORD,KNTLTR)
	  C
	  C     MATCH USER TYPED TEXT AGAINST A1 FORMAT DICTIONARY
	        MANY=1
	        IF(LOWBFR.GT.0)GO TO 1
	        LOWBFR=1
	        MANY=0
	      1 LOCK=MANY
	        CALL DALOSS(1,MAXWRD,IWORD,1,MAXKNT,
	       1KNTLTR,IBUFFR,MAXBFR,LOWBFR,KIND,MATCH,LCNWRD,
	       2LCNKNT,LCNBFR,MANY,LCNERR)
	        GO TO(5,6,12,12,6,6,6,6,2,4,11),KIND
	  C
	  C     TREAT SEMICOLON LIKE COMMA
	      2 IF(LOCK.EQ.0)GO TO 3
	        MANY=-1
	        GO TO 1
	      3 LOWBFR=LOWBFR-1
	        GO TO 11
	  C
	  C     BUFFER IS EMPTY
	      4 IF(MANY.LT.0)GO TO 11
	      5 KIND=1
	        GO TO 13
	  C
	  C     UNKNOWN INITIAL CHARACTER
	      6 LOWBFR=LCNERR
	        LCNERR=LCNERR-1
	        KIND=2
	        WRITE(ITTY,7)IWHAT,(IBUFFR(I),I=LCNBFR,LCNERR),IWHAT
	      7 FORMAT(' ILLEGAL RESPONSE ',132A1)
	        WRITE(ITTY,8)
	      8 FORMAT(' RESPOND WITH ONE OF FOLLOWING')
	        LTREND=0
	        KNTEND=0
	      9 KNTEND=KNTEND+1
	        IF(KNTEND.GT.MAXKNT)GO TO 13
	        LTRBGN=LTREND+1
	        LTREND=LTREND+KNTLTR(KNTEND)
	        WRITE(ITTY,10)(IWORD(I),I=LTRBGN,LTREND)
	     10 FORMAT(3X,132A1)
	        GO TO 9
	  C
	  C     MISSING WORD
	     11 KIND=3
	        GO TO 13
	  C
	  C     CORRECT MATCH FOUND
	     12 KIND=MATCH+3
	  C
	  C     RETURN TO CALLING PROGRAM
	     13 RETURN
	        END
	  FASP, FORTRAN Alphameric Subroutine Package         Page 508
	  Appendix A: Program to Verify Routines Copied from Listings


	  Appendix A: Program to Verify Routines Copied from Listings
	  -------- -  ------- -- ------ -------- ------ ---- --------

	  CHKSUM is a FORTRAN program which lists FORTRAN programs and
	  routines, generating a checksum for each noncomment line and
	  for each column excluding  the  characters  in  the  comment
	  lines.   The checksums are the least significant 5 digits in
	  the sums of the products of the line or column counts  times
	  numbers  identifying  each  character.   The  characters are
	  identified  by  the  numbers  0  for  the  space  (and   tab
	  character),  1  through  26  for the letters A through Z, 27
	  through 36 for the digits 0 through 9, and 37 through 45 for
	  the  characters + - * / = ( ) . and , respectively, with any
	  additional characters  being  assigned  successively  higher
	  numbers   in   the  order  in  which  these  characters  are
	  encountered.   The  file  being  read  can  contain  several
	  programs  and/or  routines which must be written in standard
	  card format.  If the end of file test (END= transfer in  the
	  READ  statement)  is  not  available,  then the END= must be
	  removed from the CHKSUM program and each input  file  should
	  then be terminated by an additional END statement which will
	  not be copied into the output file.  It is expected that tab
	  characters  will  appear rarely if ever.  Tab characters are
	  treated as single spaces in forming the  checksums  and  are
	  converted  to  single spaces in the listing, but an asterisk
	  is displayed in the listing to the left  of  each  line  and
	  below each column containing tab characters.

	  Comment lines in which the only printing  character  is  the
	  initial  letter  C  are not included in the listing.  At the
	  start of the program or routine, only the first  2  comments
	  with  printing characters to the right of the initial letter
	  C are copied into the listing since initial  comments  often
	  duplicate  the  instruction  manual.   A  comment line which
	  contains a printing character in column 2 and which  appears
	  just  before the END statement is treated specially.  When a
	  program or routine is first read by this program, a  comment
	  line  which  contains  a  printing character in column 2 and
	  which specifies a cumulative  line  checksum,  a  cumulative
	  column checksum, and a list of characters which did not have
	  predefined codes is inserted into the listing just prior  to
	  the  END statement.  The cumulative checksums each contain 6
	  digits and do  not  include  a  representation  of  the  END
	  statement.   When  the CHKSUM program processes a program or
	  routine which has been typed  from  the  listing  and  which
	  includes  the  final  comment  line  defining  the  expected
	  checksums, then  the  contents  of  this  comment  line  are
	  compared  with  those  which  are  expected  based  upon the
	  characters then in the program or routine.  If the  contents
	  of  this  final comment line are not as expected, then a new
	  final comment line specifying the checksums  actually  found
	  is written just before the END statement.  If the cumulative
	  checksums are incorrect, then "CHKSM ERROR"  is  written  at
	  the  lower  left  corner of the listing, and the user should
	  FASP, FORTRAN Alphameric Subroutine Package         Page 509
	  Appendix A: Program to Verify Routines Copied from Listings


	  compare the individual line and column checksums in the  new
	  listing  with  those  in  the original listing to locate the
	  lines  and  columns  which  contain  the  errors.   If   the
	  checksums   are  correct  but  the  list  of  characters  is
	  incorrect (as could happen if a  character  which  does  not
	  have   a   predefined  code  appears  once  in  the  FORTRAN
	  statements but is copied incorrectly either there or on  the
	  final  comment line), then "SYMBL ERROR" is written instead.
	  The word VALID is written at the lower left  corner  of  the
	  listing if no errors are found.

	  A listing produced by the CHKSUM  program  is  shown  below.
	  The  routine  did not include a checksum comment line before
	  the END statement, so neither of the words VALID  nor  ERROR
	  appears at the lower left corner of the listing.
	  16802       SUBROUTINE LENGTH(IBUFFR,MAXBFR,MAXPRT)
	        C     ROUTINE TO FIND RIGHTMOST PRINTING CHARACTER
	   6377       DIMENSION IBUFFR(MAXBFR)
	   7662*      DATA ISPACE,ITAB/1H ,1H /
	   3839       MAXPRT=MAXBFR+1
	   4491     1 MAXPRT=MAXPRT-1
	   7156       IF(MAXPRT.LE.0)GO TO 2
	  13905       IF(IBUFFR(MAXPRT).EQ.ISPACE)GO TO 1
	  12998       IF(IBUFFR(MAXPRT).EQ.ITAB)GO TO 1
	   1067     2 RETURN
	        C074297017153
	    183       END
	                                     *
	        000040521548644133888498238432139452113121124
	            0 023705504181720041392152872417384 26803
	            1 72673102428006247205019488 5 1852 0
	                6      4
	  If the routine is retyped from the listing  and  reprocessed
	  by  CHKSUM,  but  with the letter O replacing the digit 0 in
	  the first IF statement, then the new listing would be
	  16802       SUBROUTINE LENGTH(IBUFFR,MAXBFR,MAXPRT)
	        C     ROUTINE TO FIND RIGHTMOST PRINTING CHARACTER
	   6377       DIMENSION IBUFFR(MAXBFR)
	   7662*      DATA ISPACE,ITAB/1H ,1H /
	   3839       MAXPRT=MAXBFR+1
	   4491     1 MAXPRT=MAXPRT-1
	   6916       IF(MAXPRT.LE.O)GO TO 2
	  13905       IF(IBUFFR(MAXPRT).EQ.ISPACE)GO TO 1
	  12998       IF(IBUFFR(MAXPRT).EQ.ITAB)GO TO 1
	   1067     2 RETURN
	        C074297017153
	        C074057017081
	    183       END
	                                     *
	  CHKSM 000040521548644133878498238432139452113121124
	  ERROR     0 023705504181750041392152872417384 26803
	            1 72673102428004247205019488 5 1852 0
	                6      4
	  FASP, FORTRAN Alphameric Subroutine Package         Page 510
	  Appendix A: Program to Verify Routines Copied from Listings


	  Input/output formats are selected  by  the  variables  named
	  KMPR,  KOPY,  LEAD  and NULL within the CHKSUM program.  The
	  supplied values of KMPR=0, KOPY=2, LEAD=2 and NULL=1 specify
	  listings  of  the  sort described and shown on the preceding
	  pages.  Checksum comment lines are always  inserted  at  the
	  end  of  the  routines  and  programs  which  do not contain
	  correct checksum comment lines, but if KMPR, KOPY, LEAD  and
	  NULL  are all set to zero, then the routines and programs in
	  the input file will be copied with no  other  changes.   The
	  variables which can be changed are described below.

	  IDSK = number of the input device from  which  the  programs
	         and routines to be processed are read.

	  ILPT = unit number to which the copies of or listings of the
	         programs and routines are written.

	  ITAB = defined in a DATA  statement  in  the  program  as  a
	         single Hollerith tab character.  If the tab character
	         is not available, then ITAB should instead be defined
	         as a single Hollerith space character.

	  KMPR = -1, each non-comment line in the input  file  has  to
	         its  right  a  5-digit checksum in columns 73 through
	         77.  If this line checksum  is  incorrect,  then  the
	         output  file  will contain 5 asterisks to the left of
	         the line containing the error if KOPY is greater than
	         zero,  or  to  its  right in columns 73 through 77 if
	         KOPY is less than or equal to zero.
	       = 0, the input file does not  contain  a  checksum  for
	         each non-comment line.
	       = 1, each non-comment line in the input file has to its
	         left a 5-digit checksum followed by a character which
	         is ignored.  If this line checksum is incorrect, then
	         the  output file will contain 5 asterisks to the left
	         of the line containing the error if KOPY  is  greater
	         than  zero,  or to its right in columns 73 through 77
	         if KOPY is less than or equal to zero.  Each  comment
	         line  in  the input file has to its left 6 characters
	         which are ignored.  This input  format  results  when
	         routines  and/or  programs  are  typed  from listings
	         which were  produced  by  the  CHKSUM  program.   The
	         column   checksums   which   appear  in  the  listing
	         following the END statements need not be included  in
	         the input file and are ignored if found.
	       = 2, similar to KMPR=1, except that the first character
	         is  ignored  in  each  line which is read.  A listing
	         file produced by this program  using  KOPY=2  can  be
	         processed using this value of KMPR.

	  KOPY = -1, a checksum  is  to  be  included  in  columns  73
	         through  77  to the right of each non-comment line in
	         the output  file.   All  tab  characters  are  copied
	         intact.  Column checksums are not generated following
	  FASP, FORTRAN Alphameric Subroutine Package         Page 511
	  Appendix A: Program to Verify Routines Copied from Listings


	         the END statements.   The  output  file  conforms  to
	         FORTRAN format standards and can be compiled.
	       = 0, the individual lines of the programs and  routines
	         are  not  to  bear checksums in the output file.  All
	         tab characters are copied intact.   Column  checksums
	         are  not generated following the END statements.  The
	         output file conforms to FORTRAN format standards  and
	         can be compiled.
	       = 1, a 5-digit checksum and a separating space  are  to
	         be  inserted  to the left of each non-comment line in
	         the output file.  Six spaces are inserted to the left
	         of  each  comment  line  in the output file.  All tab
	         characters are copied intact.  Column  checksums  are
	         not generated following the END statements.
	       = 2, a listing of the  programs  and  routines  in  the
	         input  file  is  to  be  created.   Each  line in the
	         listing will begin  with  a  space  as  the  carriage
	         control  character.   All  tab  characters in FORTRAN
	         statements in the input file are changed  to  spaces.
	         Line checksums appear to the left of each non-comment
	         line, and column checksums  are  generated  following
	         the END statements.

	  LEAD = greater than zero, LEAD  is  the  maximum  number  of
	         comment lines at the start of each routine or program
	         in the input file which are to  be  copied  into  the
	         output  file.   Comment lines are considered to be at
	         the start of a routine or program if they precede the
	         first  FORTRAN  statement,  or, when no comment lines
	         appear before the first FORTRAN  statement,  if  they
	         appear   between   the   first   and  second  FORTRAN
	         statements.  If NULL has the value 0, then this  also
	         includes  comment lines in which the initial letter C
	         is the only printing character.
	       = 0, all comment lines which are at the  start  of  the
	         routine  or  program  and  which contain at least one
	         printing character other than the  initial  letter  C
	         are  to be copied into the output file.  If NULL also
	         has the value 0, then all comment lines are copied.

	  NULL = 0, comment lines which contain no printing characters
	         other  than the initial letter C are to be treated in
	         the same manner as any other comment lines.
	       = 1, comment lines which contain no printing characters
	         other than the initial letter C are not copied.
	  FASP, FORTRAN Alphameric Subroutine Package         Page 512
	  Appendix A: Program to Verify Routines Copied from Listings


	  The CHKSUM program, as listed by itself, is shown below.

	        C     RENBR(CHKSUM/CHECKSUM LISTER AND VERIFIER)
	        C     DONALD BARTH, HARVARD BUSINESS SCHOOL
	  35697       DIMENSION KODE(100),IBFR(80),JBFR(72),KLMSUM(72)
	  29164      1,KLMTAB(72),LTREND(3),IDIGIT(10),KOMMON(45)
	  14403       EQUIVALENCE(KODE(1),KOMMON(1))
	  20624       DATA KMPR,KOPY,LEAD,NULL,IDSK,ILPT,INITAL/
	   8427      10,2,2,1,1,20,45/
	  30835       DATA KOMMON/1HA,1HB,1HC,1HD,1HE,1HF,1HG,1HH,1HI,
	  36410      11HJ,1HK,1HL,1HM,1HN,1HO,1HP,1HQ,1HR,1HS,1HT,1HU,
	  40880      21HV,1HW,1HX,1HY,1HZ,1H0,1H1,1H2,1H3,1H4,1H5,1H6,
	  45080      31H7,1H8,1H9,1H+,1H-,1H*,1H/,1H=,1H(,1H),1H.,1H,/
	   8408       DATA LTREND/1HE,1HN,1HD/
	  39186       DATA IDIGIT/1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,
	   1152      11H9/
	  25822*      DATA ISTAR,KOMENT,ISPACE,ITAB/1H*,1HC,1H ,1H /
	        C     GENERAL INPUT AND OUTPUT FORMATS
	   3552     1 FORMAT(80A1)
	   5939     2 FORMAT(72A1,1I5)
	   5525     3 FORMAT(6X,72A1)
	   5544     4 FORMAT(7X,72A1)
	   8197     5 FORMAT(1I5,1X,72A1)
	   7480     6 FORMAT(1X,I5,73A1)
	   9500     7 FORMAT(1X,6HVALID ,72A1)
	  10102     8 FORMAT(1X,6HERROR ,72A1)
	   9984     9 FORMAT(1X,6HSYMBL ,72A1)
	   9762    10 FORMAT(1X,6HCHKSM ,72A1)
	  12526    11 FORMAT(1X,5H*****,73A1)
	  12441    12 FORMAT(5H*****,1X,72A1)
	  10097    13 FORMAT(72A1,5H*****)
	   6588    14 FORMAT(1X/1X/1X)
	  22827    15 FORMAT(7X,1HC,1I6,24H ROUTINES CONTAIN ERRORS)
	        C     PREPARE FOR FIRST ROUTINE
	   1586       KIND=-1
	   1744       KNTERR=0
	   7283       IF(KMPR.LT.0)GO TO 18
	   7103       IF(KMPR.EQ.0)GO TO 17
	   7094       IF(KMPR.EQ.1)GO TO 16
	   1529       KMPBGN=2
	   1572       KMPEND=6
	   1570       LINBGN=8
	   2083       LINEND=79
	   2187       INPUT=79
	   1402       GO TO 19
	   1792    16 KMPBGN=1
	   1558       KMPEND=5
	   1556       LINBGN=7
	   2068       LINEND=78
	   2173       INPUT=78
	   1402       GO TO 19
	   1754    17 LINBGN=1
	   1978       LINEND=72
	   2089       INPUT=72
	  FASP, FORTRAN Alphameric Subroutine Package         Page 513
	  Appendix A: Program to Verify Routines Copied from Listings


	   1402       GO TO 19
	   1759    18 LINBGN=1
	   1978       LINEND=72
	   2049       KMPBGN=73
	   2096       KMPEND=77
	   2159       INPUT=77
	        C     PREPARE FOR NEXT ROUTINE TO BE LISTED
	   2493    19 KNOWN=INITAL
	   1357       MOST=0
	   1697       LINKNT=0
	   1175       LONG=0
	   1443       LINCHK=0
	   1451       KLMCHK=0
	   4810       DO 20 KLMN=1,72
	   4286       KLMSUM(KLMN)=0
	   4806    20 KLMTAB(KLMN)=ISPACE
	        C     READ NEXT LINE AND FIND RIGHT PRINTING CHARACTER
	  23853    21 READ(IDSK,1,END=46)(IBFR(I),I=1,INPUT)
	   2896       MORE=LINEND+1
	   2897    22 MORE=MORE-1
	   8501       IF(MORE.LT.LINBGN)GO TO 21
	  12244       IF(IBFR(MORE).EQ.ISPACE)GO TO 22
	   2682       LESS=MORE+1
	   3046    23 LESS=LESS-1
	   8575       IF(LESS.LT.LINBGN)GO TO 21
	  12376       IF(IBFR(LESS).EQ.ISPACE)GO TO 23
	  11491       IF(IBFR(LESS).EQ.ITAB)GO TO 23
	  14121       IF(IBFR(LINBGN).NE.KOMENT)GO TO 38
	   8517       IF(LESS.EQ.LINBGN)GO TO 33
	   6578       IF(KIND.LT.0)KIND=1
	  15398       IF(IBFR(LINBGN+1).EQ.ISPACE)GO TO 34
	  14425       IF(IBFR(LINBGN+1).EQ.ITAB)GO TO 34
	        C     TEST IF CHECKSUMMED COMMENT IS CORRECT
	   1718       KLMN=LINBGN
	   2123       IVALUE=LINCHK
	   3138       DO 26 J=1,2
	   1577       JVALUE=0
	   3182       DO 25 I=1,6
	   2629       KLMN=KLMN+1
	   8020       IF(KLMN.GT.LESS)GO TO 30
	   3598       DO 24 K=1,10
	  15909       IF(IBFR(KLMN).NE.IDIGIT(K))GO TO 24
	   8802       JVALUE=(10*JVALUE)+K-1
	   1359       GO TO 25
	   1348    24 CONTINUE
	   1302       GO TO 30
	   1353    25 CONTINUE
	   9515       IF(IVALUE.NE.JVALUE)GO TO 30
	   2419    26 IVALUE=KLMCHK
	   6674       ITEST=KLMN+KNOWN-INITAL
	  10915       IF(ITEST.GT.LINEND)ITEST=LINEND
	   8721       IF(LESS.NE.ITEST)GO TO 28
	   1132       I=INITAL
	   1436    27 I=I+1
	  FASP, FORTRAN Alphameric Subroutine Package         Page 514
	  Appendix A: Program to Verify Routines Copied from Listings


	   7161       IF(I.GT.KNOWN)GO TO 32
	   2629       KLMN=KLMN+1
	  14838       IF(IBFR(KLMN).EQ.KODE(I))GO TO 27
	   6947    28 IF(LEAD.LE.0)GO TO 29
	   7195       IF(KIND.GT.LEAD)GO TO 21
	   1558    29 LAST=2
	   1386       GO TO 36
	   6721    30 IF(LEAD.LE.0)GO TO 31
	   7195       IF(KIND.GT.LEAD)GO TO 21
	   1534    31 LAST=3
	   1386       GO TO 36
	   1503    32 LAST=0
	   1400       GO TO 37
	        C     COMMENT HAVING SPACE OR TAB IN COLUMN 2
	   7307    33 IF(NULL.GT.0)GO TO 21
	   6578       IF(KIND.LT.0)KIND=1
	   6849    34 IF(LEAD.LE.0)GO TO 35
	   7195       IF(KIND.GT.LEAD)GO TO 21
	   2014    35 LAST=-1
	   9000    36 IF(KIND.GT.0)KIND=KIND+1
	        C     OUTPUT COMMENT LINE
	  27860    37 IF(KOPY.GT.1)WRITE(ILPT,4)(IBFR(I),I=LINBGN,
	   1126      1LESS)
	  27461       IF(KOPY.EQ.1)WRITE(ILPT,3)(IBFR(I),I=LINBGN,
	   1126      1LESS)
	  27294       IF(KOPY.LE.0)WRITE(ILPT,1)(IBFR(I),I=LINBGN,
	   1126      1LESS)
	   1303       GO TO 21
	        C     CHECK FOR COLUMN CHECKSUMS IN INPUT FILE
	   6902    38 IF(KIND.GE.0)GO TO 41
	   5922       DO 40 KLMN=LINBGN,LESS
	   4641       LETTER=IBFR(KLMN)
	   9319       IF(LETTER.EQ.ISPACE)GO TO 40
	   9484       IF(LETTER.EQ.ISTAR)GO TO 40
	   3637       DO 39 I=1,10
	  12520       IF(LETTER.EQ.IDIGIT(I))GO TO 40
	   1377    39 CONTINUE
	   1329       GO TO 41
	   1336    40 CONTINUE
	   1303       GO TO 21
	        C     TEST FOR END STATEMENT
	   3256    41 KLMN=LINBGN+5
	  12317       IF(IBFR(KLMN).EQ.ISPACE)GO TO 42
	  11430       IF(IBFR(KLMN).EQ.ITAB)GO TO 42
	  16509       IF(IBFR(KLMN).EQ.IDIGIT(1))GO TO 42
	   6714       IF(KIND.GE.0)GO TO 54
	   1371       GO TO 44
	   2235    42 LTRTST=0
	   2903    43 KLMN=KLMN+1
	   8169       IF(KLMN.GT.LESS)GO TO 44
	  12355       IF(IBFR(KLMN).EQ.ISPACE)GO TO 43
	  11466       IF(IBFR(KLMN).EQ.ITAB)GO TO 43
	   4734       LTRTST=LTRTST+1
	  20672       IF(IBFR(KLMN).NE.LTREND(LTRTST))GO TO 44
	  FASP, FORTRAN Alphameric Subroutine Package         Page 515
	  Appendix A: Program to Verify Routines Copied from Listings


	   8605       IF(LTRTST.LT.3)GO TO 43
	   8121       IF(KLMN.EQ.LESS)GO TO 45
	   6966    44 IF(KIND.GE.0)GO TO 53
	   1102       KIND=1
	   1384       GO TO 54
	        C     CONSTRUCT CHECKSUMMED COMMENT IF NONE OR WRONG
	   1870    45 KIND=-1
	   8534    46 IF(LINKNT.EQ.0)GO TO 78
	   7012       IF(LAST.EQ.0)GO TO 52
	   3633       JBFR(1)=KOMENT
	   1217       KLMN=1
	   2123       IVALUE=LINCHK
	   3191       DO 49 J=1,2
	   1577       JVALUE=0
	   3224       DO 47 I=1,6
	   4584       LFTOVR=IVALUE/10
	  20157       JVALUE=(10*JVALUE)+IVALUE-(10*LFTOVR)
	   3057    47 IVALUE=LFTOVR
	   3235       DO 48 I=1,6
	   4598       LFTOVR=JVALUE/10
	  12138       JDIGIT=JVALUE-(10*LFTOVR)+1
	   2770       JVALUE=LFTOVR
	   2629       KLMN=KLMN+1
	   8364    48 JBFR(KLMN)=IDIGIT(JDIGIT)
	   2442    49 IVALUE=KLMCHK
	   1132       I=INITAL
	   1413    50 I=I+1
	   7187       IF(I.GT.KNOWN)GO TO 51
	   7621       IF(KLMN.GE.72)GO TO 51
	   2629       KLMN=KLMN+1
	   5678       JBFR(KLMN)=KODE(I)
	   1328       GO TO 50
	  30716    51 IF(KOPY.GT.1)WRITE(ILPT,4)(JBFR(I),I=1,KLMN)
	  30339       IF(KOPY.EQ.1)WRITE(ILPT,3)(JBFR(I),I=1,KLMN)
	  30172       IF(KOPY.LE.0)WRITE(ILPT,1)(JBFR(I),I=1,KLMN)
	   8070    52 IF(KIND.EQ.-1)GO TO 55
	   1354       GO TO 70
	        C     IDENTIFY CHARACTERS AND CONSTRUCT CHECK SUMS
	   1368    53 KIND=0
	   2017    54 LAST=-1
	   4281    55 LINKNT=LINKNT+1
	   1883       LINTAB=ISPACE
	   1770       LINSUM=0
	   1705       KLMKNT=0
	   5830       DO 62 KLMN=LINBGN,MORE
	   4016       KLMKNT=KLMKNT+1
	   4641       LETTER=IBFR(KLMN)
	   9453       IF(LETTER.EQ.ISPACE)GO TO 62
	   8614       IF(LETTER.EQ.ITAB)GO TO 61
	   1812       NEWLTR=0
	   4600    56 NEWLTR=NEWLTR+1
	  10232       IF(NEWLTR.GT.KNOWN)GO TO 57
	  14770       IF(KODE(NEWLTR).NE.LETTER)GO TO 56
	   1440       GO TO 58
	  FASP, FORTRAN Alphameric Subroutine Package         Page 516
	  Appendix A: Program to Verify Routines Copied from Listings


	   3866    57 KNOWN=KNOWN+1
	   5042       KODE(KNOWN)=LETTER
	  12323    58 LINSUM=LINSUM+(KLMKNT*NEWLTR)
	   7001       IF(KIND.LT.0)GO TO 62
	  26412       KLMSUM(KLMKNT)=KLMSUM(KLMKNT)+(LINKNT*NEWLTR)
	  11149       KLMCHK=KLMCHK+(LINKNT*NEWLTR)
	  19308    59 IF(KLMSUM(KLMKNT).LT.100000)GO TO 60
	  19758       KLMSUM(KLMKNT)=KLMSUM(KLMKNT)-100000
	   1454       GO TO 59
	  12970    60 IF(KLMCHK.LT.1000000)GO TO 62
	   7336       KLMCHK=KLMCHK-1000000
	   1341       GO TO 60
	  11980    61 IF(KOPY.GT.1)IBFR(KLMN)=ISPACE
	   5761       KLMTAB(KLMKNT)=ISTAR
	  10724       IF(LONG.LT.KLMKNT)LONG=KLMKNT
	   2122       LINTAB=ISTAR
	   1354    62 CONTINUE
	  11487       IF(MOST.LT.KLMKNT)MOST=KLMKNT
	   4827       LINCHK=LINCHK+LINSUM
	  13044    63 IF(LINCHK.LT.1000000)GO TO 64
	   7313       LINCHK=LINCHK-1000000
	   1383       GO TO 63
	  12637    64 IF(LINSUM.LT.100000)GO TO 65
	   7455       LINSUM=LINSUM-100000
	   1397       GO TO 64
	        C     DETERMINE IF CHECKSUM ON LINE IS CORRECT
	   7552    65 IF(KMPR.EQ.0)GO TO 68
	   1570       IVALUE=0
	   6353       DO 67 KLMN=KMPBGN,KMPEND
	   3634       DO 66 I=1,10
	  16089       IF(IBFR(KLMN).NE.IDIGIT(I))GO TO 66
	   8725       IVALUE=(10*IVALUE)+I-1
	   1439       GO TO 67
	   1374    66 CONTINUE
	   1379    67 CONTINUE
	  10363       IF(IVALUE.EQ.LINSUM)GO TO 68
	   8060       IF(IVALUE.EQ.0)GO TO 68
	  26943       IF(KOPY.GT.1)WRITE(ILPT,11)LINTAB,(IBFR(I),
	   3639      1I=LINBGN,MORE)
	  28739       IF(KOPY.EQ.1)WRITE(ILPT,12)(IBFR(I),I=LINBGN,
	   1064      1MORE)
	  28666       IF(KOPY.LE.0)WRITE(ILPT,13)(IBFR(I),I=LINBGN,
	   1261      1LINEND)
	   1467       GO TO 69
	        C     OUTPUT THIS LINE OF FORTRAN TEXT
	  22102    68 IF(KOPY.GT.1)WRITE(ILPT,6)LINSUM,LINTAB,
	   8402      1(IBFR(I),I=LINBGN,MORE)
	  26853       IF(KOPY.EQ.1)WRITE(ILPT,5)LINSUM,(IBFR(I),
	   3639      1I=LINBGN,MORE)
	  27381       IF(KOPY.EQ.0)WRITE(ILPT,1)(IBFR(I),I=LINBGN,
	   1064      1MORE)
	  27565       IF(KOPY.LT.0)WRITE(ILPT,2)(IBFR(I),I=LINBGN,
	   3454      1LINEND),LINSUM
	   6867    69 IF(KIND.GE.0)GO TO 21
	  FASP, FORTRAN Alphameric Subroutine Package         Page 517
	  Appendix A: Program to Verify Routines Copied from Listings


	        C     CONSTRUCT CHECKSUM TOTALS BELOW COLUMNS
	  12214    70 IF(LAST.GT.0)KNTERR=KNTERR+1
	   7303       IF(KOPY.LE.1)GO TO 77
	  31606       IF(LONG.GT.0)WRITE(ILPT,4)(KLMTAB(I),I=1,LONG)
	  11986       IF(LONG.EQ.0)WRITE(ILPT,4)
	   5046       DO 72 KLMN=1,MOST
	   5727       IVALUE=KLMSUM(KLMN)
	   1591       JVALUE=1
	   4860    71 LFTOVR=IVALUE/10
	  15885       JVALUE=(10*(JVALUE-LFTOVR))+IVALUE
	   2763       IVALUE=LFTOVR
	   7973       IF(IVALUE.GT.0)GO TO 71
	   5616    72 KLMSUM(KLMN)=JVALUE
	   1461    73 LONG=0
	   5079       DO 75 KLMN=1,MOST
	   5660       JDIGIT=KLMSUM(KLMN)
	   7980       IF(JDIGIT.GT.1)GO TO 74
	   4555       KLMTAB(KLMN)=ISPACE
	   1424       GO TO 75
	   4731    74 LFTOVR=JDIGIT/10
	  11980       JDIGIT=JDIGIT-(10*LFTOVR)+1
	   5875       KLMSUM(KLMN)=LFTOVR
	   9026       KLMTAB(KLMN)=IDIGIT(JDIGIT)
	   1531       LONG=KLMN
	   1373    75 CONTINUE
	   7010       IF(LONG.LE.0)GO TO 76
	  31756       IF(LAST.LT.0)WRITE(ILPT,4)(KLMTAB(I),I=1,LONG)
	  31696       IF(LAST.EQ.0)WRITE(ILPT,7)(KLMTAB(I),I=1,LONG)
	  31745       IF(LAST.EQ.1)WRITE(ILPT,8)(KLMTAB(I),I=1,LONG)
	  31794       IF(LAST.EQ.2)WRITE(ILPT,9)(KLMTAB(I),I=1,LONG)
	  32925       IF(LAST.EQ.3)WRITE(ILPT,10)(KLMTAB(I),I=1,LONG)
	   7854       IF(LAST.LE.1)LAST=-1
	   7023       IF(LAST.GT.0)LAST=1
	   1396       GO TO 73
	   5009    76 WRITE(ILPT,14)
	   8107    77 IF(KIND.EQ.-1)GO TO 19
	   8553    78 IF(KNTERR.LE.0)GO TO 79
	  18075       IF(KOPY.GT.1)WRITE(ILPT,15),KNTERR
	   1826    79 ENDFILE ILPT
	    588       STOP
	        C398993428599
	    183       END
	                                                          *
	  VALID 000445663413667234416441951158843631332962582346694611
	           689475201587047869826639125427572846518981628485338
	           796924233646001894585241200520045176521484938178344
	           511398734598041905024462442983817228963367565077253
	           170 12 4 65 84570916 544  9242 9297 700843  512813
