


  





                  Fortran-20 -- Changes from V7 to V10


                                May 1985















    Copyright (c) 1985, Digital Equipment Corporation, Maynard, Mass., USA

         This software is furnished under a license and  may  be  used  and
    copied  only  in accordance with the terms of such license and with the
    inclusion of the above copyright notice.  This software  or  any  other
    copies  thereof  may not be provided or otherwise made available to any
    other person.  No title to and ownership  of  the  software  is  hereby
    transferred.

         The information in this software  is  subject  to  change  without
    notice and should not be construed as a commitment by Digital Equipment
    Corporation.

         Digital assumes no responsibility for the use  or  reliability  of
    its software on equipment which is not supplied by Digital.
   FORTRA.DOC - Fortran-20 Version 10


           1.0     SUMMARY  . . . . . . . . . . . . . . . . . . . . . . 1
           1.1       Bibliography . . . . . . . . . . . . . . . . . . . 2
           1.2       Monitors . . . . . . . . . . . . . . . . . . . . . 2
           1.3       Microcode  . . . . . . . . . . . . . . . . . . . . 3
           1.4       Related System Software  . . . . . . . . . . . . . 3
           2.0     NEW FEATURES . . . . . . . . . . . . . . . . . . . . 4
           2.1       Extended Addressing  . . . . . . . . . . . . . . . 4
           2.1.1       Overview . . . . . . . . . . . . . . . . . . . . 4
           2.1.2       /EXTEND And Applications With Large Arrays . . . 5
           2.1.3       /EXTEND And Applications With Large Executable 
                       Code . . . . . . . . . . . . . . . . . . . . . . 5
           2.1.4       Object Time System Placement . . . . . . . . . . 7
           2.1.5       Syntax Of Compiler Switches For Extended 
                       Addressing . . . . . . . . . . . . . . . . . . . 8
           2.1.6       FORDDT Changes For Extended Addressing . . . . . 9
           2.1.7       Debugging Extended-Addressing Programs With DDT 10
           2.1.8       Linking With TWOSEG REL Files  . . . . . . . .  11
           2.1.9       Listing Formats With /EXTEND . . . . . . . . .  11
           2.2       INQUIRE Statement  . . . . . . . . . . . . . . .  12
           2.2.1       Returned Values  . . . . . . . . . . . . . . .  12
           2.2.2       INQUIRE By Unit  . . . . . . . . . . . . . . .  14
           2.2.3       INQUIRE By File  . . . . . . . . . . . . . . .  14
           2.2.4       Error Processing . . . . . . . . . . . . . . .  16
           2.3       Compatibility Flagger  . . . . . . . . . . . . .  17
           2.3.1       New Command Switches . . . . . . . . . . . . .  17
           2.3.2       Warning Messages . . . . . . . . . . . . . . .  18
           2.4       Support Of Industry-Compatible Magtape . . . . .  19
           2.4.1       TAPEFORMAT Keyword . . . . . . . . . . . . . .  19
           2.4.2       RECORDTYPE Keyword . . . . . . . . . . . . . .  19
           2.4.3       CARRIAGECONTROL Keyword  . . . . . . . . . . .  21
           2.4.4       Implementation Notes . . . . . . . . . . . . .  21
           2.4.5       Reading And Writing Tapes Using Fortran V10  .  22
           2.4.6       Reading And Writing Tapes On VMS . . . . . . .  22
           2.5       Changes In I/O Statements  . . . . . . . . . . .  24
           2.5.1       Changes Incompatible With Version 7  . . . . .  24
           2.5.2       Enhancements To Version 7  . . . . . . . . . .  24
           2.6       Comments Within Continuation Lines . . . . . . .  25
           2.7       Additional Features With The INCLUDE Statement .  25
           2.8       Change To The /DEBUG:ARGUMENTS Switch  . . . . .  25
           2.9       New Bit-Manipulation Routines  . . . . . . . . .  26
           2.10      Changes In The Use Of Octal Constants  . . . . .  27
           2.11      PARAMETER Statements With Expressions Of Type 
                     COMPLEX  . . . . . . . . . . . . . . . . . . . .  27
           2.12      IMPLICIT NONE Statement  . . . . . . . . . . . .  27
           2.13      Octal And Hexadecimal Values In DATA Statements   27
           2.14      PAUSE ON ERROR Command For FORDDT  . . . . . . .  28
           2.15      Changes With The Tops-20 REENTER Command . . . .  28
           3.0     RESTRICTIONS . . . . . . . . . . . . . . . . . . .  29
           3.1       Overlays . . . . . . . . . . . . . . . . . . . .  29
           3.2       DBMS . . . . . . . . . . . . . . . . . . . . . .  29
           4.0     KNOWN BUGS AND DEFICIENCIES  . . . . . . . . . . .  29
           5.0     COMPATIBILITY WITH PREVIOUS VERSIONS . . . . . . .  29
           6.0     INTERNAL CHANGES . . . . . . . . . . . . . . . . .  30
   FORTRA.DOC - Fortran-20 Version 10


   APPENDIX A      OBJECT CODE SEQUENCES FOR EXTENDED ADDRESSING SUPPORT

           A.1     OBJECT CODE TO BE GENERATED INDEPENDENT OF /EXTEND A-1
           A.2     OBJECT CODE SEQUENCES FOR /EXTEND  . . . . . . . . A-1


   APPENDIX B      SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER

           B.1     SOURCE DIFFERENCES . . . . . . . . . . . . . . . . B-1
           B.2     DATA TYPES . . . . . . . . . . . . . . . . . . . . B-2
           B.3     EXPRESSIONS  . . . . . . . . . . . . . . . . . . . B-3
           B.4     SUBROUTINES AND FUNCTION ARGUMENT LISTS  . . . . . B-5
           B.5     SPECIFIC STATEMENTS  . . . . . . . . . . . . . . . B-5
           B.6     FORMAT STATEMENT . . . . . . . . . . . . . . . .  B-10
           B.7     INPUT/OUTPUT STATEMENTS  . . . . . . . . . . . .  B-11
           B.8     INTRINSIC FUNCTIONS AND FORTRAN-SUPPLIED 
                   SUBROUTINES  . . . . . . . . . . . . . . . . . .  B-13
           B.9     FUNCTIONS AND SUBROUTINES ON VMS NOT RECOGNIZED 
                   BY FORTRAN-10/20 . . . . . . . . . . . . . . . .  B-14
   FORTRA.DOC - Fortran-20 Version 10                              Page 1


    1.0  SUMMARY

    Version 10 of Fortran-20  is  a  development  release  of  the  Fortran
    compiler,   FOROTS,  FORLIB  and  FORDDT.   Fortran-20  version  10  is
    validated at the full level of the Fortran-77 standard.

    The major new features include

     o  Support of arrays, character scalars and COMMON blocks larger  than
        256K words.

     o  Support of multiple sections of code.

     o  The INQUIRE statement

     o  A compatibility flagger which optionally detects extensions to  the
        Fortran-77  standard, and incompatibilities with the VAX-11 Fortran
        currently running on the VAX under VMS.

     o  Support of unlabelled  industry-standard  magnetic  tape  (Labelled
        tapes are NOT supported)

     o  Comments may be interspersed with continuation lines.

     o  FORDDT has a PAUSE ON ERROR command which  will  cause  a  trap  to
        FORDDT whenever a runtime error is encountered.


    In addition, changes have been made to features which exist in V7:

     o  The global optimizer may now be used even though there is character
        data present in the program.

     o  The INCLUDE statement has two new options, and may be nested.

     o  Certain I/O statements have  been  changed  in  order  to  be  more
        compatible with the VAX/VMS Fortran.

     o  The IMPLICIT NONE statement has been added.

     o  The PARAMETER  statement  may  contain  expressions  involving  the
        multiplication,  division  and  exponentiation of constants of type
        COMPLEX.

     o  Values in DATA statements may be expressed as Octal or  Hexadecimal
        constants in accordance with MIL-STD-1753.


    This tape contains copies of the version 10  compiler,  FOROTS  (called
    FORO10.EXE), FORLIB and FORDDT.

    Note that you must use LINK version 6.0 (or later) for linking the .REL
    files generated by this version of Fortran.
   FORTRA.DOC - Fortran-20 Version 10                              Page 2


    1.1  Bibliography

    Two copies of each of the following  manuals  are  enclosed  with  this
    release tape.

    The Fortran language and  this  implementation  are  described  in  the
    reference manual:

            TOPS-10/20 Fortran Language Manual - AA-N383B-TK

    The installation procedures for this tape are described in:

            TOPS-20 Fortran Installation Guide - AA-P344B-TM

    There is also a booklet that provides quick reference information about
    Fortran-10/20:

            TOPS-10/20 Fortran Pocket Guide - AA-P529B-TK

    The algorithms and accuracy of the math  routines  in  FORLIB  will  be
    described in:

            TOPS-10/20 Common Math Library Reference Manual - AA-M400A-TK

    Similarities and differences between Fortran-10/20 and VAX/VMS  Fortran
    are described in:

            Fortran-10/20 and VAX Fortran Compatibility Manual -
                    AA-Y868B-TK

    It is recommended that you also refer to

    American National Standard Programming Language FORTRAN
            ANSI X3.9-1978

    Copies of this standard may be obtained from:

            American National Standards Institute
            1430 Broadway
            New York, NY 10018



    1.2  Monitors

    This version of Fortran will run on Tops-20 releases 4.1, 5.1, 6.0  and
    6.1.
   FORTRA.DOC - Fortran-20 Version 10                              Page 3


    1.3  Microcode

    Microcode version 326 (or later) must be  installed  in  order  to  use
    extended addressing.



    1.4  Related System Software

    The following system software must be used with Fortran version 10:
            LINK V6(2364) or later

    The following system software must be used to build Fortran version  10
    from sources:
            BLIS10 V7.5(227)
            MACRO V53.1(1152) or later

    The following optional software may be used with Fortran V10:

            SORT V5 (SORT V4C for 2020)
            DBMS V6
            DIL V2
   FORTRA.DOC - Fortran-20 Version 10                              Page 4


    2.0  NEW FEATURES

    2.1  Extended Addressing

    Fortran-20 version 10 will support programs larger  than  one  section,
    using  the  extended addressing hardware running under Tops-20.  Use of
    Fortran-20's extended addressing facilities requires Microcode  version
    326 or later.



    2.1.1  Overview -

    Support for extended addressing is almost  completely  transparent;   a
    program  compiled  with the /EXTEND switch will use extended addressing
    without requiring new source statements or runtime routines.

    When /EXTEND is specified, arrays and COMMON blocks can  extend  across
    multiple  sections.   Executable  code  can  also  reside  in  multiple
    sections, with the restriction that a single subprogram must not  cross
    a section boundary.

    The /EXTEND switch can  be  specified  without  arguments  to  use  the
    default  extended  address  space  layout,  which  is suitable for most
    applications in which the executable code fits within a single  section
    but  which may employ data structures which require more than a section
    of memory.  When  such  an  application  is  compiled  /EXTEND  without
    further arguments, a default memory layout is used which depends on the
    default size settings for arrays and strings:

            SECTION         PAGES           CONTENTS
            -------         -----           --------
              1             0-477           Executable code
                                            Argument blocks
                                            Literals
                                            Non-COMMON scalars
                                            Non-COMMON arrays smaller than 
                                             10,000 words
                                            Non-COMMON strings smaller than
                                             10,000 words
              1             500-577         FOROTS
              1             600-777         Reserved

             2-31            0-777          COMMON blocks
                                            Arrays larger than 10,000 words
                                            Strings larger than 10,000 words
                                            SORT (if used)

    Additional arguments to /EXTEND ([NO]COMMON:, DATA:, PSECT:, and CODE),
    in  conjunction  with  the  /SET  switch  to  LINK,  can be supplied to
    override these defaults and direct specific placement of COMMON blocks,
    non-COMMON  arrays  and  scalars,  and executable code.  For example, a
    decimal  argument  can  be  specified  for  the  DATA:   keyword  which
    overrides the 10,000 word default minimum size for arrays and character
    scalars.  /EXTEND:COMMON:(name1,name2,...) can be used to direct COMMON
   FORTRA.DOC - Fortran-20 Version 10                              Page 5


    blocks  to the .LARG. psect, and /EXTEND:NOCOMMON:(name3,name4,...) can
    be used to direct COMMON blocks to the small data psect.




    2.1.2  /EXTEND And Applications With Large Arrays -

    The simplest usage of extended addressing is for applications in  which
    the  executable  code fits in one section.  These applications may have
    very large arrays or COMMON blocks.  In many cases, these  applications
    can  be  compiled  with the /EXTEND switch with no arguments, using the
    default memory layout above.  In some cases  it  may  be  desirable  or
    necessary  to  use  the DATA or COMMON arguments to /EXTEND to redirect
    the placement of data areas  when  their  default  placements  are  not
    desired.   Specifying  a  smaller /EXTEND:DATA size may be necessary if
    the total size of non-COMMON scalars and arrays causes them to  overlap
    FOROTS pages.  If such overlap occurs, program execution will terminate
    with the error messages "?Can't get  FORO10.EXE"  and  "?Can't  overlay
    existing  pages".  A smaller DATA size will force these data structures
    into a non-FOROTS section.



    2.1.3  /EXTEND And Applications With Large Executable Code -

    A  more  complex  use  of  extended  addressing  is   one   where   the
    application's  executable  code  is larger than a section.  In order to
    build an application that has more than one section of executable code,
    you have to specify which program units will be placed in each section.

    When /EXTEND is specified, the program will be  in  three  PSECTS,  one
    analogous  to  the  present hiseg, one analogous to the present lowseg,
    and one containing the large variables.  If the user does  not  specify
    the extended addressing switch, Fortran will generate a TWOSEG REL file
    as it always has.  The three PSECTS generated under /EXTEND are:

    1.  The "large data area" (.LARG. psect)  has  a  maximum  size  of  30
        sections.   It will consist of user-specified COMMON blocks, arrays
        and character scalars that are larger than  a  user-specified  size
        (or default).

        There is no restriction on the  size  of  an  individual  array  or
        COMMON block, beyond the restriction on the total size of the large
        data area.

    2.  The "small data area" (default psect  name  .DATA.)  of  a  program
        consists  of  user-specified  COMMON blocks, and scalars and arrays
        that are smaller than  a  user-specified  size  (or  default).   If
        FORDDT is used, it will reside in the .DATA. psect.

    3.  The "executable code and sharable data area"  (default  psect  name
        .CODE.)  of  a  program  consists  of all executable code, argument
        blocks and literals.  Library functions and subroutines used by the
        program  are  placed  in  the .CODE.  psect.  This does not include
   FORTRA.DOC - Fortran-20 Version 10                              Page 6


        space used by SORT, which occupies its own section.

    For  each  "executable  code  area"  (.CODE. psect)  there  will  be  a
    corresponding  "small  data area" (.DATA. psect).  The combined size of
    these two areas must not exceed 256K words.

    The default psect names .DATA. and .CODE. may  be  changed  at  compile
    time by the /EXTEND:PSECT command switch (see 2.1.5).



    2.1.3.1  /EXTEND And /NOEXTEND PSECT Placement -

                                Kind of data

         What                         /NOEXTEND          /EXTEND
         ====                         ============       =========
         User subprogram (and FORLIB)
                       instructions   Hiseg              .CODE.
         Argument blocks              Hiseg              .CODE.
         CTC character descriptors    Hiseg              .CODE.
         Array dimension information  Hiseg              .CODE.
         EFIWs                        N/A                .CODE.
         Symbol tables (From LINK)    Lowseg or Hiseg    .DATA. (by default)
         FORMAT statements            Lowseg             .DATA.
         Constants, Literals          Lowseg             .DATA.
         Small arrays, scalars        Lowseg             .DATA.
         Large arrays                 Lowseg             .LARG.
         COMMON variables             Lowseg             .LARG. (by default)
         Variables EQUIVALENCED to
                   large arrays, etc  Lowseg             .LARG.

    The three psects will be set up according to the table below:

         Psect   Default origin  Attributes
         =====   ==============  ==========
         .DATA.  1001000         Single section, Non-zero section,
                                 Concatenated, Writable
         .CODE.  1300000         Single section, Non-zero section,
                                 Concatenated, Read-only
         .LARG.  2000000         Non-zero section, Concatenated, Writable

    Users can alter the default psect origins when loading  their  programs
    by   giving   a   /SET  switch  to  LINK  (See  the  next  section  for
    restrictions).  This may be necessary if a program has too much code or
    local  data  to  fit  in  the regions allocated for them by the default
    psect origins.  This would cause the psects to overlap,  and  would  be
    indicated  by  a LINK warning message (%LNKPOV).  Altering the defaults
    is also useful if the user wants to reserve one or  more  sections  for
    some purpose such as leaving space to load SORT or dynamic libraries at
    runtime.

    The first page (locations 000-777) of any section which  contains  code
    is reserved for use by FORDDT.  The LINK /SET switch should not specify
    a psect origin less than 1000 for any such section.
   FORTRA.DOC - Fortran-20 Version 10                              Page 7


    2.1.3.2  Building Large-Code Applications -

    When compiling large-code applications,  the  following  considerations
    apply:

    1.  The code and small data psects  for  a  single  program  unit  must
        always  reside  together in the same section, since the PC will not
        advance across sections boundaries, and the generated code  assumes
        that it is in the same section as the small data area.

    2.  You will need to use the /EXTEND:CODE keyword.  This specifies that
        the   object   code  emitted  by  the  compiler  assumes  that  all
        subprograms that it calls may be in a separate section.

    3.  You must also use the PSECT argument  to  /EXTEND  to  specify  the
        PSECT  names  for  code  and  small  data.  If you wish to link the
        program units in  several  different  compilations  (source  files)
        together  in  the same section, you should use the same psect names
        for those program units.

    At link-time, you must specify the  starting  address  for  each  psect
    using the /SET switch, according to the following rules:

    1.  The code and small data psects for a program unit must be linked in
        the same section with each other.

    2.  If a section contains any executable code, page 0 of  that  section
        is reserved for FORDDT.

    3.  You must always allocate space for the .CODE.  and  .DATA.  psects,
        since FORLIB routines will be linked in these psects.

    4.  Pages 500-577 of the section that contains .CODE.  and  .DATA.  are
        reserved for FOROTS.

    5.  You must always allocate space for the .LARG. psect.




    2.1.4  Object Time System Placement -

    The FOROTS object time system consists  of  a  pure  code  segment,  an
    impure  static  data  segment  (initially null) and dynamically created
    pages for user buffers, etc.

    FOROTS will be linked in one of two ways under extended addressing:

    1.  Sharable - The sharable (mapped) object time system is the  default
        way  of using FOROTS.  FORINI will map FOROTS into pages 500:577 of
        the section which contains FORLIB (i.e.  the section which contains
        the .DATA.  and .CODE.  psects).
   FORTRA.DOC - Fortran-20 Version 10                              Page 8


    2.  Nonsharable - If a user specifies /OTS:NONSHARABLE  to  LINK,  then
        FOROTS will be loaded with the user's program at link time.




    2.1.5  Syntax Of Compiler Switches For Extended Addressing -

    Extended addressing support will be invoked by compiler switches.   The
    switches have the following syntax:

         "/EXTEND" [ ":" Key ]
             -or-
         "/EXTEND:(" Key { "," Key } ")"
             -or-
         "/NOEXTEND"

    Key is one of:    ___

         "DATA" [ ":" Decimal_number ]
             -or-
         "NODATA"
             -or-
         [ "NO" ] "COMMON" [ ":" COMMON_block_name ]
             -or-
         [ "NO" ] "COMMON:(" COMMON_block_name { "," COMMON_block_name } ")"
             -or-
         "CODE"
             -or-
         "NOCODE"
             -or-
         "PSECT" [ ":" [data_psect][ ":" code_psect]]


    'Decimal_number' is a non-negative decimal number,  'COMMON_block_name'
    is  a  COMMON block identifier, 'data_psect' is a psect name to be used
    instead of .DATA., and 'code_psect' is a psect name to be used  instead
    of .CODE..

    The DATA keyword has a decimal argument which is the  minimum  size  in
    words  for  non-common  arrays  and  character  scalars  which  will be
    allocated to the .LARG.  psect.  The default is  10000,  which  can  be
    altered  by  changing  a  parameter  and  rebuilding the compiler.  The
    NODATA keyword specifies that all non-common  variables  will  live  in
    .DATA.   It  is  equivalent  to  DATA:1073741823,  which  excludes  all
    variables from .LARG.

    Specifying /EXTEND:COMMON without any common block names will cause all
    common  blocks  to  be  allocated  in  the  .LARG.   psect.  Similarly,
    specifying /EXTEND:NOCOMMON without any names  will  cause  all  common
    blocks  to  be  allocated  in the .DATA.  psect.  If neither keyword is
    specified, /EXTEND:COMMON is the default.
   FORTRA.DOC - Fortran-20 Version 10                              Page 9


    Individual common blocks can be explicitly placed in .LARG.  or  .DATA.
    by  putting  their  names in a list after a COMMON or NOCOMMON keyword.
    This overrides any  defaults.   For  example,  MYFILE/EXTEND:(NOCOMMON,
    COMMON:(FOO,BAR))  means  that common blocks FOO and BAR will reside in
    .LARG.  if they appear in any program unit  in  MYFILE.FOR,  while  any
    other common blocks appearing in MYFILE will be allocated in .DATA.  It
    is illegal to specify the same common block name after  both  a  COMMON
    and  NOCOMMON  keyword in any single compilation.  REL files which have
    any given COMMON block allocated to .LARG.  cannot be loaded  with  REL
    files  which  allocate  that  COMMON  block to .DATA., nor with any REL
    files containing that COMMON block  which  were  compiled  without  the
    /EXTEND switch.

    The CODE keyword specifies that the object code emitted by the compiler
    has to assume that all subprograms that it calls could be in a separate
    section.  The NOCODE keyword allows the compiler to assume that all  of
    the  code  will  be  in  the  same  section.  NOCODE is the default.  A
    program compiled with the NOCODE keyword cannot  call  any  subprograms
    compiled with the CODE keyword.

    The large data psect will always be called  ".LARG.".   However,  users
    may  set  the  code  and  data  psect  names  explicitly with the PSECT
    keyword.  If PSECT is specified with one argument, that  argument  will
    become  the  name  of the "small data area" psect.  Any second argument
    will become the name of the "code" psect.  This allows a  user  to  put
    separate program units in separate psects, and then place the psects in
    different sections with the /SET switch at LINK time.  This provides  a
    rudimentary  ability to load multiple sections of code.  Note, however,
    that the "small data" and "code" psects for any given program unit must
    be loaded into the same memory section.



    2.1.6  FORDDT Changes For Extended Addressing -

    FORDDT V10 has been modified to be able  to  run  in  any  section  and
    access  data and code in all sections.  The user interface to FORDDT is
    the  same  regardless  of  whether  or  not  a  program  uses  extended
    addressing.

    FORDDT V10 is section independent.  The same FORDDT.REL  will  work  in
    either section 0 or a non-zero section.

    If a program is  loaded  with  the  /DEBUG:FORDDT  option,  LINK  loads
    FORDDT.REL  with  the  program.   FORDDT.REL is a single segment module
    (i.e.  it has only low segment code);  therefore, when  loaded  with  a
    Fortran  object  program  that  was  compiled  with the /EXTEND switch,
    FORDDT will by default be redirected to the .DATA.  psect.

    FORDDT V10 is not guaranteed to work with previous versions of Fortran,
    and is not supported in such a configuration.
   FORTRA.DOC - Fortran-20 Version 10                             Page 10


    2.1.7  Debugging Extended-Addressing Programs With DDT -


    1.  The .CODE. psect is created with the 'Readonly' attribute;   before
        break  points are established, the $W command must be used in order
        to allow the psect to be written.

    2.  DDT V43 uses the Program Data Vectors  (PDVs),  which  contain  the
        addresses  of  symbol  tables.   DDT  V43  is fully compatible with
        Fortran V10 extended addressing, and nothing extraordinary need  be
        done to use DDT V43.

    3.  DDT V42 does not understand PDVs;   DDT  V42  instead  expects  the
        address  of  the table to be in location .JBSYM of the JOBDAT area.
        With extended addressing, that .JBSYM location  is  initialized  by
        FORINI   (the   runtime  initialization  routine  used  by  Fortran
        programs), but not until the program has started execution.

        If DDT is initially entered after the  program  has  started  (e.g.
        after  the  program terminates), FORINI will have set up the .JBSYM
        location, and thus DDT will find the symbols without the  need  for
        the work-around described below.

        If DDT is initially entered before  the  start  of  execution,  the
        symbols  will  not  be  found.   This  work-around  for the problem
        assumes that section 1 contains the .DATA./.CODE.  psects  and  the
        main program.  Assume the program to be debugged is named A.EXE:

        a)  @GET A

        b)  With the EXEC INFORMATION (ABOUT) MEMORY-USAGE command, display
            the address of the entry vector (the actual output will vary):
                 @INFORMATION MEMORY-USAGE
                 46 pages, Entry vector loc 1,,4073

        c)  Enter DDT with the EXEC command DDT.

        d)  Examine the entry  vector.   The  first  word  of  that  vector
            contains the address of the start of the program.
                 1,,4073/ JRST 301567

        e)  Use the $W command so that break-points can be set

        f)  Set a break-point at the starting address plus 3  (remember  to
            use  the  section number in the left half of the address), then
            start the program:
                 1,,301567+3$B     $G

        g)  When DDT hits the break-point, examine two locations (1,,116 is
            .JBSYM):
                 1,,116[  776370,,5772
                 1,,770001[  424000,,767712
   FORTRA.DOC - Fortran-20 Version 10                             Page 11


        h)  Enter the contents of 1,,116  (776370,,5772  in  this  example)
            into  the  location  whose  address  is  in  the  right half of
            location 1,,770001:
                 1,,767712[  424000,,767712   776370,,5772

        DDT should now recognize the symbols for program  A.   The  program
        can  now  be  SAVEd,  and  DDT  will recognize the symbols when the
        program is run again.

    4.  As an alternative to the previous item, FORDDT can be  linked  with
        the program.  When the program is started, FORDDT will cause .JBSYM
        to be initialized.  DDT can then be started (via the DDT command to
        FORDDT), and it will find the symbols.




    2.1.8  Linking With TWOSEG REL Files -

    If a main program unit compiled with /EXTEND is linked with  subprogram
    units  (Fortran  or not) which were compiled for non-extended use, then
    LINK will automatically place the LOWSEG of non-extended units  in  the
    .DATA.  psect, and the HISEG of such units into the .CODE.  psect.

    A program compiled with /EXTEND can call  a  subprogram  which  is  not
    compiled  with  /EXTEND;  however, it is illegal for a subprogram which
    is not compiled with /EXTEND to call a subprogram that is.

    Programs that were compiled by old versions of Fortran  (prior  to  V7)
    will not work if loaded in a non-zero section.

    Most  MACRO  routines  written  for  non-extended  use   will   require
    conversion  to run in non-zero sections.  Data structures accessed with
    18-bit address fields, indexed and indirect words, stack  pointers  and
    some  monitor  calls  may  need  modification  to  perform correctly in
    extended sections.  Refer to the  TOPS-20  Monitor  Call  User's  Guide
    (Chapter   8,   "Using   Extended  Addressing")  for  more  information
    concerning extended MACRO programs.



    2.1.9  Listing Formats With /EXTEND -

    When the map of data identifiers is listed,  Fortran  version  10  will
    flag  items  with  a  '!'  if  they are allocated in the .LARG.  psect.
    Fortran will continue to flag unreferenced items with a '%',  and  flag
    items with a '*' if they have no explicit data type.

    If the /MACHINE-CODE compiler switch is  used,  the  generated  machine
    code  is  placed  into the listing file.  References to variables which
    could reside in another memory section will be done through EFIWs,  and
    the machine-code listing will have addresses of the form

            '@[.EFIW LOCAT(INDEX)]'.
   FORTRA.DOC - Fortran-20 Version 10                             Page 12


    2.2  INQUIRE Statement

    The INQUIRE statement is the first language element introduced into the
    FORTRAN  language  intended  to  find out information about files being
    used or potentially being used by a FORTRAN program.  This statement is
    defined in the ANSI X3.9-1978 standard, section 12.10.3.

    There are 2 forms of the INQUIRE statement, INQUIRE by file and INQUIRE
    by unit.

    An INQUIRE by file is a INQUIRE statement containing a  FILE=  keyword,
    an  associated  file  specification,  and  no  UNIT=  keyword.   It  is
    therefore used for finding out information about a file  based  on  its
    name.   INQUIRE by file can be used to find out information about files
    which are "connected" - files for which  an  OPEN  statement  has  been
    executed or for which a data transfer statement has been executed - and
    also about files which are not "connected";  it can be used to find out
    about the existence of files before, during, and after they are used by
    the program, as well as files which are not used by the program.

    An INQUIRE by unit is an INQUIRE statement containing a  UNIT=  keyword
    and no FILE= keyword.  It is therefore used for finding out information
    about files which may be "connected" to the specified unit.

    Since Fortran does not actually open a file for which the STATUS= value
    is  'UNKNOWN'  and  the  ACCESS=  value  is 'SEQUENTIAL' (which are the
    defaults) until the first data transfer statement (READ  or  WRITE)  is
    executed, FOROTS cannot find out the full file specification (including
    device  and  generation  number)  between  the  execution  of  an  OPEN
    statement and the execution of the first data transfer statement.  Note
    that once a data transfer statement has executed for a particular unit,
    the  STATUS=  value is 'OLD'.  Once a file is opened for output (either
    with the OPEN statement or by the first data transfer  statement)  that
    file will exist in the directory.



    2.2.1  Returned Values -

    If the INQUIRE statement proceeds to completion (i.e.,  there  were  no
    errors  in  the  arguments  given  to  the  INQUIRE statement), program
    execution proceeds at the next executable statement, and the  following
    values  are  returned  (the  argument  type  for  the variable for each
    keyword is in parentheses):

    a.  IOSTAT (integer):  Returns 0.

    b.  EXIST (logical):  For INQUIRE by unit, always returns  .TRUE.   For
        INQUIRE  by  file,  returns .TRUE.  if the file exists, .FALSE.  if
        not.

    c.  OPENED (logical):  .TRUE.  if open, .FALSE.  if not.
   FORTRA.DOC - Fortran-20 Version 10                             Page 13


    d.  NUMBER (integer):   Returns  unit  number  if  open,  variable  not
        touched if not open.

    e.  NAMED  (logical):   If  file   is   open,   returns   .FALSE.    if
        STATUS='SCRATCH'  and  .TRUE.   otherwise;   if  file  is not open,
        returns .FALSE.

    f.  NAME (character):  For INQUIRE by  file,  returns  full  (expanded)
        file string if the file exists (which will be the case if OPEN with
        STATUS other than 'UNKNOWN' or ACCESS other than 'SEQUENTIAL' or an
        I/O  transfer statement has been executed).  Otherwise, returns the
        string supplied  with  the  FILE  in  the  INQUIRE  statement  with
        defaults applied.

        For INQUIRE by unit, if the file is  not  open,  the  default  file
        specification  for  that  unit  is returned;  for files opened with
        STATUS='SCRATCH', blanks are returned;  if the file  is  open  with
        STATUS  other  than  'SCRATCH'  or  'UNKNOWN'  or ACCESS other than
        SEQUENTIAL, or an I/O transfer statement  has  been  executed,  the
        full  (expanded)  file  string  is  returned;  if file is open with
        STATUS='UNKNOWN' and ACCESS='SEQUENTIAL' and no I/O  statement  has
        been executed, returns the file string given by the associated OPEN
        statement, with defaults applied.

        In all cases, if a string is to be returned, only the  device  name
        is returned for non-disk devices.

    g.  ACCESS (character):  If the file is open, returns  'SEQUENTIAL'  if
        the file is opened for sequential access or 'DIRECT' if the file is
        opened for DIRECT (RANDOM) access;  returns 'UNKNOWN' if  the  file
        is not open.

    h.  DIRECT (character):  Returns 'YES' if file can be opened for DIRECT
        access (i.e., is a disk file) or 'NO' if it cannot.

    i.  SEQUENTIAL (character):  Returns 'YES' if the file  can  be  opened
        for SEQUENTIAL access, 'NO' if it cannot.

    j.  FORM (character):  If the file is open, returns 'FORMATTED' if  the
        file  is  opened for formatted I/O, or 'UNFORMATTED' if the file is
        opened for unformatted I/O;  returns 'UNKNOWN' if the file  is  not
        open.

    k.  FORMATTED (character):  Returns 'YES' if the  file  can  be  opened
        with FORM='FORMATTED' (i.e., always).

    l.  UNFORMATTED (character):  Returns 'YES' if the file can  be  opened
        with FORM='UNFORMATTED' (i.e., always).

    m.  RECL (integer):  If the file is open,  returns  the  recordsize  of
        file (the value given with the RECL keyword of the OPEN statement),
        zero if variable-length records;  returns zero if the file  is  not
        opened.
   FORTRA.DOC - Fortran-20 Version 10                             Page 14


    n.  NEXTREC (integer):  returns the next record number if the  file  is
        open;   zero  is  returned  if  the  file is not opened or does not
        exist.  For ACCESS='APPEND', returns the number of records  written
        by the program, plus one.

    o.  BLANK (character):  Returns 'NULL' if the file was last opened with
        BLANK='NULL',  or  'ZERO' if the file was opened with BLANK='ZERO'.
        Returns 'UNKNOWN' if  the  file  is  not  open  or  is  opened  for
        unformatted I/O.

    p.  CARRIAGECONTROL (character):  For files which are open,  returns  a
        string  representing  the  value  given  in  the OPEN statement (or
        default applied) for the  file,  one  of  the  following:   'LIST',
        'FORTRAN',  'TRANSLATED', or 'NONE'.  Returns 'UNKNOWN' if the file
        is not open.




    2.2.2  INQUIRE By Unit -

    1.  If there is a file open on the specified  unit  with  STATUS  other
        than UNKNOWN or SCRATCH, or ACCESS other than SEQUENTIAL, or an I/O
        transfer statement has been  executed  using  the  specified  unit,
        FOROTS returns the full, expanded file specification.

    2.  If the file is open on the specified unit as a result  of  an  OPEN
        statement  in  which  STATUS='UNKNOWN' and ACCESS='SEQUENTIAL' were
        specified or implied,  and  no  I/O  transfer  statement  has  been
        executed  using the specified unit, FOROTS returns the string given
        in the OPEN statement,  with  defaults  applied,  for  NAME=.   The
        default  file  specification  is  DSK:FORnn.DAT.0,  where  DSK:  is
        supplied if no device is given, nn is the 2-digit  Fortran  logical
        unit  number,  and  0  is  supplied for the generation number if no
        generation number is given.

    3.  If STATUS='SCRATCH' FOROTS returns blanks for NAME=.

    4.  If there has been no OPEN statement and no I/O  transfer  statement
        has  been  executed  using  the  specified unit, FOROTS returns the
        default file specification for that unit for NAME=.




    2.2.3  INQUIRE By File - INQUIRE by file is quite a bit more complex:

    1.  If no device is given  for  the  FILE=  specifier,  FOROTS  uses  a
        default of 'DSK';  If no extension is given, FOROTS uses 'DAT'.  If
        no generation number is given, FOROTS uses a generation  number  of
        0.

    2.  FOROTS then determines if the device specified is a  disk.   If  it
        is:
   FORTRA.DOC - Fortran-20 Version 10                             Page 15


        a.  FOROTS finds out if a file exists with the  file  specification
            given  in the INQUIRE statement, and returns the answer (either
            .TRUE.  or .FALSE.) in the variable  specified  by  the  EXIST=
            keyword, if any.  In the process, if such a file exists, FOROTS
            'expands' the file specification:  a  logical  device  name  is
            translated  into  a  physical device name (it may expand into a
            complete  file  specification  which   is   overlaid   by   the
            user-specified directory, filename, extension, and generation),
            and an actual file  generation  number  is  substituted  for  a
            generation  number  of  0,  -1,  or  -2.   The  resultant  file
            specification, in string form, will be referred to hereafter as
            the 'full (expanded) file string'.

        b.  To determine the values to be returned for the INQUIRE keywords
            OPENED=  and  NUMBER=,  FOROTS searches for a match between the
            file specification given in the INQUIRE statement  and  a  file
            specification associated with a logical unit for which there is
            a 'connection'.  FOROTS looks at all the FORTRAN logical units,
            in  ascending  order,  starting with zero, for which there is a
            'connection'.  If the file does not exist on the directory  and
            an  OPEN  statement  has been executed and STATUS='UNKNOWN' and
            ACCESS='SEQUENTIAL' and no data transfer statements  have  been
            executed using the unit, FOROTS compares the file specification
            given in the INQUIRE statement (with defaults applied) with the
            exact  file  specification  given  in  the OPEN statement (with
            defaults applied).  If the file exists (which will be the  case
            if  OPEN  with STATUS other than 'UNKNOWN' or ACCESS other than
            'SEQUENTIAL' or an I/O transfer statement  has  been  executed)
            FOROTS  compares  the full file string associated with the unit
            with the full (expanded)  file  string  given  in  the  INQUIRE
            statement.   If either of these two comparisons are successful,
            FOROTS  returns  the  current  unit  number  in  the   variable
            specified  with  the  NUMBER= keyword, and returns 'YES' in the
            variable specified with the OPENED= keyword.  Note that if  the
            same file is connected on several units, the matching technique
            described will return the smallest unit number for which  there
            is a match.


    3.  For non-disk devices given in the file specification in the INQUIRE
        statement,  FOROTS  looks  at  all  the  FORTRAN  logical  units in
        ascending  order,  starting  with  zero,  for  which  there  is   a
        'connection'.

        a.  If the device in the  file  string  specified  in  the  INQUIRE
            statement  is  not  the  user's  controlling  terminal,  FOROTS
            'expands' the file specification given in the INQUIRE statement
            (thus  translating  a logical name given as the device into its
            corresponding physical name), and compares the device  part  of
            this  expanded  file  specification with the device part of the
            full (expanded) file string associated with the logical unit.

        b.  If the  device  is  the  user's  controlling  terminal  (device
            'TTY'),  FOROTS  determines  if  the device associated with the
            logical unit is also the user's controlling terminal.
   FORTRA.DOC - Fortran-20 Version 10                             Page 16


        Note that if the same device is connected on  several  units,  this
        procedure will return the smallest unit number for which there is a
        match.




    2.2.4  Error Processing -

    If an error occurs during the execution of the INQUIRE statement (e.g.,
    a file specification was given which has a syntax error), the following
    occurs:

    1.  If neither an ERR nor IOSTAT keyword are specified in  the  INQUIRE
        statement, program execution is terminated and an appropriate error
        message is typed on the user's terminal.

    2.  If an IOSTAT keyword is specified, the variable specified by it  is
        set   to   a   positive,   non-zero  integer  (see  IOSTAT  in  the
        Fortran-10/20 Language Manual, section 10.4.8);  if no ERR  keyword
        is  specified,  program  execution  proceeds at the next executable
        statement.

    3.  If an ERR keyword is specified, program execution continues at  the
        statement  specified (see ERR in the Fortran-10/20 Language Manual,
        section 10.4.7).

   FORTRA.DOC - Fortran-20 Version 10                             Page 17


    2.3  Compatibility Flagger

    The Compatibility  Flagger  adds  to  Fortran  V10  the  capability  of
    producing optional warning messages whenever a language element is used
    which is

    a.  An extension to the ANSI Fortran-77 standard

    b.  A feature not found in VAX/VMS Fortran  or  could  cause  logically
        different results when used on the VAX/VMS system


    The compatibility flagging is invoked at the user's discretion by a new
    switch recognized by the Fortran compiler command parser.

    The primary goal of this feature is to provide warning messages at  any
    point which could cause conversion problems if the user were to compile
    and execute the program on the VAX/VMS system or on an  ANSI-compatible
    system.  This includes not only compilation incompatibilities, but also
    problems that could occur at object time.



    2.3.1  New Command Switches -

    The /FLAG and /NOFLAG switches have been added  to  the  compiler  (The
    full switch names are /FLAG-NON-STANDARD and /NOFLAG-NON-STANDARD).

         /FLAG:ANSI       To give warning messages whenever the  source  is
                           an extension to the Fortran-77 standard

         /FLAG:VMS        To give warning  messages  whenever  the  program
                           could  cause  an  incompatibility  with  VAX/VMS
                           Fortran

         /FLAG:ALL        To give warnings for both Fortran-77 and VMS

         /FLAG:NONE       To do no flagging

         /FLAG:NOANSI     To do no flagging of Fortran-77 extensions

         /FLAG:NOVMS      To do no flagging of VMS incompatibilities

         /NOFLAG          To do no flagging

    The /FLAG switch can have multiple arguments, e.g.  /FLAG:(ALL,NOVMS).

    If the /FLAG switch is not present in the command, no flagging will  be
    done.  If no argument is given, then flagging will be done for both VMS
    and Fortran-77.

    The /NOFLAG switch takes no arguments.
   FORTRA.DOC - Fortran-20 Version 10                             Page 18


    2.3.2  Warning Messages -

    The warning messages will be one of the following:

              %FTNxxx Extension to Fortran-77:  text
              %FTNxxx VMS incompatibility:  text
              %FTNxxx VMS and Fortran-77 incompatibility:  text

    where 'xxx' is a unique three-letter code, and 'text' is an explanation
    of  the  specific extension or incompatibility.  This suggested text is
    described with each element.

    In addition, certain incompatibilities are  flagged  at  runtime.   The
    compiler   generates   a   global  symbol  specific  to  each  type  of
    compatibility flagging requested by the user:

              FLGV.       VMS flagging
              FLG77.      Fortran-77 flagging

    If the particular type of flagging is to be done, the associated global
    (FLGV.   and/or  FLG77.)  will  be set to a value of all ones;  if that
    flagging is not done, no global value will be  generated.   In  FORLIB,
    separate routines will each contain one of the global definitions as an
    ENTRY, with a value of all zeroes, and these routines will be loaded if
    and  only  if  the  global  value  is not defined in one or more of the
    compiled programs (i.e.  flagging is being done).  Thus if one or  more
    of  a  series of linked programs has been compiled with the flagger on,
    then the execution of that task will cause FOROTS to  do  compatibility
    checking on all routines.

    The runtime flagging includes:

     o  Incompatible carriage control

     o  Incompatible values for I/O keywords

     o  Blanks at end of output line

     o  The use of intrinsic functions and subroutines not supported by VMS
        and/or Fortran-77

    For a more detailed description of runtime flagging,  see  Appendix  B,
    sections 7 and 8.
   FORTRA.DOC - Fortran-20 Version 10                             Page 19


    2.4  Support Of Industry-Compatible Magtape

    Version 10 supports unlabelled magnetic tape  processing  in  a  manner
    compatible with the VMS system.

    It is possible to  read  and  write  single-file  labelled  tapes  with
    version  10,  but  multi-file volumes (more than one file per tape) and
    multi-volume files (a file that extends beyond one reel of tape) cannot
    be handled.  Because of insufficient testing, the use of labelled tapes
    is unsupported.

    For more information on the industry-compatible recording mode see  the
    Tops-20 Tape Processing Manual.



    2.4.1  TAPEFORMAT Keyword -

    1.  CORE-DUMP - This is the usual so-called DEC-compatible format, with
        36  bits stored in 5 frames on a 9-track tape.  This is the default
        format.

        The SET TAPE RECORD-LENGTH command (or the monitor-supplied default
        if  no  command is given) is interpreted to be the number of 36-bit
        words in the magtape  blocks  on  the  tape,  and  is  used  if  no
        BLOCKSIZE  keyword  is given in the OPEN statement.  If a BLOCKSIZE
        is given in the OPEN statement, it is interpreted to be the  number
        of 36-bit words for both formatted and unformatted files.

    2.  INDUSTRY - Four 8-bit characters per word  (left  justified  in  32
        bits  in  FOROTS'  magtape  buffer) are read or written in standard
        industry tape format.  The BLOCKSIZE given in  the  OPEN  statement
        (or,  if  none,  the  SET TAPE RECORD-LENGTH command) specifies the
        number of bytes (frames)  in  each  magtape  block,  regardless  of
        whether it is a formatted or unformatted file.  If no magnetic tape
        format is specified in the OPEN statement, FOROTS will not  attempt
        to set a default, but instead will find out the setting of the tape
        format from the monitor (which can be set via the SET  TAPE  FORMAT
        command), and set the bytesize in the OPENF accordingly.  (See note
        1 in Implementation Notes below).  FOROTS will not attempt to  stop
        a program from using a tape format other than COREDUMP or INDUSTRY.
        However, the results will be unpredictable.




    2.4.2  RECORDTYPE Keyword -

    The RECORDTYPE keyword required modification to the compiler such  that
    it  can be differentiated from RECORDSIZE, since these two keywords are
    identical in their first six  characters.   Hereafter  RECORD  will  be
    recognized as an abbreviation for RECORDSIZE.
   FORTRA.DOC - Fortran-20 Version 10                             Page 20


    1.  UNDEFINED or STREAM - for 36-bit tape format (CORE-DUMP),  this  is
        stream disk image format - 36 bit words are transferred to/from the
        tape without regard to  their  contents,  in  the  same  format  as
        formatted  and  unformatted  disk files.  For INDUSTRY tape format,
        this is ANSI "U" (undefined) record format.  This  is  the  default
        record  format  for all tape formats.  This record format is stream
        format -  7-bit  or  8-bit  bytes,  respectively,  are  transferred
        to/from  the  tape as if they were being transferred to/from a disk
        stream file.

        For all  tape  formats,  this  record  format  specifies  that  for
        formatted  files  that a standard stream record terminator - CRLF -
        is placed at the end of each record, and  that  a  standard  stream
        terminator   is   expected   on  input  to  delimit  records.   For
        unformatted  files  the  behavior  is  identical  to  that   of   a
        MODE='IMAGE'  disk  file  - a word transfer word-aligns the pointer
        and transfers  a  word  of  data  (containing  four  8-bit  bytes);
        character  data  transfers  need  not be word-aligned, and are done
        with MOVSLJ  to/from  the  (currently)  7-bit  character  variables
        defined by the FORTRAN compiler.

        With this record format, all physical blocks on the  tape  are  the
        same  size  except  for the last block, which may be a short block.
        For 36-bit mode (CORE-DUMP), the bytes  in  the  last  36-bit  word
        after  the  last  character  of  data  will be nulls.  For all tape
        formats, if a RECORDSIZE is specified for  a  formatted  file,  the
        actual  record  read/written  consists of the data, a CRLF, and the
        number of nulls necessary to word-align the record.

    2.  DELIMITED or VARIABLE - for 36-bit tape format (CORE-DUMP), this is
        not  defined or supported.  For INDUSTRY, this is the standard ANSI
        "D" tape record format - records are variable in  length,  and  the
        record  data  is  written  with  no terminators or carriage control
        characters, and preceded by a 4-byte record size  (referred  to  in
        the  ANSI  standard  as  Record  Control  Word or RCW).  Blocks are
        variable length, not to exceed the block length  specified  in  the
        OPEN   statement.   If  a  RECORDSIZE  is  specified  in  the  OPEN
        statement, this is the maximum number of  bytes  specified  in  the
        4-byte  RCW  preceding  each  record;   the record actually read or
        written is four characters less than this quantity.

        For input, the RECORDSIZE in the OPEN statement has  no  relevance,
        since  FOROTS expands its record buffer dynamically as needed.  For
        output, FOROTS will truncate records  which  exceed  the  specified
        RECORDSIZE (and give a supressable, trappable warning message).  If
        no RECORDSIZE is given, FOROTS will use the size specified  by  the
        SET  TAPE RECORD-LENGTH command (or the monitor-supplied default if
        no command is given).

    3.  FIXED - for 36-bit format  (CORE-DUMP),  this  is  not  defined  or
        supported.  For INDUSTRY, this is the standard ANSI "F" tape record
        format - record data is written with  no  terminators  or  carriage
        control  characters,  one record directly after another, to exactly
        fill fixed-length blocks.  (If the last block is  not  filled  with
        records,  it  is  a  short  block).   For  this  record  format,  a
   FORTRA.DOC - Fortran-20 Version 10                             Page 21


        RECORDSIZE must be specified in the OPEN statement.




    2.4.3  CARRIAGECONTROL Keyword -

    Carriage control is  an  attribute  of  a  file  rather  than  being  a
    directive.   None  of  these  values  has any effect on input data, and
    except for TRANSLATED and NONE, these values  have  no  effect  on  the
    output data.

    1.  LIST - When a record is printed or typed, a CRLF is appended to its
        end.   For  "U"  (UNDEFINED) record format, it has no effect, since
        CRLFs always appear in the file as record terminators.  This is the
        default value for "U" record format.

    2.  FORTRAN - When a record is printed or typed, the first character of
        the  record  is  converted  into  the  appropriate carriage control
        characters for printing.  This is the  standard  ANSI  "A"  format.
        This  is  the  default  for  "D"  and  "F" record formats.  For "U"
        (UNDEFINED) record format disk files, a bit is set in  the  FDB  so
        that  LPTSPL will print the file with /FILE:FORTRAN, converting the
        first character of each record to the appropriate carriage  control
        characters for printing, and removing the CRLF record terminator.

    3.  NONE - When each record is printed or typed,  no  extra  characters
        need  be added for carriage control, and no special action is taken
        - the assumption is that any carriage control characters needed for
        printing  exist  within  the record.  This is the standard ANSI "M"
        format.  For "U"  (UNDEFINED)  record  format,  this  value  has  a
        special effect - to suppress the normal CRLF which appears normally
        at the end of each record as a record terminator.

    4.  TRANSLATED - Similar to NONE, but implies that upon  output  FOROTS
        has interpreted column 1 of each output record into the appropriate
        carriage control characters for printing or typing.   This  is  the
        ANSI  "M"  format.   There  is  no  support possible for "F" record
        format, since the  number  of  carriage  control  characters  after
        interpretation varies widely.


    Section 2.5.1 notes some incompatibilities with Fortran V7 with  regard
    to these values.



    2.4.4  Implementation Notes -

    1.  The TOPS-20 monitor has a catch-22 in it regarding  magnetic  tape:
        in  order to know the tape format of the tape, you must do an OPENF
        JSYS.  However, the internal bytesize used by the  SINR  and  SOUTR
        JSYS  calls  is specified in the same OPENF JSYS.  Unless specified
        otherwise (via a  TAPEFORMAT=  specified  in  the  OPEN  statement)
        FOROTS  will  use  the  bytesize implied by the default tape format
   FORTRA.DOC - Fortran-20 Version 10                             Page 22


        (retrieved with the GETJI JSYS).  If FOROTS then detects  that  the
        bytesize  implied by the actual tape format is in conflict with the
        one specified in the OPENF, a fatal error message will  be  issued:
        "?Tape format conflicts with OPEN statement or default."

    2.  If a magnetic tape file is  OPENed  specifying  the  TAPEFORMAT  as
        INDUSTRY,  FOROTS  sets  the  device to be "ASCII-only";  if binary
        data is written to the file, FOROTS does not read or  write  LSCWs,
        but instead treats the data as if MODE='IMAGE' had been specified.




    2.4.5  Reading And Writing Tapes Using Fortran V10 -



    2.4.5.1  Mounting And Dismounting Tapes -

    To mount a tape a MOUNT command of the following form must be given  to
    the operating system:

            @MOUNT TAPE (NAME) LOGNAM:/WRITE-ENABLE/VOLIDS:VOLNAM

    Where LOGNAM is the logical name for  the  device  and  VOLNAM  is  the
    volume  identification.   The  /WRITE-ENABLE switch is used only if you
    intend to write to the tape.

    The /VOLIDS switch is needed only for labeled tapes.

    To dismount a Magtape unit you use the

            DISMOUNT LOGNAM:

    command.  For more information on mounting and dismounting magtapes see
    the Tops-20 Commands Reference Manual.



    2.4.6  Reading And Writing Tapes On VMS -



    2.4.6.1  Mounting Tapes (Labeled And Unlabeled) -

    When mounting a magnetic tape on a VMS  system  you  must  specify  the
    physical  drive  name that the tape will mounted on.  For VMS there are
    different mount command specifiers for labeled and unlabeled tapes.

    To mount an unlabeled tape on  VMS  (also  called  foreign)  you  would
    specify:

            $ MOUNT/NOLABEL/BLOCKSIZE=nnn/RECORDSIZE=nnn DEVNAM: LOGNAM
   FORTRA.DOC - Fortran-20 Version 10                             Page 23


    And for a labeled tape:

            $ MOUNT/OVERRIDE=OWNERIDENTIFICATION DEVNAM: VOLNAM LOGNAM

    Where DEVNAM:  is the physical device name, VOLNAM is the  volume  name
    and LOGNAM is any logical name you've chosen.  Note that the /BLOCKSIZE
    and /RECORDSIZE are required for any unlabeled  tape  operations.   The
    /OVERRIDE  specifier  is required if the label was written on a Tops-10
    or Tops-20 system.  If you do not wish to write on the tape you  should
    specify   /NOWRITE;    write  enabled  is  the  default.   For  a  full
    explanation of the VMS mount utility you should refer  to  the  VAX/VMS
    Mount Utility Reference Manual.
   FORTRA.DOC - Fortran-20 Version 10                             Page 24


    2.5  Changes In I/O Statements

    2.5.1  Changes Incompatible With Version 7 -

    1.  When a file is created by the runtime system  it  will  immediately
        appear  in  the user's directory;  in previous versions of Fortran,
        created files did not appear in the directory until that  file  was
        closed.   If the user should terminate the execution of the program
        before the file is  closed,  the  previous  generation  will  still
        exist, and the new generation will have zero length.

    2.  The definition of the CARRIAGECONTROL='FORTRAN' specifier  in  OPEN
        statements  will  more  nearly conform to VMS usage.  A replacement
        for  the  present  'FORTRAN'  specifier  ('TRANSLATED')  has   been
        implemented,  and  shipped  on  Autopatch  tape 7 for V7 customers.
        'TRANSLATED' will cause the first character of a formatted line  to
        be   changed   to  the  appropriate  carriage  control  characters;
        'FORTRAN' will leave that first character in the record,  but  that
        character will be translated by the print spooler.

        For more discussion of CARRIAGECONTROL, see section 2.4.3.

    3.  To be more compatible with VMS, the behavior  of  the  STATUS='NEW'
        specifier  under  Tops-20  has  changed when the file being created
        already exists.  In V7, the OPEN would fail with  a  'File  already
        exists'  message.   In  V10  and  beyond, this error condition will
        exist only if the user specifies  a  generation  number,  and  that
        generation  of the file already exists;  otherwise a new generation
        of the file will be created and no error message produced.

    4.  A change in the meaning of 'BLOCKSIZE' for magtapes was implemented
        in  V7:  that value was taken to count characters instead of words.
        In V10, that change is  rescinded  for  TAPEFORMAT  =  'CORE-DUMP':
        BLOCKSIZE will specify words, not characters.




    2.5.2  Enhancements To Version 7 -

    1.  The  I/O  keyword  NML  is  a  synonym  for  FMT  when  referencing
        namelists.

    2.  MODE='IMAGE' is accepted for the TTY device.  If the data is  being
        read into (written from) non-character fields, the rightmost 7 bits
        of each word will be used;  if the data is being read into (written
        from) character fields, each 7-bit byte will be used.

        When  using  MODE='IMAGE',  control  characters  have  no   special
        meaning.

        MODE='IMAGE' has been implemented in Fortran V7A on Autopatch  tape
        #8.

   FORTRA.DOC - Fortran-20 Version 10                             Page 25


    2.6  Comments Within Continuation Lines

    Fortran V7 will assume that a statement is completed  as  soon  as  any
    comment  line  is seen.  Fortran V10 supports the inclusion of comments
    within continuation lines.  For example, the following  Fortran  source
    is now valid:

                 A=B+C
           C This comment is inserted between two lines of the statement
                1  +D+E

    and will compile as    A=B+C+D+E



    2.7  Additional Features With The INCLUDE Statement

    The compiler will continue to assume that any INCLUDEd source is to  be
    listed  unless  the  /NOLIST  switch  is used in the INCLUDE statement.
    Since the VAX/VMS Fortran will  list  the  source  only  if  explicitly
    requested, Fortran-10/20 and VAX/VMS Fortran will do opposite things on
    default.  To relieve this incompatibility, Fortran-10/20 V10 has  added
    the  /LIST  switch  to  the INCLUDE statement;  by specifying /LIST (or
    /NOLIST) the user can cause the VAX/VMS Fortran  and  Fortran-10/20  to
    behave  in  a like way.  For symmetry, Fortran-10/20 has also added the
    /CREF switch.  Fortran-10/20 will continue to assume /LIST and /CREF as
    the default.

    INCLUDEd source may contain INCLUDE statements.  INCLUDE may be  nested
    up through 12 levels.



    2.8  Change To The /DEBUG:ARGUMENTS Switch

    The function of this compiler switch has  been  enhanced  so  that  the
    following checking is done:

    1.  The length of array arguments will be checked at LINK time.  If the
        length  of  array  actual  argument  is less than the corresponding
        array dummy argument, LINK will issue a  non-fatal  error  message.
        If  the  size of the array is not known at compile time (adjustably
        dimensioned or assumed size arrays), the checking is not done.

    2.  The structure of arguments will be checked  at  LINK  time.   If  a
        non-routine  name  is passed where a routine name is expected, or a
        routine name is passed where a non-routine name is  expected,  LINK
        will issue a non-fatal error message.

        The structure of statement function arguments will  be  checked  at
        compile time.  If a non-routine name is passed where a routine name
        is expected, or a routine name is passed where a  non-routine  name
        is expected, Fortran will issue a non-fatal error message.
   FORTRA.DOC - Fortran-20 Version 10                             Page 26


    3.  The length of character arguments will  be  checked  for  statement
        functions  at  compile time.  If the length of the actual character
        expression being passed to a function or subroutine is shorter than
        the  formal  variable,  then  Fortran  will issue a non-fatal error
        message.




    2.9  New Bit-Manipulation Routines

    Several new intrinsic functions, and one subroutine, have been included
    in Version 10 in support of MIL-STD-1753.

    In the following descriptions, 'bit position' is taken  from  right  to
    left,  i.e.   bit  0  is the right-most bit and bit 35 is the left-most
    bit.

    The instrinsic functions are:

    1.  IAND (K1,K2) - A bit-wise  logical  AND  of  integers  K1  and  K2,
        producing an integer

    2.  IOR (K1,K2) - A bit-wise logical inclusive OR of  integers  K1  and
        K2, producing an integer

    3.  IEOR (K1,K2) - A bit-wise logical exclusive OR (XOR) of integers K1
        and K2, producing an integer

    4.  NOT (K1) - A bit-wise logical complement of integer  K1,  producing
        an integer

    5.  ISHFT (K1,K2) - A logical shift of integer K1 by K2 bits, producing
        an  integer.   If  K2  is  positive,  the  shift  is to the left, a
        negative K2 causes a shift to the right.  The vacated bit positions
        are filled with zeroes.

    6.  ISHFTC (K1,K2,K3) - A logical rotation by K2 bits of the right-most
        K3  bits  of  K1,  producing  an  integer.   If  K2 is positive the
        rotation is to the left, a negative K2 causes  a  rotation  to  the
        right.

    7.  IBITS (K1,K2,K3) - Bits K2 through K2+K3-1  of  integer  K1  appear
        right justified in the integer result.

    8.  IBSET (K1,K2,K3) - The integer result will be the integer value K1,
        with bits K2 through K2+K3-1 set to ones.

    9.  IBCLR (K1,K2,K3) - The integer result will be the integer value K1,
        with bits K2 through K2+K3-1 set to zeroes.

   10.  BTEST (K1,K2) - The logical result will be .TRUE.   if  bit  K2  of
        integer K1 is a 1, and .FALSE.  if that bit is 0.

   FORTRA.DOC - Fortran-20 Version 10                             Page 27


    There is one subroutine, MVBITS(M,K,LEN,N,J).  All of the arguments are
    integer.   Bits  K  through  K+LEN-1  of  variable  M  are moved to bit
    positions J through J+LEN-1 of variable N.



    2.10  Changes In The Use Of Octal Constants

    Version 7 of Fortran ignores any leading zeroes in an  octal  constant;
    thus   "0000000000001  (12  leading  zeroes)  would  be  treated  as  a
    single-precision constant.  Version 10 counts  the  leading  zeroes  to
    determine  the  precision  of  the constant, so that the above constant
    would be double precision.



    2.11  PARAMETER Statements With Expressions Of Type COMPLEX

    Fortran  V7  does  not  allow   the   PARAMETER   statement   to   have
    multiplication,  division nor exponentiation involving operands of type
    COMPLEX.  Fortran V10 has removed that restriction.

    Since the calculations  involving  PARAMETER  statements  are  done  at
    compile  time,  computation  involving  complex data may use algorithms
    that differ from those used at runtime.  Thus it is possible  that  the
    result  of using a PARAMETER statement may differ in accuracy from that
    of runtime calculation.  An attempt has been made to make the PARAMETER
    statement produce results that are as accurate as possible.



    2.12  IMPLICIT NONE Statement

    The IMPLICIT NONE statement  can  be  used  to  override  all  implicit
    default type declarations.  If the IMPLICIT NONE statement is used, the
    data type of all symbolic  names  in  the  program  must  be  explicity
    declared,  and  no  other  IMPLICIT  statement  can  be included in the
    program unit.



    2.13  Octal And Hexadecimal Values In DATA Statements

    The DATA statement may contain two additional forms of constants in the
    data value lists, which will result in right-justified values.

    1.  O'ddddd - An octal constant containing the digits 0-7.

    2.  Z'hhhhh - A hexadecimal constant containing the digits 0-9 and  the
        letters A-F (to represent the decimal values 10-15).

   FORTRA.DOC - Fortran-20 Version 10                             Page 28


    2.14  PAUSE ON ERROR Command For FORDDT

    The PAUSE ON ERROR command will cause  FORDDT  to  inform  the  runtime
    system  that  it  must  trap  to  FORDDT  after  displaying any runtime
    diagnostic message e.g.  integer overflow, subscript bounds failure (if
    /DEBUG:BOUNDS is specified at compile time).  This trap will be treated
    as if it were a normal PAUSE, and the user can use any  of  the  FORDDT
    commands  to  display  and/or  alter  data  before  proceeding with the
    CONTINUE command.

    To remove the trap, the REMOVE ON ERROR command is used.

    Note that after a trap on a fatal I/O error, the FORDDT TYPE and ACCEPT
    commands  cannot  be  used,  since  they will cause an 'I/O within I/O'
    error.



    2.15  Changes With The Tops-20 REENTER Command

    Version 10 will produce the following code at the end of a main program
    when  /EXTEND is used in the compiler command.  This code will tell the
    Tops-20 EXEC that the program has a three-word entry vector.

            JRST MAIN.        ;Program start location
            JRST @.+2         ;Jump to REENTER location
            BLOCK 1           ;Reserved for the user supplied version number
            .EFIW REENT.##    ;Address of REENTER routine
            END 3,,.-4        ;To specify the entry vector

    Whenever the REENTER command is used with the Tops-20 EXEC, FOROTS will
    optionally close files and then jump to the global symbol 'REENT.'.  If
    the user should supply a routine with  the  entry  point  REENT.,  that
    routine will be entered.  If the user does not supply that entry point,
    a default routine will be loaded from  FORLIB;   this  default  routine
    will simply halt.

    This mechanism was made necessary by the fact that there is  no  JOBDAT
    area  set  up by LINK when a program uses extended addressing, and thus
    there is no .JBREN location to specify the user's re-enter point.

    Programs which do not use extended  addressing  should  still  use  the
    JOBDAT location .JBREN.
   FORTRA.DOC - Fortran-20 Version 10                             Page 29


    3.0  RESTRICTIONS

    3.1  Overlays

    Overlays  are  not  supported  under  /EXTEND.   This  is  a  permanent
    restriction.



    3.2  DBMS

    DBMS will not work in non-zero sections, and  should  not  be  used  by
    Fortran programs which have been compiled /EXTEND.



    4.0  KNOWN BUGS AND DEFICIENCIES

    None



    5.0  COMPATIBILITY WITH PREVIOUS VERSIONS

    Fortran V10 will support programs that currently run under Fortran  V7,
    within the guidelines listed below in this section.

    1.  Large code and data  areas  are  supported  without  affecting  the
        Fortran syntax or semantics.

    2.  Overlays are not  supported  under  extended  addressing,  but  are
        supported for those users who do not use extended addressing.

    3.  DBMS is not supported under extended addressing, but  is  supported
        for those users who do not use extended addressing.

    4.  Certain input/output statement specifiers have  been  changed  (See
        section 2.5).

    5.  Changes have been  made  to  the  compiler  command  parser.   Some
        switches  have  been  added,  and  the  syntax  of others have been
        modified in order to be more compatible with Tops-20 conventions.

        The /FLAG-NON-STANDARD switch has been added (See 2.2.1).

        The V7 switches /RUN, /EXIT, /HELP and /TAKE have been  changed  to
        verb-mode  commands.   For  example, in V7, the command "/RUN:PROG"
        would execute the program PROG.EXE.  In V10, the slash is not used;
        instead  the  command  is  "RUN PROG".   The  slash  form  is still
        supported for compatibility, however.

        It should be noted that some Fortran source file names could now be
        taken  for commands.  For example, if the source file T.FOR were to
        be compiled in V10, the usual command containing just the file name
        'T'  would be taken to mean 'TAKE', and the user will get the error
   FORTRA.DOC - Fortran-20 Version 10                             Page 30


        message

                ?FTNCMD Filespec required in TAKE command ...

        when the TAKE attempts to find the  following  (non-existent)  file
        name  for  the  CMD file.  The commands 'T.FOR' or 'COMPILE T' will
        compile the source.

    6.  The data type declaration REAL*16 is  now  converted  to  the  more
        realistic  REAL*8  instead  of REAL*4 as was done in V7.  A warning
        message is still given.

    7.  The Fortran-20 V10 compiler high segment starts at location 334000,
        whereas  prior versions started at higher locations.  V10 was moved
        down  so  as  not  to  overlay  PA1050  while  doing  compile-class
        commands.   Fortran-20  itself  does  not  use  PA1050,  but  other
        languages do and could thus cause  PA1050  to  be  in  memory  when
        Fortran starts.

        Autopatch tape #9 patches  the  Tops-20  EXEC  in  order  to  force
        Fortran  programs to be compiled before those of any other language
        in any one  compile-class  command.   This  in  effect  means  that
        Fortran  need  no  longer  avoid  PA1050,  and could be moved up to
        create a larger data space for the compilation of large programs.

        To relocate  FORTRA  to  a  higher  starting  address,  modify  the
        ALL20.CMD  file  used  by  the  B20FTN.CTL  batch stream.  The /SET
        switch used by LINK should be changed from

                /SET:.HIGH.:334000
        to
                /SET:.HIGH.:400000

        The 400000 address is the highest that is recommended, since FORTRA
        must still avoid overlaying the space needed by DDT.




    6.0  INTERNAL CHANGES

    FOROTS, the compiler, FORDDT and the math library have been modified to
    support  the  new features that are in this release.  Complete revision
    histories are contained in REVHST.MAC (for  the  compiler),  FORHST.MAC
    (for  FOROTS),  FORDDT.MAC  (for  FORDDT)  and MTHHST.MAC (for the math
    library).












                                 APPENDIX A

           OBJECT CODE SEQUENCES FOR EXTENDED ADDRESSING SUPPORT



   A.1  OBJECT CODE TO BE GENERATED INDEPENDENT OF /EXTEND

   In Fortran V10, the following changes have been  made  to  the  object
   code  sequences generated by the compiler in order to support extended
   addressing.  These code sequences do not depend on the /EXTEND switch.

        1.  An IFIW with global indexing sign-extends the 18 bit Y field,
            but  IFIWs  with local indexing use section local addressing.
            Therefore, IFIWs with Y fields that do not  fit  in  18  bits
            which  are  emitted  by V7 of the compiler do not compute the
            correct address.  This has been changed in V10 for such IFIWs
            by  explicitly  adding the full 36 bit Y field value into the
            index register and setting the Y field  of  the  IFIW  to  0.
            Thus  the  instruction  sequence  generated  for this Fortran
            code:
                    SUBROUTINE SUB(A)
                    INTEGER A(-200000:-190000)
                    A(I) = A(I)+1

            Has been changed from:
                    MOVE AC,A
                    ADD  AC,I
                    AOS  ^D200000(AC)
            to:
                    MOVE AC,A
                    ADD  AC,I
                    ADD  AC,[^D200000]
                    AOS  0(AC)




   A.2  OBJECT CODE SEQUENCES FOR /EXTEND

   In Fortran V10, when  the  user  specifies  the  /EXTEND  switch,  the
   following additional object code changes occur:

        1.  Indirect references  are  generated  for  all  references  to
            numeric  scalars  in large COMMON.  These references are done
            through EFIWs in  which  the  Y  field  contains  the  30-bit
   OBJECT CODE SEQUENCES FOR EXTENDED ADDRESSING SUPPORT         Page A-2


            address  of  the  scalar  and  the I and X fields are 0.  For
            example, the statements:

                    INTEGER I,J,M,N
                    COMMON /C1/I,J/C2/M,N
                    . . .
                    I = N

            were changed from:
                    MOVE  AC,C2##+1
                    MOVEM AC,C1##+0
            to:
                    MOVE  AC,@[.EFIW C2##+1]
                    MOVEM AC,@[.EFIW C1##+0]

        2.  Indirect references  are  generated  for  all  references  to
            elements  of large arrays.  These references are done through
            EFIWs in which the X field specifies an AC that contains  the
            array offset and the Y field contains the 30-bit base address
            of the array.

            For example, if A is an array which is in a different section
            from the executable code, then the statements:

                    REAL A(100000),B
                    . . .
                    B=A(I)

            are changed from:
                    MOVE  R,I               ;Where R is some AC
                    MOVE  R1,A-1(R)         ;Fetch the I'th element of A
                    MOVEM R1,B              ;Store the value into B
            to:
                    MOVE  R,I               ;Where R is some AC
                    MOVE  R1,@[.EFIW A-1(R)] ;This is an EFIW  in which the X field
                                            ;contains R   and the Y field  contains
                                            ;the 30-bit base address of the array A
                    MOVEM R1,B              ;Store the value into B

        3.  One word global byte pointers are generated in place  of  all
            one  word local byte pointers for all references to CHARACTER
            data.  This is necessary because when FOROTS  is  in  another
            section,  local  byte pointers can't be copied without losing
            the section number.   It  is  also  necessary  in  order  for
            character  arguments  to work with multiple sections of code.
            Thus, the descriptor for "'BAR'" is changed from:

            .HSCHD: 440700,,[ASCIZ |BAR  |]
                    3
            to:
            .HSCHD: 61B5+[ASCIZ |BAR  |]
                    3
   OBJECT CODE SEQUENCES FOR EXTENDED ADDRESSING SUPPORT         Page A-3


        4.  Descriptors for character functions point  to  the  functions
            with  EFIWs  instead of IFIWs under /EXTEND.  This means that
            the descriptor for "F" in the following code:

                    EXTERNAL F
                    CHARACTER*3 F
                    CALL FOO(F)
                    END

            is changed from:
            .HSCHD: IFIW  F##
                    3
            to:
            .HSCHD: .EFIW  F##
                    3

        5.  The V7 compiler tries to use  AOBJN  instructions  for  inner
            loops  whenever  the  range  of  the loop is known at compile
            time, and is small enough.  Since  EFIWs  always  use  global
            indexing,  they cannot use IOWD style loop control variables.
            Therefore, if a loop control variable is used to  index  into
            an  array  in the .LARG.  psect, the V10 compiler either does
            not use the AOBJN, or moves  the  index  value  into  another
            register  (with  an  instruction of the form MOVEI A2,0(A1) )
            prior to referencing the EFIW.

        6.  If /EXTEND:CODE is specified, function and  subroutine  calls
            are done indirectly through EFIWs.  Instead of
                    PUSHJ SP,ROUTIN##
            the compiler generates
                    PUSHJ SP,@[.EFIW ROUTIN##]













                                 APPENDIX B

           SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER



   B.1  SOURCE DIFFERENCES


        a.  Comments
            Messages: (BOTH) Non-standard character in column 1
                      (ANSI) Comment on statement

            The ANSI standard specifies that comment lines must have  the
            characters  C or asterisk (*) in column 1.  Fortran-10/20 and
            VMS allow the exclamation mark (!) to appear anywhere in  the
            source  line, to denote the start of a comment.  In addition,
            Fortran-10/20 allows the characters dollar ($)  or  slash (/)
            in column 1 to denote a comment line.

        b.  DEBUG lines
            Message: (ANSI) DEBUG lines

            Both Fortran-10/20 and  VMS  recognize  the  character  D  in
            column  1  to  denote a statement which is either compiled or
            treated as a comment, depending upon the presence or  absence
            of  a command switch at compile time.  The ANSI standard does
            not recognize this feature.

        c.  Long Identifiers

            Fortran-10/20 currently warns the user when an identifier  of
            more  than  six  characters  is used, and allows only letters
            and/or digits;  VMS allows up  to  31  characters,  including
            letters,   digits,   dollar ($)  and  underscore (_).   Since
            Fortran-10/20 currently complains, no change is made.

        d.  Identifiers and global names
            Messages: (VMS) xxxx is same as entry point
                            xxxx is same as NAMELIST name
                            xxxx is same as variable name
                            xxxx is the same as PARAMETER name

            Both Fortran-10/20 and VMS currently prohibit the name of any
            program,  subprogram,  entry point or COMMON block from being
            the same as any  other  subprogram,  entry  point  or  COMMON
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page B-2


            block.

            VMS further prohibits any program, subprogram or entry  point
            to be the same as any identifier, PARAMETER or NAMELIST.

        e.  Multi-Statement lines
            Message: (BOTH) Multi-statement line

            Fortran-10/20 allows more than one statement to appear  on  a
            line,  with  the  semi-colon  (;) separator.  Neither VMS nor
            ANSI allows this.




   B.2  DATA TYPES


        a.  Hollerith constants
            Messages: (ANSI) Hollerith constant
                      (VMS)  Hollerith constant padded with spaces

            ANSI  does  not  recognize  constants  of  the  form   nHccc;
            Fortran-10/20 and VMS do allow them.  Fortran-10/20 pads such
            a constant with spaces in order to fill  a  word;   VMS  does
            not.

        b.  Octal constants
            Message: (BOTH) Octal constant

            ANSI  does  not   recognize   octal   constants.    VMS   and
            Fortran-10/20  do  allow  octal  constants, but Fortran-10/20
            expects them in the form "ddd (a quote followed by 1-24 octal
            digits), whereas VMS expects 'dddd'O (octal digits surrounded
            by apostrophes and delimited by the letter O).

        c.  Length specifiers
            Message: (ANSI) xxxxx  length  specifier    (xxxxx  is   data
            type)

            ANSI does not recognize certain  length  specifiers  in  data
            type  declarations  nor in FUNCTION statements.  Both VMS and
            Fortran-10/20 do allow them, but VMS has a  larger  selection
            of specifiers.

            The only length specifiers recognized by ANSI are CHARACTER*n
            and CHARACTER*(*).

            In addition to the ANSI  specifiers,  Fortran-10/20  and  VMS
            accept  INTEGER*4,  REAL*4,  REAL*8, COMPLEX*8 and LOGICAL*4.
            These five specifiers receive the new warning message if ANSI
            flagging is in effect.
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page B-3


            Fortran-10/20 warns about:

                      INTEGER*2  (Uses INTEGER*4)
                      LOGICAL*1  (Uses LOGICAL*4)
                      REAL*16    (Uses REAL*8)
                      COMPLEX*16 (Uses COMPLEX*8)
                      COMPLEX*32 (Uses COMPLEX*8)

            and produces a fatal message for all others.  In order to  be
            more  compatible with VMS, Fortran-10/20 has been modified to
            allow LOGICAL*2 after producing a warning and changing it  to
            LOGICAL*4.   In all other cases, the current warning or fatal
            message is retained.




   B.3  EXPRESSIONS


        a.  Symbolic relational operators
            Message: (BOTH) Symbolic relational operator x
                                     (x replaced by operator)

            Fortran-10/20 treats the symbolic  relational  operators  (<,
            <=, >, >=, == and #) as the standard relationals (.LT., .LE.,
            .GT., .GE., .EQ.  and .NE.).  Neither VMS nor ANSI recognizes
            the symbolic versions.

        b.  Exponentiation operator (^)
            Message: (BOTH) Exponential operator ^

            Fortran allows the caret (^) as well as the  standard  double
            asterisk (**) to denote exponentiation.  Neither VMS nor ANSI
            recognizes this construct.

        c.  XOR operator
            Message: (ANSI) Logical .XOR. operator

            Fortran-10/20 and VMS support the logical operator .XOR. as a
            synonym for .NEQV., but ANSI does not allow it.

        d.  Consecutive arithmetic operators
            Messages: (ANSI) Consecutive arithmetic operators
                      (VMS)  Different precedence in exponentiation

            Both  Fortran-10/20  and  VMS  allow  the  unary   arithmetic
            operators  (-  and  +)  to follow a binary operator, but with
            slightly different precedence rules;   ANSI  does  not  allow
            this construct at all.

            Given the expression A**-B*C, Fortran-10/20 would parse it as
            (A**(-B))*C,  whereas  VMS gives the unique interpretation of
            A**(-(B*C)).
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page B-4


        e.  Concantenation of character data of length (*).
            Message: (ANSI) Concantenation with variable of  non-specific
            length

            Subprograms may specify a dummy character argument as  having
            length  (*), meaning 'use the length of the actual argument'.
            ANSI  does  not   allow   such   variables   to   appear   in
            concantenation expressions, but both VMS and Fortran-10/20 do
            allow them.

        f.  Non-integers in an integer context
            Messages: (ANSI) Non-integer subscript
                             Non-integer substring bounds
                             Non-integer as index to computed GOTO
                             Non-integer as index to RETURN
                             Non-integer used with xxxx
                                          (xxxx becomes I/O keyword)

            ANSI does not allow non-integers in the above  contexts,  but
            both  VMS  and  Fortran-10/20 convert any numeric variable to
            integer.

        g.  Numeric expressions in logical context
            Messages: (BOTH) Mixing logical and numeric
                             Numeric operand in logical context

            ANSI does not allow mixed logical/numeric expressions.

            Fortran-10/20 treats any  numeric  expression  in  a  logical
            context  as if it were a bit string (typeless quantity).  VMS
            does  the  same  for  integer  expressions,  but  non-integer
            numeric  expressions  are allowed only when assigning such an
            expression to a logical variable.

            Fortran-10/20 tests the high-order (sign) bit of  a  variable
            for  true/false,  whereas  VMS  tests  the low-order bit.  If
            numeric  expressions  are  used   in   a   logical   context,
            incompatibilities could result.

        h.  Logical expressions in numeric context
            Messages: (BOTH) Mixing logical and numeric
                             Logical operand in numeric context

            ANSI does not allow mixed logical/numeric expressions.

            VMS treats the logical expression in this context  as  if  it
            were  an  integer,  whereas  Fortran-10/20  treats  it  as  a
            typeless quantity.

        i.  Numeric variables in character context
            Message: (ANSI) Numeric expression in character context

            ANSI does  not  allow  numeric  expressions  in  a  character
            context.  Both VMS and Fortran-10/20 allow numeric scalars or
            arrays that contain Hollerith data  to  be  used  in  certain
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page B-5


            contexts, such as OPEN and CLOSE keywords and as arguments to
            some Fortran-supplied subroutines.

        j.  Overlap of character assignments
            Message: (ANSI) Assigned  variable   appears   in   character
            expression

            The ANSI standard forbids the right-hand side of a  character
            assignment  statement  from  referencing any of the character
            positions of the  character  variable  or  substring  on  the
            left-hand side.  Both VMS and Fortran-10/20 allow this.




   B.4  SUBROUTINES AND FUNCTION ARGUMENT LISTS


        a.  Return labels
            Messages: (ANSI) & used as return label
                      (BOTH) $ used as return label

            The ANSI standard specifies that an asterisk (*)  used  as  a
            dummy  argument  in a subprogram specifies an alternate point
            of return for the subprogram.  VMS allows an ampersand (&) as
            well  as  the  asterisk,  and  Fortran-10/20 allows asterisk,
            ampersand and dollar ($).

        b.  Passing values

            Fortran-10/20  passes  scalar  numeric  arguments  by  value,
            whereas  VMS  passes  them by reference.  This difference can
            produce different results in certain limited cases:

             o  When multiple copies of the same variable are passed to a
                subprogram

             o  When  a  passed  variable  is  also  referenced  by   the
                subprogram through COMMON

             o  When a subprogram contains more than one entry point, and
                the argument lists of the entry points do not agree.


            Each of these cases is specifically  forbidden  by  the  ANSI
            standard,   and  are  incompatibilities  not  caught  by  the
            flagger.

   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page B-6


   B.5  SPECIFIC STATEMENTS


        a.  ACCEPT
            Message: (ANSI) ACCEPT statement

            The ACCEPT statement is supported by VMS  and  Fortran-10/20,
            but is not recognized by ANSI.

        b.  BACKFILE
            Message: (BOTH) BACKFILE statement

            The BACKFILE statement is supported by Fortran-10/20, but  by
            neither VMS nor ANSI.

        c.  COMMON
            Message: (BOTH) Character and non-character variables in
                                COMMON
                     (VMS)  Null padding before xxxxx
                                     (xxxxx is variable name)

            ANSI forbids the mixing of numeric and character data in  any
            one  common  block.   Both  Fortran-10/20  and  VMS allow it.
            Fortran-10/20 V7 always produces a warning in this case;  V10
            produces  the  warning  only  when  compatibility flagging is
            being done.

            Since non-character variables must start  at  a  36-bit  word
            boundary  in Fortran-10/20 but not on VMS, the second message
            is written if padding is introduced.

        d.  DATA
            Message: (ANSI) Substring bounds not constant

            ANSI  forbids  the  use  of  the  implied  DO   clause   when
            referencing  substring  bounds.   Both  Fortran-10/20 and VMS
            allow this.

        e.  DECODE
            Message: (ANSI) DECODE statement

            ANSI does not recognize the DECODE statement.  Both  VMS  and
            Fortran-10/20 do allow the DECODE, with these differences:

                 o Character count -- Fortran-10/20 treats the  character
                   count  as  an internal record size, whereas VMS treats
                   it as a total string count.

                 o Slash (/) format descriptor -- Fortran-10/20  advances
                   to  the  next  internal  record upon encountering this
                   descriptor, whereas VMS does not allow the descriptor.

        f.  DO with no statement label
            Message: (ANSI) DO without statement label
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page B-7


            Both Fortran-10/20 and VMS accept a DO statement  which  does
            not specify a terminating statement label;  such a DO loop is
            instead terminated by an END DO  statement.   ANSI  does  not
            recognize this.

        g.  DO WHILE
            Message: (ANSI) DO WHILE statement

            Both VMS and Fortran-10/20 support  the  DO WHILE  statement,
            ANSI does not.

        h.  DO extended range
            Message: (ANSI) Transfer of control into DO loop

            Extended range DO loops make it possible to transfer  out  of
            the  loop,  execute  statements  in  another  section  of the
            program, and then transfer back into the DO  loop.   VMS  and
            Fortran-10/20 allow this, but ANSI does not.

            This condition is not flagged if the compilation is not being
            globally optimized, because it is only in that optimizer that
            the flow of control of a program is analyzed.

        i.  END DO
            Message: (ANSI) END DO statement

            The END DO statement terminates a DO WHILE or DO loop without
            the  terminating  statement  label.   This  is  supported  by
            Fortran-10/20 and VMS, but not by ANSI.

        j.  ENCODE
            Message: (ANSI) ENCODE statement

            The ENCODE statement is the reverse of the DECODE  statement,
            and the same incompatibilities occur (See DECODE above).

        k.  EQUIVALENCE
                 (ANSI) Character and non-character are EQUIVALENCE-d
                        Single subscript with multi-dimensioned array

            Both  VMS  and  Fortran-10/20  allow  the  use  of  a  single
            subscript  to specify the offset of a multi-dimensioned array
            in the EQUIVALENCE statement;  ANSI does not.

            ANSI forbids the mixing of numeric and character data in  any
            one  equivalence group.  Both Fortran-10/20 and VMS allow it.
            Fortran V7 always produces a warning in this  case;   in  V10
            that warning is issued only under compatibility flagging.

        l.  EXTERNAL
            Messages: (ANSI) * with external name
                      (BOTH) & with external name
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page B-8


            VMS and Fortran-10/20 have  extended  the  ANSI  standard  to
            specify  that  a  user-supplied  subprogram  is to be used in
            place  of   an   intrinsic   function   or   Fortran-supplied
            subroutine.   This is done by placing an asterisk in front of
            the name.  Further, Fortran-10/20 allows an ampersand in this
            context, but VMS does not.

        m.  FIND
            Message: (ANSI) FIND statement

            The FIND statement is supported by VMS and Fortran-10/20, but
            not by ANSI.

        n.  Assigned GOTO
            Message: (VMS) List of labels

            VMS ignores the optional list of labels in an  assigned  GOTO
            statement.   Fortran-10/20  checks  at  runtime to see if the
            assigned variable matches one of the labels in the list,  and
            proceeds to the next statement if there is no match.

        o.  Two-branch logical IF
            Message: (BOTH) Two-branch logical IF

            Fortran-10/20 supports a statement of the form

                      IF (A .LT.  B) 10,20

            where statement label 10 is the 'true'  path,  and  statement
            label  20 is the 'false' path.  Neither VMS nor ANSI supports
            this variation of the IF statement.

        p.  INCLUDE
            Messages: (ANSI) INCLUDE statement
                      (VMS)  /NOCREF switch
                             /CREF switch
                             Default for VMS is /NOLIST

            ANSI does not support the INCLUDE statement.

            Fortran-10/20 lists the included source  unless  the  /NOLIST
            switch  is  used  with  the statement, whereas VMS lists that
            source only if the /LIST switch is used with the statement or
            if  the /SHOW=INCLUDE switch is used in the compiler command.
            VMS does not recognize the /CREF and /NOCREF switches used by
            Fortran-10/20.

        q.  NAMELIST
            Message: (ANSI) NAMELIST statement

            The NAMELIST statement is not  recognized  by  ANSI,  but  is
            supported by both VMS and Fortran-10/20.
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page B-9


        r.  PARAMETER
            Message: (ANSI) No parentheses around PARAMETER list

            ANSI insists upon parentheses surrounding the  constant  list
            in  the  PARAMETER  statement, but both Fortran-10/20 and VMS
            accepts the statement without the parentheses.

            Note that both VMS and Fortran-10/20 assign to  the  constant
            the  data  type  of the symbol when parentheses are used, but
            assign to the symbol the  data  type  of  the  constant  when
            parentheses are not used.

        s.  PRINT
            Message: (BOTH) PRINT (Specifiers) statement

            Fortran-10/20 supports the PRINT statement of  the  following
            form:

                      PRINT (specifiers) iolist

            Neither VMS nor ANSI supports the (specifiers).

        t.  PUNCH
            Message: (BOTH) PUNCH statement

            Neither  VMS  nor  ANSI  supports  the  Fortran-10/20   PUNCH
            statement.

        u.  REREAD
            Message: (BOTH) REREAD statement

            The Fortran-10/20 REREAD statement is  supported  by  neither
            VMS nor ANSI.

        v.  SKIPFILE
            Message: (BOTH) SKIPFILE statement

            The Fortran-10/20 SKIPFILE statement is supported by  neither
            VMS nor ANSI.

        w.  SKIPRECORD
            Message: (BOTH) SKIPRECORD statement

            The  Fortran-10/20  SKIPRECORD  statement  is  supported   by
            neither VMS nor ANSI.

        x.  TYPE
            Message: (ANSI) TYPE statement

            The TYPE statement is supported by Fortran-10/20 and VMS, but
            not by ANSI.

        y.  UNLOAD
            Message: (BOTH) UNLOAD statement
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER       Page B-10


            The Fortran-10/20 UNLOAD statement is  supported  by  neither
            VMS nor ANSI.

        z.  WRITE
            Message: (BOTH) WRITE with default unit

            Fortran-10/20 supports a default unit in the WRITE statement,
            but neither VMS nor ANSI allows this.




   B.6  FORMAT STATEMENT


        a.  Format specifiers not supported by ANSI
            Messages: (ANSI) FORMAT edit descriptor x      (x is specific
            descriptor)
                      No decimal places specified with x

            Fortran-10/20 and VMS support $, O, Q, Z

            Fortran-10/20 (but not VMS) supports:

                 R
                 F, E, D, G in form Fw instead of Fw.0
                 G with character I/O

        b.  Default widths
            Message: (BOTH) Default widths with edit descriptor x

            Fortran-10/20 and VMS differ  on  the  field  width  that  is
            assumed if not explicitly specified.

        c.  Optional commas
            Message: (ANSI) Comma field separator is missing

            VMS and Fortran-10/20 allow  comma  field  separators  to  be
            omitted,  if  there  is no ambiguity in the interpretation of
            the format.  ANSI does not support this.

        d.  Formats in Arrays
            Message: (ANSI) Format in numeric array

            Both VMS and Fortran-10/20 allow  formats  to  be  stored  in
            numeric arrays as Hollerith constants.  ANSI does not support
            this.

   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER       Page B-11


   B.7  INPUT/OUTPUT STATEMENTS

   Many of these incompatibilities are detected  by  FOROTS  at  runtime,
   since  keyword  clauses  in  the  I/O  statements  could have variable
   arguments.  The compiler can detect incompatibilities if the arguments
   are constants.

        a.  Default file names
            Message: (VMS) Default file name

            VMS and Fortran-10/20 differ on the names of files for  which
            no explicit name is given.

        b.  Apostrophe form of record specifier
            Message: (ANSI) Apostrophe in I/O specifier

            ANSI does not support the Fortran-10/20 and VMS I/O specifier
            of the form

                      (unit'recordnumber ...)

        c.  Blanks at end of output line

            Normally, the X format edit  descriptor  cannot  be  used  to
            write  blanks  at  the end of a line.  Fortran-10/20 (but not
            VMS) has one exception:  if the line is written  with  the  $
            carriage-control, or the $ edit descriptor is used to end the
            line, those blanks are written.

            This is detected at runtime.

        d.  Carriage Control
            Message: (BOTH) Carriage control character x

            Neither VMS nor ANSI recognizes  the  Fortran-10/20  carriage
            control  characters  2, 3, -, *, /, $, period or comma.  This
            is detected at runtime.

        e.  NML= versus FMT=
            Messages: (ANSI) Use of NAMELIST
                      (VMS)  Keyword FMT instead of NML

            Fortran-10/20 accepts either keyword FMT= or NML= to  specify
            a NAMELIST in an I/O statement;  VMS accepts only NML=;  ANSI
            does not supports NAMELIST at all.

        f.  Keywords not recognized by ANSI
            Messages: (ANSI) Keyword xxxxx
                             Keyword value for xxxxx

            ACCESS='APPEND', 'SEQIN', 'SEQOUT', 'SEQINOUT', 'RANDOM' and
                   'RANDIN'
            ASSOCIATEVARIABLE=
            BLOCKSIZE=
            BUFFERCOUNT=
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER       Page B-12


            CARRIAGECONTROL=
            DENSITY=
            DEVICE=
            DIALOG and DIALOG=
            DIRECTORY=
            DISPOSE=
            FILE= with CLOSE
            FILESIZE=
            INITIALIZE=
            MODE=
            NAME=
            PADCHAR=
            PARITY=
            PROTECTION=
            READONLY
            RECORDSIZE=
            RECORDTYPE=
            STATUS='EXPUNGE' with OPEN or CLOSE
            STATUS='DELETE' or 'KEEP' with OPEN
            TAPEFORMAT=
            TYPE=
            VERSION=

        g.  Keywords not recognized by VMS
            Messages: (VMS) Keyword xxxxx
                            Keyword value for xxxxx

            ACCESS='SEQIN', 'SEQOUT', 'SEQINOUT', 'RANDOM' and 'RANDIN'
            CARRIAGECONTROL='DEVICE' and 'TRANSLATED'
            DENSITY=
            DEVICE=
            DIALOG and DIALOG=
            DIRECTORY=
            DISPOSE='EXPUNGE', 'LIST', 'PUNCH' and 'RENAME'
            FILESIZE=
            INITIALIZE=
            MODE=
            PADCHAR=
            PARITY=
            PROTECTION=
            STATUS (or TYPE)='DELETE' and 'KEEP' in the OPEN statement
            STATUS (or TYPE)='EXPUNGE' in the OPEN or CLOSE statements
            TAPEFORMAT=
            VERSION=

        h.  Keywords which are incompatible between Fortran-10/20 and VMS
            Messages: (VMS) Keyword xxxxx
                            Keyword value for xxxxx

            CARRIAGECONTROL=
            RECL=
            ASSOCIATEVARIABLE=
            DISPOSE='DELETE', 'KEEP', 'PRINT' and 'SAVE'
            TYPE='NEW', 'OLD', 'SCRATCH' and 'UNKNOWN'
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER       Page B-13


   B.8  INTRINSIC FUNCTIONS AND FORTRAN-SUPPLIED SUBROUTINES

   Messages: (VMS)  xxxxx is an intrinsic function on VMS
                    xxxxx is a Fortran-supplied routine on VMS
                    xxxxx is a generic function on VMS
                    xxxxx is not a generic function on VMS
             (ANSI) xxxxx is not an intrinsic function in Fortran-77
                    xxxxx is not a generic function in Fortran-77

   There are numerous differences between Fortran-10/20 and both VMS  and
   ANSI   in  the  names  of  intrinsic  functions  and  Fortran-supplied
   subroutines.

        a.  Fortran-10/20 Intrinsic Functions

            Instrinsic functions available on Fortran-10/20 which are not
            available on VMS:

               COTAN   DCOTAN

            Intrinsic functions available on Fortran-10/20 which are  not
            available in the Fortran-77 standard:

               BTEST   CMPLX   COSD    COTAN   DCOTAN  DFLOAT  IAND
               IBCLR   IBITS   IBSET   IEOR    IOR     ISHFT   ISHFTC
               NOT     SIND

        b.  Fortran-10/20 Fortran-supplied Subroutines

            Included here are those subroutines supplied by Fortran-10/20
            but not by VMS.

               CHKDIV  CLRFMT  DIVERT  DTOGA   DUMP    FFUNIT  GTODA
               ILL     LEGAL   OVERFL  PDUMP   QUIETX  SAVFMT  SAVRAN
               SETRAN  SORT    TRACE

            The  following  subroutine  is  available  on  both  VMS  and
            Fortran-10/20, but is not known to Fortran-77.

               MVBITS

        c.  VMS Generic Functions

            Included here are functions which are generic on VMS, but not
            generic in Fortran-10/20.

               COSD    SIND    TAND

        d.  Fortran-10/20 Generic Functions

            Included  here   are   functions   which   are   generic   in
            Fortran-10/20, but are generic on neither VMS nor Fortran-77.

               ALOG    ALOG10  AMAX1   AMIN1
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER       Page B-14


        e.  Fortran-10/20 Subroutines versus VMS Intrinsic Functions

            Included  here  are  intrinsic  functions  on  VMS,  but  are
            Fortran-supplied subroutines in Fortran-10/20.

               CDSQRT  CDLOG   CDEXP   CDSIN

        f.  Differences in Subroutines

            Included here are those  Fortran-supplied  subroutines  which
            behave  differently,  or  which  have different arguments, on
            Fortran-10/20 and VMS.

               DATE    ERRSET  ERRSNS  EXIT    TIME




   B.9  FUNCTIONS AND SUBROUTINES ON VMS NOT RECOGNIZED BY FORTRAN-10/20

   These  subprograms  are  recognized  by  VMS  Fortran,  but   not   by
   Fortran-10/20.  No flagging is done with these subprograms.

        a.  VMS Intrinsic Functions

               ACOSD   DBLEQ   IIAND   JIAND   QACOS   QDIM    QSIN
               ASIND   DCMPLX  IIBCLR  JIBCLR  QACOSD  QEXP    QSIND
               ATAN2D  DCONJG  IIBITS  JIBITS  QASIN   QEXT    QSINH
               ATAND   DREAL   IIBSET  JIBSET  QASIND  QEXTD   QSQRT
               BITEST  DIMAG   IIEOR   JIEOR   QATAN   QLOG    QTAN
               BJTEST  DTAND   IIOR    JIOR    QATAN2  QLOG10  QTAND
               DACOSD          IISHFT  JISHFT  QATAN2D QMAX1   QTANH
               DASIND          IISHFTC JISHFTC QATAND  QMIN1   SNGLQ
               DATAN2D         INOT    JNOT    QCOS    QMOD    TAND
               DATAND          IZEXT   JZEXT   QCOSD   QSIGN   ZEXT
                                               QCOSH

        b.  VMS Fortran-supplied Subroutines

               ASSIGN  CLOSE   ERRTST  FDBSET  IDATE   IRAD50
               R50ASC  RAD50   RANDU   USEREX


   [End of FORTRA.DOC]
