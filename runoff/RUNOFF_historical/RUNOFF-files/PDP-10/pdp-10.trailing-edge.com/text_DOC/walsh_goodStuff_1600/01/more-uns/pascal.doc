



                PASCAL FOR THE DECSYSTEM-20

This document describes  the  operation  of  PASCAL  on  the
DECsystem-20.   It is not intended as a tutorial.  Those who
want to learn the language should  consult  an  introductory
text,  such  as  Lecture  Notes in Computer Science - PASCAL                 _______  _____ __ ________ _______ _ ______
User Manual and  Report,  by  Kathleen  Jensen  and  Niklaus____ ______ ___  ______
Wirth.

The PASCAL system currently available on SYS:  is a  revised
version  of  the original system from Hamburg, Germany.  The
system consists of the following logically related pieces:

     1.  PCROSS, a program that reformats PASCAL programs by
         indenting  them according to the block structure of
         the  language,   and   generates   cross-referenced
         listings.

     2.  PASCAL, a program that compiles PASCAL programs  or
         library  modules into .REL files that can be loaded
         with  LINK.   The  compiler  has   several   useful
         features,   including  run-time  checks,  debugging
         code,  and  listings  with  or  without   generated
         assembly code.

     3.  PASLIB, a library .REL file that  is  automatically
         searched  by  .REL  files generated by PASCAL, that
         contains the run-time support, and the debugger.

     4.  DEBUG, a PASCAL debugger that allows users  to  set
         breakpoints by line number in PASCAL programs, type
         out and set variables, and get a back-trace of  all
         called routines.

PASCAL for the DECsystem-20                           Page 2
USING THE PASCAL SYSTEM


1.0  USING THE PASCAL SYSTEM

The following  are  basic  instructions  for  compiling  and
running  a  PASCAL  program.   Special  compiler options are
discussed later.

     @CREATE FOO.PAS    !Create your PASCAL PROGRAM     _
     INPUT:  FOO.PAS.1     _
     00100      BEGIN END.
     00200      $
     *EU

     [FOO.PAS.1]
     @R PASCAL          !Compile your program     _


     *FOO               !Default extension is .PAS     _

     PASCAL, LAST UPDATED 5-SEP-77     _______ ____ _______ ________

     NO ERROR DETECTED     __ _____ ________

     HIGHSEG:   mK     ________   __
     LOWSEG :   nK     ______ _   __
     RUNTIME:   n     ________   _

     EXIT     ____

     @LOAD FOO     _
     LINK:   Loading     _____   _______

     EXIT     ____

     @SAVE FOO     _
     FOO.EXE.1 SAVED     _________ _____

     @RUN FOO     _


     *                  !If your program does no input,     _
                        !  type a CRLF anyway
     EXIT     ____

     @     _



2.0  LANGUAGE FEATURES AND PECULIARITIES

By-products of the run-time support system have put a number
of constraints on PASCAL's syntax.  Among them are:
PASCAL for the DECsystem-20                           Page 3
LANGUAGE FEATURES AND PECULIARITIES


     1.  All control characters are  stripped  out  of  text
         files on input by the run-time support.  Therefore,
         quoted strings may  not  contain  arbitray  control
         characters,  as  might  be  desired  by  a plotting
         package, for instance.  All lower  case  characters
         are automatically converted to upper case, and tabs
         are converted to the equivalent number  of  spaces.
         Thus,  the  compiler  never  sees  these and cannot
         handle them.

     2.  Identifiers may be as long as desired, but are only
         checked  to  10  characters.   They  are allowed to
         contain any character in ['A'..'Z' or '_'].  Global
         symbols  (currently, external FORTRAN, ALGOL, COBOL
         or PASCAL routines, and  file  variables)  must  be
         unique to 6 characters, and may not include '_'.

     3.  Sets are limited to a maximum of 72 elements.  Note
         that `set of char' means `set of (' '..'_')'.

     4.  Special tokens are as follows:

              OR                Logical `or'
              AND               Logical `and'
              NOT               Logical negation
              #                 Not equal (<> doesn't exist)
              <=                Less than or equal
              >=                Greater than or equal
              % or (*           Beginning of a comment
              \ or *)           End of a comment
              :=                Assignment


     5.  Constant subranges  may  be  given  in  sets.   For
         instance,

              var S:set of char;
              S:=['A'..'F'];

         is interpreted the same as

              var S:set of char;
              S:=['A','B','C','D','E','F'];

         Note however that the subrange construction may not
         be used for CASE statement labels.

     6.  CASE  statements  may  optionally  have  the  label
         OTHERS  as  the  last  label to catch any cases not
         explicitly specified.  For instance,

              var C:char;
              case C
              of
PASCAL for the DECsystem-20                           Page 4
LANGUAGE FEATURES AND PECULIARITIES


                'A':DO_SOMETHING_WITH_A;
                'B':DO_SOMETHING_WITH_B;
                others:DO_SOMETHING_WITH_THE_REST
              end;

     7.  The LOOP statement is available.  In BNF, it  looks
         like ({ and } mean repeat 0 or more times):

         <loop statement> ::= loop
                                <statement> {;  <statement>}
                              exit if <expression>;
                                <statement> {;  <statement>}
                              end

         The meaning  should  be  obvious  from  the  syntax
         above.

     8.  Global variables may be initialized at compile time         ______
         by  using the INITPROCEDURE construct.  One example
         might be,

              var I,J:integer;  A:array [1..3] of char;
              initprocedure;
                begin
                  I:=3;
                  J:=7;
                  A[1]:='C';
                  A[3]:='$'
                end;
              procedure FOO;  ...

         Note that INITPROCEDUREs must go  between  the  VAR
         declarations  and  the  first PROCEDURE or FUNCTION
         declarations.  INITPROCEDUREs also may contain only
         assignment statements with constant values.

         INITPROCEDUREs  should   be   used   for   defining
         program-wide  constants  only.   Changing variables
         set by INITPROCEDUREs should be avoided.




3.0  SYSTEM AND EXTERNAL ROUTINES

PASCAL has many  useful  system  routines,  understands  the
calling  sequences  to  external  FORTRAN,  ALGOL,  or COBOL
routines, and allows the user to create libraries of his  or
her own PASCAL routines.
PASCAL for the DECsystem-20                           Page 5
SYSTEM AND EXTERNAL ROUTINES


3.1  PASCAL System Routines

     1.  ABS is a function that takes the absolute value  of
         its  real  or  integer  argument,  and  returns the
         result of the same type.

     2.  TIME is a function that returns as an  integer  the
         time of day in milliseconds.

     3.  RUNTIME is a function that returns  as  an  INTEGER
         the job's CPU time in milliseconds.

     4.  SQR is a function that  takes  a  real  or  integer
         argument, squares it, and returns the result of the
         same type.

     5.  TRUNC is a function that converts its REAL argument
         to an INTEGER.

     6.  ODD is a function that returns the BOOLEAN TRUE  if
         its integer argument is odd, or FALSE otherwise.

     7.  ORD is a function  that  takes  a  scalar  or  CHAR
         argument,  and  returns  its ordinal value.  ORD of
         the first value of a scalar type is 0.

     8.  CHR is a function that takes an  INTEGER  argument,
         and  returns  the  ASCII  character having the same
         numerical value.  This function is the only way  to
         generate   and   print   lower   case  and  control
         characters.

     9.  PRED is a function that takes a scalar, INTEGER, or
         CHAR   argument,   and   returns  its  predecessor.
         Essentially,  1  (in  the  appropriate  units)   is
         subtracted  from  the argument.  PRED of the lowest
         value (first scalar, most negative  number,  lowest
         number  in  a subrange, or ASCII NUL) is undefined,
         and will result in a run-time error if those checks
         are enabled (see below).

    10.  SUCC is a function similar to PRED, except that  it
         returns  the  next greater value.  A run-time error
         will result, if checks are enabled, if the greatest
         value is SUCCed.

    11.  NEW is a procedure that takes  a  pointer  variable
         and optional tag field values, allocates a block of
         core for the type of  data  to  which  the  pointer
         variable  was  declared  to  point,  and  makes the
         pointer variable point to it.  The  variable(s)  in
         the  new  area  are not initialized, so must be set
         before referencing.
PASCAL for the DECsystem-20                           Page 6
SYSTEM AND EXTERNAL ROUTINES


         If  the  allocated  area  is  a  RECORD  type  with
         variants  and  tag  field values are specified, the
         variant part may not be changed later by  assigning
         a new value to the tag variable.  If the record has
         variants but no tag field values were specified  in
         the  call to NEW, then enough core is allocated for
         the largest record, and the  tag  variable  may  be
         changed  later.  However, changing the tag variable
         invalidates all variables in the variant  part  and
         those under it as well.

    12.  PACK is a procedure used for packing elements  from
         a  standard unpacked array into a packed one.  If A
         is an unpacked array, Z is a packed  one  with  the
         same  base type, I, Z and L are index variables for
         A and Z, and ZMIN is the minimum index for Z, then,

              PACK(A,I,Z,J)

         means,

              for L:=ZMIN to ZMIN+J-1 do Z[L]:=A[L-ZMIN+I]

         Though indexing into packed arrays  is  allowed  in
         PASCAL,  and  packing  could  therefore  be done by
         hand, PACK generates  a  tight  loop  and  thus  is
         faster.

    13.  UNPACK is a procedure similar to PACK, but used for
         unpacking  elements  from  a  packed  array into an
         unpacked one.  If AMIN is the minimum index for  A,
         and  the  other  variables  are  as described under
         PACK, then,

              UNPACK(Z,J,A,I)

         means,

              for L:=AMIN to AMIN+I-1 do A[L]:=Z[L-AMIN+J]

         As with PACK, UNPACK is faster than doing the  same
         thing by hand.




3.2  Linkage To Other Languages

PASCAL understands the proper  calling  sequences,  and  can
generate  code,  for  calls  to  FORTRAN,  ALGOL,  or  COBOL
subroutines.  To use such an external routine,  declare  the
procedure  or  function  with  its argument list, at the top                                                  __ ___ ___
level of  your  program.   Then,  where  the  routine  would_____ __  ____  _______
normally  go,  substitute  `EXTERN  <language symbol>'.  For
PASCAL for the DECsystem-20                           Page 7
SYSTEM AND EXTERNAL ROUTINES


instance, FORTRAN's  SIN  routine  may  be  used  in  PASCAL
programs by giving the declaration,

     function SIN(X:real):real;  extern FORTRAN;

It is  probably  not  a  good  idea  to  pass  complex  data
structures  this  way,  since PASCAL's RECORD format may not
match those of the other languages.

Also note that any FORTRAN library function errors  will  be
trapped by PASCAL, and will stop your program;  you may not,
for instance, depend on the square root of a negative number
returning the square root of its absolute value.

Finally, as a convenience, the following REAL  functions  of
REAL arguments are pre-declared as FORTRAN functions:

     SIN, COS, SIND,  COSD,  ARCSIN  (alias  of  ASIN),
     ARCCOS  (alias  of  ACOS), ARCTAN (alias of ATAN),
     SINH, COSH, TANH, SQRT, RANDOM (alias of RAN), LOG
     (alias of ALOG10), LN (alias of ALOG), and EXP.



3.3  Linkage To PASCAL Routines

PASCAL libraries can be created by simply writing  a  module
with  just  declarations,  no  main program, and telling the
compiler  not  to  expect  a  main  program  (see   Compiler
Options).   When  this  is done, all top-level functions and
procedures are made INTERNals, and  can  be  linked  with  a
PASCAL  module  containing  a  main program.  Unfortunately,
library searching doesn't work on  PASCAL  libraries,  since
the  entry block in the .REL file (LINK block type 4) is not
set up properly.

To reference a PASCAL library routine, use the  same  syntax
as  for  calls  to  other  languages, but omit the <language
symbol> altogether.



4.0  COMPILER OPTIONS

Compiler options are selected by placing carefully formatted
comments in the source program.  The format is,

     %$f+,f-,f-,f+ ANY FURTHER COMMENT\

where each f is  a  single  character  denoting  a  compiler
option,  and  the  +  and - mean turn the option on and off,
respectively.
PASCAL for the DECsystem-20                           Page 8
COMPILER OPTIONS


The options available are,

     C+  Generate  run-time  checks   for   array   indexes,
         assignments  to  scalar  subranges,  and variables.
         Default is C+.

     D+  Generate special symbol tables, debugging code, and
         request the PASCAL debugger.  Option T+ must be set
         to use the debugger.  Default is D-.

     L+  Generate a listing of the source  file  with  error
         messages, etc.  Default is L+.

     M+  Expect a main program.  Top-level routines are  not
         made  INTERNal.   M-  means  don't  expect  a  main
         program.  Default is M+.

     O+  Print the assembly code generated  along  with  the
         program  listing.   L+  must  be  set  to get this.
         Default is O-.

     T+  Generate code to initialize the file variables  TTY
         and TTYOUTPUT (see Input-Output).  Default is T+.



5.0  INPUT-OUTPUT

Input and output routines are essentially  as  described  in
the  PASCAL  Language  report.   The  only major changes are
those needed to get  around  the  fact  that  PASCAL  cannot
handle  CRLFs  (or  any  other control characters).  All I/O
routines take a file  variable,  and  many  take  additional
arguments as well.  Short descriptions are,

     1.  RESET initializes an input file, closing it  if  it
         is already open, and then reinitializing.  The file
         of  text  INPUT  is  automatically  reset  at   the
         beginning  of  each PASCAL program.  The input file
         name   is    DSK:<first    6    chars    of    file
         identifier>.<next 3 chars>[,].

     2.  REWRITE initializes an output file, closing the old
         one   first.    The   file   of   text   OUTPUT  is
         automatically rewritten at the  beginning  of  each
         PASCAL  program.   The  file  name is generated the
         same way as for RESET.  A side effect  of  this  is
         that  all  PASCAL  users  will  find  a file called
         OUTPUT on their disk area.

     3.  GET causes the next file component to be read  from
         the  input file, and placed into the buffer area of
         the file variable.
PASCAL for the DECsystem-20                           Page 9
INPUT-OUTPUT


     4.  PUT causes the current contents of the buffer  area
         in  the  file  variable  to  be  output as the next
         component of the output file.

     5.  EOF is true for a given file variable if that  file
         is at its end-of-file.

     6.  BREAK  causes  any  internal  buffer  area  in  the
         run-time support to be dumped to the file.  This is
         good for talking to interactive  devices,  such  as
         your terminal.

     7.  PAGE causes  a  carriage-return,  form-feed  to  be
         passed  to the output file.  This is only legal for
         text files.

     8.  EOLN is true if the input text file is pointing  to
         a CRLF.  This is the way to test for end-of-line.

     9.  READ reads integers, strings, and  reals  from  the
         input file.  For instance,

              var A:real;  I:integer;  C:char;
              read(input,A,I,C)

         causes a real number,  an  integer,  and  a  single
         character to be read from the input file.

    10.  READLN has the same call as READ, but also eats the
         rest of the line through the next CRLF.

    11.  WRITE writes  integers,  strings,  characters,  and
         reals to the output file, much as READ reads them.

    12.  WRITELN has the same calling sequence as WRITE, but
         it appends a CRLF to the end of the line.

It should be  noted  that  the  I/O  routines  as  currently
implemented  in  PASCAL  are  very  cumbersome  to  use  and
difficult to master.  Thus, one  suggestion  is  to  find  a
sequence of I/O routine calls that works, then use that as a
template.  Two examples follow, the first a simple one  that
works with the PASCAL debugger, and the second more advanced
(it avoids the annoying `*' at the beginning of a  run)  but
not compatible with the debugger.
PASCAL for the DECsystem-20                          Page 10
INPUT-OUTPUT


5.1  Example 1

VAR
  S:REAL;

BEGIN
  WHILE TRUE
  DO
    BEGIN
      READ(TTY,S);
      S:=SQRT(S);
      WRITELN(TTY,S);
      BREAK(TTY);
      WRITE(TTY,'N: ');
      BREAK(TTY);
      READLN(TTY)
    END
END.
PASCAL for the DECsystem-20                          Page 11
INPUT-OUTPUT


5.2  Example 2

%$T-\
VAR
  S:REAL;

BEGIN
  REWRITE(TTYOUTPUT);
  WRITE(TTY,'N:');
  BREAK(TTYOUTPUT);
  RESET(TTY);
  WHILE TRUE
  DO
    BEGIN
      READ(TTY,S);
      S:=SQRT(S);
      WRITELN(TTY,S);
      BREAK(TTYOUTPUT);
      WRITE(TTY,'N: ');
      BREAK(TTYOUTPUT);
      READLN(TTY)
    END
END.
