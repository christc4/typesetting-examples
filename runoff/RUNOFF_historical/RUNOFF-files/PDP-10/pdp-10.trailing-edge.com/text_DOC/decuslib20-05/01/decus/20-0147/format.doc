








            FORMAT*PROG AM*US  S*GUIDE*  RMAT     RAM*   RS*  IDE*FORMAT
            *         OGR   USER      E*FO  AT   OG  M  SE S* U        A
            E  ORMAT*PR  RAM  SE  *GUI  *F   AT PR   A *U   S*GUID  FORM
            D  FORMAT*  OGRAM  S  S*GUI  *    AT*    RAM  S  S*GUI  *
            I  *FORMAT  ROGRA  U  RS*G  DE  O  A  P  GR  *US  S*GU  E
            U      RMA  PROGR  *      GUID  FO   T*  O  AM*US  S*G  D
            G  DE*FORM  *PROG  M  SE  *GUI  *FO MAT  R  RAM*U  RS*  I
            *  IDE*FOR  T*PRO  A  USE  *GU  E*FORMA  P         ERS  U
            S  UIDE*FOR  T*P  GR  *USE  *G  DE*FORM  *  OGRAM  SER  G
            R  GUIDE*FORM   PROG  M*USE  *  IDE*FOR  T  ROGRA  USE  *
      RAM*USERS*GUIDE*FORMAT*PROGRAM*USERS*GUIDE*FORMAT*PROGRAM*USERS*    E*FO
      G      ERS*      FORMAT*   GRAM*US      I      MAT*PROG AM*US  S*  ID  F
      O  AM*U  RS  UIDE  ORM  *PR  RAM  SERS*GU  E*FO  AT*PR   AM*U   S*GU   *
      R  RAM*U  R  GUIDE  O  AT*PR  R  *USERS*G  DE*FO  AT*  O  AM*    S*    E
      P  GRAM  SE  *GUI  *F  MAT*P  G  M*USERS*  IDE*  RMA  PRO  AM  S    G  D
      *      M*US      IDE*  RMAT*  O  AM*    S      *FOR  T*PRO  A  US  S*  I
      T  ROGRAM*U  RS  UIDE  ORMAT  R  RAM*U  R  GU  E*FO  AT*PR  R  *USERS  U
      A  PROGRAM*  ERS  UID  FORMA  P  GRAM*  E  *GU  E*F         G  M*USER  G
      M  *PROGRAM  SERS  UID  FOR  T*P  GRAM  S  S*GU  E*  RMAT*  O  AM*USE  *
      R  T*PROGRA  USERS  UIDE   RMAT*PR      U  RS*GU  E  ORMAT  R  RAM*US  S
      ORMAT*PROGRAM*USERS*GUIDE*FORMAT*PROGRAM*USERS*GUIDE*FORMAT*PROGRAM*USER
              R  RAM*US  S*GU       M          *       UIDE*FO       O
              P  GRAM*U  RS  UIDE*FOR  T*PROGRAM  SERS*  IDE  ORMAT*PR
              *  OGRAM*  E  *GUIDE*FO  AT*PROGRA  USERS*  I  *F
              T  ROGRAM  SE  *GUIDE*F  MAT*PROGR  *USER  GUI  *FORM
              A  PROGRA  USER    IDE*       PROG       RS*GUID    RMA
              M  *PROGR  *USERS*G  DE  ORMAT*PRO  AM*  ERS*GUIDE*F  MA
              R  T*PROG  M*USERS*G  D  FORMAT*PR  RAM*  ERS*GUIDE*F  M
              OR  T*PR  RAM*USERS  UI  *FORMAT*P  GRAM*  ERS*GUIDE  OR
               ORM    ROGR       S*GU          *  OGRAM*  E       E*F
                 RMAT*PROGRAM*USERS*GUIDE*FORMAT*PROGRAM*USERS*GUIDE
                 ORM       R  *USERS  U      R       GRAM          D
                *F  MAT*PROG  M*USER  GUI  *FO  AT*PR  RA  USERS*GUI
                E  ORMAT*PRO  AM*USE  *GU  E*F  MAT*PR  R  *
                D  FORMAT*PR  RAM*US  S*G  DE*  RMAT*P  G  M*USER
                I  *FO     P  GRAM*U  RS*  IDE  ORMAT*  O       E
                U  E*FORM  *  OGRAM*  ERS  UID  FORMAT  R  RAM*US
                G  DE*FOR  T  ROGRAM  SER  GUI  *FORMA  P  G
                *G  DE*FO  AT  ROGR  *USE  *GU  E*FOR  T*  OGRAM*USE
                 *GU       MAT*    RAM*      G       RMAT          S
                   GUIDE*FORMAT*PROGRAM*USERS*GUIDE*FORMAT*PROGRAM*U



                     FORTRAN FORMAT Statement Generator Program

                                    User's Guide

                                  Donald E. Barth

                                  1 December 1983











             FFFFFFFFF   OOO    RRRRRR    MM       MM     A    TTTTTTTT
             FF        OO   OO  RR    RR  MMM     MMM    AAA      TT
             FF       OO     OO RR     RR MMMM   MMMM   AA AA     TT
             FF       OO     OO RR    RR  MM MM MM MM  AA   AA    TT
             FFFFFF   OO     OO RRRRRR    MM  MMM  MM AA     AA   TT
             FF       OO     OO RR  RR    MM   M   MM AA     AA   TT
             FF       OO     OO RR   RR   MM       MM AAAAAAAAA   TT
             FF        OO   OO  RR    RR  MM       MM AA     AA   TT
             FF          OOO    RR     RR MM       MM AA     AA   TT

       PPPPPP    RRRRRR       OOO       GGGGGG RRRRRR        A     MM      MM
       PP    PP  RR    RR   OO   OO   GG       RR    RR     AAA    MMM    MMM
       PP     PP RR     RR OO     OO GG        RR     RR   AA AA   MMMM  MMMM
       PP    PP  RR    RR  OO     OO GG        RR    RR   AA   AA  MM MMMM MM
       PPPPPP    RRRRRR    OO     OO GG   GGGG RRRRRR    AA     AA MM  MM  MM
       PP        RR  RR    OO     OO GG     GG RR  RR    AA     AA MM      MM
       PP        RR   RR   OO     OO GG     GG RR   RR   AAAAAAAAA MM      MM
       PP        RR    RR   OO   OO   GG    GG RR    RR  AA     AA MM      MM
       PP        RR     RR    OOO       GGGGGG RR     RR AA     AA MM      MM

               UU      UU    SSSSSSS EEEEEEEEEE RRRRRRR       SSSSSSS
               UU      UU  SS        EE         RR     RR   SS
               UU      UU SS         EE         RR      RR SS
               UU      UU  SS        EE         RR     RR   SS
               UU      UU    SSSS    EEEEEEE    RRRRRRR       SSSS
               UU      UU        SS  EE         RR   RR           SS
               UU      UU         SS EE         RR    RR           SS
                UU    UU         SS  EE         RR     RR         SS
                  UUUU    SSSSSSS    EEEEEEEEEE RR      RR SSSSSSS

                    GGGGGGG UU      UU IIIIII DDDDDDD    EEEEEEEEEE
                  GG        UU      UU   II   DD     DD  EE
                 GG         UU      UU   II   DD      DD EE
                 GG         UU      UU   II   DD      DD EE
                 GG   GGGGG UU      UU   II   DD      DD EEEEEEE
                 GG      GG UU      UU   II   DD      DD EE
                 GG      GG UU      UU   II   DD      DD EE
                  GG     GG  UU    UU    II   DD     DD  EE
                    GGGGGGG    UUUU    IIIIII DDDDDDD    EEEEEEEEEE




                     FORTRAN FORMAT Statement Generator Program

                                    User's Guide

                                  Donald E. Barth

                                  1 December 1983









                           TABLE OF CONTENTS
                           ----- -- --------


      Chapter 1:  General Instructions

        Introduction  .  .  .  .  .  .  .  .  .  .  .  .  .  .   1

        Command Structure   .  .  .  .  .  .  .  .  .  .  .  .   2

        Case Notation for Alphabetic Letters  .  .  .  .  .  .   3


      Chapter 2:  Short Descriptions of the Commands

        The Commands listed in Alphabetical Order   .  .  .  .   5

        Table of Command Argument Types .  .  .  .  .  .  .  .  15


      Chapter 3:  Complete Descriptions of the Commands

        The Commands listed in Alphabetical Order   .  .  .  .  17


      Chapter 4:  Commands Needed for Paging on Video Terminals

        Introduction  .  .  .  .  .  .  .  .  .  .  .  .  .  .  95

        Example of FORTRAN Code Containing Several Messages  .  98

        Short Descriptions of the Paging Commands   .  .  .  . 101

        Table of Command Argument Types .  .  .  .  .  .  .  . 105

        Complete Descriptions of the Paging Commands   .  .  . 106


      Appendix A

        FORMAT Program Development History .  .  .  .  .  .  . 139


      Appendix B

        List of Files Included in this Package   .  .  .  .  . 141




                                     Chapter 1

                                GENERAL INSTRUCTIONS



                                    Introduction
                                    ------------

      The FORMAT program reads a sample form or a rough version  of  messages,
      and  generates  FORTRAN FORMAT statements which can be used by a FORTRAN
      program to reproduce the form complete with embedded  variables,  or  to
      generate   the   messages  with  lines  of  uniform  length.   The  case
      conventions, the structure of the commands, and the meanings of many  of
      the commands which are recognized by the FORMAT program are identical to
      those accepted by the DECsystem-10 text processing program RUNOFF.  When
      text  containing  only  those  commands which are recognized by both the
      FORMAT and RUNOFF programs is processed by the FORMAT program, then  the
      use  of  the  resulting FORMAT statements generates the text which would
      have been produced directly by  RUNOFF.   Although  the  FORMAT  program
      provides  many of the same capabilities as RUNOFF, the FORMAT program is
      itself written in a system independent subset of FORTRAN and is  not  an
      extended  version of RUNOFF.  If a RUNOFF capability is not described in
      this documentation, then this capability is not provided by  the  FORMAT
      program.   In  particular,  the  FORMAT  program  does  not  provide any
      footnoting, indexing or underlining capabilities.

      For sections of text which are too long to be represented  in  a  single
      FORMAT   statement,  the  FORMAT  program  can  generate  FORTRAN  WRITE
      statements which reference each of the resulting FORMAT statements.  The
      statement  numbers  of  the FORMAT statements and the references to them
      are incremented as necessary.  For very long messages, the text on  each
      page  can  be  broken  into  separate  FORMAT statements and sections of
      predefined FORTRAN code can be inserted automatically at  the  tops  and
      bottoms of the pages.

      The lines of text which are represented in  the  FORMAT  statements  can
      include  output field descriptions which are kept separate from the text
      which is represented in H, apostrophe or  asterisk  notation.   A  fixed
      line  of  text  can  be  superimposed  upon  each  line of text which is
      represented in the resulting FORMAT statements to rule vertical lines of
      characters.   If  identical parallel forms are being generated, then the
      input file only needs to specify the text for the left form and this can
      be copied to the right as many times as are desired.

      The FORMAT program produces 2 output files, a FORTRAN language file  and
      a proof file.  The FORTRAN language file must be merged into an existing
      program or else the input file must  have  specified  the  rest  of  the
      FORTRAN  statements,  which,  together with the newly constructed FORMAT
      statements, make up the program.  The proof file contains the text which
      would  be  generated when the resulting FORMAT statements are used.  The
      locations  at  which  output  field  specifications  are  inserted   are
      indicated  by  dollar  signs  in  this  text.   The  actual output field
      specifications are indicated in separate lines in the proof file  before
      the  lines  into  which  these output field specifications are inserted.
      The proof file also contains an indication of the location at which each
      FORMAT  statement  begins,  a  copy of each of the commands in the input2                                            FORMAT Program User's Guide


file, and a copy of each of the FORTRAN statements which were  specified
directly by the input file.


                           Command Structure
                           ------- ---------

Each line of the input file which does not start with a  period  in  the
left  column  contains  text  which  is  to be represented in the FORMAT
statements or contains a FORTRAN statement or a FORTRAN comment which is
to  be  copied  into  the output file unchanged except for possible case
conversion of the alphabetic letters.  Each line  which  starts  with  a
period  in  the  left  column  is  interpreted  as a command.  A command
consists of the leading period followed either by a word or by a  phrase
which  identifies  the  command,  followed  for  some commands by 1 or 2
numbers, by 1 or 2 characters, or by the text which extends through  the
rightmost  printing character on the line.  The alphabetic letters which
form the word or phrase can be supplied in lower case, in upper case, or
in  a  mixture of upper and lower cases.  The word, or each of the words
in a phrase, can be abbreviated by truncation leaving at least the  left
letter in each word if additional words or their abbreviations appear to
the right.  Spaces are allowed before, between and after the words in  a
phrase  but  are  not  required.   Only  enough letters must be typed to
unambiguously identify the word or phrase from all others.  The numbers,
characters or line of text which follows the word or phrase are referred
to as the arguments of the command.  The pairs of numbers  or  pairs  of
characters  which  are  arguments  of  some commands can be separated by
spaces and/or by a single comma, but the comma is  not  required  unless
only the second number or second character of the pair is supplied.

For example, a few of the many ways in which the command

     .FLAGS SPACE *

could be specified are

     .FS* or .F S * or .FLS* or .FSP* or .FLSP* or .FL SP *

Except for those commands in which the word or phrase can be followed by
the  text  which extends through the rightmost printing character on the
line, any command can be followed on the same line by another command or
by  a  semicolon  which  can  be followed in turn by whatever would have
otherwise have appeared on the next line.  If 2 commands  are  separated
by  a semicolon, then spaces can appear to the left of the semicolon and
to the right of  the  second  period,  but  cannot  appear  between  the
semicolon  and the second period.  If 2 commands appear on the same line
but are not separated by a semicolon, then spaces can appear between the
first  command and the second period.  A leading period or a command can
be followed by an exclamation point and then by a comment which  extends
through  the  next  semicolon on the same line or through the end of the
line if a semicolon does not appear on the same line to the right of the
exclamation  point.   A comment is not terminated by the appearance of a
period.      General Instructions                                                   3


      For example, the text

           .SKIP 2
           .CENTER
           This is a Title

      could also be specified by any of the following single lines

           .SKIP 2.CENTER;This is a Title
           .SKIP 2;.CENTER;This is a Title
      or
           .SKIP 2!comment;.CENTER!comment;This is a Title

      An underscore character can appear  before  any  character,  such  as  a
      leading  period in a noncommand line, or a semicolon, exclamation point,
      comma or another underscore in a command line, which is to be treated as
      an ordinary printing character.


                        Case Notation for Alphabetic Letters
                        ---- -------- --- ---------- -------

      This program can process text in which  the  letters  A  through  Z  are
      already in the desired mixture of upper and lower cases (capital letters
      and small letters, respectively), or in which the alphabetic  letters  A
      through Z are all in one case with shift indications for the other case.

      An .UPPER CASE command or 2 consecutive  circumflexes  anywhere  in  the
      source  text  indicates  that  the  cases  of  all subsequent alphabetic
      letters which are not otherwise marked are to be  retained.   An  .UPPER
      CASE command is considered to be in effect when this program is started.
      A .LOWER CASE command or 2 consecutive  back  slashes  anywhere  in  the
      source  text  indicates that all subsequent alphabetic letters which are
      not otherwise marked are to be converted  to  their  lower  case  forms.
      Regardless of the overall case setting, any single letter which is to be
      converted to its upper case form can be preceded by a single circumflex,
      and  any  single  letter which is to be converted to its lower case form
      can be preceded by a single back slash.  If a .FLAGS CAPITALIZE  command
      has  been  issued,  then  a less than sign can be used at the start of a
      word to indicate that all of the following alphabetic letters are to  be
      converted  to  their  upper  case forms in the word which extends either
      through the last character on the line, or up to the next space,  or  up
      to  the next less than sign, whichever comes first.  A single underscore
      can precede any character, such as a circumflex or a back slash or  even
      another  underscore,  which is to be treated as a nonalphabetic printing
      character.  A space which is to be treated as a  nonalphabetic  printing
      character  can  be indicated either by a number sign or by a space which
      is preceded by an underscore.  A number sign which is to be  kept  as  a
      number  sign must be preceded by a single underscore.  Any of these flag
      characters can be changed or temporarily disabled  by  commands  in  the
      source text.

      If the source file contains only lower case letters, but both cases  are
      desired  and  can  be  processed  by  the FORTRAN compiler and operating
      system, then, without any special action, all  letters  will  remain  in
      their lower case forms except for those letters which immediately follow
      a single circumflex or which are in words which are preceded by  a  less4                                            FORMAT Program User's Guide


than sign if a .FLAGS CAPITALIZE command has been issued.

If the source file contains only upper case letters, but both cases  are
desired  and  can  be  processed  by  the FORTRAN compiler and operating
system, then the input file should contain a .LOWER CASE  command  or  2
consecutive  back  slashes so that subsequent letters will be translated
to their lower case forms except for  those  letters  which  immediately
follow  a single circumflex or which follow a single underscore or which
are in words which are  preceded  by  a  less  than  sign  if  a  .FLAGS
CAPITALIZE command has been issued.  If there are sections of the source
text which are to be kept primarily in their original upper case  forms,
then  these  sections  can be preceded by an .UPPER CASE command or by 2
consecutive circumflexes, and then any individual letters which need  to
be  converted  to  their lower case forms can be preceded by single back
slashes.

For example, the source text

.preface       WRITE(1,$)
.nofill.flags capitalize.output width 60.offset 0
\\^ONLY THE FIRST LETTER IN THIS LINE REMAINS UPPER CASE.
<THE FIRST WORD IN THIS LINE WILL BE CAPITALIZED.
^^^all but the first letter of this line remains lower case.
<the first word in this line will be capitalized.
Underscores precede _^, _\, _<, _# or __ which are kept.
.program;      END

would, when processed by this program, be transformed into the following
FORTRAN text

      WRITE(1,1)
    1 FORMAT(43HOnly the first letter in this line remains ,
     111Hupper case./35HTHE first word in this line will be,
     213H capitalized./33HAll but the first letter of this ,
     324Hline remains lower case./22HTHE first word in this,
     426H line will be capitalized./20HUnderscores precede ,
     531H^, \, <, # or _ which are kept.)
      END

which would, in turn, generate the following text when run.

Only the first letter in this line remains upper case.
THE first word in this line will be capitalized.
All but the first letter of this line remains lower case.
THE first word in this line will be capitalized.
Underscores precede ^, \, <, # or _ which are kept.


                                     Chapter 2

                         SHORT DESCRIPTIONS OF THE COMMANDS



                     The Commands Listed in Alphabetical Order
                     --- -------- ------ -- ------------ -----

      Most of the commands which can appear in  the  source  files  which  are
      processed  by  the FORMAT program are summarized in this chapter and are
      described in detail in the next chapter.  However,  the  commands  which
      are  needed  for parcelling out the lines in long messages into separate
      pages are described later in this manual.

      Above the description of each command  is  shown  the  command  name  in
      capital letters together with a one line summary in small letters of the
      numbers, characters or line of text which can appear to its  right.   To
      make  the  descriptions  easier  to  read,  the command names are always
      capitalized in the descriptions, but the commands would not have  to  be
      capitalized  in  the actual source text which is processed by the FORMAT
      program.

      .BLANK number of extra blank lines to be generated

           The specified number of extra blank lines are to be represented  in
           the FORMAT statement.  .SKIP is similar.

      .BREAK

           No additional text is to be included in the line of text  currently
           being  represented  in the FORMAT statement.  Blank lines requested
           by .BLANK or  .SKIP  or  implied  by  .SPACING  are  not  generated
           immediately.   Similar  to  .EJECT which generates such blank lines
           immediately.

      .CARRIAGE next carriage control character
           or
      .CARRIAGE next carriage control, subsequent carriage control

           The first specified character  is  to  replace  the  space  in  the
           leftmost column of the next line which is represented in the FORMAT
           statements.  If a second character is specified, it is  to  replace
           the  space  in the leftmost column of each of the subsequent lines.
           Opposite of .NO CARRIAGE.  .NO CARRIAGE is the default.

      .CENTER width of region as unsigned number
      .CENTER offset from largest right margin as signed number
      .CENTRE width of region as unsigned number
           or
      .CENTRE offset from largest right margin as signed number

           The following line of text is to be centered in the region given as
           an  unsigned  number or in the region to the left of the sum of the
           largest right margin  plus  the  signed  number.   Except  for  the
           insertion of the initial spaces, the line is to be represented with
           the same number of spaces as in the original source.6                                            FORMAT Program User's Guide


.COMMENT line of text which is to be ignored

     The characters which appear to the right of  the  .COMMENT  command
     are  to be treated as the text of a comment and are otherwise to be
     ignored.

.CONTINUE next statement number, statement number increment

     The following text is to be represented in a new FORMAT  statement.
     .INSERT  and  .PREFACE  commands are retained.  .PROGRAM command is
     cancelled.  .TEXT is similar.

.COPY number of characters to copy, number of times to copy

     The indicated number of characters at the left  end  of  each  line
     represented  in the FORMAT statements, after the application of the
     line of text specified by a .MASK command if any,  but  before  the
     application  of  the  character specified by the .CARRIAGE command,
     are to be copied the indicated number of additional  times  to  the
     right.  Opposite of .NO COPY.  .NO COPY is the default.

.DEFINE GROUP

     The following lines  of  text  through  the  next  .END  DEFINITION
     command  or  the next of any of the various .DEFINE commands are to
     be copied  into  the  output  file  before  each  group  of  FORMAT
     statements  which is preceded by a .TEXT command.  A single line to
     be inserted before each group of FORMAT statements can  be  defined
     by the .GROUP command instead.

.DEFINE PREFACE

     The following lines  of  text  through  the  next  .END  DEFINITION
     command  or  the next of any of the various .DEFINE commands are to
     be copied into the output file before  each  FORMAT  statement.   A
     single  line  to  be  inserted  before each FORMAT statement can be
     defined by the .PREFACE command instead.

.EJECT

     No additional text is to be included in the line of text  currently
     being  represented  in the FORMAT statement.  All blank lines which
     have been requested by .BLANK or .SKIP or implied by  .SPACING  are
     generated  immediately.   Similar to .BREAK which does not generate
     such blank lines immediately.

.END DEFINITION

     Indicates that all of the lines of  text  have  been  be  specified
     which  are  to  be  inserted  before  some  or  all  of  the FORMAT
     statements which are generated.  If these lines were preceded by  a
     .DEFINE  GROUP  command,  then  these lines are inserted before the
     first FORMAT statement and before each subsequent FORMAT  statement
     which  follows  a  .TEXT  command.   If  these  lines  were instead
     preceded by  a  .DEFINE  PREFACE  command,  then  these  lines  are
     inserted before every FORMAT statement.      Short Descriptions of the Commands                                     7


      .END OF FILE

           No additional text is to be processed.

      .FILL

           Multiple spaces are to be removed from the following text and words
           are  to  be accumulated until the next word would extend beyond the
           right margin.  Opposite of .NO FILL.  .FILL is the default.

      .FLAGS
           or
      .FLAGS ALL

           Most flag characters are enabled in  the  source  text.   Does  not
           change interpretation of flag characters specified by .FLAGS FENCE,
           .FLAGS CONTROL and .FLAGS REMARK commands.  Opposite of  .NO  FLAGS
           ALL.  .FLAGS ALL is the default.

      .FLAGS CAPITALIZE character to precede capitalized words

           Words in which each letter is to be capitalized can be preceded  by
           the specified character.  Less than sign is assumed if no character
           follows the .FLAGS  CAPITALIZE  command.   Opposite  of  .NO  FLAGS
           CAPITALIZE.  .NO FLAGS CAPITALIZE is the default.

      .FLAGS CONTROL character to precede commands

           Commands in the source file are indicated by having  the  specified
           character  in  the  first  column.   Opposite of .NO FLAGS CONTROL.
           .FLAGS CONTROL _. is the default.

      .FLAGS FENCE character to terminate and separate commands

           A command can be followed by the specified character  and  then  by
           whatever  would  have  otherwise  have  appeared  on the next line.
           Opposite of .NO FLAGS FENCE.  .FLAGS FENCE _; is the default.

      .FLAGS INSERT character to indicate location of insertions

           The specified character can be used in program text to indicate the
           locations  at  which  statement  numbers are to be inserted, and in
           text being represented in the FORMAT  statements  to  indicate  the
           locations  at  which  output field descriptions as specified by the
           .INSERT command are to be inserted.  Opposite of .NO FLAGS  INSERT.
           .FLAGS INSERT $ is the default.

      .FLAGS LOWER CASE character to precede lower case letters

           Letters in the source text which are to be  translated  into  lower
           case  can  each be preceded by a single appearance of the specified
           character.   Two  adjacent  appearances  of  this   character   are
           equivalent to the .LOWER CASE command.  Opposite of .NO FLAGS LOWER
           CASE.  .FLAGS LOWER CASE _\ is the default.8                                            FORMAT Program User's Guide


.FLAGS QUOTE character to precede character to be used as is

     The specified character can precede any special character which  is
     to  be  treated  as  an  ordinary character.  Opposite of .NO FLAGS
     QUOTE.  .FLAGS QUOTE __ is the default.

.FLAGS REMARK character to separate commands from comments

     The specified character can precede a comment which appears to  the
     right  of  a command.  Opposite of .NO FLAGS REMARK.  .FLAGS REMARK
     _! is the default.

.FLAGS SPACE character to indicate a nonadjustable space

     The specified character can be used to represent a space  which  is
     to  be  treated  as  a  portion  of  a  word  rather than as a word
     boundary.  Opposite of .NO FLAGS SPACE.  .FLAGS  SPACE  _#  is  the
     default.

.FLAGS UPPER CASE character to precede upper case letters

     Letters in the source text which are to be translated to upper case
     can  each  be  preceded  by  a  single  appearance of the specified
     character.   Two  adjacent  appearances  of  this   character   are
     equivalent to the .UPPER CASE command.  Opposite of .NO FLAGS UPPER
     CASE.  .FLAGS UPPER CASE _^ is the default.

.GROUP line of text to precede groups of FORMAT statements

     The line of text which appears to the right of the  .GROUP  command
     is  to  be  copied into the output file before each group of FORMAT
     statements which is  preceded  by  a  .TEXT  command.   The  .GROUP
     command  can be cancelled by a .NO GROUP command.  .NO GROUP is the
     default.  A group of lines to be  inserted  before  each  group  of
     FORMAT  statements  can  be  defined  by  the .DEFINE GROUP command
     instead.

.INDENT number of extra spaces to insert beyond left margin

     The following line of text is to be indented from the  left  margin
     by the indicated number of spaces.

.INPUT WIDTH maximum number of characters in any input line

     Only the indicated number of characters in each line in  the  input
     file  are  to be read and processed.  Maximum width is 300.  .INPUT
     WIDTH 132 is the default.

.INSERT output field specification to replace next $ signs

     The characters appearing to the right of the .INSERT  command  form
     an output field specification which is to replace the next group of
     contiguous dollar signs.   All  unused  groups  of  characters  are
     discarded if either a .NO INSERT or a .TEXT command is issued.      Short Descriptions of the Commands                                     9


      .JUSTIFY

           Extra spaces are to be inserted between the words in fill  mode  to
           cause  the  lines to be flush with both the left and right margins.
           Opposite of .NO JUSTIFY.  .JUSTIFY is the default.

      .LEADING

           The FORMAT statements are to include initial blank lines  requested
           by  .BLANK and .SKIP commands which appear before the text which is
           to be represented.  Opposite of .NO LEADING.  .NO  LEADING  is  the
           default.

      .LEFT MARGIN number of spaces to left of text

           The following text is to begin in the column to the  right  of  the
           indicated  column.   This is in addition to the offset specified by
           the .OFFSET  command.   .LEFT  MARGIN  0  and  .OFFSET  1  are  the
           defaults.

      .LOWER CASE

           Upper case letters on the following lines are to be  translated  to
           lower case unless preceded by circumflexes or underscores or, if in
           flag capitalize mode, unless in words which are  preceded  by  less
           than  signs.  Equivalent to appearance of 2 back slashes.  Opposite
           of .UPPER CASE which is the default.

      .MASK text to be superimposed onto each output line

           The printing characters appearing to the right of the .MASK command
           are  to be superimposed onto each line of text which is represented
           in the FORMAT statements.  The .MASK command is cancelled by a  .NO
           MASK command.  .NO MASK is the default.

      .NO CARRIAGE

           No special character is to replace the space in the leftmost column
           of  each  line  which  is  represented  in  the  FORMAT statements.
           Opposite of .CARRIAGE.  .NO CARRIAGE is the default.

      .NO COPY

           The characters in each line represented in  the  FORMAT  statements
           are  not  to  be copied additional times to the right.  Opposite of
           .COPY.  .NO COPY is the default.

      .NO FILL

           Except for the insertion of initial spaces required for the offset,
           left  margin  and  indentation, and except for case conversions and
           removal of underscores, each of the following lines of source  text
           is  to  be regenerated exactly when the resulting FORMAT statements
           are used.  Opposite of .FILL.  .FILL is the default.10                                           FORMAT Program User's Guide


.NO FLAGS
     or
.NO FLAGS ALL

     Most flag characters are disabled in the  source  text.   Does  not
     change interpretation of flag characters specified by .FLAGS FENCE,
     .FLAGS CONTROL and .FLAGS REMARK commands.  Opposite of .FLAGS ALL.
     .FLAGS ALL is the default.

.NO FLAGS CAPITALIZE

     No special character can be used to indicate words  in  which  each
     letter  is  to be capitalized.  Opposite of .FLAGS CAPITALIZE.  .NO
     FLAGS CAPITALIZE is the default.

.NO FLAGS CONTROL

     Commands cannot be included in the source text.  Opposite of .FLAGS
     CONTROL.  .FLAGS CONTROL _. is the default.

.NO FLAGS FENCE

     No special character can follow a command to indicate that the text
     to  its  right is to be treated as though this text appeared on the
     next line.  Opposite of .FLAGS  FENCE.   .FLAGS  FENCE  _;  is  the
     default.

.NO FLAGS INSERT

     No special character can be used in program text  to  indicate  the
     locations  at  which  statement  numbers are to be inserted, and in
     text being represented in the FORMAT  statements  to  indicate  the
     locations  at  which  output field descriptions as specified by the
     .INSERT command are to be inserted.   Opposite  of  .FLAGS  INSERT.
     .FLAGS INSERT $ is the default.

.NO FLAGS LOWER CASE

     No special character can be used to indicate single  letters  which
     are  to  be  translated  into lower case.  Opposite of .FLAGS LOWER
     CASE.  .FLAGS LOWER CASE _\ is the default.

.NO FLAGS QUOTE

     No special character can precede any special character which is  to
     be  treated  as an ordinary printing character.  Opposite of .FLAGS
     QUOTE.  .FLAGS QUOTE __ is the default.

.NO FLAGS REMARK

     A comment cannot appear to the right of  a  command.   Opposite  of
     .FLAGS REMARK.  .FLAGS REMARK _! is the default.      Short Descriptions of the Commands                                    11


      .NO FLAGS SPACE

           No special character can be used to represent a space which  is  to
           be  treated  as a portion of a word rather than as a word boundary.
           Opposite of .FLAGS SPACE.  .FLAGS SPACE _# is the default.

      .NO FLAGS UPPER CASE

           No special character can be used to indicate single  letters  which
           are  to  be  translated  into upper case.  Opposite of .FLAGS UPPER
           CASE.  .FLAGS UPPER CASE _^ is the default.

      .NO GROUP

           No line of text is to be  inserted  before  each  group  of  FORMAT
           statements.  Opposite of .GROUP.  .NO GROUP is the default.

      .NO INSERT

           All unused groups of characters specified by .INSERT  commands  are
           to be discarded.

      .NO JUSTIFY

           Extra spaces are not to be inserted between the words in fill mode.
           Opposite of .JUSTIFY.  .JUSTIFY is the default.

      .NO LEADING

           The FORMAT statements are to exclude initial blank lines  requested
           by  .BLANK and .SKIP commands which appear before the text which is
           to be represented.  Opposite  of  .LEADING.   .NO  LEADING  is  the
           default.

      .NO MASK

           No line of text is to be  superimposed  onto  each  line  which  is
           represented in the FORMAT statements.  Opposite of .MASK.  .NO MASK
           is the default.

      .NO OFFSET

           No spaces are to be inserted at the  left  edge  of  each  line  in
           addition  to the normal left margin and indentation.  Equivalent to
           .OFFSET 0.  .OFFSET 1 is the default.

      .NO PREFACE

           No line of text is to be inserted  before  each  FORMAT  statement.
           Opposite of .PREFACE.  .NO PREFACE is the default.

      .NO TRAILING

           Blank lines requested after the preceding text by .BLANK  or  .SKIP
           commands  or  which  are  necessary  for  multiple line spacing are
           discarded before .TEXT commands or when the end of the source  file
           is read.  Opposite of .TRAILING.  .NO TRAILING is the default.12                                           FORMAT Program User's Guide


.OFFSET number of spaces to be inserted at left edge of text

     The indicated number of spaces is inserted at the left edge of each
     line  in  addition  to  the  normal  left  margin  and indentation.
     .OFFSET 0 is equivalent to .NO OFFSET.  .OFFSET 1 is the default.

.OUTPUT LENGTH maximum number of lines in a FORMAT statement

     FORMAT  statements  can  be  constructed  from  no  more  than  the
     indicated  number  of FORTRAN language lines.  .OUTPUT LENGTH 20 is
     the default, but this program does not impose any upper limit  upon
     this maximum.

.OUTPUT WIDTH most characters in each FORMAT statement line

     Each FORTRAN language line from which  the  FORMAT  statements  are
     constructed  can  contain  no  more  than  the  indicated number of
     characters.  Maximum is 72.  .OUTPUT WIDTH 72 is the default.

.PARAGRAPH columns to indent, multiple of line spacing
     or
.PARAGRAPH columns to indent, -1 times number of blank lines

     The next line of text is to be indented from the left margin by the
     number  of  spaces  indicated by the first argument.  If the second
     argument is greater than or equal to  zero,  then  this  times  the
     number  most  recently specified by a .SPACING command is to be the
     number of extra blank lines which are to precede the next  line  of
     text.   If the second argument is less than zero, then this without
     its sign is the number of extra blank lines which  are  to  precede
     the next line of text.

.PREFACE line of text to precede each new FORMAT statement

     The line of text which appears to the right of the .PREFACE command
     is  to be copied into the output file before each FORMAT statement.
     The .PREFACE command can be cancelled by  a  .NO  PREFACE  command.
     .NO PREFACE is the default.  A group of lines to be inserted before
     each FORMAT statement can be defined by the .DEFINE PREFACE command
     instead.

.PROGRAM next statement number, statement number increment

     The following text, through the next .TEXT or .CONTINUE command, is
     to   be  copied  unchanged  into  the  output  file  without  being
     represented in FORMAT statements.

.RESET

     All variable  conditions  are  to  be  returned  to  their  initial
     settings.      Short Descriptions of the Commands                                    13


      .RESUME GROUP

           The line or lines of text which were defined  by  either  a  .GROUP
           command  or  a  .DEFINE  GROUP command but which were disabled by a
           subsequent .NO GROUP command are to again be inserted  before  each
           group of FORMAT statements.

      .RESUME PREFACE

           The line or lines of text which were defined by either  a  .PREFACE
           command  or  a .DEFINE PREFACE command but which were disabled by a
           subsequent .NO PREFACE command are to again be inserted before each
           FORMAT statement.

      .RIGHT MARGIN rightmost column into which text is wrapped

           If in fill mode, words are wrapped around until the next word would
           extend  beyond  the  indicated  column.   .RIGHT  MARGIN  60 is the
           default.

      .SKIP multiple of extra line spacings to be generated

           A number of extra blank lines equal to the  specified  multiple  of
           the  number  which  appeared  to the right of the previous .SPACING
           command are to be represented in the FORMAT statement.   .BLANK  is
           similar.

      .SPACING separation from top of one line to top of next line

           One less than the  indicated  number  of  blank  lines  are  to  be
           inserted  between  the  lines  of  text.   .SPACING 1 giving single
           spacing is the default.

      .TEXT next statement number, statement number increment

           The following text is to be represented in a new FORMAT  statement.
           .INSERT and .PROGRAM commands are cancelled.  .CONTINUE is similar.
           .TEXT 1,1 is the default at the start  of  the  processing  of  the
           text.

      .TRAILING

           Blank lines requested after the preceding text by .BLANK  or  .SKIP
           commands  or  which  are  necessary  for  multiple line spacing are
           generated before .TEXT commands or when the end of the source  file
           is read.  Opposite of .NO TRAILING.  .NO TRAILING is the default.

      .UPPER CASE

           The cases of letters on the following lines  are  to  be  retained.
           Equivalent  to  appearance  of  2 circumflexes.  Opposite of .LOWER
           CASE.  .UPPER CASE is the default.14                                           FORMAT Program User's Guide


.USE character implying text representation notation

     Hollerith (number H) notation is used to represent text  in  FORMAT
     statements  if  the  following  character  is  an H.  Apostrophe or
     asterisk notation is used if the character is an apostrophe  or  an
     asterisk respectively.  .USE H is the default.


The commands which are listed below were described in previous  versions
of  this  manual.   These  commands  have  been renamed to obtain a more
consistent set of command names.   However,  the  old  names  are  still
recognized,  and  source  files containing commands having the old names
are still processed correctly.

.BEGIN next statement number, statement number increment

     This command has been renamed .TEXT with the same definition.  Both
     names are treated identically.

.FORMAT next statement number, statement number increment

     This command has been renamed .CONTINUE with the  same  definition.
     Both names are treated identically.

.LENGTH maximum number of lines in a FORMAT statement

     This  command  has  been  renamed  .OUTPUT  LENGTH  with  the  same
     definition.  Both names are treated identically.      Short Descriptions of the Commands                                    15


      Table of Command Argument Types and Whether BREAK is Implied
      ----- -- ------- -------- ----- --- ------- ----- -- -------

      Basic         Is .BREAK   Argument      Corresponding
      Command         Implied   Type          NO Command

      .BLANK              yes   1 number
      .BREAK              yes   none
      .CARRIAGE           no    2 characters  .NO CARRIAGE
      .CENTER or .CENTRE  yes   1 number
      .COMMENT            no    text (ignored)
      .CONTINUE           yes   2 numbers
      .COPY               yes   2 numbers     .NO COPY
      .DEFINE GROUP       no    none          .NO GROUP
      .DEFINE PREFACE     no    none          .NO PREFACE
      .EJECT              yes   none
      .END DEFINITION     no    none
      .END OF FILE        yes   none
      .FILL               yes   none          .NO FILL
      .FLAGS ALL          no    none          .NO FLAGS ALL
      .FLAGS CAPITALIZE   no    1 character   .NO FLAGS CAPITALIZE
      .FLAGS CONTROL      no    1 character   .NO FLAGS CONTROL
      .FLAGS FENCE        no    1 character   .NO FLAGS FENCE
      .FLAGS INSERT       no    1 character   .NO FLAGS INSERT
      .FLAGS LOWER CASE   no    1 character   .NO FLAGS LOWER CASE
      .FLAGS QUOTE        no    1 character   .NO FLAGS QUOTE
      .FLAGS REMARK       no    1 character   .NO FLAGS REMARK
      .FLAGS SPACE        no    1 character   .NO FLAGS SPACE
      .FLAGS UPPER CASE   no    1 character   .NO FLAGS UPPER CASE
      .GROUP              no    text          .NO GROUP
      .INDENT             yes   1 number
      .INPUT WIDTH        no    1 number
      .INSERT             no    text          .NO INSERT
      .JUSTIFY            yes   none          .NO JUSTIFY
      .LEADING            no    none          .NO LEADING
      .LEFT MARGIN        yes   1 number
      .LOWER CASE         no    none
      .MASK               no    text          .NO MASK
      .OFFSET             yes   1 number      .NO OFFSET
      .OUTPUT LENGTH      no    1 number
      .OUTPUT WIDTH       no    1 number
      .PARAGRAPH          yes   2 numbers
      .PREFACE            no    text          .NO PREFACE
      .PROGRAM            yes   2 numbers
      .RESET              yes   none
      .RESUME GROUP       no    none          .NO GROUP
      .RESUME PREFACE     no    none          .NO PREFACE
      .RIGHT MARGIN       yes   1 number
      .SKIP               yes   1 number
      .SPACING            yes   1 number
      .TEXT               yes   2 numbers
      .TRAILING           no    none          .NO TRAILING
      .UPPER CASE         no    none
      .USE                no    1 character




                                     Chapter 3

                       COMPLETE DESCRIPTIONS OF THE COMMANDS



                     The Commands Listed in Alphabetical Order
                     --- -------- ------ -- ------------ -----

      Most of the commands which can appear in  the  source  files  which  are
      processed  by the FORMAT program were summarized in the previous chapter
      and are described in detail in  this  chapter.   However,  the  commands
      which  are  needed  for  parcelling  out the lines in long messages into
      separate pages are described in the next chapter.

      Above the description of each command  is  shown  the  command  name  in
      capital letters together with a one line summary in small letters of the
      numbers, characters or line of text which can appear to its  right.   To
      make  the  descriptions  easier  to  read,  the command names are always
      capitalized in the descriptions, but the commands would not have  to  be
      capitalized  in  the actual source text which is processed by the FORMAT
      program.

      .BLANK number of extra blank lines to be generated

           The .BLANK command indicates that, after the representation in  the
           FORMAT  statement  of  the  previous  text, the specified number of
           blank lines are to be  represented  in  the  FORMAT  statement,  in
           addition  to  any  blank  lines  specified by other .BLANK or .SKIP
           commands, and, if a .SPACING command has been issued,  in  addition
           to  the  normal  line  spacing  of  one  less than the number which
           appeared to the right of the  previous  .SPACING  command.   If  no
           number  appears to the right of the .BLANK command, then the number
           1 is assumed to appear to the right of the .BLANK command  instead.
           If a .SPACING 2 command is in effect, then a .BLANK 3 command would
           result in 3+(2-1) or 4 blank lines  being  generated.   The  .BLANK
           command  is  similar  to  the  .SKIP command, except that the .SKIP
           command specifies the number of extra blank lines as a multiple  of
           the  number  which  appeared  to the right of the previous .SPACING
           command.  The .BLANK command implies a .BREAK command.

           If no text has been represented in  the  FORMAT  statements  either
           since  this program was started or since the last .TEXT command was
           issued, then the .BLANK command, like the  .SKIP  command  and  the
           .BLANK  or  .SKIP  command  implied  by  the .PARAGRAPH command, is
           ignored unless a .LEADING command is in effect.  Blank lines  which
           have  not been generated when the end of the source file is read or
           when the  next  .TEXT  command  is  issued,  but  which  have  been
           requested  by  .BLANK  or .SKIP commands or which are necessary for
           the normal line spacing, will be appended to the  FORMAT  statement
           being  constructed  if  a  .TRAIL command is then in effect.  Blank
           lines will be discarded when the end of the source file is read  or
           the  next .TEXT command is issued if a .NO TRAIL command is then in
           effect or if a .TRAIL command has not by then been issued.18                                           FORMAT Program User's Guide


     For example, the source text

     .spacing 2.output width 55
     .blank
     The quick red fox jumps over the lazy brown dog,
     then runs into the forest.
     .blank
     The quick red fox jumps over the lazy brown dog,
     then runs into the forest.
     .blank 2
     The quick red fox jumps over the lazy brown dog,
     then runs into the forest.
     .blank 3
     The quick red fox jumps over the lazy brown dog,
     then runs into the forest.

     would be transformed into the following FORTRAN text when processed
     by this program.

         1 FORMAT(38H The quick red fox jumps over the lazy,
          123H brown dog,  then  runs//17H into the forest./
          2//43H The quick red fox jumps over the lazy brow,
          318Hn dog,  then  runs//17H into the forest.////
          445H The quick red fox jumps over the lazy brown ,
          516Hdog,  then  runs//17H into the forest./////
          645H The quick red fox jumps over the lazy brown ,
          716Hdog,  then  runs//17H into the forest.)


.BREAK

     The .BREAK command indicates that  no  additional  text  is  to  be
     included  in  the  line  of text currently being represented in the
     FORMAT statement.  The line of text is assumed to be  shorter  than
     normal,  and  so  is  not right justified by the insertion of extra
     spaces between the groups of printing  characters  (words)  on  the
     line.  The .BREAK command is similar to the .EJECT command with the
     exception that blank lines requested by .BLANK  commands  or  .SKIP
     commands   or  implied  by  .SPACING  commands  are  not  generated
     immediately when the  .BREAK  command  is  issued  if  no  printing
     characters  have  been  accumulated  into the current line of text.
     The representation of the line of text will be followed by a number
     of blank lines equal to one less than the number which followed the
     previous .SPACING command if the .TRAIL command has been issued  or
     if  additional  text  is  represented.   A  .BREAK  command is also
     implied by most other commands which change the manner in which the
     source text is represented.      Complete Descriptions of the Commands                                 19


           For example, the source text

           .output width 55.spacing 2
           one
           two three
           .break
           four five six
           seven eight nine ten
           .break
           eleven twelve thirteen fourteen fifteen
           sixteen seventeen eighteen nineteen twenty twenty-one

           would be transformed into the following FORTRAN text when processed
           by this program.

               1 FORMAT(14H one two three//19H four five six seve,
                116Hn eight nine ten//24H eleven twelve thirteen ,
                237Hfourteen  fifteen  sixteen  seventeen//4H eig,
                332Hhteen nineteen twenty twenty-one)


      .CARRIAGE next carriage control character
           or
      .CARRIAGE next carriage control, subsequent carriage control

           The first character in each line of text which  is  generated  when
           the  resulting FORMAT statements are used can be interpreted by the
           FORTRAN operating system to  select  the  carriage  motion  on  the
           output  device to which the text is written.  The .CARRIAGE command
           allows the specification of these carriage control characters.   If
           a  .CARRIAGE command has not been issued, or if a .CARRIAGE command
           is issued without any following characters, or if  a  .NO  CARRIAGE
           command  is  issued,  then  the  leftmost  character in each of the
           subsequent lines of text which are being represented in the  FORMAT
           statements  will  be a space if a positive offset has been selected
           by  the  combination  of  .OFFSET,  .LEFT  MARGIN  and  .INDENT  or
           .PARAGRAPH commands, and completely blank lines will be represented
           in the FORMAT statements by consecutive slashes.

           If the .CARRIAGE command is followed by a printing character, or is
           followed  by  a pair of printing characters optionally separated by
           spaces and/or separated by a single comma, then the first character
           following   the  .CARRIAGE  command  is  to  replace  the  leftmost
           character in the next line of text  which  is  represented  in  the
           resulting  FORMAT statements, providing that the character which is
           to be replaced is a space which was not quoted by an underscore and
           was not specified by a number sign.  If the next line of text which
           is represented in the resulting FORMAT statements is a blank  line,
           regardless  of  whether  this  blank  line  has been requested by a
           .BLANK command or a .SKIP command or has been implied by a .SPACING
           command  or  was  encountered in text being copied in no fill mode,
           then the line will contain only  the  character  specified  by  the
           .CARRIAGE  command.  In order for a space, number sign, circumflex,
           back slash, less than sign (if in flag  capitalize  mode),  period,
           comma,  semicolon,  exclamation point or underscore to be specified
           by the .CARRIAGE command as the carriage  control  character,  this
           character would have to be preceded by an underscore.20                                           FORMAT Program User's Guide


     If a second printing character follows the .CARRIAGE command, then,
     after  the  next  line  of  text  has  been  generated, this second
     printing character is to replace the leftmost character in each  of
     the subsequent lines of text, providing that the character which is
     to be replaced is a space which was not quoted by an underscore and
     was  not  specified by a number sign.  If a printing character does
     not appear between the .CARRIAGE command and the  following  comma,
     then  the  character following the comma is considered to have also
     preceded the comma.  Neither the  .CARRIAGE  command  nor  the  .NO
     CARRIAGE  command  implies  a .BREAK command.  A .BREAK command, or
     some other command which implies a .BREAK command,  should  usually
     be  issued before the .CARRIAGE command since, if the lines of text
     are being constructed in fill mode, the carriage control  character
     is applied to the current line of text only after this line of text
     has otherwise been completed.

     For example, the source text

     .spacing 2.right margin 54.output width 55.paragraph
     .carriage 1*.preface       WRITE(1,$)
     This is the first line in the demonstration of the
     insertion of the carriage control character.
     .eject.carriage 1#.paragraph
     This is the second line in the demonstration of the
     insertion of the carriage control character.
     .eject.carriage 1.paragraph
     This is the third line in the demonstration of the
     insertion of the carriage control character.
     .eject.no carriage.paragraph
     This is the fourth line in the demonstration of the
     insertion of the carriage control character.
     .eject.program;      END

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(1,1)
         1 FORMAT(38H1     This is the first line in  the  ,
          117Hdemonstration  of/1H*/20H*the insertion of th,
          229He carriage control character./1H*/1H1/6X,2HTh,
          345His is the second line in the  demonstration  ,
          42Hof/1X/37H the insertion of the carriage contro,
          512Hl character./1X/1H1/6X,19HThis is the third l,
          630Hine in  the  demonstration  of//10H the inser,
          739Htion of the carriage control character.///6X,
          845HThis is the fourth line in the  demonstration,
          94H  of//37H the insertion of the carriage contro,
          112Hl character./)
           END      Complete Descriptions of the Commands                                 21


           which would, in turn, generate the following text when run.

           1     This is the first line in  the  demonstration  of
           *
           *the insertion of the carriage control character.
           *
           1
                 This is the second line in the  demonstration  of

            the insertion of the carriage control character.

           1
                 This is the third line in  the  demonstration  of

            the insertion of the carriage control character.


                 This is the fourth line in the  demonstration  of

            the insertion of the carriage control character.


      .CENTER width of region as unsigned number
      .CENTER offset from largest right margin as signed number
      .CENTRE width of region as unsigned number
           or
      .CENTRE offset from largest right margin as signed number

           The .CENTER command indicates that the  following  line  of  source
           text is to be centered and, except for the insertion of the initial
           spaces needed to obtain centering, is  to  be  represented  in  the
           FORMAT  statement with the same number of spaces as in the original
           source.  If  no  number  follows  the  .CENTER  command,  then  the
           following  line  is  to  be  centered  between  column zero and the
           farthest right margin which  has  yet  been  set.   If  the  number
           following the .CENTER command is signed, then the following line is
           to be centered between column zero and the column which is the  sum
           of the indicated number and the farthest right margin which has yet
           been set, so that the line is shifted from its centered position by
           half  the  signed  number  of columns.  If the number following the
           .CENTER command  is  unsigned  and  greater  than  zero,  then  the
           following  line  of  text is to be centered between column zero and
           the indicated column.  If the number following the .CENTER  command
           is  unsigned  and  zero,  then the following line is to be centered
           between the current left and right margins.  If the .CENTER command
           was  preceded  by  an  .INDENT command, then the .INDENT command is
           ignored.  The .CENTER command implies a .BREAK command both  before
           and after the following line of source text.22                                           FORMAT Program User's Guide


     For example, the source text

     .OFFSET 0;.OUTPUT WIDTH 55;.PREFACE       WRITE(1,$)
     1234567890123456789012345678901234567890123456789012345
     .LEFT MARGIN 14;.RIGHT MARGIN 34
     The quick red fox jumps over the lazy brown dog
     .CENTER 0;CENTER   0
     .CENTER 52;CENTER  52
     .CENTER -4;CENTER  -4
     .CENTER;CENTER   #
     .CENTER;CENTER
     .CENTER;    CENTER
     .CENTER +12;CENTER +12
     .CENTER 76;CENTER  76
     .LEFT MARGIN 30;.RIGHT MARGIN 50;.CENTER 0
     CENTER   0
     The quick red fox jumps over the lazy brown dog
     .LEFT MARGIN 0
     1234567890123456789012345678901234567890123456789012345
     .PROGRAM;      END

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(1,1)
         1 FORMAT(38H12345678901234567890123456789012345678,
          117H90123456789012345/14X,20HThe  quick  red  fox/
          214X,20Hjumps  over the lazy/14X,9Hbrown dog/19X,
          310HCENTER   0/21X,10HCENTER  52/23X,9HCENTER  -,
          41H4/25X,6HCENTER,4X/27X,6HCENTER/29X,6HCENTER/9X,
          522X,10HCENTER +12/33X,10HCENTER  76/35X,6HCENTER,
          63X,1H0/30X,20HThe  quick  red  fox/30X,7Hjumps  ,
          713Hover the lazy/30X,9Hbrown dog/12H123456789012,
          843H3456789012345678901234567890123456789012345)
           END

     which would, in turn, generate the following text when run.

     1234567890123456789012345678901234567890123456789012345
                   The  quick  red  fox
                   jumps  over the lazy
                   brown dog
                        CENTER   0
                          CENTER  52
                            CENTER  -4
                              CENTER
                                CENTER
                                  CENTER
                                    CENTER +12
                                      CENTER  76
                                        CENTER   0
                                   The  quick  red  fox
                                   jumps  over the lazy
                                   brown dog
     1234567890123456789012345678901234567890123456789012345      Complete Descriptions of the Commands                                 23


      .COMMENT rest of line is ignored regardless of contents

           The text which appears to the right  of  the  .COMMENT  command  is
           treated  as  a  comment  and  is  ignored.  The comment can include
           exclamation points, semicolons and  other  periods.   Two  adjacent
           appearances  of the upper case shift character or of the lower case
           shift character are recognized, however,  and  the  requested  case
           shifts are applied to the source text on the following lines.

           The .COMMENT command can be used at the left end of  each  line  of
           explanations or instructions which are to appear in the source text
           but which are not be be copied into the resulting  FORTRAN  output.
           If  the instructions are instead to appear in the resulting FORTRAN
           output, then these instructions should be incorporated into FORTRAN
           comment  lines  starting  with the letter C and must appear below a
           .PROGRAM command.

           The .COMMENT command can be inserted  at  the  left  end  of  other
           commands  which  are to be inactivated but which are to kept in the
           source text.  A period followed by a exclamation point  could  also
           be   inserted  at  the  left  end  of  commands  which  are  to  be
           inactivated, but if a semicolon appears on the line, then the  text
           to  the  right  of  the semicolon would be treated as normal source
           text again.

           For example, the source text

           .output width 55.right margin 54
           This sentence is followed by a simple comment.
           .comment continuing across a ; (semicolon) character
           THE COMMENT WHICH APPEARS AFTER THIS WORD
           .COMMENT CONTAINING \\ (DOUBLE BACKSLASHES)
           CONTAINS A DOUBLE BACKSLASH WHICH SELECTS UPPER TO
           LOWER CASE CONVERSION IN THE FOLLOWING TEXT.
           THE COMMENT WHICH APPEARS AFTER THIS WORD
           .comment.skip.nofill!.skip.nofill;.skip.nofill^^
           CONTAINS A DOUBLE CIRCUMFLEX WHICH RESTORES THE
           RETENTION OF ORIGINAL CASES.
           The characters which select case conversion or
           retention are acted upon even though the commands
           which have been commented out are otherwise ignored.

           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

               1 FORMAT(38H This sentence is followed by a  simpl,
                117He  comment.   THE/24H COMMENT  WHICH  APPEARS,
                231H  AFTER  THIS  WORD  contains a/10H double ba,
                345Hckslash which selects  upper  to  lower  case/
                445H conversion  in  the following text.  the com,
                510Hment which/31H appears after this word CONTAI,
                624HNS A  DOUBLE  CIRCUMFLEX/17H WHICH  RESTORES ,
                738H THE RETENTION OF ORIGINAL CASES.  The/4H cha,
                845Hracters which select case conversion  or  ret,
                96Hention/36H are  acted  upon  even  though the ,
                119Hcommands which have/22H been commented out ar,
                220He otherwise ignored.)24                                           FORMAT Program User's Guide


     which would, in turn, generate the following text when run.

      This sentence is followed by a  simple  comment.   THE
      COMMENT  WHICH  APPEARS  AFTER  THIS  WORD  contains a
      double backslash which selects  upper  to  lower  case
      conversion  in  the following text.  the comment which
      appears after this word CONTAINS A  DOUBLE  CIRCUMFLEX
      WHICH  RESTORES  THE RETENTION OF ORIGINAL CASES.  The
      characters which select case conversion  or  retention
      are  acted  upon  even  though the commands which have
      been commented out are otherwise ignored.


.CONTINUE next statement number, statement number increment

     The .CONTINUE command indicates that no additional text  is  to  be
     represented by the FORMAT statement currently being constructed and
     that the text appearing in subsequent lines in the source  file  is
     to  be represented in a new FORMAT statement.  The preface line, if
     any, indicated by a previous .PREFACE command will be written  into
     the  output  before  this next FORMAT statement.  All unused output
     field descriptions previously specified by  .INSERT  commands  will
     still  be  available.   The new FORMAT statement will include blank
     lines which have been requested by .SKIP  or  .BLANK  commands,  or
     which  are  necessary for multiple line spacing, but which have not
     yet been generated.  If the .CONTINUE command is issued within  the
     range of a .PROGRAM command, then the range of the .PROGRAM command
     is terminated.  The .CONTINUE command is  identical  to  the  .TEXT
     command, except that a .TEXT command would discard all output field
     descriptions, and, unless the .LEADING and .TRAILING  commands  are
     in  effect,  would  discard all blank lines which have not yet been
     generated.

     If a number follows the .CONTINUE command, then this number is used
     to  modify  the  statement number of the next FORMAT statement.  If
     the number is not signed, then the number will be used directly  as
     the  statement  number of the next FORMAT statement.  If the number
     is signed, then the statement number of the next  FORMAT  statement
     will  differ  from  the  statement  number  of  the previous FORMAT
     statement by the  indicated  amount.   If  no  number  follows  the
     .CONTINUE  command, or if a comma follows the .CONTINUE command but
     no number appears between the .CONTINUE  command  and  this  comma,
     then  the statement number of the next FORMAT statement will differ
     from that of the previous FORMAT statement by the current value  of
     the statement number increment.

     Modifications of the statement number are cumulative such that if 2
     or more .TEXT and/or .CONTINUE and/or .PROGRAM commands are issued,
     then the statement number of the next FORMAT statement will be  the
     result  of  the  application of each of these commands in turn.  If
     the statement number of the FORMAT statement following a section of
     program  text  indicated  by  an  initial .PROGRAM command is to be
     modified, but the program text includes dollar signs which  are  to
     be  replaced  by  this statement number, then this statement number
     should be modified by the  .PROGRAM  command  rather  than  by  the
     following .TEXT or .CONTINUE command, since, if the modification is
     done by the .TEXT or .CONTINUE command,  then  incorrect  statement      Complete Descriptions of the Commands                                 25


           numbers  will  have been inserted into the program text.  Statement
           numbers, if any, inserted into a preface line defined by a .PREFACE
           command will, however, always be correct since the statement number
           of the next FORMAT statement is known  when  the  preface  line  is
           generated.

           If the .CONTINUE command is followed either by 2 numbers or else by
           a  comma  and  then  by a number, then the right number becomes the
           statement number increment after the generation of the next  FORMAT
           statement.   The  increment can be either positive or negative.  If
           the number is  unsigned,  then  the  increment  is  assumed  to  be
           positive.   If the .CONTINUE command is followed by 2 numbers, then
           these numbers do not need to be  separated  by  a  comma.   If  the
           .CONTINUE command is not followed by any numbers, or is followed by
           a single number  which  is  not  preceded  by  a  comma,  then  the
           statement number increment is not changed.

           For example, the source text

           .preface       WRITE(1,$)
           .continue 10,5   ;This is a message in FORMAT 10
           .program         ;C     FORMAT statement $ follows
           .continue,20     ;This is a message in FORMAT 15
           .continue        ;This is a message in FORMAT 35
           .program 100-10  ;C     FORMAT statement $ follows
           .continue        ;This is a message in FORMAT 100
           .continue        ;This is a message in FORMAT 90

           would be transformed into the following FORTRAN text when processed
           by this program.

                 WRITE(1,10)
              10 FORMAT(31H This is a message in FORMAT 10)
           C     FORMAT statement 15 follows
                 WRITE(1,15)
              15 FORMAT(31H This is a message in FORMAT 15)
                 WRITE(1,35)
              35 FORMAT(31H This is a message in FORMAT 35)
           C     FORMAT statement 100 follows
                 WRITE(1,100)
             100 FORMAT(32H This is a message in FORMAT 100)
                 WRITE(1,90)
              90 FORMAT(31H This is a message in FORMAT 90)


      .COPY number of characters to copy, number of times to copy

           The .COPY command indicates that, to the  immediate  right  of  the
           initial offset in each line of text which is copied in no fill mode
           or which is constructed in fill  mode,  the  number  of  characters
           indicated  by  the  first  number is to be duplicated the number of
           times indicated by the second number.  The initial spaces requested
           either  by  the .OFFSET command or by the default .OFFSET 1 command
           cannot be duplicated and are not included in the  character  count.
           The  carriage  control character specified by the .CARRIAGE command
           is not duplicated even if the initial offset is zero.  If the .MASK
           command  has  specified a template line, then the same replacements26                                           FORMAT Program User's Guide


     of nonquoted spaces are also made in the copies.  If the line which
     is  being  copied contains dollar signs which are being replaced by
     output field specifications specified by the .INSERT command,  then
     it  is the dollar signs which are counted to determine the width of
     the region being copied, not the characters inserted  in  place  of
     the  dollar  signs,  and  the  same insertions are also made in the
     copies.  If the first number following the .COPY  command  is  less
     than  the  number of characters to the right of the initial offset,
     including the template characters which might have been defined  by
     the  .MASK  command, then all of the characters to the right of the
     initial offset will be copied.  If the first number is greater than
     the  number  of  characters to the right of the initial offset then
     extra spaces at the right will also be copied.  The  range  of  the
     .COPY command can be cancelled by a subsequent .NO COPY command.  A
     .COPY command issued within the range of a .PROGRAM command applies
     to  the  source text following the next .TEXT or .CONTINUE command.
     Both the .COPY command and the .NO  COPY  command  imply  a  .BREAK
     command.

     For example, the source text

     .insert 5H01234
     .insert 5H56789
     .insert 6H111111
     .insert 6H222222
     .insert 6HPUBLIC
     .insert 6HSECRET
     .preface       WRITE(1,$)
     .offset 2.copy 29,1.output width 55.carriage 1,*
     ************************
     .left margin 2.right margin 22
     .mask *                      *
     .skip.center 0;Corporation: $$$$$
     .center 0;       Firm: $$$$$
     .skip;To gain initial access to the computer, you will
     use the numbers $$$$$$ and $$$$$$ and password $$$$$$.
     To run the programs, you will use the  password $$$$$$.
     .skip.left margin 0;************************
     .program;      END      Complete Descriptions of the Commands                                 27


           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

                 WRITE(1,1)
               1 FORMAT(38H1 ************************     *******,
                117H*****************/3H* *,22X,7H*     *,22X,1H*/
                218H* *  Corporation: ,5H01234,15H  *     *  Corp,
                39Horation: ,5H01234,3H  */3H* *,9X,6HFirm: ,
                45H56789,9H  *     *,9X,6HFirm: ,5H56789,3H  */
                53H* *,22X,7H*     *,22X,1H*/17H* * To   gain    ,
                638Hinitial *     * To   gain    initial */4H* * ,
                745Haccess     to    the *     * access     to   ,
                86H the */36H* * computer,  you  will *     * com,
                919Hputer,  you  will */22H* * use    the   numbe,
                133Hrs *     * use    the   numbers */4H* * ,
                26H111111,8H  and   ,6H222222,9H *     * ,
                36H111111,8H  and   ,6H222222,2H */11H* * and pas,
                46Hsword ,6HPUBLIC,23H. *     * and password ,
                56HPUBLIC,3H. */30H* * To run the programs, *    ,
                625H * To run the programs, */16H* * you   will  ,
                739Huse  the *     * you   will  use  the */3H* *,
                810H password ,6HSECRET,22H.     *     * password,
                91H ,6HSECRET,7H.     */3H* *,22X,7H*     *,22X,
                11H*)
                 WRITE(1,2)
               2 FORMAT(38H* ************************     *******,
                117H*****************)
                 END

           which would, in turn, generate the following text when run.

           1 ************************     ************************
           * *                      *     *                      *
           * *  Corporation: 01234  *     *  Corporation: 01234  *
           * *         Firm: 56789  *     *         Firm: 56789  *
           * *                      *     *                      *
           * * To   gain    initial *     * To   gain    initial *
           * * access     to    the *     * access     to    the *
           * * computer,  you  will *     * computer,  you  will *
           * * use    the   numbers *     * use    the   numbers *
           * * 111111  and   222222 *     * 111111  and   222222 *
           * * and password PUBLIC. *     * and password PUBLIC. *
           * * To run the programs, *     * To run the programs, *
           * * you   will  use  the *     * you   will  use  the *
           * * password SECRET.     *     * password SECRET.     *
           * *                      *     *                      *
           * ************************     ************************


      .DEFINE GROUP

           The .DEFINE GROUP command indicates that  the  following  lines  of
           source  text  which  do  not  start with periods are to be inserted
           before each FORMAT statement  which  either  is  the  first  FORMAT
           statement  ever  generated during this use of this program or which
           is the first FORMAT statement generated after a .TEXT command.  The
           lines  specified  by  the  .DEFINE  GROUP  command are not inserted28                                           FORMAT Program User's Guide


     before a FORMAT statement which is  generated  merely  because  the
     previous  FORMAT statement has filled or merely because a .CONTINUE
     command has been issued to  break  the  text  into  another  FORMAT
     statement.   The  lines  which  are  to be inserted before each new
     group of FORMAT statements will include all of the lines  which  do
     not  start  with  periods  in  the  source text up to the next .END
     DEFINITION, .PROGRAM, .TEXT, .CONTINUE, .GROUP, .PREFACE,  .TOP  or
     .BOTTOM  command or up to any of the various .DEFINE commands.  The
     .GROUP command can be used instead of the .DEFINE GROUP command  if
     just  a  single  line  is  to  be inserted before each new group of
     FORMAT statements.  Unlike the  .GROUP  command,  however,  nothing
     else  can  appear  to the right of the .DEFINE GROUP command on the
     same line unless it follows a semicolon.

     The .DEFINE GROUP command allows the insertion of several lines  of
     FORTRAN  text  before  each  group  of  FORMAT statements which are
     logically connected.  The rules which govern  the  construction  of
     the  lines  which  are  specified  by the .DEFINE GROUP command are
     identical to those which are  described  for  the  .DEFINE  PREFACE
     command.   If  both  types  of  lines  are  being inserted before a
     particular FORMAT statement, then the lines specified by the .GROUP
     or .DEFINE GROUP command are inserted before those specified by the
     .PREFACE or .DEFINE PREFACE command.

     For example, the source text

     .OUTPUT WIDTH 55.OUTPUT LENGTH 3.NO JUSTIFY
     .DEFINE GROUP
           GO TO 1000
     C     NEW MESSAGE
     $$$$$ CONTINUE$=
     .END DEFINITION
     .PREFACE       WRITE(ITTY,$)
     The first FORMAT statement which is generated should
     be preceded by both group and preface lines even
     though this text is not preceded by either a .TEXT
     or a .CONTINUE command.
     .CONTINUE
     This text appears after a .CONTINUE command.
     It should be preceded by preface but not group lines.
     .TEXT 100
     This text appears after a .TEXT command and
     should be preceded by both group and preface lines.      Complete Descriptions of the Commands                                 29


           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text.

                 GO TO 1000
           C     NEW MESSAGE
               1 CONTINUE
                 WRITE(ITTY,2)
               2 FORMAT(38H The first FORMAT statement which is g,
                118Henerated should be/23H preceded by both group,
                235H and preface lines even though this)
                 WRITE(ITTY,3)
               3 FORMAT(38H text is not preceded by either a .TEX,
                116HT or a .CONTINUE/9H command.)
                 WRITE(ITTY,4)
               4 FORMAT(38H This text appears after a .CONTINUE c,
                121Hommand.  It should be/20H preceded by preface,
                221H but not group lines.)
                 GO TO 1000
           C     NEW MESSAGE
             100 CONTINUE
                 WRITE(ITTY,101)
             101 FORMAT(38H This text appears after a .TEXT comma,
                116Hnd and should be/25H preceded by both group a,
                217Hnd preface lines.)


      .DEFINE PREFACE

           The .DEFINE PREFACE command indicates that the following  lines  of
           source  text  which  do  not  start with periods are to be inserted
           before each new FORMAT statement in the resulting  FORTRAN  output.
           These  lines  will  not  appear  at  the  location in the resulting
           FORTRAN output corresponding to their location in the  source  text
           unless  a  new  FORMAT  statement  also  happens  to  begin at that
           location.  The lines are copied directly as  FORTRAN  code,  rather
           than  being  taken as text which is to be represented in the FORMAT
           statements.  The lines which are to be  inserted  before  each  new
           FORMAT  statement  will include all of the lines which do not start
           with periods in the source text up to  the  next  .END  DEFINITION,
           .PROGRAM,  .TEXT,  .CONTINUE,  .GROUP,  .PREFACE,  .TOP  or .BOTTOM
           command or up to any of the various .DEFINE commands.  The .PREFACE
           command  can be used instead of the .DEFINE PREFACE command if just
           a single line is to be inserted before each new  FORMAT  statement.
           Unlike  the  .PREFACE  command, however, nothing else can appear to
           the right of the .DEFINE PREFACE command on the same line unless it
           follows a semicolon.

           If an .END DEFINITION command appears after the lines which are  to
           be  inserted,  then the lines following the .END DEFINITION command
           will be processed in the same manner as before the .DEFINE  PREFACE
           command was issued.  If a .PROGRAM command was issued more recently
           than either a .TEXT command or a .CONTINUE command, then the  lines
           of  source text will be copied into the output directly rather than
           being represented in a FORMAT statement.  If a .PROGRAM command has
           not  been issued more recently, then the following source text will
           be represented in the FORMAT statements.30                                           FORMAT Program User's Guide


     The insertion of the preface lines before each new FORMAT statement
     can  be  terminated  either  by issuing a .NO PREFACE command or by
     specifying a null preface by issuing either a .PREFACE command with
     nothing  to  its  right  or  a  .DEFINE  PREFACE  command  followed
     immediately  by  a  .END  DEFINITION  command.   These  methods  of
     cancelling  the  preface  line are not identical.  If a .NO PREFACE
     command is used to cancel the insertion of the preface lines,  then
     a  .RESUME  PREFACE  command  can  be  issued  later  to resume the
     insertion of the same  preface  lines  before  the  subsequent  new
     FORMAT  statements.   If  a  .PREFACE  command  is  issued  without
     anything to its right or a  .DEFINE  PREFACE  command  is  followed
     immediately by a .END DEFINITION command, however, then the .RESUME
     PREFACE command cannot be used  to  resume  the  insertion  of  the
     previous  preface  lines.   Neither  the  .PREFACE command, nor the
     .DEFINE PREFACE command,  nor  the  .NO  PREFACE  command  nor  the
     .RESUME PREFACE command implies a .BREAK command.

     The Lines of text  which  are  specified  by  the  .DEFINE  PREFACE
     command  are  stored  in  the  same  area  as  are  those which are
     specified by the .GROUP or .DEFINE GROUP, .TOP or .DEFINE  TOP  and
     .BOTTOM  or .DEFINE BOTTOM commands.  There can be at most 30 lines
     containing together no more than 500 characters  in  all  of  these
     collections  of  lines.   These lines include those which have been
     temporarily disabled by the .NO GROUP, .NO PREFACE, .NO TOP or  .NO
     BOTTOM commands.

     Any dollar signs which are not preceded by underscores in the lines
     which  are  to  be  inserted  will  be  replaced  each  time by the
     statement number of the FORMAT statement before which the lines are
     inserted.   The  manner  in which these dollar signs are handled is
     described in detail in the description  of  the  .PREFACE  command.
     The  description  of  the  .PREFACE command should be consulted for
     additional information about when and how the  lines  of  text  are
     inserted.

     For example, the source text

     .output width 55.output length 5
     .define preface
     C
     C     THIS IS A NEW FORMAT STATEMENT
           WRITE(ITTY,$)
     .end definition
     This is some text which will demonstrate the insertion
     of several lines of FORTRAN code before each new FORMAT
     statement.  The code which is inserted can contain any
     desired mixture of comments and FORTRAN instructions.
     .text
     This comes after a .TEXT command
     .continue
     and this comes after a .CONTINUE command.      Complete Descriptions of the Commands                                 31


           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text.

           C
           C     THIS IS A NEW FORMAT STATEMENT
                 WRITE(ITTY,1)
               1 FORMAT(38H This is some text which will demonstr,
                123Hate  the  insertion  of/18H several  lines  o,
                243Hf  FORTRAN  code  before  each  new  FORMAT/
                345H statement.  The code  which  is  inserted  c,
                416Han  contain  any)
           C
           C     THIS IS A NEW FORMAT STATEMENT
                 WRITE(ITTY,2)
               2 FORMAT(38H desired mixture of comments and FORTR,
                116HAN instructions.)
           C
           C     THIS IS A NEW FORMAT STATEMENT
                 WRITE(ITTY,3)
               3 FORMAT(33H This comes after a .TEXT command)
           C
           C     THIS IS A NEW FORMAT STATEMENT
                 WRITE(ITTY,4)
               4 FORMAT(38H and this comes after a .CONTINUE comm,
                14Hand.)


      .EJECT

           The .EJECT command indicates that  no  additional  text  is  to  be
           included  in  the  line  of text currently being represented in the
           FORMAT statement.  The line of text is assumed to be  shorter  than
           normal,  and  so  is  not right justified by the insertion of extra
           spaces between the groups of printing  characters  (words)  on  the
           line.  The .EJECT command is similar to the .BREAK command with the
           exception that all blank lines  requested  by  .BLANK  commands  or
           .SKIP  commands  or  implied by .SPACING commands will be generated
           immediately when the .EJECT command is issued even if  no  printing
           characters  have  been  accumulated  into the current line of text.
           The .EJECT command can be issued  before  a  .CARRIAGE  command  to
           prevent  the  newly specified carriage control character from being
           inserted into the start of the lines which have been specified  but
           not yet forced into the FORMAT statement.

           For example, the source text

           one
           .skip 2
           .carriage *,*
           two
           .skip 2
           .eject
           .carriage @,@
           three32                                           FORMAT Program User's Guide


     would be transformed into the following FORTRAN text when processed
     by this program.

         1 FORMAT(4H one/1H*/1H*/4H*two/1H*/1H*/6H@three)


.END DEFINITION

     The .END DEFINITION command terminates the specification  of  lines
     of  FORTRAN  text  which was started by the previous .DEFINE GROUP,
     .DEFINE PREFACE, .DEFINE TOP  or  .DEFINE  BOTTOM  command.   These
     lines  of  FORTRAN  text  are to be inserted subsequently before or
     after the FORMAT statements to allow use of these FORMAT statements
     by  the  program in which these FORMAT statements will be embedded.
     The lines of FORTRAN text specified by the various .DEFINE commands
     are  stored  in  a  common  area.   There  can  be at most 30 lines
     containing together no more than 500 characters  in  all  of  these
     collections.

     After the .END DEFINITION command has been  issued,  the  following
     lines of source text will be processed in the same manner as before
     the .DEFINE command was issued.  If a .PROGRAM command  was  issued
     more  recently  than either a .TEXT command or a .CONTINUE command,
     then the lines of source  text  will  be  copied  into  the  output
     directly rather than being represented in a FORMAT statement.  If a
     .PROGRAM command has  not  been  issued  more  recently,  then  the
     following source text will be represented in the FORMAT statements.

     A particular collection of lines will be copied into the  resulting
     FORTRAN  output  whenever  the required conditions are encountered.
     The .DEFINE GROUP command specifies lines of FORTRAN text which are
     to  be  inserted before the first FORMAT statement produced by this
     program and before the first  FORMAT  statement  produced  after  a
     .TEXT  command  is  issued.   The .DEFINE PREFACE command specifies
     lines of FORTRAN text which are to  be  inserted  before  each  new
     FORMAT  statement,  regardless  of the reason for the break between
     the previous FORMAT statement and  the  current  FORMAT  statement.
     The  .DEFINE  TOP  and  .DEFINE  BOTTOM  commands  specify lines of
     FORTRAN text which are to be inserted before and after  the  FORMAT
     statements for each page of text which will be displayed on a video
     terminal and are described in a later section of this manual.

     The specification of additional lines of FORTRAN text by any of the
     various  .DEFINE  commands  can  also be terminated by a subsequent
     .PROGRAM, .TEXT,  .CONTINUE,  .GROUP,  .PREFACE,  .TOP  or  .BOTTOM
     command, or by any other of the various .DEFINE commands.      Complete Descriptions of the Commands                                 33


           For example, the source text

           .output width 55
           .define group
           C     THIS IS INSERTED BEFORE EACH NEW GROUP OF FORMATS
                 WRITE(ITTY,100)
           .define preface
           C     THIS IS INSERTED BEFORE EACH NEW FORMAT STATEMENT
                 WRITE(ITTY,$)
           .end definition
           This text will be in the first format statement.
           .continue
           This comes after the first CONTINUE command.
           .program
           C     THIS IS INSERTED BY A PROGRAM COMMAND
           .continue
           This comes after the second CONTINUE command.
           .text
           This comes after a TEXT command.

           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text.

           C     THIS IS INSERTED BEFORE EACH NEW GROUP OF FORMATS
                 WRITE(ITTY,100)
           C     THIS IS INSERTED BEFORE EACH NEW FORMAT STATEMENT
                 WRITE(ITTY,1)
               1 FORMAT(38H This text will be in the first format,
                111H statement.)
           C     THIS IS INSERTED BEFORE EACH NEW FORMAT STATEMENT
                 WRITE(ITTY,2)
               2 FORMAT(38H This comes after the first CONTINUE c,
                17Hommand.)
           C     THIS IS INSERTED BY A PROGRAM COMMAND
           C     THIS IS INSERTED BEFORE EACH NEW FORMAT STATEMENT
                 WRITE(ITTY,3)
               3 FORMAT(38H This comes after the second CONTINUE ,
                18Hcommand.)
           C     THIS IS INSERTED BEFORE EACH NEW GROUP OF FORMATS
                 WRITE(ITTY,100)
           C     THIS IS INSERTED BEFORE EACH NEW FORMAT STATEMENT
                 WRITE(ITTY,4)
               4 FORMAT(33H This comes after a TEXT command.)


      .END OF FILE

           The .END OF FILE command  indicates  that  the  processing  of  the
           source  text  is  complete.   Any additional commands or additional
           text appearing on the same line to the right of the  .END  OF  FILE
           command  are  ignored.   No  additional source text is read.  Blank
           lines which have not  yet  been  generated,  but  which  have  been
           requested  by  .SKIP  or .BLANK commands or which are necessary for
           multiple line spacing, will be appended  to  the  FORMAT  statement
           currently  being  constructed  if  a  .TRAIL  command is in effect.
           Blank lines will be discarded if a .NO TRAIL command is  in  effect
           or  if  a  .TRAIL  command  has  not  been issued.  An .END OF FILE34                                           FORMAT Program User's Guide


     command is necessary at the end of the  source  file  only  if  the
     system  where  this  program  is being used does not support end of
     file tests in FORTRAN READ statements.


.FILL

     The .FILL command indicates that each line of text  represented  in
     the  FORMAT  statements  is  to be filled with the next words which
     appear in the source text until the  following  word  would  extend
     beyond  the  current right margin.  If the first word is wider than
     the current separation between the left and right margins, then the
     entire  word  is  fitted  onto  the  current line.  A .FILL command
     terminates the range of the previous .NO FILL command  which  would
     have  caused  each line of text represented in the resulting FORMAT
     statements to contain the same number of words  per  line  and  the
     same  number of spaces preceding and between words as in the source
     text.  A .FILL command is assumed to be in effect when this program
     is  started.  A .FILL command issued within the range of a .PROGRAM
     command applies to the source text  following  the  next  .TEXT  or
     .CONTINUE command.  The .FILL command implies a .BREAK command.

     Within the range of the .FILL command, a space  separates  adjacent
     words  which  appear  on  the  same line of text represented in the
     FORMAT statements, regardless of whether these  words  appeared  on
     separate  lines  of  the  source  text or appeared on the same line
     separated by additional spaces.  A second space follows each colon,
     semicolon, exclamation point, question mark and period which is not
     preceded by an  underscore  character  but  which  is  followed  by
     another  word.  If a .NO JUSTIFY command has not been issued, or if
     a .JUSTIFY command has been issued more recently than a .NO JUSTIFY
     command,  then  additional spaces are inserted between the words to
     cause the line of text to  extend  to  the  current  right  margin,
     providing  that a .BREAK command does not follow and is not implied
     to follow the rightmost word on the line.

     For example, the source text

     .FILL.OFFSET 0.RIGHT MARGIN 55.OUTPUT WIDTH 55
     .PREFACE       WRITE(1,$)
          The                    FILL                command
             indicates           that                each
                line             of               text
                   represented   in             the
                      FORMAT     statements   is
                         to      be    filled
     .NO JUSTIFY;           with the  next
                         words   which appear
                      in         the      source
                   text          until          the
                following        word            would
     .NOFILL;extend              beyond               the
          current                right               margin.
     .PROGRAM;      END      Complete Descriptions of the Commands                                 35


           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

                 WRITE(1,1)
               1 FORMAT(38HThe FILL command  indicates  that  eac,
                117Hh  line  of  text/24Hrepresented in the FORMA,
                228HT statements is to be filled/13Hwith the next,
                338H words which appear in the source text/4Hunti,
                426Hl the following word would/6Hextend,14X,3Hbey,
                53Hond,15X,3Hthe/5X,7Hcurrent,16X,5Hright,15X,1Hm,
                66Hargin.)
                 END

           which would, in turn, generate the following text when run.

           The FILL command  indicates  that  each  line  of  text
           represented in the FORMAT statements is to be filled
           with the next words which appear in the source text
           until the following word would
           extend              beyond               the
                current                right               margin.

           In the above example, the first line in the text which is generated
           when the FORTRAN text is run is justified since a .BREAK command is
           not implied following the rightmost word on the line.   The  second
           line  is not justified since a .BREAK command is implied by the .NO
           JUSTIFY command which follows the rightmost word on the line.   The
           third  and  fourth  lines  are  within the range of the .NO JUSTIFY
           command and so are not justified.  The fifth and  sixth  lines  are
           within the range of the .NOFILL command and so are direct copies of
           the corresponding lines in the source text.


      .FLAGS
           or
      .FLAGS ALL

           The .FLAGS ALL command indicates that  all  flag  characters  which
           were initially active, or which have been individually activated by
           the  corresponding  .FLAGS  commands,  and  which  have  not   been
           individually  disabled by the corresponding .NO FLAGS commands, are
           to be active in the source text.  The following flag characters are
           activated by the .FLAGS ALL command.

             $  (dollar sign) or whatever character  has  been  most  recently
                selected by a .FLAGS INSERT command.
             \  (back slash) or whatever  character  has  been  most  recently
                selected by a .FLAGS LOWER CASE command.
             _  (underscore) or whatever  character  has  been  most  recently
                selected by a .FLAGS QUOTE command.
             #  (number sign) or whatever character  has  been  most  recently
                selected by a .FLAGS SPACE command.
             ^  (circumflex) or whatever  character  has  been  most  recently
                selected by a .FLAGS UPPER CASE command.
             <  (less than sign) if  a  .FLAGS  CAPITALIZE  command  has  been
                issued,  or whatever character has been most recently selected
                by a .FLAGS CAPITALIZE  command.   This  flag  character  will36                                           FORMAT Program User's Guide


          remain  inactive  if  a .FLAGS CAPITALIZE command has not been
          issued.

     All of these flag characters can be  temporarily  disabled  by  the
     issuing  of a .NO FLAGS or a .NO FLAGS ALL command.  The .FLAGS ALL
     command  and  the  .NO  FLAGS  ALL  command  do  not   change   the
     interpretation  of the flag characters which identify and terminate
     commands.  The flag characters which  are  to  be  interpreted  and
     acted  upon  in a preface line specified by the .PREFACE command or
     in a field specification defined by the  .INSERT  command  must  be
     those  which  are  active  when  the  preface  line  or  the  field
     specification is defined, regardless of what flag characters happen
     to  be  active  when the preface line or the field specification is
     used.  Neither the .FLAGS ALL command nor the .NO FLAGS ALL command
     implies a .BREAK command.

     For example, the source text

     .OUTPUT WIDTH 55.RIGHT MARGIN 55.OFFSET 0.NOFILL
     .UPPERCASE.INSERT 3^^H\\THE
     .CONTINUE.PREFACE       \\WRITE(1,$)
     \\^THE QUICK#_RED <FOX JUMPS OVER $$$ LAZY _BROWN <DOG.
     .PROGRAM
     \\^THE QUICK#_RED <FOX JUMPS OVER $$$ LAZY _BROWN <DOG.
     .NO FLAGS
     .CONTINUE.FLAGS CAPITALIZE.UPPER CASE.INSERT 3^^H\\THE
     \\^THE QUICK#_RED <FOX JUMPS OVER $$$ LAZY _BROWN <DOG.
     .PROGRAM.PREFACE       \\WRITE(1,$)
     \\^THE QUICK#_RED <FOX JUMPS OVER $$$ LAZY _BROWN <DOG.
     .FLAGS
     .UPPER CASE.CONTINUE
     \\^THE QUICK#_RED <FOX JUMPS OVER $$$ LAZY _BROWN <DOG.
     .PROGRAM
     \\^THE QUICK#_RED <FOX JUMPS OVER $$$ LAZY _BROWN <DOG.

     would be transformed into the following FORTRAN text when processed
     by this program.

           write(1,1)
         1 FORMAT(30HThe quick Red <fox jumps over ,3Hthe,
          117H lazy Brown <dog.)
     The quick Red <fox jumps over   2 lazy Brown <dog.
           write(1,2)
         2 FORMAT(38H\\^THE QUICK#_RED <FOX JUMPS OVER $$$ ,
          117HLAZY _BROWN <DOG.)
     \\^THE QUICK#_RED <FOX JUMPS OVER $$$ LAZY _BROWN <DOG.
           \\WRITE(1,$)
         3 FORMAT(29HThe quick Red FOX jumps over ,
          13^^H\\THE,16H lazy Brown DOG.)
     The quick Red FOX jumps over   4 lazy Brown DOG.

     It should be noted that the final preface line and the final  field
     specification  were  defined  in  the  above example while the flag
     characters were inactive so these flag characters  are  treated  as
     nonflag  characters  even  though  the  preface  line and the field
     specification are applied later when the flag characters are  again
     active.      Complete Descriptions of the Commands                                 37


      .FLAGS CAPITALIZE character to precede capitalized words

           The .FLAGS CAPITALIZE command indicates that the  single  character
           appearing  as its argument can be used in the following source text
           at the start of words in which the alphabetic  letters  are  to  be
           converted to upper case.  The case mode which is in effect when the
           specified capitalization flag character is found in  the  following
           source  text,  regardless  of whether this case mode is the default
           retention  of  cases  which  can  also  be  specified   by   double
           circumflexes  or  by the .UPPER CASE command, or is the translation
           of upper case into lower case which is  specified  by  double  back
           slashes  or  by the .LOWER CASE command, will be restored following
           the next space, the next end of line or the next appearance of  the
           specified  capitalization  flag  character.   The .FLAGS CAPITALIZE
           command does not imply a .BREAK command.

           The  capitalization  flag  character  specified   by   the   .FLAGS
           CAPITALIZE  command  should  not  currently be active as some other
           flag indication, and should not be one of the alphabetic letters  A
           through  Z.  The capitalization flag character is recognized in all
           of the following source text, including the text being  represented
           in  the  FORMAT  statements,  the text within the range of .PROGRAM
           commands, and within commands  and  their  arguments.   Within  the
           range  of  the  .FLAGS CAPITALIZE command, underscores must precede
           all appearances of the capitalization flag character which  are  to
           be  treated  like  other  characters.   If  no  capitalization flag
           character is specified by the .FLAGS CAPITALIZE command,  then  the
           last character so specified by a previous .FLAGS CAPITALIZE command
           will be used, or the less than sign will be used  if  no  character
           has previously been specified by any .FLAGS CAPITALIZE command.

           No capitalization flag character is active  when  this  program  is
           started.  The capitalization flag character specified by the .FLAGS
           CAPITALIZE  command  can  temporarily  be  treated  as  a   nonflag
           character  if  a  .NO  FLAGS CAPITALIZE command is issued, but will
           again become active when a .FLAGS  CAPITALIZE  command  is  issued.
           The  capitalization  flag character, like all other flag characters
           in the source text, can also temporarily be treated  as  a  nonflag
           character  if  a  .NO FLAGS or .NO FLAGS ALL command is issued, but
           will again become active when a .FLAGS or  .FLAGS  ALL  command  is
           issued,  providing that a .FLAGS CAPITALIZE command has been issued
           more recently than a .NO FLAGS CAPITALIZE command.  Words which are
           marked  by  the  capitalization  flag  character  in a preface line
           defined by the .PREFACE command or in a field specification defined
           by the .INSERT command are converted to upper case when the preface
           line or the field specification is defined, regardless of what  the
           capitalization  flag  character happens to be when the preface line
           or the field specification is used.38                                           FORMAT Program User's Guide


     For example, the source text

     .nofill.offset 0.out width 55.preface       WRITE(1,$)
     .flag capitalize
     ^^UPPER lower <Le^S^s\T\han<UPPERlower UPPER lower
     UPPER lower <Le^S^s\T\han UPPER lower
     UPPER lower <Le^S^s\T\han
     UPPER lower
     .fcap %
     \\UPPER lower %Le^S^s\T\han%UPPER*lower UPPER lower
     UPPER lower %Le^S^s\T\han UPPER lower
     UPPER lower %Le^S^s\T\han
     UPPER lower
     .no flag
     ^^UPPER lower %Le^S^s\T\han%UPPERlower UPPER lower
     \\UPPER lower %Le^S^s\T\han%UPPER*lower UPPER lower
     .flag
     ^^UPPER lower %Le^S^s\T\han%UPPERlower UPPER lower
     \\UPPER lower %Le^S^s\T\han%UPPER*lower UPPER lower
     .no flag capitalize
     ^^UPPER lower %Le^S^s\T\han%UPPERlower UPPER lower
     \\UPPER lower %Le^S^s\T\han%UPPER*lower UPPER lower
     .program;      END

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(1,1)
         1 FORMAT(38HUPPER lower LESSthANUPPERlower UPPER l,
          14Hower/32HUPPER lower LESSthAN UPPER lower/3HUPP,
          217HER lower LESSthAN/11HUPPER lower/9Hupper low,
          334Her LESSthANupper*lower upper lower/8Hupper lo,
          424Hwer LESSthAN upper lower/17Hupper lower LESSt,
          53HhAN/11Hupper lower/24H^^upper lower %le^s^s\t\,
          626Hhan%upperlower upper lower/15H\\upper lower %,
          736Hle^s^s\t\han%upper*lower upper lower/6HUPPER ,
          836Hlower LESSthANUPPERlower UPPER lower/6Hupper ,
          937Hlower LESSthANupper*lower upper lower/5HUPPER,
          139H lower %LeSSthan%UPPERlower UPPER lower/3Hupp,
          242Her lower %leSSthan%upper*lower upper lower)
           end      Complete Descriptions of the Commands                                 39


           which would, in turn, generate the following text when run.

           UPPER lower LESSthANUPPERlower UPPER lower
           UPPER lower LESSthAN UPPER lower
           UPPER lower LESSthAN
           UPPER lower
           upper lower LESSthANupper*lower upper lower
           upper lower LESSthAN upper lower
           upper lower LESSthAN
           upper lower
           ^^upper lower %le^s^s\t\han%upperlower upper lower
           \\upper lower %le^s^s\t\han%upper*lower upper lower
           UPPER lower LESSthANUPPERlower UPPER lower
           upper lower LESSthANupper*lower upper lower
           UPPER lower %LeSSthan%UPPERlower UPPER lower
           upper lower %leSSthan%upper*lower upper lower


      .FLAGS CONTROL character to precede commands

           The .FLAGS CONTROL command  indicates  that  the  single  character
           appearing  as its argument can be used in the following source text
           at the start of lines which  are  to  be  interpreted  as  commands
           rather  than  as  text  which  is  to  be represented in the FORMAT
           statements.  If no character is specified  by  the  .FLAGS  CONTROL
           command,  then the last character so specified by a previous .FLAGS
           CONTROL command will be used, or the period  will  be  used  if  no
           character  has  previously  been  specified  by  any .FLAGS CONTROL
           command.  The .FLAGS  CONTROL  command  does  not  imply  a  .BREAK
           command.

           The control flag character specified by the .FLAGS CONTROL  command
           should  not  currently be active as some other flag indication, and
           should not be one of the alphabetic letters A through  Z.   If  the
           .FLAGS  CONTROL  command  is  followed  on the same line by another
           command, then these commands should be  separated  by  a  semicolon
           rather  than  by the appearance of either the original control flag
           character or of the new  control  flag  character,  since  the  new
           control flag character is not active until after the .FLAGS CONTROL
           command is interpreted, and the  original  control  flag  character
           will not be active when the next command is interpreted.

           If the control flag character appears at the start of a line  which
           is  not  a  command  line  or if the control flag character appears
           within a command line but does not indicate the  start  of  another
           command,  then  the  control  flag character must be preceded by an
           underscore.  The control flag character  specified  by  the  .FLAGS
           CONTROL command can also be treated as a nonflag character if a .NO
           FLAGS COMMAND is issued.  Of  course,  if  the  .NO  FLAGS  CONTROL
           command  is  issued,  then  no  further  commands can appear in the
           source text.

           For example, the source text

           .flag control *.this is the first line
           *output width 55;and this is the second line.
           *flag control =;=preface       WRITE(1,$)40                                           FORMAT Program User's Guide


     would be transformed into the following FORTRAN text when processed
     by this program.

           WRITE(1,1)
         1 FORMAT(38H .this is the first line and this is t,
          115Hhe second line.)


.FLAGS FENCE character to terminate and separate commands

     The .FLAGS  FENCE  command  indicates  that  the  single  character
     appearing  as  its  argument  can  be  used in command lines in the
     following source text to terminate any command except  those  which
     take  the  rest  of  the line of text as their arguments.  The text
     which follows the use of the separation flag character can  be  any
     text  which  could appear on the next line if nothing else appeared
     to the right of the command.   The  separation  flag  character  is
     required  between  two  commands on the same line only if the first
     command is followed by an exclamation point and then by a  comment.
     If  no character is specified by the .FLAGS FENCE command, then the
     last character so specified by a previous .FLAGS FENCE command will
     be  used,  or  the  semicolon  will  be  used  if  no character has
     previously been specified by any .FLAGS FENCE command.  The  .FLAGS
     FENCE command does not imply a .BREAK command.

     The separation flag character specified by the .FLAGS FENCE command
     should  not  currently be active as some other flag indication, and
     should not be one of the alphabetic letters A through  Z.   If  the
     .FLAGS  FENCE  command  is  followed  on  the  same line by another
     command, then either the .FLAGS FENCE command should not itself  be
     terminated  by a separation flag character or else the .FLAGS FENCE
     command should  be  terminated  by  the  original  separation  flag
     character  rather than by the appearance of the new separation flag
     character since the new separation flag  character  is  not  active
     until after the .FLAGS FENCE command is interpreted.

     If the separation flag character appears in a comment in a  command
     line but is not to terminate the comment, or appears as a character
     argument of a command, then the separation flag character  must  be
     preceded  by  an  underscore.   The  separation  flag character can
     temporarily be treated as a nonflag character if a .NO FLAGS  FENCE
     command is issued, but will again become active when a .FLAGS FENCE
     command is issued.

     For example, the source text

     .flag fence @!a comment;.indent 5@This text is to be
     .output width 55@represented in the FORMAT statement.

     would be transformed into the following FORTRAN text when processed
     by this program.

         1 FORMAT(6X,35HThis text is to be represented in t,
          120Hhe FORMAT statement.)      Complete Descriptions of the Commands                                 41


      .FLAGS INSERT character to indicate location of insertions

           The .FLAGS INSERT  command  indicates  that  the  single  character
           appearing  as  its  argument  can be used in the source text on the
           lines following a .PROGRAM command and in the text to the right  of
           a  .PREFACE  command  to  indicate locations at which the statement
           number of the next FORMAT statement is to  be  inserted.   If  more
           contiguous  appearances  of  the insertion flag character are found
           than there are digits in  the  statement  number,  then  additional
           spaces are inserted to the left of the statement number so that the
           total number of characters which are inserted equals the number  of
           insertion flag characters in the group.  The character specified by
           the .FLAGS INSERT command can also be used within the  source  text
           which  is  being  represented in the resulting FORMAT statements to
           indicate locations at which the output field descriptions specified
           by  the  .INSERT  command  are  to  be  inserted.   The  number  of
           contiguous appearances of the insertion flag character in the  text
           being  represented in the FORMAT statements indicates the number of
           characters which will be  generated  when  a  FORTRAN  variable  is
           written   out   using  the  field  specification.   The  number  of
           contiguous appearances of  the  insertion  flag  character  is  the
           number  of  character  positions  which  must  be  reserved for the
           appearance of this variable when the words in the source  text  are
           wrapped  around  and  justified by this program.  The .FLAGS INSERT
           command does not imply a .BREAK command.

           The insertion flag character specified by the .FLAGS INSERT command
           should  not  currently be active as some other flag indication, and
           should not be one of the alphabetic letters A  through  Z.   Within
           the  range  of  the .FLAGS INSERT command, underscores must precede
           all appearances of the insertion flag character  which  are  to  be
           treated  like  any other character.  If no insertion flag character
           is specified by the .FLAGS INSERT command, then the last  character
           so  specified  by a previous .FLAGS INSERT command will be used, or
           the dollar sign will be used if no character  has  previously  been
           specified by any .FLAGS INSERT command.

           The insertion flag character specified by the .FLAGS INSERT command
           can  temporarily  be  treated as a nonflag character if a .NO FLAGS
           INSERT command is issued, but  will  again  become  active  when  a
           .FLAGS  INSERT  command  is  issued.  The insertion flag character,
           like all other  flag  characters  in  the  source  text,  can  also
           temporarily be treated as a nonflag character if a .NO FLAGS or .NO
           FLAGS ALL command is issued, but will again become  active  when  a
           .FLAGS  or .FLAGS ALL command is issued, providing that a .NO FLAGS
           INSERT command has not been issued  more  recently  than  a  .FLAGS
           INSERT  command.   The  character  which  is  to be replaced by the
           statement number in a preface line defined by the .PREFACE  command
           is  the  insertion  flag character which is active when the preface
           line is defined, regardless of what the  insertion  flag  character
           happens to be when the preface line is used.42                                           FORMAT Program User's Guide


     For example, the source text

     .flags insert @.output width 55.program 100,10
     .insert 1I8
     .insert 1A8
     .preface       WRITE(1$2,@)
     ^^C     NEXT FORMAT STATEMENT IS @.
     .continue;\\^MAXIMUM AMOUNT OF LOAN IS $@@@@@@@@.
     .flags insert $.program
     ^^C     NEXT FORMAT STATEMENT IS $.
     .continue;\\^MAXIMUM AMOUNT OF LOAN IS _$$$$$$$$$.
     .no flags.program
     ^^C     NEXT FORMAT STATEMENT IS $.
     .continue;\\^MAXIMUM AMOUNT OF LOAN IS _$$$$$$$$$.

     would be transformed into the following FORTRAN text when processed
     by this program.

     C     NEXT FORMAT STATEMENT IS 100.
           WRITE(1$2,100)
       100 FORMAT(28H Maximum amount of loan is $,1I8,1H.)
     C     NEXT FORMAT STATEMENT IS 110.
           WRITE(1$2,110)
       110 FORMAT(28H Maximum amount of loan is $,1A8,1H.)
     ^^c     next format statement is $.
           WRITE(1$2,120)
       120 FORMAT(38H \\^maximum amount of loan is _$$$$$$$,
          13H$$.)


.FLAGS LOWER CASE character to precede lower case letters

     The .FLAGS LOWER CASE command indicates that the  single  character
     appearing as its argument can be used in the source text before any
     alphabetic letter in the range A through Z which is to be converted
     to  its  lower case form.  Two adjacent lower case shift characters
     indicate that all subsequent alphabetic letters are to be converted
     to  lower  case,  except  for the next letter immediately following
     either an underscore or a circumflex and except for all letters  in
     the word immediately following a less than sign if within the range
     of a .FLAGS CAPITALIZE command.  The range of the lower case  shift
     lock indicated either by the 2 adjacent lower case shift characters
     or by the equivalent .LOWER CASE command can be  terminated  either
     by  2  adjacent  circumflexes  or  by  the  equivalent  .UPPER CASE
     command.  The .FLAGS LOWER CASE command does  not  imply  a  .BREAK
     command.

     The lower case shift character specified by the .FLAGS  LOWER  CASE
     command   should  not  currently  be  active  as  some  other  flag
     indication, and should not be  one  of  the  alphabetic  letters  A
     through  Z.   Within  the  range  of the .FLAGS LOWER CASE command,
     underscores must precede all appearances of the  lower  case  shift
     character  which are to be treated like any other character.  If no
     lower case shift character is specified by the  .FLAGS  LOWER  CASE
     command,  then the last character so specified by a previous .FLAGS
     LOWER CASE command will be used, or the back slash will be used  if
     no character has previously been specified by any .FLAGS LOWER CASE      Complete Descriptions of the Commands                                 43


           command.

           The lower case shift character specified by the .FLAGS  LOWER  CASE
           command  can temporarily be treated as a nonflag character if a .NO
           FLAGS LOWER CASE command is issued, but will  again  become  active
           when  a  .FLAGS LOWER CASE command is issued.  The lower case shift
           character, like all other flag characters in the source  text,  can
           also  temporarily  be treated as a nonflag character if a .NO FLAGS
           or .NO FLAGS ALL command is issued, but will  again  become  active
           when a .FLAGS or .FLAGS ALL command is issued, providing that a .NO
           FLAGS LOWER CASE command has not been issued more recently  than  a
           .FLAGS LOWER CASE command.  Letters which are preceded by the lower
           case shift character or which are within the range of a lower  case
           shift  lock in a preface line defined by the .PREFACE command or in
           a field specification defined by the .INSERT command are  converted
           to  lower  case when the preface line or the field specification is
           defined, regardless of what the case shift characters happen to  be
           when the preface line or the field specification is used.

           For example, the source text

           .flag capitalize.nofill.output width 55
           \\\T\H\I\S \l\i\n\e WILL be ^^\A\L\L \l\o\w\e\r case
           ^^^t^h^i^s ^L^I^N^E WILL <be \\^A^L^L ^u^p^p^e^r <CASE
           .flag lower case -.flag upper case +.flag capitalize @
           ---T-H-I-S -l-i-n-e WILL be ++-A-L-L -l-o-w-e-r case
           +++t+h+i+s +L+I+N+E WILL @be --+A+L+L +u+p+p+e+r @CASE

           would be transformed into the following FORTRAN text when processed
           by this program.

               1 FORMAT(33H this line will be all lower case/2H T,
                131HHIS LINE WILL BE ALL UPPER CASE/10H this line,
                223H will be all lower case/18H THIS LINE WILL BE,
                315H ALL UPPER CASE)


      .FLAGS QUOTE character to precede character to be used as is

           The .FLAGS  QUOTE  command  indicates  that  the  single  character
           appearing as its argument can be used in the source text before any
           character which is to  be  treated  as  an  ordinary  nonalphabetic
           nonflag  printing  character.   The  .FLAGS  QUOTE command does not
           imply a .BREAK command.

           The quotation flag character specified by the .FLAGS QUOTE  command
           should  not  currently be active as some other flag indication, and
           should not be one of the alphabetic letters A  through  Z.   Within
           the range of the .FLAGS QUOTE command, the quotation flag character
           must precede all appearances of the quotation flag character  which
           are  to  be treated like any other character.  If no quotation flag
           character is specified by the .FLAGS QUOTE command, then  the  last
           character  so  specified by a previous .FLAGS QUOTE command will be
           used, or the underscore will be used if no character has previously
           been specified by any .FLAGS QUOTE command.44                                           FORMAT Program User's Guide


     The quotation flag character specified by the .FLAGS QUOTE  command
     can  temporarily  be  treated as a nonflag character if a .NO FLAGS
     QUOTE command is issued, but will again become active when a .FLAGS
     QUOTE  command  is  issued.  The quotation flag character, like all
     other flag characters in the source text, can also  temporarily  be
     treated  as  a  nonflag  character  if a .NO FLAGS or .NO FLAGS ALL
     command is issued, but will again become active when  a  .FLAGS  or
     .FLAGS  ALL  command  is  issued,  providing that a .NO FLAGS QUOTE
     command has not been issued  more  recently  than  a  .FLAGS  QUOTE
     command.   If characters within the definition of a preface line by
     the .PREFACE command or of a field  specification  by  the  .INSERT
     command  are  to be treated as nonflag printing characters in spite
     of their usual interpretations, then  these  characters  should  be
     preceded  by  the quotation flag character which is active when the
     preface line or the field specification is defined,  regardless  of
     what quotation flag character happens to be active when the preface
     line or the field specification is used.

     For example, the source text

     .flags quote *.left margin 3.output width 55
     Some typical flag characters are
     .indent -3
     *###the number sign
     .indent -3
     *^##the circumflex
     .indent -3
     *\##the back slash
     .indent -3
     *$##the dollar sign
     .indent -3
     _##the underscore

     would be transformed into the following FORTRAN text when processed
     by this program.

         1 FORMAT(4X,32HSome typical flag characters are/
          119H #  the number sign/18H ^  the circumflex/1H ,
          217H\  the back slash/19H $  the dollar sign/2H _,
          316H  the underscore)


.FLAGS REMARK character to separate commands from comments

     The .FLAGS REMARK  command  indicates  that  the  single  character
     appearing  as  its  argument  can  be  used in command lines in the
     following source text to indicate that the following  text  through
     the  end  of the line or through the next appearance of a semicolon
     on the same line is to be  treated  as  a  comment  and  is  to  be
     ignored.  Less than signs in the comment do not apply after the end
     of the comment, but all case shift locks indicated in  the  comment
     by double back slashes or by double circumflexes are applied to the
     text following the comment.  The remark flag character is  inactive
     following those commands which take the rest of the line of text as
     their arguments.  If no character is specified by the .FLAGS REMARK
     command,  then the last character so specified by a previous .FLAGS
     REMARK command will be used, or the exclamation point will be  used      Complete Descriptions of the Commands                                 45


           if  no character has previously been specified by any .FLAGS REMARK
           command.  The  .FLAGS  REMARK  command  does  not  imply  a  .BREAK
           command.

           The remark flag character specified by the  .FLAGS  REMARK  command
           should  not  currently be active as some other flag indication, and
           should not be one of the alphabetic letters A through  Z.   If  the
           .FLAGS  REMARK  command  is followed on the same line by a comment,
           then the comment should be indicated by the  original  remark  flag
           character  since  the  new remark flag character will not be active
           until the .FLAGS REMARK command is interpreted.

           If the remark flag character appears within a command line  but  is
           not  to  indicate  the  start  of  a  comment, then the remark flag
           character must be preceded  by  an  underscore.   The  remark  flag
           character  specified  by  the  .FLAGS  REMARK  command  can also be
           treated as a nonflag character if a .NO  FLAGS  REMARK  command  is
           issued,  but  will again become active when a .FLAGS REMARK command
           is issued.

           For example, the source text

           .!.indent 5!command which has been commented out
           .flags capitalize!comment separating commands;.offset 0
           .preface one<two!three four
           FIRST LINE
           .continue! 2\\back slashes;.preface five<six;seven eight
           .!capitalization stops at end of <comment;SECOND LINE
           .flag remark @!at sign inactive;.text@ 2^^circumflexes
           .preface nine<ten.eleven twelve
           THIRD LINE

           would be transformed into the following FORTRAN text when processed
           by this program.

           oneTWO!THREE four
               1 FORMAT(10HFIRST LINE)
           fiveSIX;SEVEN eight
               2 FORMAT(11Hsecond line)
           nineTEN.ELEVEN twelve
               3 FORMAT(10HTHIRD LINE)


      .FLAGS SPACE character to indicate a nonadjustable space

           The .FLAGS  SPACE  command  indicates  that  the  single  character
           appearing  as its argument can be used in the following source text
           to indicate the location of a space  which  is  to  be  treated  as
           though  it were a printing character.  The use of the space holding
           character is completely equivalent to the use of a  space  preceded
           by an underscore.  The .FLAGS SPACE command does not imply a .BREAK
           command.

           The space holding character specified by the .FLAGS  SPACE  command
           should  not  currently be active as some other flag indication, and
           should not be one of the alphabetic letters A through Z.  The space
           holding  character  is  recognized  in  all of the following source46                                           FORMAT Program User's Guide


     text,  including  the  text  being  represented   in   the   FORMAT
     statements,  the  text  within  the range of .PROGRAM commands, and
     within the arguments of commands.  Within the range of  the  .FLAGS
     SPACE  command,  underscores  must  precede  all appearances of the
     space holding character which are to be left unchanged rather  than
     be converted to spaces.  If no space holding character is specified
     by the .FLAGS SPACE command, then the last character  so  specified
     by a previous .FLAGS SPACE command will be used, or the number sign
     will be used if no character has previously been specified  by  any
     .FLAGS SPACE command.

     The space holding character specified by the .FLAGS  SPACE  command
     can  temporarily  be  treated as a nonflag character if a .NO FLAGS
     SPACE command is issued, but will again become active when a .FLAGS
     SPACE  command  is  issued.   The space holding character, like all
     other flag characters in the source text, can also  temporarily  be
     treated  as  a  nonflag  character  if a .NO FLAGS or .NO FLAGS ALL
     command is issued, but will again become active when  a  .FLAGS  or
     .FLAGS  ALL  command  is  issued,  providing that a .NO FLAGS SPACE
     command has not been issued  more  recently  than  a  .FLAGS  SPACE
     command.   Nonadjustable  spaces  in  a preface line defined by the
     .PREFACE command or in a field specification defined by the .INSERT
     command  should  be  indicated  by  the  space holding character in
     effect when the preface line or the field specification is defined,
     regardless  of  what the space holding character happens to be when
     the preface line or the field specification is used.

     For example, the source text

     .output width 55
     .insert 10Hthe   _####
     .insert 10Hthe   *###
     .preface ######write(1_#2,$)
     This   demonstrates   $space###holding   character.
     .flags space *.break
     This   demonstrates   $space***holding   character.

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text.

           write(1#2,1)
         1 FORMAT(19H This demonstrates ,10Hthe   #   ,2Hsp,
          124Hace   holding character./17H This demonstrate,
          22Hs ,10Hthe   *   ,26Hspace   holding character.)


.FLAGS UPPER CASE character to precede upper case letters

     The .FLAGS UPPER CASE command indicates that the  single  character
     appearing as its argument can be used in the source text before any
     alphabetic letter in the range A through Z which is to be converted
     to  its  upper case form.  Two adjacent upper case shift characters
     indicate that the cases of all subsequent alphabetic letters are to
     be left unchanged, except for the next letter immediately following
     either a back slash or a  single  circumflex  and  except  for  all
     letters  in  the  word  immediately  following  a less than sign if
     within the range of a .FLAGS CAPITALIZE command.  The range of  the      Complete Descriptions of the Commands                                 47


           retained  case  shift lock indicated either by the 2 adjacent upper
           case shift characters or by the equivalent .UPPER CASE command  can
           be  terminated  either  by  2  adjacent  back  slashes  or  by  the
           equivalent .LOWER CASE command.  The .FLAGS UPPER CASE command does
           not imply a .BREAK command.

           The upper case shift character specified by the .FLAGS  UPPER  CASE
           command   should  not  currently  be  active  as  some  other  flag
           indication, and should not be  one  of  the  alphabetic  letters  A
           through  Z.   Within  the  range  of the .FLAGS UPPER CASE command,
           underscores must precede all appearances of the  upper  case  shift
           character  which are to be treated like any other character.  If no
           upper case shift character is specified by the  .FLAGS  UPPER  CASE
           command,  then the last character so specified by a previous .FLAGS
           UPPER CASE command will be used, or the circumflex will be used  if
           no character has previously been specified by any .FLAGS UPPER CASE
           command.

           The upper case shift character specified by the .FLAGS  UPPER  CASE
           command  can temporarily be treated as a nonflag character if a .NO
           FLAGS UPPER CASE command is issued, but will  again  become  active
           when  a  .FLAGS UPPER CASE command is issued.  The upper case shift
           character, like all other flag characters in the source  text,  can
           also  temporarily  be treated as a nonflag character if a .NO FLAGS
           or .NO FLAGS ALL command is issued, but will  again  become  active
           when a .FLAGS or .FLAGS ALL command is issued, providing that a .NO
           FLAGS UPPER CASE command has not been issued more recently  than  a
           .FLAGS UPPER CASE command.  Letters which are preceded by the upper
           case shift character in a preface  line  defined  by  the  .PREFACE
           command  or in a field specification defined by the .INSERT command
           are converted to upper case when the  preface  line  or  the  field
           specification  is  defined,  regardless  of  what  the  case  shift
           characters happen  to  be  when  the  preface  line  or  the  field
           specification is used.

           For example, the source text

           .flag capitalize.nofill.output width 55
           .upper case
           ^this \F\O\L\L\O\W\S \a\n .UPPER <case command.
           .lower case
           ^THIS \F\O\L\L\O\W\S a .^L^O^W^E^R <case command.
           ^^^this \F\O\L\L\O\W\S \t\w\o CIRCUM<flex characters.
           \\^THIS \F\O\L\L\O\W\S two ^B^A^C^K <slash characters.
           .flag lower case -.flag upper case+.flag capitalize @
           +++this -F-O-L-L-O-W-S -t-w-o PLUS @sign characters.
           --+THIS -F-O-L-L-O-W-S two +M+I+N+U+S @sign characters.

           would be transformed into the following FORTRAN text when processed
           by this program.

               1 FORMAT(37H This follows an .UPPER CASE command./
                136H This follows a .LOWER CASE command./6H This ,
                234Hfollows two CIRCUMFLEX characters./8H This fo,
                332Hllows two BACK SLASH characters./9H This fol,
                430Hlows two PLUS SIGN characters./11H This follo,
                529Hws two MINUS SIGN characters.)48                                           FORMAT Program User's Guide


.GROUP line of text to precede groups of FORMAT statements

     The characters which appear to the right of the .GROUP  command  on
     the  same  line are to be copied into the output file on a separate
     line before each FORMAT statement which either is the first  FORMAT
     statement  ever  generated during this use of this program or which
     is the first FORMAT statement generated after a .TEXT command.  The
     character  to  the  immediate right of the .GROUP command must be a
     space.  The line of text which is to be copied into the output file
     before  each  new group of FORMAT statements starts with the second
     character to the right of the .GROUP command, whether or  not  this
     is a printing character, and extends through the rightmost printing
     character on the line.  The line specified by the .GROUP command is
     not  inserted  before  a FORMAT statement which is generated merely
     because the previous FORMAT statement has filled or merely  because
     a  .CONTINUE command has been issued to break the text into another
     FORMAT statement.

     If more than a single line must be inserted before each  new  group
     of  FORMAT statements, then a .DEFINE GROUP command followed by the
     lines of text and then by an .END DEFINITION command should be used
     to  specify  the lines instead.  Regardless of which method is used
     to specify the line or lines, the insertions of the line  or  lines
     are performed similarly.

     The .GROUP command allows the insertion of a line of  FORTRAN  text
     before   each  group  of  FORMAT  statements  which  are  logically
     connected.  For example, this line might cause a transfer  back  to
     the calling program after the completion of the use of the previous
     group  of  FORMAT  statements.   The   rules   which   govern   the
     construction  of  the line which is specified by the .GROUP command
     are identical  to  those  which  are  described  for  the  .PREFACE
     command.   If  both  types  of  lines  are  being inserted before a
     particular FORMAT statement, then the lines defined by  the  .GROUP
     or .DEFINE GROUP command are inserted before those specified by the
     .PREFACE or .DEFINE PREFACE command.

     For example, the source text

     .output width 55.output length 2
     .group       GO TO 1000
     .preface $$$$$ WRITE(ITTY,$=$)
     This is the first text in the example.
     It should be preceded by both a group
     and a preface line.
     .continue
     This text follows a .CONTINUE command.
     .text 100
     This text follows a .TEXT command.      Complete Descriptions of the Commands                                 49


           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text.

                 GO TO 1000
               1 WRITE(ITTY,2)
               2 FORMAT(38H This is the  first  text  in  the  ex,
                123Hample.   It  should  be)
               3 WRITE(ITTY,4)
               4 FORMAT(38H preceded by both a group and a prefac,
                17He line.)
               5 WRITE(ITTY,6)
               6 FORMAT(38H This text follows a .CONTINUE command,
                11H.)
                 GO TO 1000
             100 WRITE(ITTY,101)
             101 FORMAT(35H This text follows a .TEXT command.)


      .INDENT number of extra spaces to insert beyond left margin

           The .INDENT command indicates that the left end of the next line of
           text which is represented in the FORMAT statement is to be indented
           the indicated number of spaces from the left  margin  which  is  in
           effect  when the first word in the line is found.  The number which
           follows the .INDENT command can be either positive  indicating  the
           insertion  of  extra  initial  spaces,  or  negative indicating the
           deletion of spaces from the left margin.  If the number is missing,
           then   a   positive  indentation  of  5  spaces  is  assumed.   The
           indentation is applied regardless  of  whether  the  next  line  is
           copied  in  no  fill  mode  or is constructed in fill mode.  If the
           .INDENT command was preceded by a .CENTER command, then the .CENTER
           command  is  ignored.  The .INDENT command implies a .BREAK command
           before the following line of source text.

           For example, the source text

           .offset 0.left margin 0.right margin 55.output width 55
           .indent 5.preface       WRITE(1,$)
           The flag characters which are listed below are
           deactivated by the .NO FLAGS command.
           .left margin 5
           .indent -3
           _$##(dollar sign) or whatever character has been
           selected by a .FLAGS INSERT command.
           .indent -3
           _###(number sign) or whatever character has been
           selected by a .FLAGS SPACE command.
           .PROGRAM;      END50                                           FORMAT Program User's Guide


     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(1,1)
         1 FORMAT(5X,35HThe flag characters which  are  lis,
          115Hted  below  are/26Hdeactivated by the .NO FLA,
          211HGS command./30H  $  (dollar  sign)  or  whate,
          325Hver  character  has  been/5X,13Hselected by a,
          423H .FLAGS INSERT command./18H  #  (number  sign,
          537H)  or  whatever  character  has  been/5X,2Hse,
          633Hlected by a .FLAGS SPACE command.)
           END

     which would, in turn, generate the following text when run.

          The flag characters which  are  listed  below  are
     deactivated by the .NO FLAGS command.
       $  (dollar  sign)  or  whatever  character  has  been
          selected by a .FLAGS INSERT command.
       #  (number  sign)  or  whatever  character  has  been
          selected by a .FLAGS SPACE command.


.INPUT WIDTH maximum number of characters in any input line

     The .INPUT WIDTH command specifies the maximum number of characters
     which  are  to  be read from in each line in the input file.  If an
     input line contains more than the specified number  of  characters,
     then  the  characters  which  appear  to the right of the specified
     number of characters are ignored.  The input line  width  specified
     by the .INPUT WIDTH command applies to all following lines, but not
     to the line in which it is specified.   The  .INPUT  WIDTH  command
     does not imply a .BREAK command.

     If the number which follows the .INPUT WIDTH command  is  unsigned,
     then  this  number will be used as the line width for the following
     input lines.  If the number which follows the .INPUT WIDTH  command
     is  signed,  then  the previous input line width is adjusted by the
     indicated amount.  The input line width is 132 when this program is
     started.  The input line width cannot exceed 300 characters.

     For example, the source text

     .input width 5.text 10
     12345This is not read
     .iw+5This is not read
     1234567890This is not read

     would be transformed into the following FORTRAN text when processed
     by this program.

        10 FORMAT(17H 12345 1234567890)      Complete Descriptions of the Commands                                 51


      .INSERT output field specification to replace next $ signs

           The .INSERT command specifies the group of characters which  is  to
           replace  the  next  group  of contiguous dollar signs which are not
           preceded by underscores in the text being represented in the FORMAT
           statements.   The  character  to the immediate right of the .INSERT
           command must be a space.  The group of characters which  is  to  be
           inserted  starts  with  the  second  character  to the right of the
           .INSERT command, whether or not this is a printing  character,  and
           extends  through  the rightmost printing character on the line.  If
           an .INSERT command has not been issued, or if no printing character
           appears to the right of the .INSERT command, then the next group of
           contiguous dollar signs is removed, but the group of characters  to
           be  inserted  is  of  zero  length so no characters are inserted in
           place of the group of dollar signs.  If 2 or more .INSERT  commands
           have specified groups of characters which have not yet been used to
           replace groups of contiguous dollar signs,  then  these  groups  of
           characters  are  applied  in  the order in which they were defined.
           Unless the lengths of 3 arrays in this program  are  increased,  no
           more  than 50 groups of characters having an aggregate length of no
           more than 500 characters can have been specified but remain  unused
           at  any  time.   All  unused  groups of characters are discarded if
           either a .NO INSERT command or  a  .TEXT  command  is  encountered.
           Neither  the  .INSERT  command nor the .NO INSERT command implies a
           .BREAK command.

           The text on either side of the group  of  contiguous  dollar  signs
           being   replaced  is  represented  in  H  or  apostrophe  notation,
           whichever has been selected by the .USE  command.   The  characters
           which  are  being  inserted  will be interpreted as an output field
           specification when the FORMAT statements  are  used.   If  in  fill
           mode,  the  number  of  dollar signs in the group being replaced is
           used in determining the length of the line  being  accumulated,  so
           the number of dollar signs in the group being replaced should equal
           the number of characters which will  be  generated  by  the  output
           field  specification  when  the  FORMAT  statements  are used.  For
           example, 9 dollar signs would be used to mark the location  in  the
           text  at  which a 9 character date representation such as 12-Jan-80
           is  to  be  generated  using  a  1I2,1H-,1A3,1H-,1I2  output  field
           specification.   Commas are inserted on either side of the original
           location of the group of dollar signs so the .INSERT command should
           not  specify  commas  at the start and at the end of the text being
           inserted.  The text being inserted  can  be  split  onto  the  next
           continuation  line  of  the FORMAT statement following any comma in
           the text being inserted.

           Within the text being inserted, an underscore character, which will
           not  be  copied  into  the  FORMAT statement, can appear before any
           character, such as a comma, space, number  sign,  circumflex,  back
           slash,  less  than  sign  (if  in  flag capitalize mode) or another
           underscore, which is to be treated as a nonflag  character.   If  a
           comma  in the text being inserted is not at a location at which the
           text being inserted can be split onto the next continuation line of
           the  FORMAT  statement,  then  the  comma  should be preceded by an
           underscore.  If the text being inserted is to  end  with  a  space,
           then  this  space should be preceded by an underscore.  The .INSERT
           command cannot be followed on the same line either by a comment  or52                                           FORMAT Program User's Guide


     by  another  command,  so  semicolons and exclamation points in the
     text to be inserted do not need to be preceded by underscores.

     For example, the source text

     .program 10
           DATA KOUNT,IDAY,IYEAR/12345,12,80/
           DATA IMONTH/3HJan/
           WRITE(1,$)KOUNT,IDAY,IMONTH,IYEAR
     .insert 1I5
     .insert 1I2,1H-,1A3,1H-,1I2
     .continue.output width 55
     $$$$$ items were produced on $$$$$$$$$.
     .program
           END

     would, when processed by this  program,  be  transformed  into  the
     following proof file

     .program 10
           DATA KOUNT,IDAY,IYEAR/12345,12,80/
           DATA IMONTH/3HJan/
           WRITE(1,10)KOUNT,IDAY,IMONTH,IYEAR
     .insert 1I5
     .insert 1I2,1H-,1A3,1H-,1I2
     .continue
     .output width 55
        10 FORMAT(
     1I5
     1I2,1H-,1A3,1H-,1I2
      $$$$$ items were produced on $$$$$$$$$.
     .program
           END

     and would also be transformed into the following FORTRAN text

           DATA KOUNT,IDAY,IYEAR/12345,12,80/
           DATA IMONTH/3HJan/
           WRITE(1,10)KOUNT,IDAY,IMONTH,IYEAR
        10 FORMAT(1H ,1I5,24H items were produced on ,1I2,
          11H-,1A3,1H-,1I2,1H.)
           END

     which would, in turn, generate the following text when run.

      12345 items were produced on 12-Jan-80.


.JUSTIFY

     The .JUSTIFY command indicates that the lines  of  text  which  are
     constructed  in fill mode are to be extended to the right margin by
     the addition of extra spaces between the words.  The  extra  spaces
     are added between the words starting at the right end in the first,
     third and every other line following a .BREAK command or  following
     any  command which implies a .BREAK command, and are added starting
     at the left in the alternate lines.   Extra  spaces  are,  however,      Complete Descriptions of the Commands                                 53


           never  inserted in the final line before a .BREAK command or before
           any command which implies a .BREAK command.  The  .JUSTIFY  command
           implies a .BREAK command

           A .JUSTIFY command is assumed to be in effect when this program  is
           started.   A  .NO JUSTIFY command should be issued instead if lines
           which are constructed in fill mode are not required to have exactly
           the  same  lengths,  but  the lines are still to be filled with the
           most words which do not extend beyond the right margin.  If  a  .NO
           JUSTIFY  command  is  in effect, then words are separated by single
           spaces and sentences by two spaces.  A .JUSTIFY or  a  .NO  JUSTIFY
           command  issued  within  the range of a .PROGRAM command applies to
           the lines of text constructed in fill mode following the next .TEXT
           or  .CONTINUE  command.  A .JUSTIFY or a .NO JUSTIFY command issued
           within the range of a .NO FILL command applies to the lines of text
           constructed following the next .FILL command.

           For example, the source text

           .output width 55.right margin 55.offset 0
           .no justify.preface       WRITE(1,$)
           The .JUSTIFY and the .NO JUSTIFY commands do not
           apply to text which is within the range of .NO FILL
           commands  and does not apply to the text which is
           within the range of the .PROGRAM command.
           .justify.skip
           The .JUSTIFY and the .NO JUSTIFY commands do not
           apply to text which is within the range of .NO FILL
           commands  and does not apply to the text which is
           within the range of the .PROGRAM command.
           .nofill.skip
           The .JUSTIFY and the .NO JUSTIFY commands do not
           apply to text which is within the range of .NO FILL
           commands  and does not apply to the text which is
           within the range of the .PROGRAM command.
           .program;      END

           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

                 WRITE(1,1)
               1 FORMAT(38HThe .JUSTIFY and the .NO JUSTIFY comma,
                116Hnds do not apply/25Hto text which is within t,
                229Hhe range of .NO FILL commands/12Hand does not,
                338H apply to the text which is within the/4Hrang,
                426He of the .PROGRAM command.//14HThe .JUSTIFY a,
                541Hnd the .NO JUSTIFY commands do not  apply/1Ht,
                645Ho  text which is within the range of .NO FILL,
                79H commands/33Hand does not apply to the  text  ,
                822Hwhich  is  within  the/19Hrange of the .PROGR,
                911HAM command.//29HThe .JUSTIFY and the .NO JUST,
                119HIFY commands do not/22Happly to text which is,
                229H within the range of .NO FILL/12Hcommands  an,
                337Hd does not apply to the text which is/5Hwithi,
                436Hn the range of the .PROGRAM command.)
                 END54                                           FORMAT Program User's Guide


     which would, in turn, generate the following text when run.

     The .JUSTIFY and the .NO JUSTIFY commands do not apply
     to text which is within the range of .NO FILL commands
     and does not apply to the text which is within the
     range of the .PROGRAM command.

     The .JUSTIFY and the .NO JUSTIFY commands do not  apply
     to  text which is within the range of .NO FILL commands
     and does not apply to the  text  which  is  within  the
     range of the .PROGRAM command.

     The .JUSTIFY and the .NO JUSTIFY commands do not
     apply to text which is within the range of .NO FILL
     commands  and does not apply to the text which is
     within the range of the .PROGRAM command.


.LEADING

     The .LEADING command indicates that blank lines which are requested
     prior  to  the  specification of any text which is to appear in the
     FORMAT statements, either when this program  is  first  started  or
     following a .TEXT command, are to be represented in the next FORMAT
     statement if an .EJECT command is issued or if some text  which  is
     to  be  represented  in the FORMAT statement is actually specified.
     Such leading blank lines can be requested by a .BLANK  or  a  .SKIP
     command.   Leading  blank  lines  are  discarded  if  a .NO LEADING
     command is in effect or if a .LEADING command has not been  issued.
     Neither  the .LEADING command nor the .NO LEADING command implies a
     .BREAK command.

     For example, the source text

     .spacing 2.output width 55.skip
     The quick red fox jumps over the lazy brown dog, then
     runs into the forest
     .text.leading.skip
     The quick red fox jumps over the lazy brown dog, then
     runs into the forest
     .text.trailing.skip
     The quick red fox jumps over the lazy brown dog, then
     runs into the forest
     .text.no leading.skip
     The quick red fox jumps over the lazy brown dog, then
     runs into the forest      Complete Descriptions of the Commands                                 55


           would be transformed into the following FORTRAN text when processed
           by this program.

               1 FORMAT(38H The quick red fox jumps over the lazy,
                123H brown dog,  then  runs//16H into the forest)
               2 FORMAT(//36H The quick red fox jumps over the la,
                125Hzy brown dog,  then  runs//15H into the fores,
                21Ht)
               3 FORMAT(//36H The quick red fox jumps over the la,
                125Hzy brown dog,  then  runs//15H into the fores,
                21Ht/)
               4 FORMAT(38H The quick red fox jumps over the lazy,
                123H brown dog,  then  runs//16H into the forest/)


      .LEFT MARGIN number of spaces to left of text

           The .LEFT MARGIN command specifies the number of spaces  which  are
           to  be  inserted to the left of each of the lines of text which are
           being represented in the FORMAT statements in  either  fill  or  no
           fill  modes.  The left margin specified by the .LEFT MARGIN command
           is in addition to the leftmost  spaces  specified  by  the  .OFFSET
           command  or  in addition to the single left space which is obtained
           if neither the .OFFSET command nor the .NO OFFSET command has  been
           issued.   An .INDENT or .PARAGRAPH command can be issued prior to a
           particular paragraph to temporarily change the left margin for  the
           leading  line  in  that paragraph.  If the number which follows the
           .LEFT MARGIN command is unsigned, then this number will be used  as
           the  left  margin.   If  the  number which follows the .LEFT MARGIN
           command is signed, then the previous left margin is adjusted by the
           indicated  amount.   If  no number follows the .LEFT MARGIN command
           then the left margin is reset to zero.  The  .LEFT  MARGIN  command
           implies a .BREAK command.

           If the lines of text are being constructed in fill mode,  then  the
           left  margin specified by the .LEFT MARGIN command should be to the
           left of the right margin specified by the .RIGHT MARGIN command  or
           to  the  left  of column 60 if a .RIGHT MARGIN command has not been
           issued.  The right margin is ignored if the lines of text are being
           copied  in  no  fill  mode.  The only spaces which are inserted are
           those which are specified by the .OFFSET command if a signed number
           following  the  .LEFT  MARGIN  command causes the left margin to be
           negative.56                                           FORMAT Program User's Guide


     For example, the source text

     .preface       WRITE(1,$)
     .output width 55;Default left margin and default offset
     .left margin 10 ;Left margin 10 obtained as .lm 10
     .left margin -5 ;Left margin 5 obtained as .lm-5
     .left margin -5 ;Left margin 0 obtained as .lm-5
     .left margin -5 ;Left margin -5 which is treated as 0
     .left margin +5 ;Left margin 0 obtained as .lm+5
     .left margin +5 ;Left margin 5 obtained as .lm+5
     .offset 6       ;Unchanged left margin and offset 6
     .left margin 10 ;Left margin 10 obtained as .lm 10
     .left margin -5 ;Left margin 5 obtained as .lm-5
     .left margin -5 ;Left margin 0 obtained as .lm-5
     .left margin -5 ;Left margin -5 which is treated as 0
     .left margin +5 ;Left margin 0 obtained as .lm+5
     .left margin +5 ;Left margin 5 obtained as .lm+5
     .program ;      END

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(1,1)
         1 FORMAT(38H Default left margin and default offse,
          11Ht/11X,33HLeft margin 10 obtained as .lm 10/6X,
          231HLeft margin 5 obtained as .lm-5/10H Left marg,
          322Hin 0 obtained as .lm-5/19H Left margin -5 whi,
          418Hch is treated as 0/23H Left margin 0 obtained,
          59H as .lm+5/6X,30HLeft margin 5 obtained as .lm+,
          61H5/11X,34HUnchanged left margin and offset 6/9X,
          77X,33HLeft margin 10 obtained as .lm 10/11X,2HLe,
          829Hft margin 5 obtained as .lm-5/6X,9HLeft marg,
          922Hin 0 obtained as .lm-5/6X,16HLeft margin -5 w,
          120Hhich is treated as 0/6X,18HLeft margin 0 obta,
          213Hined as .lm+5/11X,24HLeft margin 5 obtained a,
          37Hs .lm+5)
           END

     which would, in turn, generate the following text when run.

      Default left margin and default offset
                Left margin 10 obtained as .lm 10
           Left margin 5 obtained as .lm-5
      Left margin 0 obtained as .lm-5
      Left margin -5 which is treated as 0
      Left margin 0 obtained as .lm+5
           Left margin 5 obtained as .lm+5
                Unchanged left margin and offset 6
                     Left margin 10 obtained as .lm 10
                Left margin 5 obtained as .lm-5
           Left margin 0 obtained as .lm-5
           Left margin -5 which is treated as 0
           Left margin 0 obtained as .lm+5
                Left margin 5 obtained as .lm+5      Complete Descriptions of the Commands                                 57


      .LOWER CASE

           The .LOWER CASE command indicates that all  upper  case  alphabetic
           letters which are not specially marked are to be converted to their
           lower case forms in the source text which follows the  end  of  the
           command or, if the .LOWER CASE command is followed by a comment, in
           the  source  text  which  follows  the  comment.   The  lower  case
           conversion  selected  by  the .LOWER CASE command is not applied to
           any  letter  which  is  immediately  preceded  by   an   underscore
           indicating  that  its case is to be retained, is not applied to any
           letter which is immediately preceded  by  a  circumflex  indicating
           that  it  is  to  be converted to upper case, and is not applied to
           letters which are both within the  range  of  a  .FLAGS  CAPITALIZE
           command  and  within  a  word which is preceded by a less than sign
           indicating that these letters are to be converted  to  upper  case.
           The  .LOWER  CASE  command  is  equivalent  to  the appearance of 2
           consecutive back slashes except that the 2 back slashes can  appear
           anywhere and that the lower case conversion indicated by the 2 back
           slashes is applied immediately to all of the following  text.   The
           cases  of  alphabetic  letters  are retained unless the .LOWER CASE
           command has been issued or unless 2 consecutive back  slashes  have
           been  found.   The retention of cases can also be reselected either
           by the .UPPER CASE command or by the appearance  of  2  consecutive
           circumflexes.   Neither the .LOWER CASE command nor the .UPPER CASE
           command implies a .BREAK command.

           For example, the source text

           .nofill.output width 55.preface       WRITE(1,$)
           .noflags.flags capitalize;noflags
             UPPER lower U^P\P_ER l^o\w_er
             U<PPER l<ower U<PPE<R l<owe<r <U^P\P_ER <l^o\w_er
           .lower case.flags;lower case
             UPPER lower U^P\P_ER l^o\w_er
             U<PPER l<ower U<PPE<R l<owe<r <U^P\P_ER <l^o\w_er
           .upper case;upper case
             UPPER lower U^P\P_ER l^o\w_er
             U<PPER l<ower U<PPE<R l<owe<r <U^P\P_ER <l^o\w_er
           .program;      END

           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

                 WRITE(1,1)
               1 FORMAT(8H noflags/3X,24HUPPER lower U^P\P_ER l^o,
                15H\w_er/3X,34HU<PPER l<ower U<PPE<R l<owe<r <U^P,
                215H\P_ER <l^o\w_er/11H lower case/3X,9Hupper low,
                314Her uPpEr lOwer/3X,24HuPPER lOWER uPPEr lOWEr ,
                411HUPpER LOweR/11H upper case/3X,12HUPPER lower ,
                511HUPpER lOwer/3X,27HUPPER lOWER UPPER lOWEr UPp,
                68HER LOweR)
                 END58                                           FORMAT Program User's Guide


     which would, in turn, generate the following text when run.

      noflags
        UPPER lower U^P\P_ER l^o\w_er
        U<PPER l<ower U<PPE<R l<owe<r <U^P\P_ER <l^o\w_er
      lower case
        upper lower uPpEr lOwer
        uPPER lOWER uPPEr lOWEr UPpER LOweR
      upper case
        UPPER lower UPpER lOwer
        UPPER lOWER UPPER lOWEr UPpER LOweR


.MASK text to be superimposed onto each output line

     The printing characters which follow the .MASK command on the  same
     line  replace  the  nonquoted  spaces  to  the right of the initial
     offset in each line of text which is copied  in  no  fill  mode  or
     which  is  constructed  in fill mode.  All printing characters, all
     spaces which were preceded by underscores or which were represented
     by  number  signs,  and  all initial spaces requested by an .OFFSET
     command or by the default .OFFSET 1, are  left  unchanged  in  each
     line  of  text  which is represented in the FORMAT statements.  The
     character to the immediate right of the .MASK  command  must  be  a
     space.   The  group  of characters which is to be superimposed onto
     each output line starts with the second character to the  right  of
     the .MASK command, whether or not this is a printing character, and
     extends through the rightmost printing character on the  line.   No
     characters  are  superimposed  onto  the  output lines if the .MASK
     command is issued without any following characters, or if no  .MASK
     command  has  yet  been  issued,  or if a .NO MASK command has been
     issued more recently than a .MASK command.  A .MASK command  issued
     within  the  range of a .PROGRAM command applies to the source text
     following the next .TEXT or .CONTINUE command.  Neither  the  .MASK
     command  nor  the  .NO  MASK  command  implies a .BREAK command.  A
     .BREAK or .EJECT command should be issued before the .MASK  or  .NO
     MASK  command  unless  it  is really desired to change the template
     line which is to be applied to the line which  is  currently  being
     accumulated  in  fill mode or to the blank lines which have not yet
     been written out to the FORMAT statements.

     Within the text specified  by  the  .MASK  command,  an  underscore
     character,  which will not be copied into the FORMAT statement, can
     appear before any character, such as  a  number  sign,  circumflex,
     back  slash, less than sign (if in flag capitalize mode) or another
     underscore, which is to be treated as  a  nonflag  character.   The
     .MASK  command  cannot  be  followed  on  the same line either by a
     comment or by another command, so semicolons and exclamation points
     in  the  text  to  be  superimposed  do  not need to be preceded by
     underscores.      Complete Descriptions of the Commands                                 59


           For example, the source text

           .left margin 2.right margin 13.preface       WRITE(1,$)
           .carriage 1.offset 5.copy 17,2.mask *             *
           .indent -1.output width 55;=============
           .insert 3Hhow
           .insert 5H.MASK
           .insert 3Hand
           .insert 5H.COPY
           .skip;This shows $$$ $$$$$ $$$ $$$$$ commands work.
           .skip.indent -1;=============
           .break.no mask.no copy.skip;Not in range of either.
           .program;      END

           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

                 WRITE(1,1)
               1 FORMAT(38H1    *=============*  *=============* ,
                116H *=============*/5X,1H*,13X,4H*  *,13X,4H*  *,
                213X,1H*/5X,34H* This  shows *  * This  shows *  ,
                315H* This  shows */5X,2H* ,3Hhow,3X,5H.MASK,2H *,
                44H  * ,3Hhow,3X,5H.MASK,6H *  * ,3Hhow,3X,
                55H.MASK,2H */5X,2H* ,3Hand,3X,5H.COPY,6H *  * ,
                63Hand,3X,5H.COPY,6H *  * ,3Hand,3X,5H.COPY,2H */
                75X,42H* commands    *  * commands    *  * comman,
                87Hds    */5X,7H* work.,7X,10H*  * work.,7X,3H*  ,
                97H* work.,7X,1H*/5X,1H*,13X,4H*  *,13X,4H*  *,9X,
                14X,1H*/5X,35H*=============*  *=============*  *,
                214H=============*//7X,3HNot,6X,2Hin/7X,7Hrange  ,
                34H  of/7X,7Heither.)
                 END

           which would, in turn, generate the following text when run.

           1    *=============*  *=============*  *=============*
                *             *  *             *  *             *
                * This  shows *  * This  shows *  * This  shows *
                * how   .MASK *  * how   .MASK *  * how   .MASK *
                * and   .COPY *  * and   .COPY *  * and   .COPY *
                * commands    *  * commands    *  * commands    *
                * work.       *  * work.       *  * work.       *
                *             *  *             *  *             *
                *=============*  *=============*  *=============*

                  Not      in
                  range    of
                  either.


      .NO CARRIAGE

           The first character in each line of text which  is  generated  when
           the  resulting FORMAT statements are used can be interpreted by the
           FORTRAN operating system to  select  the  carriage  motion  on  the
           output  device  to  which  the  text  is written.  The .NO CARRIAGE
           command indicates that the leftmost character in the line  of  text60                                           FORMAT Program User's Guide


     which  is  currently  being  constructed  for representation in the
     FORMAT statements, and in each of the  subsequent  lines  of  text,
     will  be  a  space  if  a  positive offset has been selected by the
     combination of .OFFSET, .LEFT  MARGIN  and  .INDENT  or  .PARAGRAPH
     commands,  and  completely  blank  lines will be represented in the
     FORMAT statements by consecutive slashes.  The .NO CARRIAGE command
     terminates the insertion of the carriage control character, if any,
     selected by the previous .CARRIAGE command.   No  carriage  control
     character is in effect when this program is first started.  Neither
     the .NO CARRIAGE command nor the .CARRIAGE command implies a .BREAK
     command.   A  .BREAK command, or some other command which implies a
     .BREAK command, should usually be issued before  the  .NO  CARRIAGE
     command  since,  if the lines of text are being constructed in fill
     mode, the carriage control character is applied to the current line
     of text only after this line of text has otherwise been completed.

     For example, the source text

     .carriage 1,*.right margin 54.output width 55
     .preface       WRITE(1,$)
     The .NO CARRIAGE command terminates the generation of
     the carriage control character specified by the
     previous .CARRIAGE command.
     .break.no carriage
     The .NO CARRIAGE command terminates the generation of
     the carriage control character specified by the
     previous .CARRIAGE command.
     .program;      END

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(1,1)
         1 FORMAT(38H1The .NO CARRIAGE command terminates t,
          117Hhe generation  of/24H*the   carriage  control,
          231H  character  specified  by  the/10H*previous ,
          318H.CARRIAGE command./23H The .NO CARRIAGE comma,
          432Hnd terminates the generation  of/9H the   ca,
          545Hrriage  control  character  specified  by  th,
          61He/28H previous .CARRIAGE command.)
           END

     which would, in turn, generate the following text when run.

     1The .NO CARRIAGE command terminates the generation  of
     *the   carriage  control  character  specified  by  the
     *previous .CARRIAGE command.
      The .NO CARRIAGE command terminates the generation  of
      the   carriage  control  character  specified  by  the
      previous .CARRIAGE command.      Complete Descriptions of the Commands                                 61


      .NO COPY

           The .NO COPY command indicates  that  the  text  specified  by  the
           source  file is to be represented only once in the resulting FORMAT
           statements instead of being duplicated to form 2 or  more  parallel
           columns containing the same text.  A .NO COPY command issued within
           the range of a .COPY  command  terminates  the  production  of  the
           parallel columns selected by the .COPY command.  A .NO COPY command
           issued within the range of a .PROGRAM command applies to the source
           text following the next .TEXT or .CONTINUE command.  Both the .COPY
           command and the .NO COPY command imply a .BREAK command.

           For example, the source text

           .right margin 20.copy 25,1.carriage 1,*.offset 3
           .output width 55.preface       WRITE(1,$)
           The .NO COPY command terminates the range of the
           previous .COPY command.
           .no copy
           Both the .COPY command and the .NO COPY command imply
           a .BREAK command
           .program;      END

           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

                 WRITE(1,1)
               1 FORMAT(38H1  The .NO COPY command     The .NO CO,
                110HPY command/31H*  terminates the range     ter,
                217Hminates the range/24H*  of   the    previous ,
                34X,20Hof   the    previous/17H*  .COPY command.,
                411X,14H.COPY command./23H*  Both    the    .COPY/
                523H*  command  and the .NO/18H*  COPY command im,
                65Hply a/17H*  .BREAK command)
                 END

           which would, in turn, generate the following text when run.

           1  The .NO COPY command     The .NO COPY command
           *  terminates the range     terminates the range
           *  of   the    previous     of   the    previous
           *  .COPY command.           .COPY command.
           *  Both    the    .COPY
           *  command  and the .NO
           *  COPY command imply a
           *  .BREAK command


      .NO FILL

           The .NO FILL command indicates that each line of source text  which
           is  not  within  the range of a .PROGRAM command and which does not
           begin with a period is to be shifted to the right by the number  of
           spaces which has been selected by the combination of .OFFSET, .LEFT
           MARGIN and .INDENT or  .PARAGRAPH  commands,  and  is  then  to  be
           represented  in the FORMAT statements with the same number of words
           per line and with the same number of spaces, in addition  to  those62                                           FORMAT Program User's Guide


     inserted  at  the left, as in the source text.  The right margin is
     ignored.  The .NO FILL command terminates the range of the previous
     .FILL  command  which  would  have  caused  each line of text to be
     filled with as many words as will fit on the line when separated by
     at least single spaces.  A .FILL command is assumed to be in effect
     when this program is started.  A .NO FILL command issued within the
     range  of  a  .PROGRAM command applies to the source text following
     the next .TEXT or .CONTINUE statement.  A .JUSTIFY, .NO JUSTIFY  or
     .RIGHT MARGIN command issued within the range of a .NO FILL command
     applies to the source text following the next .FILL command.   Both
     the .NO FILL command and the .FILL command imply a .BREAK command.

     For example, the source text

     .output width 55.right margin 55.offset 0
     .nofill.preface       WRITE(1,$)
       The .NO FILL        command is       not   equivalent
       to  the combination of      a        .FILL command
       and a   .NO         JUSTIFY command.
     .fill
       The .NO FILL        command is       not   equivalent
       to  the combination of      a        .FILL command
       and a   .NO         JUSTIFY command.
     .no   justify
       The .NO FILL        command is       not   equivalent
       to  the combination of      a        .FILL command
       and a   .NO         JUSTIFY command.
     .program;      END

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(1,1)
         1 FORMAT(14H  The .NO FILL,8X,10Hcommand is,7X,1Hn,
          115Hot   equivalent/24H  to  the combination of,
          26X,1Ha,8X,13H.FILL command/13H  and a   .NO,9X,
          316HJUSTIFY command./25HThe  .NO  FILL  command  ,
          430His  not  equivalent   to   the/11Hcombination,
          544H  of  a  .FILL  command  and  a  .NO JUSTIFY/
          68Hcommand./34HThe .NO FILL command is not equiva,
          711Hlent to the/30Hcombination of a .FILL command,
          818H and a .NO JUSTIFY/8Hcommand.)
           END      Complete Descriptions of the Commands                                 63


           which would, in turn, generate the following text when run.

             The .NO FILL        command is       not   equivalent
             to  the combination of      a        .FILL command
             and a   .NO         JUSTIFY command.
           The  .NO  FILL  command  is  not  equivalent   to   the
           combination  of  a  .FILL  command  and  a  .NO JUSTIFY
           command.
           The .NO FILL command is not equivalent to the
           combination of a .FILL command and a .NO JUSTIFY
           command.
           command.
           The .NO FILL command is not equivalent to the
           combination of a .FILL command and a .NO JUSTIFY
           command.


      .NO FLAGS
           or
      .NO FLAGS ALL

           The .NO FLAGS ALL command indicates that the flag characters  which
           are  listed  below  are  to  be inactive in the source test.  Every
           appearance of these flag characters is to be left unchanged and  is
           to  be  treated  like  the appearance of any other nonflag printing
           character.

             $  (dollar sign) or whatever character  has  been  most  recently
                selected by a .FLAGS INSERT command.
             \  (back slash) or whatever  character  has  been  most  recently
                selected by a .FLAGS LOWER CASE command.
             _  (underscore) or whatever  character  has  been  most  recently
                selected by a .FLAGS QUOTE command.
             #  (number sign) or whatever character  has  been  most  recently
                selected by a .FLAGS SPACE command.
             ^  (circumflex) or whatever  character  has  been  most  recently
                selected by a .FLAGS UPPER CASE command.
             <  (less than sign) or whatever character has been most  recently
                selected  by a .FLAGS CAPITALIZE command.  This flag character
                is initially inactive and will remain inactive unless a .FLAGS
                CAPITALIZE command is issued.

           All flag characters which were initially active, or which have been
           individually  activated  by  the corresponding .FLAGS commands, and
           which have not been individually deactivated by  the  corresponding
           .NO  FLAGS commands, will be reactivated if a subsequent .FLAGS ALL
           command is issued.  The .FLAGS ALL command and the  .NO  FLAGS  ALL
           command  do  not  change  the interpretation of the flag characters
           which identify and terminate commands.  The flag  characters  which
           are  to  be interpreted and acted upon in a preface line defined by
           the .PREFACE command or in a field  specification  defined  by  the
           .INSERT  command  must  be  those which are active when the preface
           line or the field specification is defined, regardless of what flag
           characters  happen  to be active when the preface line or the field
           specification is used.  Neither the .FLAGS ALL command nor the  .NO
           FLAGS ALL command implies a .BREAK command.64                                           FORMAT Program User's Guide


.NO FLAGS CAPITALIZE

     Every appearance of the less than sign, or  of  whatever  character
     has  been most recently selected by a .FLAGS CAPITALIZE command, is
     to be left unchanged and is to be treated like  the  appearance  of
     any  other character.  No flag character is to be available to mark
     words  in  which  every  letter  is   to   be   capitalized.    The
     capitalization  flag  character  can be reactivated by a subsequent
     .FLAGS CAPITALIZE command.  No  capitalization  flag  character  is
     active when this program is started.


.NO FLAGS CONTROL

     The source text contains no additional commands.  Lines which start
     with  periods,  or  with  whatever character has been most recently
     selected by a .FLAGS CONTROL command, are not to be interpreted  as
     commands.  This command probably should not be issued.


.NO FLAGS FENCE

     Every appearance in a command line of the semicolon, or of whatever
     character  has  been  most  recently  selected  by  a  .FLAGS FENCE
     command, is to be treated as a part of the argument list or comment
     in  which  it  appears.  No flag character is available which, when
     used in a command line, causes the text to the right  of  the  flag
     character  to  be treated as though this text were on the following
     line.  The separation  flag  character  can  be  reactivated  by  a
     subsequent .FLAGS FENCE command.


.NO FLAGS INSERT

     Every appearance of the dollar sign, or of whatever  character  has
     been  most  recently  selected by a .FLAGS INSERT command, is to be
     left unchanged and is to be treated  like  the  appearance  of  any
     other  character.  No flag character is available to mark locations
     in preface lines and in program text at which the statement numbers
     of  the  next  FORMAT  statements  are  to  be  inserted.   No flag
     character  is  available  to  mark  locations  in  the  text  being
     represented   in   the   FORMAT   statements  at  which  the  field
     specifications defined by the .INSERT command are to  be  inserted.
     The  insertion  flag  character  can be reactivated by a subsequent
     .FLAGS INSERT command.


.NO FLAGS LOWER CASE

     Every appearance of the back slash, or of  whatever  character  has
     been  most  recently selected by a .FLAGS LOWER CASE command, is to
     be left unchanged and is to be treated like the appearance  of  any
     other character.  No flag character is available to mark individual
     alphabetic letters which are to be converted to  their  lower  case
     forms.   The  lower  case  shift  character can be reactivated by a
     subsequent .FLAGS LOWER CASE command.      Complete Descriptions of the Commands                                 65


      .NO FLAGS QUOTE

           Every appearance of the underscore, or of  whatever  character  has
           been  most  recently  selected  by a .FLAGS QUOTE command, is to be
           left unchanged and is to be treated  like  the  appearance  of  any
           other  character.  No flag character is available which can precede
           other characters which  are  to  be  treated  as  nonflag  printing
           characters.   The  quotation flag character can be reactivated by a
           subsequent .FLAGS QUOTE command.


      .NO FLAGS REMARK

           Every appearance in a command line of the exclamation point, or  of
           whatever  character  has  been  most  recently selected by a .FLAGS
           REMARK command, is to be treated as a part of the argument list  in
           which it appears.  No flag character is available which can be used
           in command lines to indicate that the following text,  through  the
           end  of  the  line or through the next appearance of a semicolon on
           the same line, is to be treated as a comment and is to be  ignored.
           The remark flag character can be reactivated by a subsequent .FLAGS
           REMARK command.


      .NO FLAGS SPACE

           Every appearance of the number sign, or of whatever  character  has
           been  most  recently  selected  by a .FLAGS SPACE command, is to be
           left unchanged and is to be treated  like  the  appearance  of  any
           other  character.  No flag character is available which can be used
           to indicate the location of a space  which  is  to  be  treated  as
           though  it were a printing character.  However, a space preceded by
           an underscore can still  be  used  for  this  purpose.   The  space
           holding  character  can be reactivated by a subsequent .FLAGS SPACE
           command.


      .NO FLAGS UPPER CASE

           Every appearance of the circumflex, or of  whatever  character  has
           been  most  recently selected by a .FLAGS UPPER case command, is to
           be left unchanged and is to be treated like the appearance  of  any
           other character.  No flag character is available to mark individual
           alphabetic letters which are to be converted to  their  upper  case
           forms.   The  upper  case  shift  character can be reactivated by a
           subsequent .FLAGS UPPER CASE command.


      .NO GROUP
           The .NO GROUP command indicates that the  FORTRAN  text  which  was
           specified  by  a previous .GROUP or .DEFINE GROUP command is not to
           be generated before the first FORMAT statement produced after  each
           .TEXT  command.   A  .RESUME  GROUP command can, however, be issued
           later to resume the insertion of the same FORTRAN text before  each
           new  group of FORMAT statements.  Neither the .NO GROUP command nor
           the .GROUP command nor the .DEFINE GROUP command implies  either  a
           .BREAK or a .CONTINUE command.66                                           FORMAT Program User's Guide


     The .NO GROUP command is not equivalent to a .GROUP command  issued
     without  any  text to its right, since the latter would discard the
     FORTRAN text which previously was inserted before each new group of
     FORMAT  statements.   After the .NO GROUP command been issued, this
     FORTRAN text still occupies the  storage  reserved  for  the  lines
     which  can also be defined by the .PREFACE or .DEFINE PREFACE, .TOP
     or .DEFINE TOP, and .BOTTOM  or  .DEFINE  BOTTOM  commands.   These
     commands  can  define  a  total of no more than 30 lines containing
     together no more than 500 characters.

     The FORTRAN text specified by the .GROUP  command  or  the  .DEFINE
     GROUP command is not generated until enough lines of text have been
     constructed to fill the first line of the first  FORMAT  statement.
     If  a  .NO GROUP command is issued before enough lines of text have
     been constructed to completely fill the first  line  of  the  first
     FORMAT  statement, then the FORTRAN text will not be generated even
     if this FORTRAN text was active  during  the  construction  of  the
     first  line  of  text which is represented in the FORMAT statement.
     Consequently, it is better to issue a .GROUP,  .DEFINE  GROUP,  .NO
     GROUP,  or  .RESUME  GROUP  command  after  the .TEXT, .CONTINUE or
     .PROGRAM command which terminates the  previous  FORMAT  statement,
     rather than before.

     For example, the source text

     .group       GO TO 1000
     .preface $$$$$ WRITE(1,$=$)
     This is the first line
     .text
     This is the second line
     .text.no group
     This is the third line

     would be transformed into the following FORTRAN text when processed
     by this program.

           GO TO 1000
         1 WRITE(1,2)
         2 FORMAT(23H This is the first line)
           GO TO 1000
         3 WRITE(1,4)
         4 FORMAT(24H This is the second line)
         5 WRITE(1,6)
         6 FORMAT(23H This is the third line)


.NO INSERT

     The .NO INSERT command indicates  that  all  groups  of  characters
     which have been specified by the .INSERT command since this program
     was started, or since the last .NO  INSERT  or  .TEXT  command  was
     issued,  and which have not yet been used, are to be discarded.  If
     a group of contiguous dollar signs is encountered in the text which
     is  being  represented in the FORMAT statements before a subsequent
     .INSERT command is issued, then the group of dollar signs  will  be
     removed  but  nothing  will  be  inserted  into its place.  The .NO
     INSERT command  is  usually  not  necessary  since  the  groups  of      Complete Descriptions of the Commands                                 67


           characters  which  are  defined  by  the .INSERT command are always
           discarded after use anyway.

           Neither the .NO INSERT command nor the .INSERT  command  implies  a
           .BREAK  command.   Insertions  into  lines  of text which are being
           constructed in fill mode are made after the line has otherwise been
           completed,  either when a command which implies a .BREAK command is
           encountered or when the first word which would overflow the line is
           encountered.   If  the .NO INSERT command is issued before the line
           has been completed, then  any  groups  of  characters  which  would
           otherwise  have  been available for insertion into the line will be
           discarded instead.

           For example, the source text

           .output width 55
           .insert 7Hcommand
           .insert 6Hgroups
           .insert 3Hthe
           The .NO INSERT $$$$$$$ discards $$$$$$ of characters
           which were defined by $$$ .INSERT command, but which
           .no insert
           remain unused.

           would be transformed into the following FORTRAN text when processed
           by this program.

               1 FORMAT(16H The .NO INSERT ,7Hcommand,9H discards,
                11H ,6Hgroups,22H of  characters  which/7H were  ,
                213Hdefined  by  ,28H  .INSERT  command,  but  wh,
                310Hich remain/8H unused.)

           In the FORMAT statement shown above, merely a comma  appears  where
           the  word  3Hthe would have been inserted if the .NO INSERT command
           had not been issued.


      .NO JUSTIFY

           The .NO JUSTIFY command indicates that  lines  of  text  which  are
           constructed  in fill mode are to have only one space between a pair
           of words and two spaces between any of the punctuation marks colon,
           semicolon,  exclamation  point,  question  mark  and period and the
           following word.  If merely a single space is required  between  one
           of  these  punctuation  marks  and  the  following  word,  then the
           punctuation mark must be preceded by an underscore.  The  lines  of
           text  are not extended to the right margin by the addition of extra
           spaces between the words.  The .NO JUSTIFY command  terminates  the
           range  of the previous .JUSTIFY command.  A .JUSTIFY command, which
           causes the lines of text which are constructed in fill mode  to  be
           extended  to the right margin, is assumed to be in effect when this
           program is started.  A .NO JUSTIFY or  a  .JUSTIFY  command  issued
           within  the  range  of  a  .PROGRAM  command  applies  to  the text
           following the next .TEXT or .CONTINUE command.  A .NO JUSTIFY or  a
           .JUSTIFY  command  issued  within  the  range of a .NO FILL command
           applies to the lines of text constructed following the  next  .FILL
           command.   Both  the  .NO  JUSTIFY command and the .JUSTIFY command68                                           FORMAT Program User's Guide


     imply a .BREAK command.

     For example, the source text

     .no justify.output width 55.right margin 55
     .offset 0.preface       WRITE(1,$)
     Lines    of    text   which     are    constructed
        in  fill   mode,     but without justification,
      have   the   words wrapped  around          until
       the  next    word   would  extend         beyond
       the right margin,     but     the          lines
       are   not      of uniform length.
     .program;      END

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(1,1)
         1 FORMAT(38HLines of text which are constructed in,
          115H fill mode, but/26Hwithout justification, hav,
          226He the words wrapped around/15Huntil the next ,
          334Hword would extend beyond the right/8Hmargin, ,
          440Hbut the lines are not of uniform length.)
           END

     which would, in turn, generate the following text when run.

     Lines of text which are constructed in fill mode, but
     without justification, have the words wrapped around
     until the next word would extend beyond the right
     margin, but the lines are not of uniform length.


.NO LEADING

     The .NO LEADING command indicates that blank lines requested  by  a
     .BLANK  or a .SKIP command are to be discarded if no other text has
     been represented in the FORMAT statements since  this  program  was
     started or since a .TEXT command was issued.  A .NO LEADING command
     is assumed to be in effect when this program is  started.   Initial
     blank  lines  are  represented only if a .LEADING command is issued
     before the blank lines are  requested.   Neither  the  .NO  LEADING
     command nor the .LEADING command implies a .BREAK command.

     For example, the source text

     .leading.skip.output width 55
     Leading blank lines requested by .SKIP commands are
     generated within the range of a .LEADING command
     .text.skip
     Leading blank lines requested by .SKIP commands are
     generated within the range of a .LEADING command
     .text.no leading.skip
     Leading blank lines requested by .SKIP commands are
     discarded within the range of a .NO LEADING command      Complete Descriptions of the Commands                                 69


           would be transformed into the following FORTRAN text when processed
           by this program.

               1 FORMAT(/37H Leading  blank  lines  requested  by,
                124H  .SKIP   commands   are/17H generated within,
                232H the range of a .LEADING command)
               2 FORMAT(/37H Leading  blank  lines  requested  by,
                124H  .SKIP   commands   are/17H generated within,
                232H the range of a .LEADING command)
               3 FORMAT(38H Leading  blank  lines  requested  by ,
                123H .SKIP   commands   are/18H discarded within ,
                234Hthe range of a .NO LEADING command)


      .NO MASK

           The .NO MASK command indicates that the template line specified  by
           a  previous .MASK command is no longer to be superimposed onto each
           line  of  text  which  is  represented  in  the  resulting   FORMAT
           statements.   The .NO MASK command is equivalent to a .MASK command
           issued without any text to  its  right.   A  .NO  MASK  command  is
           assumed  to be in effect when this program is started.  Neither the
           .NO MASK command nor the .MASK command implies a .BREAK command.  A
           .BREAK  or  .EJECT  command should be issued before the .NO MASK or
           .MASK command unless it is really desired to  change  the  template
           line  which  is  to be applied to the line which is currently being
           accumulated in fill mode or to the blank lines which have  not  yet
           been written out to the FORMAT statements.

           For example, the source text

           .output width 55.preface       WRITE(1,$)
           .left margin 5.right margin 45.carriage 1,*
           .mask  @                                              @
           The .NO MASK command terminates the range of the
           previous .MASK command.
           .mask  %                                              %
           The .NO MASK command has no effect if a .MASK command
           has not been issued.
           .nomask.program;      END

           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

                 WRITE(1,1)
               1 FORMAT(38H1 @   The  .NO  MASK  command  termina,
                112Htes  the   @/29H* %   range  of  the  previou,
                221Hs  .MASK command.   %/20H* %   The .NO MASK c,
                330Hommand has no effect if  a   %/11H*     .MASK,
                429H command has not been issued.)
                 END70                                           FORMAT Program User's Guide


     which would, in turn, generate the following text when run.

     1 @   The  .NO  MASK  command  terminates  the   @
     * %   range  of  the  previous  .MASK command.   %
     * %   The .NO MASK command has no effect if  a   %
     *     .MASK command has not been issued.


.NO OFFSET

     The .NO OFFSET command indicates that each line of  text  which  is
     represented  in  the FORMAT statements is not to be shifted further
     to the right than is indicated by  the  combination  of  the  .LEFT
     MARGIN  and .INDENT or .PARAGRAPH commands.  The .NO OFFSET command
     is equivalent to an .OFFSET 0 command.  An  .OFFSET  1  command  is
     assumed to be in effect when this program is started.  Both the .NO
     OFFSET and .OFFSET commands imply a .BREAK command.

     For example, the source text

     .offset 1.indent 5.right margin 50.output width 55
     .preface       WRITE(1,$)
     The default .OFFSET 1 command provides an empty column
     for the carriage control character.
     .no offset.indent 5;The .NO OFFSET command prevents the
     generation of this empty column.
     .program;      END

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(1,1)
         1 FORMAT(6X,35HThe default .OFFSET  1  command  pr,
          110Hovides  an/31H empty column for the carriage ,
          218Hcontrol character./5X,20HThe   .NO   OFFSET  ,
          325H command   prevents   the/16Hgeneration of th,
          416His empty column.)
           END

     which would, in turn, generate the following text when run.

           The default .OFFSET  1  command  provides  an
      empty column for the carriage control character.
          The   .NO   OFFSET   command   prevents   the
     generation of this empty column.


.NO PREFACE

     The .NO PREFACE command indicates that the FORTRAN  text  specified
     by a previous .PREFACE command or .DEFINE PREFACE command is not to
     be generated before each of the next FORMAT statements.  A  .RESUME
     PREFACE  command  can,  however  be  issued  later  to  resume  the
     insertion  of  the  same  FORTRAN  text  before  each  new   FORMAT
     statement.   Neither  the  .NO  PREFACE  command  nor  the .PREFACE
     command nor the .DEFINE PREFACE command implies either a .BREAK  or
     a .CONTINUE command.      Complete Descriptions of the Commands                                 71


           The .NO PREFACE command is not equivalent  to  a  .PREFACE  command
           issued  without  any  text  to  its  right,  since the latter would
           discard the FORTRAN text which previously was inserted before  each
           FORMAT  statement.  After the .NO PREFACE command been issued, this
           FORTRAN text still occupies the  storage  reserved  for  the  lines
           which  can  also be defined by the .GROUP or .DEFINE GROUP, .TOP or
           .DEFINE  TOP,  and  .BOTTOM  or  .DEFINE  BOTTOM  commands.   These
           commands  can  define  a  total of no more than 30 lines containing
           together no more than 500 characters.

           The FORTRAN text specified by the .PREFACE command or  the  .DEFINE
           PREFACE  command  is  not generated until enough lines of text have
           been constructed  to  fill  the  first  line  of  the  next  FORMAT
           statement.   If a .NO PREFACE command is issued before enough lines
           of text have been constructed to completely fill the first line  of
           the  next  FORMAT  statement,  then  the  FORTRAN  text will not be
           generated  even  if  this  FORTRAN  text  was  active  during   the
           construction  of the first line of text which is represented in the
           FORMAT statement.  Consequently, it is better to issue a  .PREFACE,
           .DEFINE  PREFACE, .NO PREFACE, or .RESUME PREFACE command after the
           .TEXT, .CONTINUE or .PROGRAM command which terminates the  previous
           FORMAT statement, rather than before.

           For example, the source text

           .preface       WRITE(1,$)
           This is the first line
           .continue
           This is the second line
           .continue.no preface
           This is the third line

           would be transformed into the following FORTRAN text when processed
           by this program.

                 WRITE(1,1)
               1 FORMAT(23H This is the first line)
                 WRITE(1,2)
               2 FORMAT(24H This is the second line)
               3 FORMAT(23H This is the third line)


      .NO TRAILING

           The .NO TRAILING command indicates that the FORMAT  statements  are
           not  to include trailing blank lines resulting from .SKIP or .BLANK
           commands issued after all other text has been  represented  in  the
           FORMAT statements and are not to include the blank lines implied by
           multiple spacing after the final line of text  represented  in  the
           FORMAT  statements.   A  .NO  TRAILING  command is assumed to be in
           effect  when  this  program  is  first  started.   If,  instead,  a
           .TRAILING command has been issued more recently than a .NO TRAILING
           command, then each .TEXT command and the reading of the end of  the
           file  (or  the issuing of an .END OF FILE command) generates all of
           the blank lines which have been requested or  which  are  necessary
           for  multiple  line  spacing  following  the  final  line  of  text
           represented in the FORMAT statements.   Neither  the  .NO  TRAILING72                                           FORMAT Program User's Guide


     command nor the .TRAILING command implies a .BREAK command.

     For example, the source text

     .no trailing.spacing 1
     This is the first line
     .skip.text.spacing 2
     This is the second line
     .text.trailing.spacing 1
     This is the third line
     .skip.text.spacing 2
     This is the fourth line

     would be transformed into the following FORTRAN text when processed
     by this program.

         1 FORMAT(23H This is the first line)
         2 FORMAT(24H This is the second line)
         3 FORMAT(23H This is the third line/)
         4 FORMAT(24H This is the fourth line/)


.OFFSET number of spaces to be inserted at left edge of text

     The .OFFSET command indicates that  each  line  of  text  which  is
     represented  in the FORMAT statements is to be shifted to the right
     by the insertion of the indicated number of  extra  spaces  at  the
     left.  If the number which follows the .OFFSET command is unsigned,
     then this number will be used as the number of extra  spaces  which
     are  to be inserted at the left end of each line in addition to the
     spaces specified by the combination of .LEFT MARGIN and .INDENT  or
     .PARAGRAPH  commands.   If  the  number  which  follows the .OFFSET
     command is signed, then the previous  offset  is  adjusted  by  the
     indicated   amount.    The  carriage  control  character,  if  any,
     specified by the .CARRIAGE command will be  superimposed  upon  the
     leftmost  of  the  spaces  in  the  offset specified by the .OFFSET
     command.  A template line specified by a  .MASK  command  would  be
     applied  to  the  text to the right of the offset.  A .COPY command
     would duplicate the characters to the right  of  the  offset  after
     application  of  the  template line, if any.  An offset of 1 column
     which provides a space as the carriage control  character  on  each
     line  is  assumed to be in effect when this program is started.  No
     initial spaces other than those specified  by  the  combination  of
     .LEFT  MARGIN and .INDENT or .PARAGRAPH commands are inserted if an
     .OFFSET 0 command or the equivalent .NO OFFSET command  is  issued.
     The .OFFSET and .NO OFFSET commands both imply a .BREAK command.      Complete Descriptions of the Commands                                 73


           For example, the source text

           .left margin 5.right margin 44.output width 55
           .preface       WRITE(1,$)
           .mask @                                               @
           .offset 1.indent 5.carriage 1,*
           The offset specified by the .OFFSET command is in
           addition to that specified by the .LEFT MARGIN
           and .INDENT or .PARAGRAPH commands.
           .offset 6.indent 5.carriage 1,*
           The offset specified by the .OFFSET command is in
           addition to that specified by the .LEFT MARGIN
           and .INDENT or .PARAGRAPH commands.
           .program;      END

           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

                 WRITE(1,1)
               1 FORMAT(2H1@,9X,30HThe  offset   specified   by  ,
                19H the    @/33H*@    .OFFSET  command is in addi,
                217Htion to that    @/24H*@    specified  by  the,
                326H  .LEFT  MARGIN   and    @/15H*@    .INDENT o,
                422Hr .PARAGRAPH commands.,12X,1H@/7H1     @,9X,
                539HThe  offset   specified   by   the    @/3H*  ,
                63X,42H@    .OFFSET  command is in addition to th,
                77Hat    @/35H*     @    specified  by  the  .LEF,
                820HT  MARGIN   and    @/21H*     @    .INDENT or,
                921H .PARAGRAPH commands.,12X,1H@)
                 END

           which would, in turn, generate the following text when run.

           1@         The  offset   specified   by   the    @
           *@    .OFFSET  command is in addition to that    @
           *@    specified  by  the  .LEFT  MARGIN   and    @
           *@    .INDENT or .PARAGRAPH commands.            @
           1     @         The  offset   specified   by   the    @
           *     @    .OFFSET  command is in addition to that    @
           *     @    specified  by  the  .LEFT  MARGIN   and    @
           *     @    .INDENT or .PARAGRAPH commands.            @


      .OUTPUT LENGTH maximum number of lines in a FORMAT statement

           The .OUTPUT LENGTH command specifies the maximum number of  FORTRAN
           language lines from which each FORMAT statement can be constructed.
           The number of lines set by the .OUTPUT LENGTH command should not be
           greater  than  the maximum number of lines accepted by the compiler
           which will be used to  process  the  resulting  FORMAT  statements.
           .OUTPUT  LENGTH 20 is the default, but this program does not impose
           any upper limit upon this maximum.  The combination of the  .OUTPUT
           LENGTH command and the .OUTPUT WIDTH command set the maximum number
           of characters in a single FORMAT statement, but  do  not  otherwise
           restrict  the  maximum  number  of  lines  of  text  which  can  be
           represented in each FORMAT statement.  The .OUTPUT LENGTH  command,
           like  most other commands which merely describe the manner in which74                                           FORMAT Program User's Guide


     the text is represented in the FORMAT statements, does not imply  a
     .BREAK command.

     For example, the source text

     .offset 0.output width 55.output length 3
     .preface       WRITE(1,$)
     The FORMAT command indicates that no additional text
     is to be represented by the FORMAT statement currently
     being constructed and that the text appearing in
     subsequent lines in the source file is to be
     .output length 10
     represented in a new FORMAT statement. The preface
     line, if any, indicated by a previous PREFACE command
     will be written into the output before this next FORMAT
     .output length 3
     statement. All unused output field descriptions
     previously specified by INSERT commands will still be
     available.

     would be transformed into the following FORTRAN text when processed
     by this program.

           WRITE(1,1)
         1 FORMAT(38HThe FORMAT command indicates that no a,
          122Hdditional text  is  to/19Hbe  represented  by,
          241H  the  FORMAT  statement  currently being)
           WRITE(1,2)
         2 FORMAT(38Hconstructed and that the text appearin,
          122Hg in subsequent  lines/19Hin  the  source  fi,
          241Hle  is  to be represented in a new FORMAT/1Hs,
          345Htatement.   The  preface  line,  if  any,  in,
          414Hdicated  by  a/27Hprevious  PREFACE  command ,
          533H will  be written into the output)
           WRITE(1,3)
         3 FORMAT(38Hbefore this next FORMAT statement.  Al,
          122Hl unused output  field/19Hdescriptions  previ,
          241Hously  specified  by INSERT commands will)
           WRITE(1,4)
         4 FORMAT(19Hstill be available.)


.OUTPUT WIDTH most characters in each FORMAT statement line

     The  .OUTPUT  WIDTH  command  specifies  the  maximum   number   of
     characters  in  each  FORTRAN  language  line from which the FORMAT
     statements are constructed,  including  the  5  characters  in  the
     statement number field and the single character in the continuation
     field.  .OUTPUT WIDTH  72  is  the  greatest  width  which  can  be
     specified  and  is  the  default.   The  combination of the .OUTPUT
     LENGTH command and the .OUTPUT WIDTH command set the maximum number
     of  characters  in  a single FORMAT statement, but do not otherwise
     restrict  the  maximum  number  of  lines  of  text  which  can  be
     represented  in  each FORMAT statement.  The .OUTPUT WIDTH command,
     like most other commands which merely describe the manner in  which
     the  text is represented in the FORMAT statements, does not imply a
     .BREAK command.      Complete Descriptions of the Commands                                 75


           For example, the source text

           .output width 35
           The quick red fox jumps over the lazy brown dog,
           then runs into the forest.
           .output width 45
           The quick red fox jumps over the lazy brown dog,
           then runs into the forest.
           .output width 55

           would be transformed into the following FORTRAN text when processed
           by this program.

               1 FORMAT(18H The quick red fox,
                125H jumps over the lazy brow,
                218Hn dog,  then  runs/13H into  the  f,
                335Horest.   The  quick  red fox jumps ,
                413Hover the lazy/28H brown dog, then runs into t,
                510Hhe forest.)


      .PARAGRAPH columns to indent, multiple of line spacing
           or
      .PARAGRAPH columns to indent, -1 times number of blank lines

           The .PARAGRAPH command indicates that the next line of  text  which
           is  represented  in  the FORMAT statements is to be indented by the
           indicated number of spaces from the left  margin  which  is  effect
           when  the first word in the line is found.  The indicated number of
           initial spaces are added to the left margin  if  the  first  number
           following  the .PARAGRAPH command is greater than or equal to zero.
           The indicated number of spaces are deleted from the left margin  if
           the  first number which follows the .PARAGRAPH command is less than
           zero.  If the first number  following  the  .PARAGRAPH  command  is
           missing,  then the indentation specified by the previous .PARAGRAPH
           command will be applied or a positive indentation of 5  columns  is
           assumed  if  no  previous  .PARAGRAPH command has specified a first
           argument.

           If the second argument following the .PARAGRAPH command is  greater
           than  or  equal  to zero, then a number of blank lines equal to the
           specified multiple of the number which appeared to the right of the
           previous  .SPACING  command, or the specified number of blank lines
           directly if a .SPACING command has not yet been issued, are  to  be
           represented  in  the  FORMAT statement between the previous line of
           text and the next line of text, in  addition  to  any  blank  lines
           specified  by previous .BLANK or .SKIP commands, and, if a .SPACING
           command has been issued, in addition to a  number  of  blank  lines
           equal  to  one  less than the number which appeared to the right of
           the previous .SPACING command.  If the  second  argument  following
           the  .PARAGRAPH command is less than zero, then the number of extra
           blank lines is equal to the negative of the value specified by  the
           argument  rather  than  to  the  multiple  of  the number which was
           specified  by  the  .SPACING  command.   If  the  second   argument
           following  the  .PARAGRAPH  command  is  missing,  then  the second
           argument specified by  the  previous  .PARAGRAPH  command  will  be
           applied,  or  a second argument of -1 indicating 1 extra blank line76                                           FORMAT Program User's Guide


     in addition to the blank lines needed for the normal  line  spacing
     is assumed if no previous .PARAGRAPH command has specified a second
     argument.  If no text has been represented in the FORMAT statements
     either  since  the  start  of the source was read or since the last
     .TEXT command was issued, then the extra blank lines  specified  by
     the .PARAGRAPH command are not generated even if a .LEADING command
     is in effect.

     If the second argument following the .PARAGRAPH command is  greater
     than  zero,  then  the  .PARAGRAPH  command  is  equivalent  to the
     combination of an .INDENT command and  a  .SKIP  command.   If  the
     second  argument following the .PARAGRAPH command is equal to zero,
     then the .PARAGRAPH command is equivalent to  an  .INDENT  command.
     If  the  second  argument  following the .PARAGRAPH command is less
     than zero,  then  the  .PARAGRAPH  command  is  equivalent  to  the
     combination  of  an  .INDENT command and a .BLANK command having as
     its argument the second argument of the .PARAGRAPH command  without
     its  sign.  If a .SPACING 2 command is in effect, then a .PARAGRAPH
     5,3 command would result in  (2-1)+(3*2)  =  7  blank  lines  being
     generated before the next line which would be indented 5 columns to
     the right.  A  .PARAGRAPH  5,-6  command  would  produce  the  same
     results.  The .PARAGRAPH command implies a .BREAK command.

     For example, the source text

     .output width 55.left margin 5.right margin 54
     .carriage 1,*.paragraph.preface       WRITE(1,$)
     This line is at the start of the source and will only
     be indented.
     .spacing 2.paragraph 10
     (spacing-1)-(negative argument) = (1-1)-(-1) = 1 blank
     line since the default .SPACING 1 command was in effect
     at the end of the previous line.
     .paragraph
     (2-1)-(-1) = 2 blank lines precede this paragraph since
     the .SPACING 2 command was in effect at the end of the
     previous line.
     .paragraph -5,2
     (spacing-1)+(spacing*(positive argument)) = (2-1)+(2*2)
     = 5 lines precede this paragraph.
     .program;      END      Complete Descriptions of the Commands                                 77


           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

                 WRITE(1,1)
               1 FORMAT(1H1,10X,30HThis line is at the start of t,
                114Hhe source  and/27H*     will only be indented,
                21H./1H*/1H*,15X,29H(spacing-1)-(negative    argu,
                310Hment)    =/1H*/27H*     (1-1)-(-1)  =  1  bla,
                428Hnk  line  since  the default/1H*/9H*     .SP,
                545HACING 1 command was in effect at  the  end  o,
                61Hf/1H*/24H*     the previous line./1H*/1H*/1H*,
                715X,39H(2-1)-(-1) = 2 blank lines precede this/
                81H*/41H*     paragraph  since  the  .SPACING  2 ,
                914Hcommand was in/1H*/23H*     effect at the end,
                122H of the previous line./1H*/1H*/1H*/1H*/1H*/
                231H*(spacing-1)+(spacing*(positive,6X,8Hargument,
                32H)),7X,1H=/1H*/29H*     (2-1)+(2*2) = 5 lines p,
                422Hrecede this paragraph.)
                 END

           which would, in turn, generate the following text when run.

           1          This line is at the start of the source  and
           *     will only be indented.
           *
           *               (spacing-1)-(negative    argument)    =
           *
           *     (1-1)-(-1)  =  1  blank  line  since  the default
           *
           *     .SPACING 1 command was in effect at  the  end  of
           *
           *     the previous line.
           *
           *
           *               (2-1)-(-1) = 2 blank lines precede this
           *
           *     paragraph  since  the  .SPACING  2 command was in
           *
           *     effect at the end of the previous line.
           *
           *
           *
           *
           *
           *(spacing-1)+(spacing*(positive      argument))       =
           *
           *     (2-1)+(2*2) = 5 lines precede this paragraph.


      .PREFACE line of text to precede each new FORMAT statement

           The characters which appear to the right of the .PREFACE command on
           the  same  line are to be copied into the output file on a separate
           line before each new FORMAT  statement  which  is  generated.   The
           character  to the immediate right of the .PREFACE command must be a
           space.  The line of text which is to be copied into the output file
           before  each  new FORMAT statement starts with the second character78                                           FORMAT Program User's Guide


     to the right of the .PREFACE command, whether  or  not  this  is  a
     printing  character,  and  extends  through  the rightmost printing
     character on the line.  A .PREFACE command issued within the  range
     of a .PROGRAM command applies to the source text following the next
     .TEXT or .CONTINUE command.  If more than a  single  line  must  be
     inserted  before  each new FORMAT statement, then a .DEFINE PREFACE
     command followed  by  the  lines  of  text  and  then  by  an  .END
     DEFINITION  command  should  be  used  to  define the preface lines
     instead.  Regardless of which method is used to define the  preface
     line  or  lines,  the  insertions  of the preface line or lines are
     performed similarly.

     The insertion of the preface line before each new FORMAT  statement
     can  be  terminated  either  by  issuing  a  subsequent .NO PREFACE
     command, or by establishing  a  null  preface  by  issuing  another
     .PREFACE command without anything to its right.  These 2 methods of
     cancelling the preface line are not identical.  If  a  .NO  PREFACE
     command is used to cancel the insertion of the preface line, then a
     .RESUME PREFACE command can be issued later to resume the insertion
     of   the  same  preface  line  before  the  subsequent  new  FORMAT
     statements.  If a .PREFACE command is issued  without  anything  to
     its right, however, then the .RESUME PREFACE command cannot be used
     to resume the insertion of the previous preface line.  Neither  the
     .PREFACE  command,  nor  the  .NO  PREFACE  command nor the .RESUME
     PREFACE command implies a .BREAK command.

     The Line of text which is defined by the .PREFACE command is stored
     in  the same area as are those which are specified by the .GROUP or
     .DEFINE GROUP, .TOP or .DEFINE TOP and .BOTTOM  or  .DEFINE  BOTTOM
     commands.   There  can  be  at most 30 lines containing together no
     more than 500 characters in all  of  these  collections  of  lines.
     These  lines  include those which have been temporarily disabled by
     the .NO GROUP, .NO PREFACE, .NO TOP or .NO BOTTOM commands.

     The .PREFACE command would typically be used to insert single  line
     FORTRAN  language  WRITE  statements  before  each  of  the  FORMAT
     statements which represents portions of a long section of text.  In
     the  line  of text specified by the .PREFACE command, all groups of
     contiguous dollar signs which are not preceded by underscores  will
     be  replaced  each  time the line of text is copied into the output
     file by the statement number of the following FORMAT statement.  If
     the group of dollar signs contains more dollar signs than there are
     digits in the number, then additional spaces are  inserted  to  the
     left of the statement number so that the total number of characters
     which are inserted equals the number of dollar signs in the  group.
     If  the  group  of  dollar signs does not contain more dollar signs
     than there are digits in the number, then all  of  the  digits  are
     represented, but no extra spaces are inserted.

     The group of dollar signs can be followed immediately by  either  a
     plus  or a minus sign and then by a number to cause the value which
     is inserted in place of the group of dollar signs to be  larger  or
     smaller than the statement number of the following FORMAT statement
     by the indicated amount.  The value of the  next  statement  number
     can  itself be modified if an equal sign appears between the dollar
     sign and the plus or minus sign, or between the dollar sign and the
     actual  value  which  the  next statement number is to have.  If an      Complete Descriptions of the Commands                                 79


           equal sign appears to the  immediate  right  of  the  dollar  sign,
           however,  then  neither  this expression nor the resulting value is
           copied into the resulting preface line at this point.

           For example,

           $      would be replaced by the value of the next statement number.
                  No extra spaces would be inserted.

           $$$$   would be replaced by the next statement number.  If this  is
                  less  than 1000, then enough spaces are inserted at the left
                  to produce at least 4 characters.

           $+     would be replaced by the sum of the  next  statement  number
                  and  the  statement number increment.  The value of the next
                  statement number would not  itself  be  changed.   $-  would
                  subtract the increment instead.

           $+10   would be replaced by 10 more than  the  value  of  the  next
                  statement  number.   The  value of the next statement number
                  would not itself be changed.

           $=     would set the value of the next statement number to the  sum
                  of  its  current  value  and the statement number increment.
                  Neither the $= nor the resulting value would appear at  this
                  point  in the preface line when it is copied into the output
                  file.  There could be several adjacent dollar signs, but the
                  extra  dollar  signs  would  be ignored.  $=+ would have the
                  same effect.  $=- would subtract the increment instead.

           $=100  would set the value of the next  statement  number  to  100.
                  Neither  the  $=100  nor the resulting value would appear at
                  this point in the preface line when it is  copied  into  the
                  output file.

           $=+10  would increase the value of the next statement number by 10.
                  Neither  the  $=+10  nor the resulting value would appear at
                  this point in the preface line when it is  copied  into  the
                  output file.

           Within the text specified by the .PREFACE  command,  an  underscore
           character,  which  will  not  be  copied  into the output file, can
           appear before any character, such as  a  number  sign,  circumflex,
           back  slash,  less than sign (if in flag capitalize mode), a dollar
           sign or another underscore, which is to be  treated  as  a  nonflag
           character.   The  .PREFACE  command  cannot be followed on the same
           line either by a comment or by another command, so  semicolons  and
           exclamation  points  in  the line of text specified by the .PREFACE
           command do not need to be preceded by underscores.

           For example, the source text

           .output length 2.output width 55.right margin 30.
           .preface       IF(KONTRL.EQ.1)WRITE(1,$$$)
           The .PREFACE command allows several FORMAT statements
           representing a single section of text to be used under
           the same conditions.80                                           FORMAT Program User's Guide


     would be transformed into the following FORTRAN text when processed
     by this program.

           IF(KONTRL.EQ.1)WRITE(1,  1)
         1 FORMAT(31H The  .PREFACE  command  allows/4H sev,
          127Heral    FORMAT   statements)
           IF(KONTRL.EQ.1)WRITE(1,  2)
         2 FORMAT(31H representing a single  section/4H of ,
          127H text  to be used under the)
           IF(KONTRL.EQ.1)WRITE(1,  3)
         3 FORMAT(17H same conditions.)

     The following example demonstrates one manner in which manipulation
     of the statement numbers might be used to prevent duplication.  The
     $=$$$ which appears in  the  definition  of  the  preface  line  is
     treated  as  consisting of 2 parts.  The $= first changes the value
     of the next statement number by the current increment, then,  since
     a  dollar has no special meaning to the right of an equal sign, nor
     for that matter to the right of a plus or  minus  sign  or  to  the
     right of a number, the $$$ is replaced by this new number.

     .output length 2.output width 55.right margin 30.
     .preface $$$$$ IF(KONTRL.EQ.1)WRITE(1,$=$$$)
     The .PREFACE command allows several FORMAT statements
     representing a single section of text to be used under
     the same conditions.

     This  would  be  converted  to  the  following  FORTRAN  text  when
     processed by this program.

         1 IF(KONTRL.EQ.1)WRITE(1,  2)
         2 FORMAT(31H The  .PREFACE  command  allows/4H sev,
          127Heral    FORMAT   statements)
         3 IF(KONTRL.EQ.1)WRITE(1,  4)
         4 FORMAT(31H representing a single  section/4H of ,
          127H text  to be used under the)
         5 IF(KONTRL.EQ.1)WRITE(1,  6)
         6 FORMAT(17H same conditions.)


.PROGRAM next statement number, statement number increment

     The .PROGRAM command indicates that no additional  text  is  to  be
     represented by the FORMAT statement currently being constructed and
     that the source text appearing on the following lines of the  input
     file,  through  the  next .TEXT or .CONTINUE command or through the
     reading of the end of the file (or the issuing of an .END  OF  FILE
     command)  is to be copied into the output file directly rather than
     being represented in a  FORMAT  statement.   No  extra  spaces  are
     inserted at the start of the lines within the range of the .PROGRAM
     command regardless of whether an .OFFSET command has  been  issued,
     and no extra blank lines are inserted between these lines even if a
     .SPACING command has been issued.  Case conversions and removal  of
     underscores before characters to be copied literally continue to be
     performed within the range of  the  .PROGRAM  command,  and  dollar
     signs  are  replaced, as described below, by the number of the next
     FORMAT statement which can be generated.      Complete Descriptions of the Commands                                 81


           In  the  lines  within  the  range  of  the  .PROGRAM  command,  an
           underscore  character,  which  will  not  be copied into the output
           file, can appear before any  character,  such  as  a  number  sign,
           circumflex,  back  slash,  less  than  sign  (if in flag capitalize
           mode),  dollar  sign,  another  underscore,  initial   period,   or
           rightmost  space,  which  is  to  be  treated  as though it were an
           ordinary printing character.  All lines beginning with a period  in
           the  left  column  will  be  interpreted  as commands.  In order to
           output a line starting with a period, this period must be  preceded
           by an underscore character.

           In the noncommand lines following the .PROGRAM command, all  groups
           of  contiguous  dollar  signs  which are not preceded by underscore
           characters will be replaced by the statement number of  the  FORMAT
           statement  which  would  be  generated  when  either  a  .TEXT or a
           .CONTINUE command is next encountered.   If  the  group  of  dollar
           signs  contains  more  dollar  signs  than  there are digits in the
           number, then additional spaces are inserted  to  the  left  of  the
           statement  number  so that the total number of characters which are
           inserted equals the number of dollar signs in the  group.   If  the
           group of dollar signs does not contain more dollar signs than there
           are digits in the number, then all of the digits  are  represented,
           but no extra spaces are inserted.

           The numbers which can follow the .PROGRAM command are identical  to
           those which can follow the .TEXT and .CONTINUE commands.  The first
           number  which  can  follow  any  of  these  commands  modifies  the
           statement  number  of the next FORMAT statement.  The second number
           which can follow any of these commands becomes the statement number
           increment  after  the generation of the next FORMAT statement.  The
           description of the .CONTINUE command describes  the  interpretation
           of  these numbers in detail.  If the statement number of the FORMAT
           statement following a section  of  program  text  indicated  by  an
           initial  .PROGRAM  command  is to be modified, but the program text
           includes dollar signs which are to be replaced  by  this  statement
           number,  then  this  statement  number  should  be  modified by the
           .PROGRAM command rather than by the following  .TEXT  or  .CONTINUE
           command,  since,  if  the  modification  is  done  by  the .TEXT or
           .CONTINUE command, then incorrect statement numbers will have  been
           inserted into the program text.

           For example, the source text

           .spacing 2.output width 55.offset 0
           .text 10,10    ;Statement ten
           .program       ;Next statement will be number $$$.
           .continue      ;Statement twenty
           .program+5,100 ;Next statement will be number $$.
           .trail         !blank lines will now end statements
           _.Underscore before initial period and dollar sign _$.
           .continue      ;Statement twenty-five
           .program       ;Next statement will be number $.
           .continue      ;Statement one hundred and twenty-five82                                           FORMAT Program User's Guide


     would be transformed into the following FORTRAN text when processed
     by this program.

        10 FORMAT(13HStatement ten)
     Next statement will be number  20.
        20 FORMAT(/16HStatement twenty)
     Next statement will be number 25.
     .Underscore before initial period and dollar sign $.
        25 FORMAT(/21HStatement twenty-five/)
     Next statement will be number 125.
       125 FORMAT(37HStatement one hundred and twenty-five/)


.RESET

     The .RESET command returns all conditions which can be  changed  by
     commands  and  by  case  shift  locks  in  the source text to their
     original settings.  If additional text appears on the same line  to
     the  right  of  the  .RESET  command  then the original set of flag
     characters will be recognized in  this  additional  text,  and  the
     cases  of  alphabetic letters will be retained at the start of this
     additional text.  The width of the line in which the .RESET command
     is found is set by the input line width in effect when the line was
     read, but the next line read from the source file will  be  of  the
     original width.

     The following commands are implied by the .RESET command.

          .FILL
          .FLAGS ALL
          .FLAGS CONTROL _.
          .FLAGS FENCE _;
          .FLAGS INSERT $
          .FLAGS LOWER CASE _\
          .FLAGS QUOTE __
          .FLAGS REMARK _!
          .FLAGS SPACE _#
          .FLAGS UPPER CASE _^
          .INPUT WIDTH 132 (applies to next line read)
          .JUSTIFY
          .LEFT MARGIN 0
          .NO BOTTOM
          .NO CARRIAGE
          .NO COPY
          .NO FLAGS CAPITALIZE
          .NO GROUP
          .NO INSERT
          .NO LEADING
          .NO MASK
          .NO PAGE CARRIAGE
          .NO PAGING
          .NO PREFACE
          .NO TOP
          .NO TRAILING
          .OFFSET 1
          .OUTPUT LENGTH 20
          .OUTPUT WIDTH 72      Complete Descriptions of the Commands                                 83


                .PAGE LENGTH 22
                .RIGHT MARGIN 60
                .SPACING 1
                .TEXT 1,1
                .UPPER CASE
                .USE H

           The .NO BOTTOM, .NO PAGE CARRIAGE, .NO PAGING, .NO  TOP  and  .PAGE
           LENGTH  commands  which are listed in the above table are used when
           the text in lengthy  messages  is  being  divided  into  pages  for
           display  on  a video terminal.  These commands are described in the
           next chapter of this manual.

           After the .RESET command has  been  issued,  a  .PARAGRAPH  command
           without  arguments  would be assumed to be equivalent to .PARAGRAPH
           5,-1,3.  The third number after the .PARAGRAPH command is used only
           when the text is being divided into pages.


      .RESUME GROUP

           If a .NO GROUP command has been issued  to  prevent  the  insertion
           into  the output file of the FORTRAN text specified by the previous
           .GROUP or .DEFINE GROUP command, then  the  .RESUME  GROUP  command
           resumes  the insertion of this FORTRAN text before the first FORMAT
           statement produced after  each  .TEXT  command.   A  .RESUME  GROUP
           command is implied by each new .GROUP or .DEFINE GROUP command.  If
           a .NO GROUP command has not been issued,  then  the  .RESUME  GROUP
           command is unnecessary and has no effect.

           The FORTRAN text specified by a .GROUP or .DEFINE GROUP command  is
           not generated until enough lines of output text have been specified
           to fill the first line of the first FORMAT statement.  Whether this
           FORTRAN  text  is  generated  or not depends, at the time the first
           line of the FORMAT statement has been completed, upon whether  this
           FORTRAN  text  has  been  specified  by  a  .GROUP or .DEFINE GROUP
           command, and upon whether this FORTRAN text has been deactivated by
           a  subsequent  .NO  GROUP  command  or  reactivated by a subsequent
           .RESUME GROUP command.  Consequently,  it  is  better  to  issue  a
           .GROUP,  .DEFINE  GROUP,  .NO GROUP, or .RESUME GROUP command after
           the .TEXT, .CONTINUE  or  .PROGRAM  command  which  terminates  the
           previous FORMAT statement, rather than before.

           For example, the source text

           .output width 55
           .group       WRITE(ITTY,$)
           This text comes after the definition of a group
           line by the .GROUP command.
           .text.no group
           This text comes after the .NO GROUP command.
           There will not be a group line before this FORMAT.
           .text.resume group
           This text comes after the .RESUME GROUP command.
           The group line will again appear before this FORMAT.84                                           FORMAT Program User's Guide


     would be transformed into the following FORTRAN text when processed
     by this program.

           WRITE(ITTY,1)
         1 FORMAT(38H This text comes after the definition ,
          123Hof a group line by  the/16H .GROUP command.)
         2 FORMAT(38H This text comes after the .NO GROUP c,
          123Hommand.  There will not/18H be a group line b,
          218Hefore this FORMAT.)
           WRITE(ITTY,3)
         3 FORMAT(38H This text comes after the .RESUME GRO,
          123HUP command.  The  group/18H line will again a,
          225Hppear before this FORMAT.)


.RESUME PREFACE

     If a .NO PREFACE command has been issued to prevent  the  insertion
     into  the output file of the FORTRAN text specified by the previous
     .PREFACE or .DEFINE  PREFACE  command,  then  the  .RESUME  PREFACE
     command  resumes the insertion of this FORTRAN text before each new
     FORMAT statement.  A .RESUME PREFACE command is implied by each new
     .PREFACE  or .DEFINE PREFACE command.  If a .NO PREFACE command has
     not been issued, then the .RESUME PREFACE  command  is  unnecessary
     and has no effect.

     The FORTRAN text specified by a .PREFACE or .DEFINE PREFACE command
     is  not  generated  until  enough  lines  of  output text have been
     specified to fill the first line  of  the  next  FORMAT  statement.
     Whether  this FORTRAN text is generated or not depends, at the time
     the first line of the FORMAT statement  has  been  completed,  upon
     whether  this  FORTRAN  text  has  been  specified by a .PREFACE or
     .DEFINE PREFACE command, and upon whether  this  FORTRAN  text  has
     been deactivated by a subsequent .NO PREFACE command or reactivated
     by a subsequent  .RESUME  PREFACE  command.   Consequently,  it  is
     better  to  issue  a  .PREFACE,  .DEFINE  PREFACE,  .NO PREFACE, or
     .RESUME PREFACE command after  the  .TEXT,  .CONTINUE  or  .PROGRAM
     command which terminates the previous FORMAT statement, rather than
     before.

     For example, the source text

     .output width 55
     .preface       WRITE(ITTY,$)
     This text comes after the definition of a preface
     line by the .PREFACE command.
     .continue.no preface
     This text comes after the .NO PREFACE command.
     There will not be a preface line before this FORMAT.
     .continue.resume preface
     This text comes after the .RESUME PREFACE command.
     The preface line will again appear before this FORMAT.      Complete Descriptions of the Commands                                 85


           would be transformed into the following FORTRAN text when processed
           by this program.

                 WRITE(ITTY,1)
               1 FORMAT(38H This text comes after the definition ,
                123Hof a  preface  line  by/18H the .PREFACE comm,
                24Hand.)
               2 FORMAT(38H This text comes after the .NO PREFACE,
                123H command.   There  will/18H not be a preface ,
                224Hline before this FORMAT.)
                 WRITE(ITTY,3)
               3 FORMAT(38H This text comes after  the  .RESUME  ,
                123HPREFACE  command.   The/18H preface line will,
                233H again appear before this FORMAT.)


      .RIGHT MARGIN rightmost column into which text is wrapped

           The  .RIGHT  MARGIN  command  specifies  the  maximum   number   of
           characters  in each line of text which is constructed in fill mode,
           including the left margin specified by the  .LEFT  MARGIN  command,
           the  indentation  which  is  specified  either  by  an .INDENT or a
           .PARAGRAPH command, and the words of text and the spacings  between
           words  which  are  accumulated on the current line either until the
           next word would cause the total number of characters in the line to
           exceed  the  right margin specified by the .RIGHT MARGIN command or
           until a command which implies a .BREAK command is encountered.   If
           the  number  which  follows  the .RIGHT MARGIN command is unsigned,
           then this number will be used  as  the  right  margin.   The  right
           margin  is  assumed to be 60 if a .RIGHT MARGIN command has not yet
           been encountered.  If the number which follows  the  .RIGHT  MARGIN
           command  is  signed,  then the previous right margin is adjusted by
           the indicated amount.  If  no  number  follows  the  .RIGHT  MARGIN
           command then the right margin is reset to the farthest right margin
           which it has yet been set.  The .RIGHT  MARGIN  command  implies  a
           .BREAK command.

           The right margin is the maximum length of the line of  text  before
           the  application  of the template line specified by a .MASK command
           and before the line is duplicated by a .COPY  command.   The  right
           margin  does  not  include  the  leftmost  spaces  specified by the
           .OFFSET command or the single  left  space  which  is  obtained  if
           neither  the  .OFFSET  command  nor the .NO OFFSET command has been
           issued.  The combination of the right margin and the initial offset
           specified  by  the  .OFFSET  command  cannot exceed 300.  The right
           margin is always assumed to be large enough for the current line to
           include  at least 1 word.  The right margin is ignored if the lines
           of text are being represented in no fill mode.86                                           FORMAT Program User's Guide


     For example, the source text

     .output width 55.carriage 1,*.preface       WRITE(1,$)
     .left margin 5.right margin 30.indent 5
     The .RIGHT MARGIN command implies a .BREAK command.
     .right margin 40.indent -5
     The .RIGHT MARGIN command applies only to text which is
     constructed in fill mode.
     .nofill;The right margin is ignored in no fill mode.
     .program;      END

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(1,1)
         1 FORMAT(1H1,10X,20HThe  .RIGHT   MARGIN/7H*     c,
          124Hommand  implies a .BREAK/14H*     command./
          241H*The .RIGHT MARGIN command  applies  only/1H*,
          35X,35Hto  text  which  is  constructed in/4H*   ,
          412H  fill mode./29H*     The right margin is ign,
          521Hored in no fill mode.)
           END

     which would, in turn, generate the following text when run.

     1          The  .RIGHT   MARGIN
     *     command  implies a .BREAK
     *     command.
     *The .RIGHT MARGIN command  applies  only
     *     to  text  which  is  constructed in
     *     fill mode.
     *     The right margin is ignored in no fill mode.


.SKIP multiple of extra line spacings to be generated

     The .SKIP command indicates that, after the representation  in  the
     FORMAT  statement  of  the  previous  text, a number of blank lines
     equal to the specified multiple of the number which appeared to the
     right  of the previous .SPACING command, or the specified number of
     blank lines directly if a .SPACING command has not yet been issued,
     are  to  be represented in the FORMAT statement, in addition to any
     blank lines specified by other .BLANK or .SKIP commands, and, if  a
     .SPACING  command has been issued, in addition to a number of blank
     lines equal to one less than the number which appeared to the right
     of  the  previous  .SPACING  command.   If no number appears to the
     right of the .SKIP command, then the number 1 is assumed to  appear
     to the right of the .SKIP command instead.  If a .SPACING 2 command
     is in effect, then a .SKIP 3 command would result in (3*2)+(2-1) or
     7 blank lines being generated.  The .SKIP command is similar to the
     .BLANK command, except that the .BLANK command always specifies the
     number  of extra blank lines directly.  The .SKIP command implies a
     .BREAK command.

     If no text has been represented in  the  FORMAT  statements  either
     since  this program was started or since the last .TEXT command was
     issued, then the .SKIP command, like the  .BLANK  command  and  the      Complete Descriptions of the Commands                                 87


           .SKIP  or  .BLANK  command  implied  by  the .PARAGRAPH command, is
           ignored unless a .LEADING command is in effect.  Blank lines  which
           have  not been generated when the end of the source file is read or
           when the  next  .TEXT  command  is  issued,  but  which  have  been
           requested  by  .SKIP  or .BLANK commands or which are necessary for
           the normal line spacing, will be appended to the  FORMAT  statement
           being  constructed  if  a  .TRAIL command is then in effect.  Blank
           lines will be discarded when the end of the source file is read  or
           the  next .TEXT command is issued if a .NO TRAIL command is then in
           effect or if a .TRAIL command has not by then been issued.

           For example, the source text

           .spacing 2.output width 55
           .skip
           The quick red fox jumps over the lazy brown dog,
           then runs into the forest.
           .skip
           The quick red fox jumps over the lazy brown dog,
           then runs into the forest.
           .skip 2
           The quick red fox jumps over the lazy brown dog,
           then runs into the forest.
           .skip 3
           The quick red fox jumps over the lazy brown dog,
           then runs into the forest.

           would be transformed into the following FORTRAN text when processed
           by this program.

               1 FORMAT(38H The quick red fox jumps over the lazy,
                123H brown dog,  then  runs//17H into the forest./
                2///42H The quick red fox jumps over the lazy bro,
                319Hwn dog,  then  runs//17H into the forest./////
                4/44H The quick red fox jumps over the lazy brown,
                517H dog,  then  runs//17H into the forest.///////
                6/44H The quick red fox jumps over the lazy brown,
                717H dog,  then  runs//17H into the forest.)


      .SPACING separation from top of one line to top of next line

           The .SPACING command specifies the separation from the top  of  one
           line of text to the top of the next line of text when the resulting
           FORMAT statements are used.  The number specified by  the  .SPACING
           command  is one greater than the number of blank lines which are to
           separate lines of text which are constructed in fill mode or  which
           are  copied in no fill mode.  The intervening blank lines which are
           required when the .SPACING command has specified  a  value  greater
           than 1 are generated after each line of text, not before.  No blank
           lines follow the final line of text unless a .TRAILING  command  is
           in  effect.   The  .SPACING  command  implies  a .BREAK command.  A
           .SPACING 1 command which gives single spacing with  no  intervening
           blank  lines  is  assumed  to  be  in  effect  when this program is
           started.  If a line of text is being constructed when the  .SPACING
           command is encountered, then the number of blank lines which follow
           that line of text is determined by the line spacing  which  was  in88                                           FORMAT Program User's Guide


     effect  during  the  construction  of that line of text, not by the
     newly specified spacing.

     For example, the source text

     .output width 55.right margin 54
     .carriage 1,*.preface       WRITE(1,$)
     A .SPACING 1 command is assumed to be in effect when
     this program is started.
     .spacing 2
     No blank lines precede this since the .SPACING 2
     command forced out previous line before taking effect.
     .blank 2;Normal spacing and 2 blank lines
     .skip 2;Normal spacing and 2 multiples of 2 blank lines
     .paragraph 5,2;Paragraph similar to .skip 2.indent 5
     .program;      END

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(1,1)
         1 FORMAT(38H1A .SPACING 1 command is assumed to be,
          117H in  effect  when/24H*this program is started,
          21H./41H*No blank lines  precede  this  since  th,
          314He  .SPACING  2/1H*/23H*command forced out pre,
          432Hvious line before taking effect./1H*/1H*/1H*/
          533H*Normal spacing and 2 blank lines/1H*/1H*/1H*/
          61H*/1H*/37H*Normal spacing and 2 multiples of 2 ,
          711Hblank lines/1H*/1H*/1H*/1H*/1H*/10H*     Para,
          833Hgraph similar to .skip 2.indent 5)
           END

     which would, in turn, generate the following text when run.

     1A .SPACING 1 command is assumed to be in  effect  when
     *this program is started.
     *No blank lines  precede  this  since  the  .SPACING  2
     *
     *command forced out previous line before taking effect.
     *
     *
     *
     *Normal spacing and 2 blank lines
     *
     *
     *
     *
     *
     *Normal spacing and 2 multiples of 2 blank lines
     *
     *
     *
     *
     *
     *     Paragraph similar to .skip 2.indent 5      Complete Descriptions of the Commands                                 89


      .TEXT next statement number, statement number increment

           The .TEXT command indicates  that  no  additional  text  is  to  be
           represented by the FORMAT statement currently being constructed and
           that the text appearing in subsequent lines in the source  file  is
           to  be represented in a new FORMAT statement.  The preface line, if
           any, indicated by a previous .PREFACE command will be written  into
           the  output  before  this next FORMAT statement.  All unused output
           field descriptions previously specified by .INSERT commands will be
           discarded.   If  the  .TEXT command is issued within the range of a
           .PROGRAM command,  then  the  range  of  the  .PROGRAM  command  is
           terminated.   Blank  lines  which  have not yet been generated, but
           which have been requested by .SKIP or .BLANK commands or which  are
           necessary for multiple line spacing, will be appended to the FORMAT
           statement currently being constructed if a .TRAILING command is  in
           effect.  Such trailing blank lines will be discarded before the new
           FORMAT statement is begun if a .NO TRAILING command is in effect or
           if  a  .TRAILING command has not been issued.  If the .TEXT command
           is followed by .SKIP or .BLANK commands before the next text  which
           is  to  be represented in the FORMAT statements, then these leading
           blank lines will be represented only if a .LEADING  command  is  in
           effect.   Such  leading  blank lines are discarded if a .NO LEADING
           command is in effect or if a .LEADING command has not been  issued.
           The  .TEXT  command  is  identical to the .CONTINUE command, except
           that a .CONTINUE command would retain all previously specified  but
           unused  field descriptions, and, providing that there is additional
           text to be represented, a .CONTINUE  command  would  represent  all
           blank lines which have not yet been generated.

           The numbers which can follow the .TEXT  command  are  identical  to
           those  which  can  follow the .CONTINUE and .PROGRAM commands.  The
           first number which can follow any of these  commands  modifies  the
           statement  number  of the next FORMAT statement.  The second number
           which can follow any of these commands becomes the statement number
           increment  after  the generation of the next FORMAT statement.  The
           description of the .CONTINUE command describes  the  interpretation
           of  these numbers in detail.  If the statement number of the FORMAT
           statement following a section  of  program  text  indicated  by  an
           initial  .PROGRAM  command  is to be modified, but the program text
           includes dollar signs which are to be replaced  by  this  statement
           number,  then  this  statement  number  should  be  modified by the
           .PROGRAM command rather than by the following  .TEXT  or  .CONTINUE
           command,  since,  if  the  modification  is  done  by  the .TEXT or
           .CONTINUE command, then incorrect statement numbers will have  been
           inserted into the program text.90                                           FORMAT Program User's Guide


     For example, the source text

     .spacing 2.output width 55
     .text 10,10;.preface       WRITE(1,$)
     .insert I2
     .insert F2
     The quick red fox jumps $$ feet over the lazy brown dog
     .text
     The quick red fox jumps $$ feet over the lazy brown dog
     .skip;.text +100
     .insert I2
     .insert F2
     .insert A2
     The quick red fox jumps $$ feet over the lazy brown dog
     .continue,5
     The quick red fox jumps $$ feet over the lazy brown dog
     .skip;.continue
     The quick red fox jumps $$ feet over the lazy brown dog

     would be transformed into the following FORTRAN text when processed
     by this program.

           WRITE(1,10)
        10 FORMAT(25H The quick red fox jumps ,I2,7H feet o,
          122Hver the lazy brown dog)
           WRITE(1,20)
        20 FORMAT(25H The quick red fox jumps ,9H feet ove,
          120Hr the lazy brown dog)
           WRITE(1,120)
       120 FORMAT(25H The quick red fox jumps ,I2,7H feet o,
          122Hver the lazy brown dog)
           WRITE(1,130)
       130 FORMAT(/25H The quick red fox jumps ,F2,6H feet ,
          123Hover the lazy brown dog)
           WRITE(1,135)
       135 FORMAT(///25H The quick red fox jumps ,A2,4H fee,
          125Ht over the lazy brown dog)


.TRAILING

     The .TRAILING command indicates that the FORMAT statements  are  to
     include  blank lines resulting from .SKIP or .BLANK commands issued
     after all text has been represented in the  FORMAT  statements  and
     are  to include the blank lines necessary for multiple line spacing
     following  the  final  line  of  text  represented  in  the  FORMAT
     statements.   If  a  .TRAILING command has not been issued, or if a
     .NO TRAILING command has been issued more recently than a .TRAILING
     command,  then each .TEXT command and the reading of the end of the
     file (or the issuing of an .END OF FILE command)  instead  discards
     all  blank  lines  which  did  not  precede  text  which  has  been
     represented  in  the  FORMAT  statements.   Neither  the  .TRAILING
     command nor the .NO TRAILING command implies a .BREAK command.      Complete Descriptions of the Commands                                 91


           For example, the source text

           .spacing 2.output width 55.use'.offset 0.text 10
           The quick red fox jumps over the lazy brown dog,
           then runs into the forest.
           .text 20
           The quick red fox jumps over the lazy brown dog,
           then runs into the forest.
           .skip.text 30.trail
           The quick red fox jumps over the lazy brown dog,
           then runs into the forest.
           .text 40
           The quick red fox jumps over the lazy brown dog,
           then runs into the forest.
           .skip

           would be transformed into the following FORTRAN text when processed
           by this program.

              10 FORMAT('The quick red fox jumps over the lazy b',
                1'rown dog,  then  runs'//'into the forest.')
              20 FORMAT('The quick red fox jumps over the lazy b',
                1'rown dog,  then  runs'//'into the forest.')
              30 FORMAT('The quick red fox jumps over the lazy b',
                1'rown dog,  then  runs'//'into the forest.'/)
              40 FORMAT('The quick red fox jumps over the lazy b',
                1'rown dog,  then  runs'//'into the forest.'///)


      .UPPER CASE

           The .UPPER CASE command indicates that the cases of all  alphabetic
           letters  which  are  not specially marked are to be retained in the
           source text which follows the end of the command or, if the  .UPPER
           CASE  command  is  followed  by a comment, in the source text which
           follows the comment.  Regardless of the issuing of the .UPPER  CASE
           command,  any  letter  which  is  preceded by a back slash is still
           converted to its lower case form, any letter which is preceded by a
           circumflex  is  still  converted  to  its  upper  case  form,  and,
           providing that a .FLAGS CAPITALIZE command  has  been  issued,  any
           letter  which is in a word which is preceded by a less than sign is
           also converted to its upper case form.  The .UPPER CASE command  is
           equivalent  to  the appearance of 2 consecutive circumflexes except
           that the 2 circumflexes can appear anywhere and that the  retention
           of  cases indicated by the 2 circumflexes is applied immediately to
           all of the following text.  An .UPPER CASE command is assumed to be
           in  effect  when  this program is started.  Upper case letters will
           instead be converted to their lower case forms if the  .LOWER  CASE
           command  or  the  equivalent 2 consecutive back slashes are issued.
           Neither the .UPPER CASE command nor the .LOWER CASE command implies
           a .BREAK command.92                                           FORMAT Program User's Guide


     For example, the source text

     .offset 0.right margin 55.output width 55
     .flags capitalize.preface       WRITE(1,$)
     An <.upper ^c^a^s^e \C\O\M\M\A\N\D does not have to be
     issued when this program is first started.
     .lower case
     ^A <.LOWER ^C^A^S^E \C\O\M\M\A\N\D CAN BE ISSUED TO
     CAUSE CONVERSION TO LOWER CASE.
     .upper case
     The <.upper ^c^a^s^e \C\O\M\M\A\N\D can, of course, be
     reissued at any time.
     .program;      END

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(1,1)
         1 FORMAT(38HAn .UPPER CASE command does not have t,
          117Ho be issued  when/24Hthis  program  is first ,
          231Hstarted.  A .LOWER CASE command/10Hcan be iss,
          345Hued to cause conversion to lower  case.   The/
          445H.UPPER  CASE command can, of course, be reiss,
          510Hued at any/5Htime.)
           END

     which would, in turn, generate the following text when run.

     An .UPPER CASE command does not have to be issued  when
     this  program  is first started.  A .LOWER CASE command
     can be issued to cause conversion to lower  case.   The
     .UPPER  CASE command can, of course, be reissued at any
     time.


.USE character implying text representation notation

     The .USE command specifies the notation which  is  to  be  used  to
     represent  the  text  in the FORMAT statements being generated.  If
     the next printing character following the .USE command is either an
     upper  or lower case letter H, then the text will be represented in
     Hollerith notation as the number  of  characters  followed  by  the
     letter  H  in  the case indicated and then by the characters of the
     text.  If the next printing character following the .USE command is
     not the letter H, then that character will be appended to both ends
     of the text and will be doubled  wherever  it  appears  within  the
     text.   .USE'  would  select  apostrophe  notation, and .USE* would
     select the asterisk notation used by some computers  which  do  not
     include  the apostrophe in their character sets.  The .USE command,
     like most other commands which merely describe the manner in  which
     the  text is represented in the FORMAT statements, does not imply a
     .BREAK command.

     One or more spaces can appear between  the  .USE  command  and  the
     following printing character, but are not required.  In order for a
     space, number sign, circumflex, back slash, less than sign  (if  in
     flag  capitalize  mode),  period,  semicolon,  exclamation point or      Complete Descriptions of the Commands                                 93


           underscore to be specified by the .USE command  as  the  delimiting
           character,   this  character  would  have  to  be  preceded  by  an
           underscore.

           For example, the source text

           .out width 55;one * two ** three ' four '' five
           .break.use'  ;one * two ** three ' four '' five
           .break.use * ;one * two ** three ' four '' five
           .break.useH  ;one * two ** three ' four '' five
           .break.use h ;one * two ** three ' four '' five

           would be transformed into the following FORTRAN text when processed
           by this program.

               1 FORMAT(34H one * two ** three ' four '' five/' ',
                1'one * two ** three '' four '''' five'/* one ***,
                2* two **** three ' four '' five*/12H one * two *,
                322H* three ' four '' five/19h one * two ** three,
                415h ' four '' five)




                                     Chapter 4

                   COMMANDS NEEDED FOR PAGING ON VIDEO TERMINALS



                                    Introduction
                                    ------------

      On some computer systems, the lines which have been displayed on a video
      terminal  are  counted  and  the system pauses each time that enough new
      text has been generated to fill the screen.  When the text on the screen
      is erased, enough lines are displayed from the top down until the screen
      fills again, and then the typing of  text  pauses.   If  the  screen  is
      already full, then each new line is displayed first at the bottom of the
      screen.  The lines already on the screen are shifted upward as new lines
      are  added  and the top line disappears.  The typing of text pauses each
      time that the first line which was displayed after  the  previous  pause
      would be lost.

      After each pause, the user is expected to instruct the system to  resume
      the typing of the text.  This assures that the user has a chance to read
      all of the text which is  on  the  screen.   The  extra  interaction  is
      acceptable  to  the  user  if  most  of  the text which is displayed was
      generated by the program.  However, the user will already have read  the
      text  on  the  screen  anyway if the user is interacting every few lines
      with the program.  If the program usually types much less  than  a  full
      screen  after  each  interaction with the user, then it may be better to
      turn off the automatic pausing each time that the screen is filled,  and
      to  instead have the program, rather than the computer system upon which
      the program is being run, parcel out the lines in the longer messages.

      The commands described in  the  previous  portion  of  this  manual  are
      sufficient  for the construction of short messages, for the construction
      of  long  messages  which  will  be  typed  onto  paper,  and  for   the
      construction of long messages which will be displayed on video terminals
      which pause automatically each time the screen fills.  However,  if  the
      system  cannot  pause each time the screen fills on a video terminal, or
      if this function is turned off so that short sections of dialog are  not
      interrupted  unexpectedly, then the program will have to count the lines
      in long messages and pause at the proper points.  The  FORTRAN  code  to
      produce  these  pauses could be inserted by hand.  This could be done by
      finding the points in the message at which the  screen  fills,  breaking
      the lines in the source text at these points, and then inserting at each
      of these points a .PROGRAM command followed by the  FORTRAN  code  which
      waits for the user to do something such as press the RETURN key.  If the
      text is being justified, then number signs which produce spaces  in  the
      resulting  text  would  have to be inserted into the bottom line on each
      page to get the bottom line to be the same length as  the  rest  of  the
      lines on the page.  Of course, if the message is ever revised, or if the
      margins or the number of lines which can be displayed on a single screen
      are  ever  changed, then the .PROGRAM commands and the following FORTRAN
      code and the number signs which were used to  obtain  the  extra  spaces
      would  have  to be removed before determining the breaks between the new
      pages.96                                           FORMAT Program User's Guide


The FORMAT program provides a set of commands which perform all  of  the
operations  necessary  for  dividing  the  messages into pages each just
large enough to fill the screen.  These commands are described  in  this
chapter.   The  resulting  FORTRAN  code  has  the general form which is
outlined below.  Where FORTRAN code is indicated as  being  inserted  at
the start of a message, at the start of a new page, or after a completed
page, each of these types of insertions can consist of several lines and
can  contain unique statement numbers both in the statement number field
and in the text of the statements.  The WRITE statements  represent  the
FORTRAN  code  which  is  specified by the .PREFACE command and which is
inserted before each individual FORMAT statement, but  this  code  could
also  consist  of several lines.  The multiple dots indicate lines which
are not shown in the outline but which would fill out  the  page  in  an
actual application.

      FORTRAN code to begin a new message

      FORTRAN code to clear screen before new page

      WRITE(ITTY,101)
  101 FORMAT(' Text at top of first page'/ ... )
         .
         .
      WRITE(ITTY,103)
  103 FORMAT( ... /' Text in middle of first page'/ ... )
         .
         .
      WRITE(ITTY,105)
  105 FORMAT( ... /' Text at bottom of first page')

      FORTRAN code to pause at bottom of page

      FORTRAN code to clear screen before new page

      WRITE(ITTY,106)
  106 FORMAT(' Text at top of second page'/ ... )
         .
         .
      WRITE(ITTY,103)
  108 FORMAT( ... /' Text in middle of second page'/ ... )
         .
         .
      WRITE(ITTY,110)
  110 FORMAT( ... /' Text at bottom of second page')

      FORTRAN code to pause at bottom of page

The parcelling out of lines into pages is activated by issuing a .PAGING
command.   The number of lines displayed on the page is set to zero when
this program is started and after each new  .TEXT  command.   The  lines
which are counted are, of course, the lines which result when the FORMAT
statements are used, not the lines in the source  text  which  is  being
processed.   If  a .PAGING command has not been issued, then page breaks
are not automatically inserted into the messages  but  the  counting  of
lines  is  still performed.  A new page can be forced at any point.  The
number of lines remaining unused at the bottom of the page can be tested
and  a  new  page  can  be  forced  if too few lines remain unused.  The      Commands Needed for Paging on Video Terminals                         97


      bottoms of the pages can be filled out with extra blank lines, or enough
      blank  lines  can  be  inserted to cause the next line to be any desired
      distance from the bottom of  the  page.   The  character  inserted  into
      column  1 as a carriage control can also be made different for the first
      line on a page.

      Since the parcelling out of lines into pages depends upon the  insertion
      of  FORTRAN  code  before and after the text on each page, the number of
      lines which can be displayed on each page must be indicated in the  text
      which the FORMAT program processes.  Consequently, the resulting FORTRAN
      program can only be used on terminals which can display  at  least  this
      number  of lines on the screen.  The source text must be changed and the
      FORMAT program must be run again if the resulting FORTRAN code is to  be
      used  with  a  video  terminal which cannot display as many lines on the
      screen.  It is suggested that the  smallest  screen  size  be  made  the
      standard  if  the resulting FORTRAN program is to be used with terminals
      having different screen sizes.   However,  provided  that  the  type  of
      terminal  being used is known, the FORTRAN text which is inserted at the
      tops and at the bottoms of the pages can be written  in  such  a  manner
      that  the  same  resulting  FORTRAN  code  can  be  used  with  hardcopy
      terminals, with video terminals which can only scroll new text into  the
      bottom  of  the  screen,  and  with  video terminals which can clear the
      screen under program control.  It is only necessary  that  the  code  to
      clear  the screen and to pause at the bottom of the screen be skipped if
      a hardcopy terminal is used, and that the code which clears  the  screen
      be skipped if the terminal cannot clear the screen.98                                           FORMAT Program User's Guide


          Example of FORTRAN Code Containing Several Messages
          ------- -- ------- ---- ---------- ------- --------

If the FORMAT program is used to process a group of messages,  then  the
resulting FORTRAN code should also include the logic necessary to select
among these messages.  The resulting FORTRAN code might  be  similar  to
the subroutine which is outlined below.  This subroutine can display any
1 of 3 messages.  Paging is activated only during the processing of  the
second  message, which is assumed to be longer than the others.  Even if
paging is activated for the longer messages, it should still  be  turned
off for messages which use much less than a full page.

      SUBROUTINE HELP(ITTY,KNDMSG)
C     ITTY   = UNIT NUMBER ON WHICH TO DISPLAY MESSAGE
C     KNDMSG = SELECTS WHICH MESSAGE IS DISPLAYED
      GO TO(100,200,300),KNDMSG
      GO TO 4
  100 CONTINUE
      WRITE(ITTY,101)
  101 FORMAT(' Short first message')
      GO TO 4
  200 CONTINUE
      WRITE(ITTY,1)
      WRITE(ITTY,201)
  201 FORMAT(' First lines on 1st page of 2nd message')
         .
      write and format statements for middle of page
         .
      WRITE(ITTY,205)
  205 FORMAT(' Final lines on 1st page of 2nd message')
      WRITE(ITTY,2)
      READ(ITTY,3)IPAUSE
      WRITE(ITTY,1)
      WRITE(ITTY,206)
  206 FORMAT(' First lines on 2nd page of 2nd message')
         .
      write and format statements for middle of page
         .
      WRITE(ITTY,210)
  210 FORMAT(' Final lines on 2st page of 2nd message')
      WRITE(ITTY,2)
      READ(ITTY,3)IPAUSE
      GO TO 4
  300 CONTINUE
      WRITE(ITTY,301)
  301 FORMAT(' Short third message')
    1 FORMAT('1Top line on page')
    2 FORMAT(' Press RETURN to continue')
    3 FORMAT(1A1)
    4 RETURN
      END

The original source  text  which  would  be  processed  to  produce  the
subroutine shown above is outlined below.  The FORTRAN statements at the
start and end of the subroutine  were  programmed  in  the  conventional
manner  and  are  merely  copied  into  the resulting file.  The FORTRAN
statements starting with the SUBROUTINE statement and extending  through      Commands Needed for Paging on Video Terminals                         99


      the  computed  GO  TO  statement  appear after a .PROGRAM command in the
      original source text.  Likewise, the FORMAT, RETURN and  END  statements
      at  the end of the subroutine also appear after a .PROGRAM command.  The
      GO TO 4 statement which transfers back to the calling program after  the
      previous  message  and  the labeled CONTINUE statement which defines the
      start of the section to which the computed GO TO transfers  are  defined
      by  a  .DEFINE  GROUP  command and are inserted before the start of each
      message.  The WRITE(ITTY,1) statement which clears each page is  defined
      by  a  .DEFINE TOP command and is inserted at the top of each page.  The
      WRITE(ITTY,2) statement and READ(ITTY,3)IPAUSE statement which tell  the
      user that the program is pausing and then wait for the user to press the
      RETURN key are defined by a .DEFINE BOTTOM command and are  inserted  at
      the bottom of each page.

      .define group
            GO TO 4
      $$$$$ CONTINUE$=
      .define top
            WRITE(ITTY,1)
      .define bottom
            WRITE(ITTY,2)
            READ(ITTY,3)IPAUSE
      .define preface
            WRITE(ITTY,$)
      .program
            SUBROUTINE HELP(ITTY,KNDMSG)
      C     ITTY   = UNIT NUMBER ON WHICH TO DISPLAY MESSAGE
      C     KNDMSG = SELECTS WHICH MESSAGE IS DISPLAYED
            GO TO(100,200,300),KNDMSG
      .use '
      .text 100
               .
            text of short first message
               .
      .text 200
      .paging
               .
            text of long second message
               .
      .page
      .no paging
      .text 300
               .
            text of short third message
               .
      .program
          1 FORMAT('1Top line on page')
          2 FORMAT(' Press RETURN to continue')
          3 FORMAT(1A1)
          4 RETURN
            END

      If the resulting FORTRAN code is to be  used  with  different  types  of
      terminals,  then  the  FORTRAN  code  which  is inserted at the tops and
      bottoms of the pages must perform differently depending upon the type of
      terminal being used.  For example, if a variable named IVIDEO is defined
      so that100                                          FORMAT Program User's Guide


IVIDEO = -1, if a hardcopy terminal is being used

       = 0, if a video terminal is being used which can scroll but which
         cannot clear the screen under program control

       = 1, if a video terminal is being used which can both scroll  and
         clear the screen under program control

then all of these types of terminals would be handled  properly  if  the
text  which  is  inserted at the tops and at the bottoms of the pages is
similar to

.DEFINE TOP
      IF(IVIDEO.LE.0)GO TO 5
         .
      code to clear the screen
         .
    5 CONTINUE
.END DEFINITION

and

.DEFINE BOTTOM
      IF(IVIDEO.LT.0)GO TO 6
         .
      code to pause when the screen fills
         .
    6 CONTINUE
.END DEFINITION      Commands Needed for Paging on Video Terminals                        101


                     Short Descriptions of the Paging Commands
                     ----- ------------ -- --- ------ --------

      Most of the commands which are summarized in this section of the  manual
      and  which  are  described in detail later in this chapter are used only
      when the lines in long messages are being parcelled out into pages.   In
      addition,  the  .BLANK, .LEADING, .NO LEADING, .NO TRAILING, .PARAGRAPH,
      .SKIP and  .TRAILING  commands,  which  were  described  in  an  earlier
      chapter,  are  interpreted  slightly  differently  when  paging is being
      performed.  These differences are also described here.

      Above the description of each command  is  shown  the  command  name  in
      capital letters together with a one line summary in small letters of the
      numbers, characters or line of text which can appear to its  right.   To
      make  the  descriptions  easier  to  read,  the command names are always
      capitalized in the descriptions, but the commands would not have  to  be
      capitalized  in  the actual source text which is processed by the FORMAT
      program.

      .BLANK number of single spaced lines at page bottom times -1

           Enough blank lines are inserted so that there is just  enough  room
           left  at  the bottom of the page for the indicated number of single
           spaced lines.  See also the .SKIP command.

      .BOTTOM line of text to be inserted at bottom of each page

           The line of text which appears to the right of the .BOTTOM  command
           is  to  be  copied  into the output file after the FORMAT statement
           which contains the final line which is  to  be  displayed  on  each
           page.   The  .BOTTOM  command  can  be  cancelled  by  a .NO BOTTOM
           command.  .NO BOTTOM is the  default.   A  group  of  lines  to  be
           inserted  at  the bottom of each page can be defined by the .DEFINE
           BOTTOM command instead.

      .DEFINE BOTTOM

           The following lines  of  text  through  the  next  .END  DEFINITION
           command  or  the next of any of the various .DEFINE commands are to
           be copied into the output file after  the  FORMAT  statement  which
           contains  the  final line which is to be displayed on each page.  A
           single line to be inserted at  the  bottom  of  each  page  can  be
           defined by the .BOTTOM command instead.

      .DEFINE TOP

           The following lines  of  text  through  the  next  .END  DEFINITION
           command  or  the next of any of the various .DEFINE commands are to
           be copied into the output file before the  FORMAT  statement  which
           contains  the  first line which is to be displayed on each page.  A
           single line to be inserted at the top of each page can  be  defined
           by the .TOP command instead.102                                          FORMAT Program User's Guide


.LEADING

     Blank lines are to be  retained  at  the  top  of  each  new  page.
     Opposite  of  .NO LEADING which is the default.  Blank lines at the
     bottom of the page are discarded unless  a  .TRAILING  command  has
     been issued.

.NO BOTTOM

     No line of text is to be inserted at the bottom of each  new  page.
     Opposite of .BOTTOM.  .NO BOTTOM is the default.

.NO LEADING

     Blank lines are discarded at the top of  each  page.   Opposite  of
     .LEADING.  .NO LEADING is the default.

.NO PAGE CARRIAGE

     No special character is to replace the space in the leftmost column
     of  the  lines  which  are  included  on  each.   Opposite of .PAGE
     CARRIAGE.  .NO PAGE CARRIAGE is the default.

.NO PAGING

     The current FORMAT statement is not terminated and a  new  page  is
     not  begun  each time that the page fills.  However, .PAGE commands
     can still be issued to begin a new page and .TEST  PAGE  and  .TEST
     SPACING  commands  can still be issued to begin a new page if there
     are less than the indicated number of lines remaining unused on the
     page.  Opposite of .PAGING.  .NO PAGING is the default.

.NO TOP

     No line of text is to be inserted at the  top  of  each  new  page.
     Opposite of .TOP.  .NO TOP is the default.

.NO TRAILING

     Blank lines are discarded at the bottom of each page.  The page  is
     not  filled out with blank lines to make the number of lines on the
     page equal the page size indicated by  the  .PAGE  LENGTH  command.
     Opposite of .TRAILING.  .NO TRAILING is the default.

.PAGE

     The following text is to be displayed on a new page.  If  there  is
     already  something  on  the  current  page, then the current FORMAT
     statement is terminated and the line defined by the .BOTTOM command
     is  copied  into  the output file.  If subsequent lines of text are
     represented in the FORMAT statements, then the line defined by  the
     .TOP  command is copied into the output file before the next FORMAT
     statement and the first character defined  by  the  .PAGE  CARRIAGE
     command replaces the space in the leftmost column of the first line
     represented in the next FORMAT statement.      Commands Needed for Paging on Video Terminals                        103


      .PAGE CARRIAGE carriage control for top line, for next lines

           The first character which is specified is to replace the  space  in
           the  leftmost  column  of the first line on each page.  If a second
           character is specified, it is to replace the space in the  leftmost
           column  of  each  of the subsequent lines on the page.  Opposite of
           .NO PAGE CARRIAGE which is the default.

      .PAGE LENGTH maximum number of lines on single page

           If paging is enabled, then a new page is begun each time  that  the
           indicated  number  of  lines  have  been represented on the current
           page.

      .PAGE POSITION line count on page as unsigned number
           or
      .PAGE POSITION adjustment of line count as signed number

           If the number following the .PAGE POSITION is unsigned,  then  this
           number  is  taken  to be the number of lines already represented on
           the current page.  If the number is  signed,  then  the  number  of
           lines  already on the page is taken to be the number already on the
           page adjusted by the  indicated  number.   This  command  does  not
           insert or remove any lines from the page but merely places the page
           boundary after a different line.

      .PAGING

           The current FORMAT statement is terminated and a new page is  begun
           each  time  that the page fills.  This parcelling out of lines into
           pages continues through the rest of  the  file.   Opposite  of  .NO
           PAGING which is the default.

      .PARAGRAPH indent, skip lines, unused lines needed on page

           If a .PAGING command has been issued, then a new page is  begun  if
           there is not enough room left on the current page for the indicated
           number of additional lines of text at  the  current  line  spacing.
           The next line of text will be placed into a new paragraph.

      .RESUME BOTTOM

           The line or lines of text which were defined by  either  a  .BOTTOM
           command  or  a  .DEFINE BOTTOM command but which were disabled by a
           subsequent .NO BOTTOM command are  to  again  be  inserted  at  the
           bottom of each new page.

      .RESUME TOP

           The line or lines of text which  were  defined  by  either  a  .TOP
           command  or  a  .DEFINE  TOP  command  but which were disabled by a
           subsequent .NO TOP command are to again be inserted at the  top  of
           each new page.104                                          FORMAT Program User's Guide


.SKIP number of normal spaced lines at page bottom times -1

     Enough blank lines are inserted so that there is just  enough  room
     left at the bottom of the page for the indicated number of lines at
     the current line spacing.  See also the .BLANK command.

.TEST PAGE number of single spaced lines needed on page

     A new page is begun if there is not enough room left  on  the  page
     for the indicated number of additional single spaced lines of text.

.TEST SPACING number of multiple spaced lines needed on page

     A new page is begun if there is not enough room left  on  the  page
     for the indicated number of additional lines of text at the current
     line spacing.

.TOP line of text to be inserted at top of each page

     The line of text which appears to the right of the .TOP command  is
     to be copied into the output file before the FORMAT statement which
     contains the first line which is to be displayed on each page.  The
     .TOP command can be cancelled by a .NO TOP command.  .NO TOP is the
     default.  A group of lines to be inserted at the top of  each  page
     can be defined by the .DEFINE TOP command instead.

.TRAILING

     The bottom of each page will be filled with enough blank  lines  to
     make  the number of lines on the page equal the page size specified
     by the .PAGE LENGTH command.  Opposite of .NO TRAILING which is the
     default.  Blank lines at the top of the page are discarded unless a
     .LEADING command has been  issued.   Blank  lines  before  a  .TEXT
     command  or  at  the  end  of  the  document are discarded unless a
     .TRAILING command has  been  issued  and  an  extra  .PAGE  command
     appears at these locations.      Commands Needed for Paging on Video Terminals                        105


      Table of Command Argument Types and Whether BREAK is Implied
      ----- -- ------- -------- ----- --- ------- ----- -- -------

      Basic         Is .BREAK   Argument      Corresponding
      Command         Implied   Type          NO Command

      .BLANK              yes   negative number
      .BOTTOM             no    text          .NO BOTTOM
      .DEFINE BOTTOM      no    several lines .NO BOTTOM
      .DEFINE TOP         no    several lines .NO TOP
      .LEADING            no    none          .NO LEADING
      .PAGE               yes   none
      .PAGE CARRIAGE      no    2 characters  .NO PAGE CARRIAGE
      .PAGE LENGTH        no    1 number
      .PAGE POSITION      yes   1 number
      .PAGING             yes   none          .NO PAGING
      .PARAGRAPH          yes   3 numbers
      .RESUME BOTTOM      no    none
      .RESUME TOP         no    none
      .SKIP               yes   negative number
      .TEST PAGE          yes   1 number
      .TEST SPACING       yes   1 number
      .TOP                no    text          .NO TOP
      .TRAILING           no    none          .NO TRAILING106                                          FORMAT Program User's Guide


              Complete Descriptions of the Paging Commands
              -------- ------------ -- --- ------ --------

Most of the commands which were summarized earlier in this  chapter  and
which  are  described  in  detail in this section of the manual are used
only when the lines in long messages are being parcelled out into pages.
In   addition,   the   .BLANK,  .LEADING,  .NO  LEADING,  .NO  TRAILING,
.PARAGRAPH, .SKIP and .TRAILING commands, which  were  described  in  an
earlier  chapter,  are  interpreted  slightly differently when paging is
being performed.  These differences are also described here.

Above the description of each command  is  shown  the  command  name  in
capital letters together with a one line summary in small letters of the
numbers, characters or line of text which can appear to its  right.   To
make  the  descriptions  easier  to  read,  the command names are always
capitalized in the descriptions, but the commands would not have  to  be
capitalized  in  the actual source text which is processed by the FORMAT
program.

.BLANK number of single spaced lines at page bottom times -1

     If the .BLANK command is followed by a negative number, then enough
     blank  lines are to be generated before the next line of text which
     is represented in the FORMAT statements to cause there to  be  room
     for  only the indicated number of single spaced lines to be printed
     at the bottom of the page.  The  .SKIP  command  can  similarly  be
     followed  by  a  negative  number to cause enough blank lines to be
     generated to allow room for only the indicated number of  lines  to
     be printed at the current line spacing at the bottom of the page.

     If a .SPACING 2 command has been issued  to  give  double  spacing,
     then  a  .SKIP-5 command would be equivalent to a .BLANK-9 command,
     not to a .BLANK-10 command, since the line spacing after the bottom
     double spaced line would not be included in the line count.  Except
     for the adjustment of the number appearing  to  the  right  of  the
     .SKIP command to allow for the current line spacing, the .BLANK and
     .SKIP commands perform identically.  The description of  the  .SKIP
     command  appearing  later  in  this section of the manual should be
     consulted for additional information.


.BOTTOM line of text to be inserted at bottom of each page

     The characters which appear to the right of the .BOTTOM command  on
     the  same  line are to be copied into the output file on a separate
     line after the FORMAT statements  which  represent  each  completed
     page.   The character to the immediate right of the .BOTTOM command
     must be a space.  The line of text which is to be copied  into  the
     output  file  after  each  completed  page  starts  with the second
     character to the right of the .BOTTOM command, whether or not  this
     is a printing character, and extends through the rightmost printing
     character on the line.  The line of text specified by  the  .BOTTOM
     command  is  copied  into  the  output  file  as a line of ordinary
     FORTRAN  text.   This  line  is  not  represented  in  the   FORMAT
     statements.  For example, the line of text specified by the .BOTTOM
     command might be used to cause the program to pause after a page of
     text  has  been  displayed  until  the  user types something on the      Commands Needed for Paging on Video Terminals                        107


           terminal.  The rules which govern the  specification  of  the  line
           which  is  defined  by  the  .BOTTOM command are identical to those
           which are described earlier in the manual for the .PREFACE command.

           Provided that there is already something on the page, the  line  of
           text  specified  by  the  .BOTTOM command is copied into the output
           file whenever a .PAGE command is issued, or whenever a  .TEST  PAGE
           or  a  .TEST  SPACING  command  fails,  or, provided that a .PAGING
           command has been issued,  whenever  either  the  page  fills  or  a
           .PARAGRAPH  command  is  issued  near the bottom of the page.  If a
           .TRAILING command has been issued,  then  enough  blank  lines  are
           first  represented  in the FORMAT statement to fill the rest of the
           page before the line specified by the .BOTTOM is  copied  into  the
           output  file.  It is not necessary that a .PAGING command have been
           issued before the .PAGE or the .TEST  PAGE  or  the  .TEST  SPACING
           command.

           If more than a single  line  must  be  inserted  after  the  FORMAT
           statements  which  represent  each  completed  page, then a .DEFINE
           BOTTOM command followed by the lines of text and then  by  an  .END
           DEFINITION  command  should  be  used  to define the lines instead.
           Regardless of which method is used to define the line or lines, the
           insertions  of the line or lines are performed similarly.  The line
           of text specified by the .BOTTOM command or the lines specified  by
           the  .DEFINE  BOTTOM  command will continue to be inserted into the
           output file after the FORMAT statements representing each completed
           page  of text until a subsequent .NO BOTTOM command is issued.  The
           insertion of the line or lines will be resumed if a .RESUME  BOTTOM
           command is issued after the .NO BOTTOM command.

           If the current page is empty and a .PAGE POSITION command  has  not
           been  issued,  then  a .PAGE or .TEST PAGE or .TEST SPACING command
           will not fill the page with blank lines and will not cause the line
           of  text  specified  by the .BOTTOM command to be inserted into the
           output file.  If paging has been  enabled,  but  the  page  is  not
           completely full when a .TEXT command is encountered or when the end
           of the source file is reached, then the rest of  the  page  is  not
           filled  with  blank  lines  and  the  line of text specified by the
           .BOTTOM command is not inserted unless a  .TEST  PAGE  or  a  .TEST
           SPACING  command  which fails or a .PAGE command is inserted before
           the .TEXT command or before the end of the input  file.   Inserting
           an  extra  .PAGE command before the .TEXT command or before the end
           of the input file will not cause any problems  even  if  the  final
           page is completely full.

           For example, the source text

           .page length 5.right margin 14.output width 55
           .paging.page carriage 1.no justify.trailing
           .preface       WRITE(ITTY,$)
           .bottom       READ(ITTY,999)LTRDMY
           This is some text on the first page.
           It will be filled with relatively little text.
           .page
           This comes after the page command.
           .program
             999 FORMAT(1A1)108                                          FORMAT Program User's Guide


     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(ITTY,1)
         1 FORMAT(13H1This is some/12H text on the/6H first,
          16H page./11H It will be/12H filled with)
           READ(ITTY,999)LTRDMY
           WRITE(ITTY,2)
         2 FORMAT(11H1relatively/13H little text.///)
           READ(ITTY,999)LTRDMY
           WRITE(ITTY,3)
         3 FORMAT(11H1This comes/15H after the page/5H comm,
          14Hand.)
       999 FORMAT(1A1)

     which would, in turn, generate the following  pages  of  text  when
     run.

     *****************  *****************  *****************
     *1This is some  *  *1relatively    *  *1This comes    *
     * text on the   *  * little text.  *  * after the page*
     * first page.   *  *               *  * command.      *
     * It will be    *  *               *  *****************
     * filled with   *  *               *
     *****************  *****************


.DEFINE BOTTOM

     The .DEFINE BOTTOM command indicates that the  following  lines  of
     source  text  which do not start with periods are to be copied into
     the output file after the FORMAT statements  which  represent  each
     completed page.  The lines which are to be inserted into the output
     file will include all of the lines which do not start with  periods
     in the source text up to the next .END DEFINITION, .PROGRAM, .TEXT,
     .CONTINUE, .GROUP, .PREFACE, .TOP or .BOTTOM command or up  to  any
     of  the  various  .DEFINE commands.  If just a single line is to be
     inserted, then it could also be defined by a .BOTTOM command.   The
     single line would appear to the right of the .BOTTOM command on the
     same line.  Unlike the .BOTTOM command, however, the first line  of
     text  cannot  appear  to the right of the .DEFINE BOTTOM command on
     the same line unless a semicolon appears between the .DEFINE BOTTOM
     command and the rest of the line.

     Regardless of whether a .BOTTOM command or a .DEFINE BOTTOM command
     is  used to define the line or lines, the insertions of the line or
     lines are performed similarly.  The line of text specified  by  the
     .BOTTOM  command  or  the  lines  specified  by  the .DEFINE BOTTOM
     command will continue to be inserted into the output file after the
     FORMAT  statements representing each completed page of text until a
     subsequent .NO BOTTOM command is issued.  The insertion of the line
     or  lines  will  be  resumed  if a .RESUME BOTTOM command is issued
     after the .NO BOTTOM command.

     The Lines of text which are specified by the .DEFINE BOTTOM command
     are stored in the same area as are those which are specified by the
     .GROUP or .DEFINE GROUP, .PREFACE or .DEFINE PREFACE  and  .TOP  or      Commands Needed for Paging on Video Terminals                        109


           .DEFINE  TOP  commands.   There  can be at most 30 lines containing
           together no more than 500 characters in all of these collections of
           lines.   These  lines  include  those  which  have been temporarily
           disabled by the .NO GROUP, .NO  PREFACE,  .NO  TOP  or  .NO  BOTTOM
           commands.

           The description of the .BOTTOM command should be consulted for more
           information  concerning  the  text  which  can  be  inserted at the
           bottoms of the pages.


      .DEFINE TOP

           The .DEFINE TOP command  indicates  that  the  following  lines  of
           source  text  which do not start with periods are to be copied into
           the output file before the FORMAT statement  which  represents  the
           top line on each new page.  The lines which are to be inserted into
           the output file will include all of the lines which  do  not  start
           with  periods  in  the  source text up to the next .END DEFINITION,
           .PROGRAM, .TEXT,  .CONTINUE,  .GROUP,  .PREFACE,  .TOP  or  .BOTTOM
           command  or  up  to any of the various .DEFINE commands.  If just a
           single line is to be inserted, then it could also be defined  by  a
           .TOP  command.   The  single  line would appear to the right of the
           .TOP command on the same line.  Unlike the .TOP  command,  however,
           the  first  line  of text cannot appear to the right of the .DEFINE
           TOP command on the same line unless a semicolon appears between the
           .DEFINE TOP command and the rest of the line.

           Regardless of whether a .TOP command or a .DEFINE  TOP  command  is
           used  to  define  the  line or lines, the insertions of the line or
           lines are performed similarly.  The line of text specified  by  the
           .TOP command or the lines specified by the .DEFINE TOP command will
           continue to be inserted into the  output  file  before  the  FORMAT
           statement  which  represents  the top line on each new page until a
           subsequent .NO TOP command is issued.  The insertion of the line or
           lines  will be resumed if a .RESUME TOP command is issued after the
           .NO TOP command.

           The Lines of text which are specified by the  .DEFINE  TOP  command
           are stored in the same area as are those which are specified by the
           .GROUP or .DEFINE GROUP, .PREFACE or .DEFINE PREFACE and .BOTTOM or
           .DEFINE  BOTTOM commands.  There can be at most 30 lines containing
           together no more than 500 characters in all of these collections of
           lines.   These  lines  include  those  which  have been temporarily
           disabled by the .NO GROUP, .NO  PREFACE,  .NO  TOP  or  .NO  BOTTOM
           commands.

           The description of the .TOP command should be  consulted  for  more
           information  concerning  the text which can be inserted at the tops
           of the pages.110                                          FORMAT Program User's Guide


.LEADING

     The .LEADING command causes blank lines which are requested at  the
     tops  of  pages  to  be  represented in the FORMAT statements.  The
     .TRAILING command causes blank lines which  are  requested  at  the
     bottoms of pages or which are requested just before a .TEXT command
     or at the end of the input file to be  represented  in  the  FORMAT
     statements.   If  both  a  .LEADING command and a .TRAILING command
     have been issued, then blank lines which  are  requested  near  the
     bottom  of  a page for which there is not enough room at the bottom
     of the page will be represented at the top of the next page.

     The .LEADING command is the opposite of the  .NO  LEADING  command.
     .NO  LEADING  is  the  default.  If a .LEADING command has not been
     issued, or if a .NO LEADING command has been issued more  recently,
     then  blank  lines requested at the top of a page or which overflow
     the bottom of the previous page will be discarded.

     For example, the source text

     .page length 5.right margin 14.no justify
     .paging.page carriage 1.output width 55
     .preface       WRITE(ITTY,$)
     .skip
     A LEADING command hasn't been issued.
     .skip 2.page.leading.skip 1
     A LEADING command is now active.
     .trailing.skip 2
     Both LEADING and TRAILING are active.

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(ITTY,1)
         1 FORMAT(10H1A LEADING/15H command hasn't/6H been ,
          17Hissued.)
           WRITE(ITTY,2)
         2 FORMAT(1H1/10H A LEADING/15H command is now/2H a,
          16Hctive./)
           WRITE(ITTY,3)
         3 FORMAT(1H1/13H Both LEADING/13H and TRAILING/1H ,
          111Hare active.)

     which would, in turn, generate the following  pages  of  text  when
     run.

     *****************  *****************  *****************
     *1A LEADING     *  *1              *  *1              *
     * command hasn't*  * A LEADING     *  * Both LEADING  *
     * been issued.  *  * command is now*  * and TRAILING  *
     *****************  * active.       *  * are active.   *
                        *               *  *****************
                        *****************      Commands Needed for Paging on Video Terminals                        111


      .NO BOTTOM

           The line of text specified by a previous  .BOTTOM  command  or  the
           lines of text specified by a previous .DEFINE BOTTOM command are no
           longer to be inserted at the bottom  of  each  completed  page.   A
           .RESUME  BOTTOM  command can, however, be issued later to cause the
           line or lines defined earlier to again be inserted at the bottom of
           each completed page.

           The .NO BOTTOM command is  not  equivalent  to  issuing  a  .BOTTOM
           command  without  anything  to  its  right  or to issuing a .DEFINE
           BOTTOM command immediately followed by an .END DEFINITION  command.
           Neither  a  .BOTTOM  command  without  anything  to its right nor a
           .DEFINE BOTTOM command immediately followed by an  .END  DEFINITION
           command  would allow a .RESUME BOTTOM command to be issued later to
           cause the line or lines defined earlier to again be inserted at the
           bottom of each page.


      .NO LEADING

           The .NO LEADING command causes blank lines which are  requested  at
           the tops of pages to be discarded.  The .NO TRAILING command causes
           blank lines which are requested at the bottoms of  pages  or  which
           are  requested  just  before  a  .TEXT command or at the end of the
           input file to be discarded.  If  both  a  .LEADING  command  and  a
           .TRAILING  command have not been issued, or if either a .NO LEADING
           command or a .NO TRAILING command has been  issued  more  recently,
           then  blank lines which are requested near the bottom of a page for
           which there is not enough room at  the  bottom  of  the  page  will
           likewise be discarded.

           The .NO LEADING command is the opposite of  the  .LEADING  command.
           .NO  LEADING  is  the  default.  If a .LEADING command has not been
           issued, or if a .NO LEADING command has been issued more  recently,
           then  blank  lines requested at the top of a page or which overflow
           the bottom of the previous page will be discarded.


      .NO PAGE CARRIAGE

           No character is to be inserted in place of the space  at  the  left
           end  of  each  line  on the page.  The .NO PAGE CARRIAGE command is
           equivalent  to  the  .PAGE  CARRIAGE  command  issued  without  any
           following  characters.   The  .NO  PAGE  CARRIAGE  command  is  not
           equivalent to a .PAGE CARRIAGE _ ,_  command since the latter would
           cause  spaces  to  be used as the carriage control characters.  The
           .NO  PAGE  CARRIAGE  command  would  cause  skipped  lines  to   be
           represented  in  the  resulting FORMAT statements by merely slashes
           while the .PAGE CARRIAGE _ ,_  command would cause skipped lines to
           be represented by /1X.

           .NO PAGE CARRIAGE is the default.112                                          FORMAT Program User's Guide


     For example, the source text

     .page length 5.right margin 14.output width 55
     .preface       WRITE(1,$)
     .paging.page carriage 1,+.spacing 2.no justify
     This is double spaced on the first page.
     .page.page carriage _ ,_
     This has space as carriage control.
     .page.no page carriage
     This does not have carriage control.

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(1,1)
         1 FORMAT(15H1This is double/1H+/14H+spaced on the/
          11H+/12H+first page.)
           WRITE(1,2)
         2 FORMAT(15H This has space/1X/12H as carriage/1X/
          19H control.)
           WRITE(1,3)
         3 FORMAT(14H This does not//14H have carriage//1H ,
          18Hcontrol.)

     which would, in turn, generate the following  pages  of  text  when
     run.

     *****************  *****************  *****************
     *1This is double*  * This has space*  * This does not *
     *+              *  *               *  *               *
     *+spaced on the *  * as carriage   *  * have carriage *
     *+              *  *               *  *               *
     *+first page.   *  * control.      *  * control.      *
     *****************  *****************  *****************


.NO PAGING

     The lines displayed on each page are still to be counted, but a new
     page  is not to be generated whenever the page fills.  The carriage
     control character, if any, which will be inserted into the left end
     of  each  line  will  be  that  specified by the .CARRIAGE command,
     rather than by the .PAGE CARRIAGE command.   Subsequent  .PARAGRAPH
     commands  will not test the number of lines remaining unused on the
     page.  The .NO PAGING command  terminates  the  parcelling  out  of
     lines  into  separate  pages  which  might have been initiated by a
     previous  .PAGING  command  and  terminates  the  construction   of
     explicitly  declared  pages  which  might  have been initiated by a
     .PAGE command or by a .TEST PAGE or  .TEST  SPACING  command  which
     failed.   The .NO PAGING command terminates the current output line
     but does not terminate the FORMAT statement and does not change the
     number of lines which are considered to be on the page.  .NO PAGING
     is the default.

     A .TEST PAGE or a .TEST SPACING command can still be used  after  a
     .NO  PAGING  command  has  been  issued  to  cause a new page to be
     started if enough room for a specified number  of  lines  does  not      Commands Needed for Paging on Video Terminals                        113


           remain  unused  at the bottom of the page.  If a .TEST PAGE command
           or a .TEST SPACING command fails, i.e. there is not  enough  unused
           room on the page, or if a .PAGE command is issued, then the current
           FORMAT statement will be treated as containing the end  of  a  page
           and  a  new  page will be started.  The .TEST PAGE command or .TEST
           SPACING command which fails or the .PAGE  command  will  cause  the
           current  FORMAT  statement  to be finished, the text specified by a
           .BOTTOM or .DEFINE BOTTOM command to be inserted after  the  FORMAT
           statement,  the  text specified by a .TOP or .DEFINE TOP command to
           be inserted before the  next  FORMAT  statement  and  the  carriage
           control characters specified by a .PAGE CARRIAGE command to be used
           for the following lines.  A new page will not, however, be  started
           whenever  the  current  page  fills.   If a .TEST PAGE command or a
           .TEST SPACING command succeeds, i.e. there is enough unused room on
           the  page, then the .TEST PAGE command or the .TEST SPACING command
           merely terminates the current line and is equivalent  to  a  .BREAK
           command.


      .NO TOP

           The line of text specified by a previous .TOP command or the  lines
           of  text  specified by a previous .DEFINE TOP command are no longer
           to be inserted at the top of each page.  A .RESUME TOP command can,
           however, be issued later to cause the line or lines defined earlier
           to again be inserted at the top of each page.

           The .NO TOP command is not equivalent to  issuing  a  .TOP  command
           without  anything  to its right or to issuing a .DEFINE TOP command
           immediately followed by an .END DEFINITION command.  Neither a .TOP
           command  without  anything  to  its right nor a .DEFINE TOP command
           immediately followed by an .END DEFINITION command  would  allow  a
           .RESUME  TOP  command to be issued later to cause the line or lines
           defined earlier to again be inserted at the top of each page.


      .NO TRAILING

           The .NO TRAILING command causes blank lines which are requested  at
           the  bottoms  of  pages  or which are requested just before a .TEXT
           command or at the end of the input file to be discarded.   The  .NO
           LEADING  command causes blank lines which are requested at the tops
           of pages to be  discarded.   If  both  a  .LEADING  command  and  a
           .TRAILING  command have not been issued, or if either a .NO LEADING
           command or a .NO TRAILING command has been  issued  more  recently,
           then  blank lines which are requested near the bottom of a page for
           which there is not enough room at  the  bottom  of  the  page  will
           likewise be discarded.

           The .NO TRAILING command is the opposite of the .TRAILING  command.
           .NO  TRAILING  is the default.  If a .TRAILING command has not been
           issued, or if a .NO TRAILING command has been issued more recently,
           then  blank  lines  requested  at  the  bottom  of  a  page will be
           discarded.114                                          FORMAT Program User's Guide


.PAGE

     The next lines which are represented in the FORMAT  statements  are
     to  be  placed  on  a new page.  It is not necessary that a .PAGING
     command have been issued.  If some text is on the current page, and
     if  a  .TRAILING  command  has been issued, then enough blank lines
     will be generated to fill the page.  The line of text specified  by
     the  .BOTTOM  command  is  then inserted into the output file.  The
     current page is terminated by generating the blank lines which fill
     the current page and by inserting the line of text specified by the
     .BOTTOM command even if paging is  not  being  performed  when  the
     .PAGE command is issued.

     If a .LEADING  command  has  not  been  issued,  then  blank  lines
     requested  by  a subsequent .BLANK or .SKIP command will be ignored
     until something else is placed into the new page.  The line of text
     specified by the .TOP command will be inserted into the output file
     before the next FORMAT statement.  If the leftmost character in the
     first  line  represented  in  the next FORMAT statement is a space,
     then this space will be replaced by the first  character  specified
     by  the  .PAGE CARRIAGE command.  If the leftmost character in each
     of the second and subsequent lines represented in the  next  FORMAT
     statements  is  a  space  then  this  space will be replaced by the
     second character specified by the .PAGE CARRIAGE command.

     If a .PAGING command has been issued, then the new  page  will  end
     when  the  number of additional lines specified by the .PAGE LENGTH
     command have been represented  in  the  FORMAT  statements.   If  a
     .LEADING command and a .TRAILING command have not both been issued,
     but a .BLANK or a .SKIP command requests a  group  of  blank  lines
     which  extend across the end of the new page, then the lines beyond
     the end of the new page will be lost.  If both a  .LEADING  command
     and  a  .TRAILING command have been issued, and a .BLANK or a .SKIP
     command requests a group of blank lines which extend across the end
     of  the  new page, then all of these lines will be represented even
     if it requires 1 or more fully blank pages to do so.

     If a new page of text is started by a .PAGE command, but a  .PAGING
     command  has  not  been  issued,  then  this  new  page will not be
     terminated when the page fills.  Consequently, a  .BLANK  or  .SKIP
     command  which extends beyond the end of the page will generate all
     of the lines which it specifies, rather than having the blank lines
     be  cut  off  when  the page becomes full, provided that at least 1
     printing line appears after the blank lines.  However,  the  number
     of  lines  on the page will still be counted and can be tested by a
     .TEST PAGE or .TEST SPACING command.  The page will extend  to  the
     next  .TEST  PAGE  or  .TEST SPACING command which fails, or to the
     next .PAGE or .TEXT command.   If  a  .TRAILING  command  has  been
     issued, then the .TEST PAGE or .TEST SPACING command which fails or
     the .PAGE command would fill the rest of the page with blank  lines
     if  it  is  not  already  full.  The .TEST PAGE or .TEST SPACING or
     .PAGE command would then cause the line specified  by  the  .BOTTOM
     command to be inserted.

     If a new page of text is started by a .PAGE command, but a  .PAGING
     command  has not been issued, then a subsequent .TEXT command would
     turn off paging entirely.  If a .TEXT command is encountered, but a      Commands Needed for Paging on Video Terminals                        115


           .PAGING  command  has  not  been issued, then the carriage controls
           specified by a .PAGE CARRIAGE command would not  be  inserted  into
           the left column of the following lines which are represented in the
           FORMAT statements, and the line of text specified by a .TOP command
           would  not  be  inserted  before the next FORMAT statement which is
           generated.  If a .PAGING command has been issued,  then  the  .TEXT
           command  would  start  a new page instead.  Regardless of whether a
           .PAGING command has been issued or not, the line of text  specified
           by  a  .BOTTOM  command is not inserted into the output file at the
           end of the page if the page is terminated by a .TEXT command or  is
           at  the  end  of  the input file unless the page just happens to be
           full.  If the final page is to be filled with blank lines and is to
           be  followed  by the line of text specified by the .BOTTOM command,
           then an extra .PAGE command should precede the .TEXT command or the
           end of the input file.

           For example, the source text

           .page length 5.right margin 14.output width 55
           .no justify
           .preface       WRITE(1,$)
           .page carriage 1
           .paging.trailing
           This page will be terminated early.
           .page
           This sentence is long enough that it will
           have to be continued onto a second page.

           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

                 WRITE(1,1)
               1 FORMAT(15H1This page will/14H be terminated/2H e,
                15Harly.//)
                 WRITE(1,2)
               2 FORMAT(14H1This sentence/15H is long enough/2H t,
                111Hhat it will/11H have to be/15H continued onto)
                 WRITE(1,3)
               3 FORMAT(15H1a second page.)

           which would, in turn, produce the following pages of text when run.

           *****************  *****************  *****************
           *1This page will*  *1This sentence *  *1a second page.*
           * be terminated *  * is long enough*  *****************
           * early.        *  * that it will  *
           *               *  * have to be    *
           *               *  * continued onto*
           *****************  *****************


      .PAGE CARRIAGE carriage control for top line, for next lines

           The  .PAGE  CARRIAGE  command  can  be  followed  by   2   printing
           characters.   If  the  first  character  is  specified,  then  this
           character will replace the space at the left end of the top line on
           each  page.   If  both  characters  are  specified, then the second116                                          FORMAT Program User's Guide


     character will replace the space at the left end of the second  and
     following  lines  on  each  page.   If  only the first character is
     specified, then the space  at  the  left  end  of  the  second  and
     following  lines  on each page is not replaced.  If only the second
     character is specified, then this character will replace the  space
     at the left end of each line on each page.  If no characters follow
     the .PAGE CARRIAGE command, then the space at the left end of  each
     line  on the page will not be replaced.  Depending upon the FORTRAN
     system with which the resulting FORMAT  statements  are  used,  the
     character  at  the  left end of each line may be used as a carriage
     control to set the line spacing when the text is displayed.

     The structure of the .PAGE CARRIAGE command is  identical  to  that
     described  earlier  in  this manual for the .CARRIAGE command.  Any
     number of spaces or a single comma can separate the  characters  if
     both  are  specified,  but  the  spaces or the single comma are not
     necessary.  If only the first character is given, then it does  not
     matter  if  this  is  followed  by  a  comma.   If  only the second
     character is specified, then this must  be  preceded  by  a  single
     comma.   In order to have any of the flag characters or punctuation
     marks be used as the carriage control  characters,  these  must  be
     preceded by an underscore character.

     The characters specified by the .PAGE CARRIAGE command are inserted
     only  while  paging  is  being  performed, either due to a .PAGE or
     .PAGING command having been issued, or due to a .TEST PAGE or .TEST
     SPACING  command  having failed.  The .PAGE CARRIAGE command can be
     issued before paging begins, but the characters  specified  by  the
     command  will  not  be  inserted  until  paging begins.  The second
     character originally specified by a .CARRIAGE command will again be
     inserted  in place of the leftmost space on each line if paging was
     enabled by a .PAGING command and is then terminated by a subsequent
     .NO  PAGING command, or if paging was implied by a .PAGE command or
     by a .TEST PAGE or .TEST SPACING command which failed and  is  then
     terminated  by  a subsequent .TEXT command.  If a .CARRIAGE command
     has not specified a second character, then the space  at  the  left
     end  of each line will be left unchanged when paging is terminated.
     The characters specified by the  .PAGE  CARRIAGE  command  will  be
     inserted again if paging is resumed later.

     The characters specified by the .PAGE CARRIAGE command are inserted
     only  if the character at the left end of the line is a space or if
     the line is completely blank.  It does not matter if the  space  at
     the  left  end  of  the line was requested by an .OFFSET command, a
     .LEFT MARGIN command, an .INDENT command or a  .PARAGRAPH  command.
     A  blank  line into which the character is inserted might have been
     requested by a .BLANK or .SKIP command or might be the line  before
     a  paragraph  or  might be a line required to fill out a page.  The
     characters specified by the .PAGE CARRIAGE command are not inserted
     if  any  printing  character  appears  at the left end of the line.
     Unless either a .NO OFFSET command or a .OFFSET 0 command has  been
     issued, each line will be offset to the right to allow room for the
     insertion of these characters.      Commands Needed for Paging on Video Terminals                        117


           The commands shown below would produce the results described to the
           right.

           .PAGE CARRIAGE 1,* !insert 1 at start of first line
                              !and * at start of following lines
           .PAGE CARRIAGE *,* !insert * at start of each line

           .PAGE CARRIAGE ,*  !same as the above

           .PAGE CARRIAGE 1   !insert 1 at start of first line
                              !but nothing into following lines
           .PAGE CARRIAGE 1,  !same as the above

           For example, the source text

           .page length 5.right margin 14.output width 55
           .no justify.trailing.paging
           .preface       WRITE(1,$)
           .carriage,+
           .page carriage 1-
           This is on a fixed length page.
           .page.no paging
           Paging is not being performed at this point.
           .page
           A page command started this page
           which will not end after a fixed number of lines.

           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

                 WRITE(1,1)
               1 FORMAT(13H1This is on a/13H-fixed length/5H-page,
                11H./1H-/1H-)
                 WRITE(1,2)
               2 FORMAT(14H+Paging is not/6H+being/11H+performed ,
                12Hat/12H+this point./1H+)
                 WRITE(1,3)
               3 FORMAT(15H1A page command/13H-started this/3H-pa,
                18Hge which/13H-will not end/14H-after a fixed/
                210H-number of/7H-lines.)

           which would, in turn, generate the following  pages  of  text  when
           run.

           *****************  *****************  *****************
           *1This is on a  *  *+Paging is not *  *1A page command*
           *-fixed length  *  *+being         *  *-started this  *
           *-page.         *  *+performed at  *  *-page which    *
           *-              *  *+this point.   *  *-will not end  *
           *-              *  *+              *  *-after a fixed *
           *****************  *****************  *-number of     *
                                                 *-lines.        *
                                                 *****************118                                          FORMAT Program User's Guide


.PAGE LENGTH maximum number of lines on single page

     The .PAGE LENGTH command specifies the number of  lines  which  are
     expected  to  appear  on a single page.  If the number appearing to
     the right of the .PAGE LENGTH command  is  not  signed,  then  this
     number  is  used directly as the number of lines which are expected
     on a page.  If the number is signed, then the number of lines which
     are  expected  on  a  page  is  adjusted by this amount.  The .PAGE
     LENGTH command does not itself cause the lines to be parcelled  out
     into pages of the indicated length.

     The number of lines displayed on the page is set to  zero  by  each
     .TEXT  or  .PAGE  command  or  by  each .TEST PAGE or .TEST SPACING
     command which fails.  If a .PAGING command has  been  issued,  then
     the  number of lines displayed on the page is also set to zero each
     time that the current page fills.  The number of  lines  which  are
     considered  to be on the page can be modified by the .PAGE POSITION
     command.  Each line which is represented in the  FORMAT  statements
     increases the number of lines on the page by 1.

     If a .PAGING command has been issued,  then  a  new  page  will  be
     started  each  time that the number of lines specified by the .PAGE
     LENGTH command have been represented on the current page,  as  well
     as  each time that a .PARAGRAPH command is issued closer to the end
     of the page than is specified by the third number which appears  to
     the  right  of  the  .PARAGRAPH  command.   Regardless of whether a
     .PAGING command has  been  issued,  a  new  page  will  be  started
     whenever   a  .TEST  PAGE  or  a  .TEST  SPACING  command  requests
     verification of the availability of more lines  than  would  remain
     unused  on  a  page  of  the  length  specified by the .PAGE LENGTH
     command.

     If a .TRAILING command has been issued, then  the  bottom  of  each
     page  will  be  filled  with  enough  blank lines to make the total
     number of lines on the page be at least  equal  to  the  number  of
     lines  specified  by  the  .PAGE LENGTH command.  The bottom of the
     page is not filled with blank lines and the  text  specified  by  a
     .BOTTOM  or  .DEFINE BOTTOM command is not inserted into the output
     file if the page is terminated by a .TEXT command of if the page is
     terminated by reaching the end of the input file.

     The page size is assumed to be 22 lines if a .PAGE  LENGTH  command
     has  not been issued.  If the video terminal can display a total of
     24 lines, then this reserves 2 extra lines at  the  bottom  of  the
     screen  which  can  be  used for instructions about how the user is
     expected to signal to the program that  the  next  page  should  be
     displayed.      Commands Needed for Paging on Video Terminals                        119


           For example, the source text

           .right margin 14.output width 55.no justify
           .trailing.paging.page carriage 1
           .preface       WRITE(ITTY,$)
           .page length 5
           This page will end with a PARAGRAPH command.
           .paragraph
           This page will end with a TEST PAGE command.
           .test page 2
           This final page will end with a PAGE command.
           .page

           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

                 WRITE(ITTY,1)
               1 FORMAT(15H1This page will/11H end with a/5H PARA,
                15HGRAPH/9H command./)
                 WRITE(ITTY,2)
               2 FORMAT(15H1     This page/14H will end with/2H a,
                110H TEST PAGE/9H command./)
                 WRITE(ITTY,3)
               3 FORMAT(11H1This final/14H page will end/6H with ,
                16Ha PAGE/9H command./)

           which would, in turn, generate the following  pages  of  text  when
           run.

           *****************  *****************  *****************
           *1This page will*  *1     This page*  *1This final    *
           * end with a    *  * will end with *  * page will end *
           * PARAGRAPH     *  * a TEST PAGE   *  * with a PAGE   *
           * command.      *  * command.      *  * command.      *
           *               *  *               *  *               *
           *****************  *****************  *****************


      .PAGE POSITION line count on page as unsigned number
           or
      .PAGE POSITION adjustment of line count as signed number

           The number of lines which are considered to be on the current  page
           is  set  to  or  adjusted  by  the indicated number.  If the number
           appearing to the right of the .PAGE POSITION command is not signed,
           then  the  number of lines is set to the indicated number directly.
           If the number is signed, then the number of lines is incremented by
           the  indicated  number.   The lines indicated by the .PAGE POSITION
           command are assumed to be single spaced so the number of  lines  is
           not  multiplied  by the current line spacing.  If a .PAGING command
           has been issued and  the  .PAGE  POSITION  command  would  fill  or
           overflow  the  page, then the current page is finished and the line
           count on the new page is set to zero.

           A new top of page is generated if the page is empty when the  .PAGE
           POSITION  command is issued and if the start of a new page has been
           requested previously either by a .PAGING  command  or  by  a  .PAGE120                                          FORMAT Program User's Guide


     command or by a .TEST PAGE or a .TEST SPACING command which failed.
     The .PAGE POSITION command can be issued without a following number
     to  generate a new top of page if the current page is empty but not
     change the line count on the page.  If the PAGE POSITION command is
     issued without a number, then another .PAGE POSITION command with a
     number should appear before any other text is  represented  in  the
     FORMAT  statements.  A new bottom of page is generated if the lines
     indicated as being on the page would fill  or  overflow  the  page,
     provided  that  a .PAGING command has been issued so that the lines
     are being parcelled out into pages.  Both a new top of page  and  a
     new  bottom  of  page  will  be  generated  if  the lines are being
     parcelled out into pages and nothing is on the page  when  a  .PAGE
     POSITION command which fills or overflows the page is issued.

     The .PAGE POSITION command is used to adjust the number of lines on
     the  page  to  allow  the  program  which uses the resulting FORMAT
     statements to independently insert lines into the page.  Since  the
     current  page  should  be finished before the lines are inserted if
     these lines would extend across the page  boundary,  a  .TEST  PAGE
     command should be issued before the .PROGRAM command which precedes
     the FORTRAN source code which inserts the lines.  Since  the  .TEST
     PAGE  command  might  generate a bottom of a page, a .PAGE POSITION
     command without a following number should also  appear  before  the
     .PROGRAM  command to generate a new top of page before the inserted
     lines if and only if the page is then empty.  If the text is  being
     multiply  spaced,  or if a .BLANK or a .SKIP command is issued just
     before the .TEST PAGE command, then a .TRAILING command  should  be
     active  when the .PROGRAM command is issued so that the blank lines
     will be represented in the FORMAT  statements  before  the  FORTRAN
     source  code which inserts the lines.  If it is not desired to have
     the .TRAILING command be active elsewhere, then it  can  be  issued
     just  before  the .PROGRAM command and the .NO TRAILING command can
     be issued just after the .PROGRAM command.  The FORTRAN source code
     should  be  followed by a .CONTINUE command if the text which is to
     be represented in the following FORMAT statements is to  appear  on
     the  same page as the inserted lines.  The .CONTINUE command should
     be followed in turn by the .PAGE POSITION command and its following
     number.   The  .PAGE  POSITION  command  with  its following number
     should not be issued before the .PROGRAM command since  that  could
     cause  a  new  bottom  of  page  to be generated prematurely if the
     inserted lines would fill the page.      Commands Needed for Paging on Video Terminals                        121


           A typical sequence for these  various  commands,  for  the  FORTRAN
           SOURCE  code,  and  for  the text which is to be represented in the
           FORMAT statements on either side of the  inserted  lines  is  shown
           below.

                 .
           Text to be on page before inserting 10 lines
                 .
           .blank.test page 10.page position
           .trailing.program.no trailing
                 GO TO 1000 !Transfer to code to insert 10 lines
            1001 CONTINUE   !Return here after inserting 10 lines
           .continue.page position +10.blank
                 .
           Text to be on page after inserting 10 lines
                 .

           For example, the source text

           .paging.page length 5.right margin 14.output width 55
           .no justify
           .top       WRITE(ITTY,1)
           .define bottom
                 WRITE(ITTY,2)
                 READ(ITTY,3)LTRRTN
           .preface       WRITE(ITTY,$)
           .program
                 DATA ITTY/5/
                 KOUNT=0
                 CALL HELP(ITTY,1)
                 DO 2 LINE=1,4
                 KOUNT=KOUNT+1
                 WRITE(ITTY,1)KOUNT
               1 FORMAT(' INSERT',1I3)
               2 CONTINUE
                 CALL HELP(ITTY,2)
                 DO 4 LINE=1,3
                 KOUNT=KOUNT+1
                 WRITE(ITTY,3)KOUNT
               3 FORMAT(' INSERT',1I3)
               4 CONTINUE
                 CALL HELP(ITTY,3)
                 DO 6 LINE=1,4
                 KOUNT=KOUNT+1
                 WRITE(ITTY,5)KOUNT
               5 FORMAT(' INSERT',1I3)
               6 CONTINUE
                 CALL HELP(ITTY,4)
                 STOP
                 END
                 SUBROUTINE HELP(ITTY,KIND)
                 GO TO(100,200,300,400),KIND
             100 CONTINUE
           .text 500
           .page position
           .program
                 GO TO 4122                                          FORMAT Program User's Guide


     C
     C     AFTER FIRST INSERTION
       200 CONTINUE
     .continue
     .page position 4
     This is after 1st insertion.
     .test page 3
     .page position
     .program
           GO TO 4
     C
     C     AFTER SECOND INSERTION
       300 CONTINUE
     .continue
     .page position +3
     This is after 2nd insertion.
     .test page 4
     .page position
     .program
           GO TO 4
     C
     C     AFTER THIRD INSERTION
       400 CONTINUE
     .continue
     .page position +4
     .program
         1 FORMAT('1Read message')
         2 FORMAT(' Press RETURN',_$)
         3 FORMAT(1A1)
         4 RETURN
           END

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           DATA ITTY/5/
           KOUNT=0
           CALL HELP(ITTY,1)
           DO 2 LINE=1,4
           KOUNT=KOUNT+1
           WRITE(ITTY,1)KOUNT
         1 FORMAT(' INSERT',1I3)
         2 CONTINUE
           CALL HELP(ITTY,2)
           DO 4 LINE=1,3
           KOUNT=KOUNT+1
           WRITE(ITTY,3)KOUNT
         3 FORMAT(' INSERT',1I3)
         4 CONTINUE
           CALL HELP(ITTY,3)
           DO 6 LINE=1,4
           KOUNT=KOUNT+1
           WRITE(ITTY,5)KOUNT
         5 FORMAT(' INSERT',1I3)
         6 CONTINUE
           CALL HELP(ITTY,4)
           STOP      Commands Needed for Paging on Video Terminals                        123


                 END
                 SUBROUTINE HELP(ITTY,KIND)
                 GO TO(100,200,300,400),KIND
             100 CONTINUE
                 WRITE(ITTY,1)
                 GO TO 4
           C
           C     AFTER FIRST INSERTION
             200 CONTINUE
                 WRITE(ITTY,501)
             501 FORMAT(14H This is after)
                 WRITE(ITTY,2)
                 READ(ITTY,3)LTRRTN
                 WRITE(ITTY,1)
                 WRITE(ITTY,502)
             502 FORMAT(15H 1st insertion.)
                 GO TO 4
           C
           C     AFTER SECOND INSERTION
             300 CONTINUE
                 WRITE(ITTY,503)
             503 FORMAT(14H This is after)
                 WRITE(ITTY,2)
                 READ(ITTY,3)LTRRTN
                 WRITE(ITTY,1)
                 WRITE(ITTY,504)
             504 FORMAT(15H 2nd insertion.)
                 GO TO 4
           C
           C     AFTER THIRD INSERTION
             400 CONTINUE
                 WRITE(ITTY,2)
                 READ(ITTY,3)LTRRTN
               1 FORMAT('1Read message')
               2 FORMAT(' Press RETURN',$)
               3 FORMAT(1A1)
               4 RETURN
                 END

           which would, in turn, generate the following text when run.

           *****************  *****************  *****************
           *1Read message  *  *1Read message  *  *1Read message  *
           * INSERT  1     *  * 1st insertion.*  * 2nd insertion.*
           * INSERT  2     *  * INSERT  5     *  * INSERT  8     *
           * INSERT  3     *  * INSERT  6     *  * INSERT  9     *
           * INSERT  4     *  * INSERT  7     *  * INSERT 10     *
           * This is after *  * This is after *  * INSERT 11     *
           * Press RETURN  *  * Press RETURN  *  * Press RETURN  *
           *****************  *****************  *****************

           The dollar sign at the right end of the FORMAT statement  which  is
           used  to  tell the user to press the RETURN key is a DECsystem10/20
           notation which prevents the production of a carriage  return  after
           the  text  which is specified by the FORMAT statement.  This causes
           the cursor or printhead to remain to the right of the final line on
           the  page  until the user presses the RETURN key.  This dollar sign124                                          FORMAT Program User's Guide


     must be quoted with an underscore in the  original  text  which  is
     processed  by  the  FORMAT program to prevent its being replaced by
     the number of the next FORMAT statement.


.PAGING

     The .PAGING command indicates that each time the  number  of  lines
     specified  by  the  .PAGE  LENGTH command have been included on the
     current page, then the current FORMAT statement is to be terminated
     and  a  new page is to be started.  The text specified by a .BOTTOM
     command or by a .DEFINE BOTTOM command is inserted into the  output
     file  after the FORMAT statement which specifies the bottom line of
     the page just finished.  The text specified by a .TOP command or by
     a .DEFINE TOP command is inserted before the FORMAT statement which
     specifies the top line on the next page.

     The issuing of the .PAGING command does not immediately cause a new
     page to be started unless the current page is already full when the
     paging command is issued.  If something is already on  the  current
     page  when the .PAGING command is issued, but the page is not full,
     then the rest of the lines on the current page will have the second
     character specified by the .PAGE CARRIAGE command as their carriage
     control characters.  The top line on the next page  will  have  the
     first  character  specified  by  the  .PAGE CARRIAGE command as its
     carriage control character and the second and subsequent  lines  on
     the next page will have the second character specified by the .PAGE
     CARRIAGE command as their  carriage  control  characters.   If  the
     current  page  either  is  empty  or  is  already full when .PAGING
     command is issued, then the next line of text which is  represented
     in the FORMAT statements will be the top line on a new page.

     The number of lines on the page is set to zero  by  each  .TEXT  or
     .PAGE command, or by each .TEST PAGE or .TEST SPACING command which
     fails.  A .CONTINUE command would start a new line in  the  output,
     but  does  not  return  the  line  count to zero.  A .PAGE POSITION
     command can be used  to  modify  the  number  of  lines  which  are
     considered  to  already  be  on  the  page.  None of these commands
     terminate the parcelling out of the lines into pages once a .PAGING
     command  has  been issued.  The .PAGING command does not change the
     number of lines on the page when it is issued unless  the  page  is
     already full.

     The parcelling out of the lines into pages can be terminated  by  a
     subsequent  .NO  PAGING  command.  The counting of the lines on the
     page continues after the .NO PAGING command has  been  issued,  but
     the  carriage  control  characters for the subsequent lines will be
     specified by the previous .CARRIAGE command,  rather  than  by  the
     .PAGE CARRIAGE command.  .NO PAGING is the default.

     It is not necessary that a .PAGING  command  have  been  issued  in
     order  to  obtain  output which is divided into pages.  The .PAGING
     command merely causes the output to be divided into pages each time
     the  page  fills.   The  pages  can also be declared explicitly.  A
     .PAGE command or a .TEST PAGE or a .TEST PAGING command which fails
     would  terminate  the  current  page and start a new page even if a
     .PAGING command has not been issued.  Regardless of which method is      Commands Needed for Paging on Video Terminals                        125


           used  to  terminate the current page and to start the new page, the
           text specified by a .BOTTOM command or by a .DEFINE BOTTOM  command
           is   inserted  into  the  output  file  after  the  current  FORMAT
           statement, the text specified by a .TOP command or by a .DEFINE TOP
           command  is  inserted  before  the  next  FORMAT statement, and the
           carriage control characters specified by the .PAGE CARRIAGE command
           appear at the left ends of the subsequent lines.

           If a .PAGING or .PAGE command or a  .TEST  PAGE  or  .TEST  SPACING
           command  which  fails  has  been  issued, then a .TEXT command will
           terminate the current page, but the bottom of the page will not  be
           filled  with  blank  lines,  and  the  text  specified by a .BOTTOM
           command or by a .DEFINE BOTTOM command will not be inserted  unless
           the  page  is already full when the .TEXT command is issued.  If it
           is desired that an end of page  always  be  produced,  filled  with
           blank lines if a .TRAILING command has been issued, and followed by
           the text specified by a .BOTTOM or .DEFINE BOTTOM command, then the
           .TEXT command should be preceded by an extra .PAGE command.

           If a .PAGING command has been issued,  then  a  TEXT  command  will
           cause  the  text  specified  by  a .TOP command or by a .DEFINE TOP
           command to be inserted before the next FORMAT  statement  and  will
           cause  the characters specified by the .PAGE CARRIAGE command to be
           used as the carriage control characters for the  subsequent  lines.
           However,  if  a .PAGING command has not been issued, then the .TEXT
           command will terminate the use of the carriage  control  characters
           specified by the .PAGE CARRIAGE command and the text specified by a
           .TOP command or by a .DEFINE  TOP  command  will  not  be  inserted
           before the next FORMAT statement.

           For example, the source text

           .page length 5.right margin 14.output width 55
           .no justify.trailing
           .page carriage +-
           .preface       WRITE(ITTY,$)
           .top       WRITE(ITTY,1)
           .define bottom
                 WRITE(ITTY,2)
                 READ(ITTY,3)LTRRTN
           .program
                 DATA ITTY/5/
           .text 100
           This text will not be divided into pages.
           .paging
           This text will be split into pages and will
           use carriage control set by PAGE CARRIAGE.
           Text set by TOP and BOTTOM commands will
           be inserted at page boundary.
           .no paging
           This text will not be divided into pages.
           .program
               1 FORMAT('1Read message')
               2 FORMAT(' Press RETURN',_$)
               3 FORMAT(1A1)
                 END126                                          FORMAT Program User's Guide


     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           DATA ITTY/5/
           WRITE(ITTY,100)
       100 FORMAT(15H This text will/15H not be divided/1H ,
          111Hinto pages./15H-This text will/11H-be split i,
          23Hnto)
           WRITE(ITTY,2)
           READ(ITTY,3)LTRRTN
           WRITE(ITTY,1)
           WRITE(ITTY,101)
       101 FORMAT(15H+pages and will/13H-use carriage/3H-co,
          112Hntrol set by/15H-PAGE CARRIAGE./10H-Text set ,
          22Hby)
           WRITE(ITTY,2)
           READ(ITTY,3)LTRRTN
           WRITE(ITTY,1)
           WRITE(ITTY,102)
       102 FORMAT(15H+TOP and BOTTOM/14H-commands will/2H-b,
          113He inserted at/15H-page boundary./9H This tex,
          26Ht will/15H not be divided/12H into pages.)
         1 FORMAT('1Read message')
         2 FORMAT(' Press RETURN',$)
         3 FORMAT(1A1)
           END

     which would, in turn, generate the following  pages  of  text  when
     run.

     *****************  *****************  *****************
     * This text will*  *1Read message  *  *1Read message  *
     * not be divided*  *+pages and will*  *+TOP and BOTTOM*
     * into pages.   *  *-use carriage  *  *-commands will *
     *-This text will*  *-control set by*  *-be inserted at*
     *-be split into *  *-PAGE CARRIAGE.*  *-page boundary.*
     * Press RETURN  *  *-Text set by   *  * This text will*
     *****************  * Press RETURN  *  * not be divided*
                        *****************  * into pages.   *
                                           *****************


.PARAGRAPH indent, skip lines, unused lines needed on page

     The .PARAGRAPH command indicates that the following lines which are
     represented  in the FORMAT statements will form a new paragraph.  A
     number of blank lines equal to the second argument times  the  line
     spacing  which  has  been set by the previous .SPACING command will
     appear between the previous text and the start  of  the  paragraph.
     The  first  line  of  the  paragraph will be indented from the left
     margin by the number of columns specified by  the  first  argument.
     The  first  2  arguments of the .PARAGRAPH command are described in
     detail earlier in this manual.

     The third argument is ignored if a .PAGING  command  has  not  been
     issued,  or if the current page is empty.  If a .PAGING command has
     been issued, then the third argument specifies the  minimum  number      Commands Needed for Paging on Video Terminals                        127


           of  lines  of text for which there must still be room to be printed
           on the page at the current line spacing  and  in  addition  to  the
           spacing between the paragraphs.  If there is not enough room on the
           current page, and if a .TRAILING command has been issued, then  the
           rest  of  the  current  page  will  be  filled  with  blank  lines.
           Regardless of whether of a .TRAILING command has  been  issued,  if
           the test fails, then the FORMAT statement currently being assembled
           will be closed, and text specified by a .BOTTOM or  .DEFINE  BOTTOM
           command  will  be inserted.  If some text which is to be in the new
           paragraph follows, then the text specified by a .TOP or .DEFINE TOP
           command will be inserted before the text specified by a .PREFACE of
           .DEFINE PREFACE command, and the carriage  control  for  the  first
           line  of the paragraph will be set to the first character specified
           by the previous .PAGE CARRIAGE command.

           If the third argument is missing,  then  the  value  of  the  third
           argument  set by the previous .PARAGRAPH command will be used.  The
           third argument will be assumed to have the value  3  if  the  third
           argument has not been specified in any previous .PARAGRAPH command.

           If a .SPACING 2 command has been issued to get double spacing, then
           a  .PARAGRAPH  5,1,3 command would require that there be at least 8
           unused lines on the page.  This is the sum  of  the  1  blank  line
           after  the  last  line of the previous paragraph, the 2 blank lines
           between the paragraphs requested by  the  second  argument,  the  3
           printed  lines  requested by the third argument, and the total of 2
           blank lines between these printed lines.  The total number of lines
           can be calculated as

                1 less than the current line spacing
           plus the second argument times the current line spacing
           plus the third argument
           plus 1 less than the third argument times 1 less than the line
                spacing.

           For example, the source text

           .page length 10.right margin 24.output width 55
           .paging.page carriage 1.trailing
           .preface       WRITE(ITTY,$)
           .bottom       READ(ITTY,101)IPAUSE
           .paragraph
           This demonstrates that the .PARAGRAPH commands checks
           if there is enough room at the bottom of the page for
           a reasonable number of lines to be printed.
           .paragraph
           This follows a .PARAGRAPH command.  There wasn't enough
           room on the first page for this paragraph.
           .paragraph
           This also follows a .PARAGRAPH command. However, There
           is enough room on the page for it.
           .program
             101 FORMAT(1A1)128                                          FORMAT Program User's Guide


     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(ITTY,1)
         1 FORMAT(25H1     This   demonstrates/9H that    ,
          116Hthe   .PARAGRAPH/25H commands checks if there/
          225H is  enough  room  at the/16H bottom of the p,
          39Hage for a/25H reasonable   number   of/5H line,
          416Hs to be printed.///)
           READ(ITTY,101)IPAUSE
           WRITE(ITTY,2)
         2 FORMAT(25H1     This   follows    a/9H .PARAGRA,
          12HPH,6X,8Hcommand./25H There wasn't enough room/
          225H on  the  first  page for/16H this paragraph./
          3/6X,19HThis also follows a/11H .PARAGRAPH,6X,1Hc,
          47Hommand./25H However, There is enough/7H room o,
          518Hn the page for it.)
           READ(ITTY,101)IPAUSE
       101 FORMAT(1A1)

     which would, in turn, generate the following 2 pages of  text  when
     run.

     *************************** ***************************
     *1     This   demonstrates* *1     This   follows    a*
     * that    the   .PARAGRAPH* * .PARAGRAPH      command.*
     * commands checks if there* * There wasn't enough room*
     * is  enough  room  at the* * on  the  first  page for*
     * bottom of the page for a* * this paragraph.         *
     * reasonable   number   of* *                         *
     * lines to be printed.    * *      This also follows a*
     *                         * * .PARAGRAPH      command.*
     *                         * * However, There is enough*
     *                         * * room on the page for it.*
     *************************** ***************************


.RESUME BOTTOM

     The text specified  by  the  previous  .BOTTOM  or  .DEFINE  BOTTOM
     command,  but  which  was  subsequently  disabled  by  a .NO BOTTOM
     command, is once again to be inserted into the  output  file  after
     the  FORMAT  statement which contains the bottom line on each page.
     A .RESUME BOTTOM command is implied by each new .BOTTOM or  .DEFINE
     BOTTOM  command.  The .RESUME BOTTOM command has no effect if a .NO
     BOTTOM command has not been issued.   The  .RESUME  BOTTOM  command
     cannot  be used to restore the insertion of the text specified by a
     previous .BOTTOM or .DEFINE BOTTOM command but which  was  disabled
     by  a  subsequent  .BOTTOM  or .DEFINE BOTTOM command which did not
     specify any text which was to be inserted.      Commands Needed for Paging on Video Terminals                        129


      .RESUME TOP

           The text specified by the previous .TOP or .DEFINE TOP command, but
           which was subsequently disabled by a .NO TOP command, is once again
           to be inserted into the output file  before  the  FORMAT  statement
           which contains the top line on each page.  A .RESUME TOP command is
           implied by each new .TOP or .DEFINE TOP command.  The  .RESUME  TOP
           command  has  no  effect  if a .NO TOP command has not been issued.
           The .RESUME TOP command cannot be used to restore the insertion  of
           the  text  specified  by a previous .TOP or .DEFINE TOP command but
           which was disabled by a subsequent  .TOP  or  .DEFINE  TOP  command
           which did not specify any text which was to be inserted.


      .SKIP number of normal spaced lines at page bottom times -1

           If the .SKIP command is followed by a negative number, then  enough
           blank  lines are to be generated before the next line of text which
           is represented in the FORMAT statements to cause there to  be  room
           for only the indicated number of lines to be printed at the current
           line spacing at the bottom of the page.   The  .BLANK  command  can
           similarly be followed by a negative number to place the next line a
           specified number of single spaced lines  from  the  bottom  of  the
           page,  rather then allowing enough room for the indicated number of
           lines to be printed at the current line spacing at  the  bottom  of
           the page.

           A .LEADING command does not  have  to  be  active  when  the  .SKIP
           command  is  issued with a negative argument either at the top of a
           page or before any printing characters have been represented in the
           FORMAT  statements.   Enough blank lines will be generated when the
           next line which contains printing characters is represented in  the
           FORMAT  statement  to place this line at the proper location on the
           page regardless of whether  the  page  was  empty  when  the  .SKIP
           command  was issued.  The .SKIP command with a negative argument is
           ignored if the location of the next line would  already  be  at  or
           below the indicated position.

           The .SKIP command can be issued with a negative argument even if  a
           .PAGING  command has not been issued.  If a .PAGING command has not
           been issued, then the page will be assumed to extend from the .TEXT
           command, .PAGE command or .TEST SPACING or .TEST PAGE command which
           generated the last break between the pages.  If a  .PAGING  command
           has not been issued, then a .PARAGRAPH command will not have caused
           the break between the pages.

           The effect of a .SKIP command issued with a  negative  argument  is
           quite  different  from  that of a .TEST SPACING command.  The .SKIP
           command moves the next printed line down on the page so that  there
           is room for only the indicated number of lines to be printed on the
           page.  The .SKIP command never generates a  new  page.   The  .TEST
           SPACING  command  never  changes  the  location of the next line if
           there is enough room left on the page for the indicated  number  of
           lines  to  be  printed.   The .TEST SPACING command instead insures
           that there is enough room left on the page for the indicated number
           of lines to be printed, and starts a new page if there is not.130                                          FORMAT Program User's Guide


     A .SKIP command issued with a negative argument can be followed  by
     a  .TEST  SPACING  command to place the following lines together at
     the bottom of the current page if they will fit or on  the  top  of
     the next page if they will not fit.  Reversing the order of these 2
     commands  would  insure  that  the  following  lines  would  appear
     together  at  the bottom of the current page if they fit, or on the
     bottom of the following page if they do not fit on  the  bottom  of
     the current page.

     If a .SPACING 2 command has been issued to obtain  double  spacing,
     then  a  .SKIP-3 command would generate enough blank lines to place
     the next line at a location 5 lines from the bottom of the page  so
     that there would be only enough room left on the page for 3 printed
     lines and the 2 blank lines between them.  A .BLANK-3 command would
     place  the  next  line at a location 3 lines from the bottom of the
     page regardless of the line spacing.

     For example, the source text

     .page length 10.right margin 24.output width 55
     .paging.page carriage 1
     .preface       WRITE(ITTY,$)
     .bottom       READ(ITTY,101)IPAUSE
     This is single spaced at the top of the page.
     .skip-2
     This is single spaced at the bottom of the page.
     .spacing 2
     This is double spaced at the top of the page.
     .skip-2
     This is double spaced at the bottom of the page.
     .program
       101 FORMAT(1A1)

     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(ITTY,1)
         1 FORMAT(25H1This is single spaced at/9H the top ,
          112Hof the page.///////23H This is single spaced ,
          22Hat/24H the bottom of the page.)
           READ(ITTY,101)IPAUSE
           WRITE(ITTY,2)
         2 FORMAT(25H1This is double spaced at//9H the top ,
          112Hof the page./////25H This is double spaced at/
          2/24H the bottom of the page.)
           READ(ITTY,101)IPAUSE
       101 FORMAT(1A1)      Commands Needed for Paging on Video Terminals                        131


           which would, in turn, generate the following text when run.

           *************************** ***************************
           *1This is single spaced at* *1This is double spaced at*
           * the top of the page.    * *                         *
           *                         * * the top of the page.    *
           *                         * *                         *
           *                         * *                         *
           *                         * *                         *
           *                         * *                         *
           *                         * * This is double spaced at*
           * This is single spaced at* *                         *
           * the bottom of the page. * * the bottom of the page. *
           *************************** ***************************


      .TEST PAGE number of single spaced lines needed on page

           A new page is to be started if there is not enough room left on the
           current  page  for the indicated number of additional single spaced
           lines of text.  The maximum number of lines which  are  assumed  to
           fit  into  the  current  page  is  the  number which was set by the
           previous .PAGE LENGTH command.  The page  is  assumed  to  hold  22
           lines if a .PAGE LENGTH command has not been issued.

           The .TEST SPACING command can similarly be used to check  if  there
           is enough room left on the current page for the indicated number of
           additional lines spaced  according  to  the  most  recently  issued
           .SPACING  command.  If a .SPACING 2 command has been issued to give
           double spacing, then a .TEST SPACING 5 command would be  equivalent
           to a .TEST PAGE 9 command, since a blank line would not have to fit
           into the page below  the  bottom  printed  line.   Except  for  the
           adjustment  of  the  number  appearing  to  the  right of the .TEST
           SPACING command to allow for the current line  spacing,  the  .TEST
           PAGE   and   .TEST   SPACING  commands  perform  identically.   The
           description of the .TEST SPACING command should  be  consulted  for
           additional information.


      .TEST SPACING number of multiple spaced lines needed on page

           A new page is to be started if there is not enough room left on the
           current  page  for the indicated number of additional lines of text
           to be displayed at the line spacing set by  the  previous  .SPACING
           command.  The maximum number of lines which are assumed to fit into
           the current page is the number which was set by the previous  .PAGE
           LENGTH  command.   The  page is assumed to hold 22 lines if a .PAGE
           LENGTH command has not been issued.

           It is not necessary that the lines are  being  parcelled  out  into
           pages  when  the  .TEST SPACING command is issued.  A .TEST PAGE or
           .TEST SPACING command which fails, i.e. which  requires  more  than
           the  remaining  unused  space  on  the  page,  or  a .TEXT or .PAGE
           command, sets the  line  count  on  the  new  page  to  zero.   All
           subsequent  lines  are counted and are considered to be on the same
           page until a new page is started regardless of  whether  a  .PAGING
           command has been issued.132                                          FORMAT Program User's Guide


     If the .TEST SPACING command succeeds, i.e. if there is enough room
     left  on  the current page to display the indicated number of lines
     at the  current  line  spacing,  then  the  .TEST  SPACING  command
     terminates  the  current  output line but does not start a new page
     and is equivalent to  a  .BREAK  command.   If  the  .TEST  SPACING
     command fails, i.e. if there is not enough room remaining unused on
     the current page, then the page is filled with  blank  lines  if  a
     .TRAILING  command has been issued, the current FORMAT statement is
     finished, and the text specified by a  .BOTTOM  or  .DEFINE  BOTTOM
     command  is inserted after the FORMAT statement.  Also, if the test
     fails, then the text specified by a .TOP  or  .DEFINE  TOP  command
     will be inserted before the next FORMAT statement, and the carriage
     control characters specified by the .PAGE CARRIAGE command will  be
     inserted at the left ends of the lines of text on the new page.  If
     a .PAGING command has not been issued, then the next .TEXT  command
     will  resume  the  insertion  of  the  carriage  control  character
     specified by the .CARRIAGE command.

     If NUMBER1 is the number specified by the .TEST SPACING command and
     if  NUMBER2  is the number specified by the .SPACING command, then,
     in order for a new page not to be necessary,  there  must  be  room
     enough  on  the  current  page  for  NUMBER1  printed lines and for
     (NUMBER1-1) groups of (NUMBER2-1) blank lines between  the  printed
     lines.  The number of required lines can then be expressed as

          NUMBER1+((NUMBER1-1)*(NUMBER2-1))

     which is equivalent to

          1+(NUMBER2*(NUMBER1-1))

     where the asterisk represents  multiplication.   If  a  .SPACING  2
     command  has  been  issued  so that the output text is being double
     spaced,  then  a  .TEST  SPACING  5  command  would  test  for  the
     availability   of  9  lines  which  can  be  calculated  either  as
     5+((5-1)*(2-1)) = 5+(4*1) = 9 or as 1+(2*(5-1)) = 1+(2*4) = 9.

     The .TEST PAGE command is similar  to  the  .TEST  SPACING  command
     except  that  the .TEST PAGE command checks if there is enough room
     left on the current page for a specific  number  of  single  spaced
     lines.  If a .SPACING command has not been issued, or if a .SPACING
     1 command has been issued most recently, so that the lines of  text
     are  being  single  spaced,  then the .TEST SPACING command and the
     .TEST PAGE command are equivalent.      Commands Needed for Paging on Video Terminals                        133


           For example, the source text

           .page length 7.right margin 14.output width 55
           .trailing.spacing 2
           .page carriage +-
           .preface       WRITE(ITTY,$)
           .top       WRITE(ITTY,1)
           .define bottom
                 WRITE(ITTY,2)
                 READ(ITTY,3)LTRRTN
           .program
                 DATA ITTY/5/
           .text 100
           TEST SPACING
           .test spacing 3
           commands are
           .test spacing 3
           interspersed
           .test page 5
           among these
           .test page 5
           double spaced
           .test spacing 3
           lines of text.
           .program
               1 FORMAT('1Read message')
               2 FORMAT(' Press RETURN',_$)
               3 FORMAT(1A1)
                 END

           would, when processed by this  program,  be  transformed  into  the
           following FORTRAN text

                 DATA ITTY/5/
                 WRITE(ITTY,100)
             100 FORMAT(13H TEST SPACING//13H commands are////)
                 WRITE(ITTY,2)
                 READ(ITTY,3)LTRRTN
                 WRITE(ITTY,1)
                 WRITE(ITTY,101)
             101 FORMAT(13H+interspersed/1H-/12H-among these/1H-/
                11H-/1H-/1H-)
                 WRITE(ITTY,2)
                 READ(ITTY,3)LTRRTN
                 WRITE(ITTY,1)
                 WRITE(ITTY,102)
             102 FORMAT(14H+double spaced/1H-/15H-lines of text./
                11H-)
               1 FORMAT('1Read message')
               2 FORMAT(' Press RETURN',$)
               3 FORMAT(1A1)
                 END134                                          FORMAT Program User's Guide


     which would, in turn, generate the following  pages  of  text  when
     run.

     *****************  *****************  *****************
     * TEST SPACING  *  *1Read message  *  *1Read message  *
     *               *  *+interspersed  *  *+double spaced *
     * commands are  *  *-              *  *-              *
     *               *  *-among these   *  *-lines of text.*
     *               *  *-              *  *-              *
     *               *  *-              *  *****************
     *               *  *-              *
     * Press RETURN  *  *-              *
     *****************  * Press RETURN  *
                        *****************


.TOP line of text to be inserted at top of each page

     The characters which appear to the right of the .TOP command on the
     same  line are to be copied into the output file on a separate line
     before the FORMAT statement which represents the top line  on  each
     new page.  The character to the immediate right of the .TOP command
     must be a space.  The line of text which is to be copied  into  the
     output  file  before  the  start  of  each new page starts with the
     second character to the right of the .TOP command, whether  or  not
     this  is  a  printing  character, and extends through the rightmost
     printing character on the line.  The line of text specified by  the
     .TOP  command  is copied into the output file as a line of ordinary
     FORTRAN  text.   This  line  is  not  represented  in  the   FORMAT
     statements.   The  line of text specified by the .TOP command might
     be used to clear the screen on a video terminal before the text  on
     the  page  is  displayed  or  to  place  a standard header onto the
     screen.  The rules which govern the specification of the line which
     is  defined  by  the  .TOP command are identical to those which are
     described elsewhere  in  this  manual  for  the  .PREFACE  command.
     Dollar  signs  can appear in the line specified by the .TOP command
     to indicate locations at which the next statement numbers are to be
     inserted,  and  these  statement  numbers  can  be  manipulated  as
     described for the .PREFACE command.

     Provided that a .TRAILING command has been issued and that there is
     already  something  on the page, enough blank lines are represented
     in the FORMAT statement to fill the current page whenever  a  .PAGE
     command  is  issued,  or  whenever  a .TEST PAGE or a .TEST SPACING
     command fails, or, provided that a .PAGING command has been issued,
     whenever  the  page  fills.  Then the line of text specified by the
     .TOP command is copied into the output file just  before  the  next
     line  of text is placed on the next page.  It is not necessary that
     a .PAGING command have been issued before the .PAGE  or  the  .TEST
     PAGE or the .TEST SPACING command.

     If more than a single line  must  be  inserted  before  the  FORMAT
     statement  which  represents  the top line on each new page, then a
     .DEFINE TOP command followed by the lines of text and  then  by  an
     .END DEFINITION command should be used to define the lines instead.
     Regardless of which method is used to define the line or lines, the
     insertions  of the line or lines are performed similarly.  The line      Commands Needed for Paging on Video Terminals                        135


           of text specified by the .TOP command or the lines specified by the
           .DEFINE  TOP  command  will continue to be inserted into the output
           file before the FORMAT statement representing the top line on  each
           new page of text until a subsequent .NO TOP command is issued.  The
           insertion of this text will be resumed if a .RESUME TOP command  is
           issued after the .NO TOP command.

           The .GROUP  or  .DEFINE  GROUP  command  defines  lines  which  are
           inserted  before a logical section of text which could be continued
           onto several pages.  The .TOP or .DEFINE TOP command defines  lines
           which  are  inserted before each new page.  The .PREFACE or .DEFINE
           PREFACE command  defines  lines  which  are  inserted  before  each
           individual  FORMAT  statement.   Typically,  the  .GROUP or .DEFINE
           GROUP command would be used  to  define  a  transfer  back  to  the
           calling  program  when the previous section was completed and would
           construct the numbered statement to which the calling program would
           transfer  to  use  the  current  section.   The .TOP or .DEFINE TOP
           command would define the FORTRAN statements  needed  to  clear  the
           screen  before the first and each subsequent page.  The .PREFACE or
           .DEFINE PREFACE command would insert the WRITE statements needed to
           use  the FORMAT statements.  If several of these types of lines are
           being inserted before a particular FORMAT statement, then the lines
           defined  by the .GROUP or .DEFINE GROUP command are inserted first,
           followed by the lines specified by the .TOP or .DEFINE TOP command,
           followed  in turn by the lines specified by the .PREFACE or .DEFINE
           PREFACE command.

           For example, the source text

           .page length 5.right margin 14.output width 55
           .no justify
           .preface       WRITE(ITTY,$)
           .top       WRITE(ITTY,100)
           .define bottom
                 WRITE(ITTY,101)
                 READ(ITTY,102)LTRDMY
           .end definition
           .paging.trailing
           .program;      ITTY=5
           .text;This page will be terminated early.
           .page
           This sentence is long enough that it will
           have to be continued onto a second page.
           .page
           .program
             100 FORMAT('1Sample Screen'/)
             101 FORMAT(/' Press RETURN',_$)
             102 FORMAT(1A1)
                 END136                                          FORMAT Program User's Guide


     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           ITTY=5
           WRITE(ITTY,100)
           WRITE(ITTY,1)
         1 FORMAT(15H This page will/14H be terminated/2H e,
          15Harly.//)
           WRITE(ITTY,101)
           READ(ITTY,102)LTRDMY
           WRITE(ITTY,100)
           WRITE(ITTY,2)
         2 FORMAT(14H This sentence/15H is long enough/2H t,
          111Hhat it will/11H have to be/15H continued onto)
           WRITE(ITTY,101)
           READ(ITTY,102)LTRDMY
           WRITE(ITTY,100)
           WRITE(ITTY,3)
         3 FORMAT(15H a second page.////)
           WRITE(ITTY,101)
           READ(ITTY,102)LTRDMY
       100 FORMAT('1Sample Screen'/)
       101 FORMAT(/' Press RETURN',$)
       102 FORMAT(1A1)
           END

     which would, in turn, generate the following  pages  of  text  when
     run.

     *****************  *****************  *****************
     *1Sample Screen *  *1Sample Screen *  *1Sample Screen *
     *               *  *               *  *               *
     * This page will*  * This sentence *  * a second page.*
     * be terminated *  * is long enough*  *               *
     * early.        *  * that it will  *  *               *
     *               *  * have to be    *  *               *
     *               *  * continued onto*  *               *
     *               *  *               *  *               *
     * Press RETURN  *  * Press RETURN  *  * Press RETURN  *
     *****************  *****************  *****************

     The dollar sign in the FORMAT statement in the above example  is  a
     DECsystem10/20 notation for preventing a carriage return from being
     included at the end of a line which is displayed on  the  terminal.
     This allows the screen cursor to remain to the right of the request
     until the user presses the RETURN key.


.TRAILING

     The .TRAILING command indicates that each page which is  terminated
     by  a  .PAGE  command  or  by a .TEST PAGE or .TEST SPACING command
     which fails is to be filled with enough blank  lines  to  make  the
     number  of lines on the page be equal to the page size specified by
     the .PAGE LENGTH command.   If  both  a  .TRAILING  command  and  a
     .PAGING  command  have been issued, then a .PARAGRAPH command which
     appears closer to the bottom of the page than the number  of  lines      Commands Needed for Paging on Video Terminals                        137


           specified  by  the  third  number  appearing  to  the  right of the
           .PARAGRAPH command will also fill the bottom of the page with blank
           lines.   Regardless of whether a .PAGING command has been issued, a
           page which is terminated by a .TEXT command or which is at the  end
           of the input file will not be filled with blank lines.  However, if
           a .TRAILING command has been issued, then any blank lines requested
           by  a  .BLANK  or .SKIP command just before the .TEXT command or at
           the end of the input file, and the interline spacing requested by a
           .SPACING command, will be represented at the bottom of the page.

           If both a .TRAILING  command  and  a  .LEADING  command  have  been
           issued,  then any blank lines requested at the bottom of a page for
           which there is not enough room on that page will be  shown  at  the
           top  of  the  next  page.   If both of these commands have not been
           issued, then blank lines which are requested at  the  bottom  of  a
           page,  but  for  which  there  is not enough room on that page, are
           discarded.

           If the output text is not being paged, then  the  .LEADING  command
           can  be  used  to  obtain  blank  lines  requested  at the start or
           immediately after a .TEXT command, and the .TRAILING command can be
           used  to  obtain blank lines requested at the end of the input file
           or immediately before a .TEXT command.  Regardless of  whether  the
           output  text  is  being  paged,  the  .TRAILING command changes the
           timing of the representation of blank  lines  which  are  requested
           just  before  a .PROGRAM command.  If the .TRAILING command has not
           been issued, then it is not known  when  the  .PROGRAM  command  is
           issued  whether  the blank lines will be needed, so the blank lines
           must be reserved until after the next .CONTINUE  command.   If  the
           .TRAILING  command  has been issued, then the blank lines requested
           immediately before a .PROGRAM command are represented in the FORMAT
           statement before the lines of the text appearing after the .PROGRAM
           command are copied as FORTRAN statements into the output file.

           The .TRAILING command is the opposite of the .NO TRAILING  command.
           If  a  .NO  TRAILING  command  has  been  issued, or if a .TRAILING
           command has not been issued, then the bottoms of the pages are  not
           filled  with  blank  lines  and  none  of the blank lines requested
           immediately before a .TEXT command or at the end of the input  file
           are represented in the FORMAT statements.

           For example, the source text

           .page length 5.right margin 14.no justify
           .paging.page carriage 1.output width 55
           .preface       WRITE(ITTY,$)
           A TRAILING command hasn't been issued.
           .page.trailing
           A TRAILING command is now active.
           .test page 3
           This comes after the TEST PAGE command.138                                          FORMAT Program User's Guide


     would, when processed by this  program,  be  transformed  into  the
     following FORTRAN text

           WRITE(ITTY,1)
         1 FORMAT(11H1A TRAILING/15H command hasn't/5H been,
          18H issued.)
           WRITE(ITTY,2)
         2 FORMAT(11H1A TRAILING/15H command is now/5H acti,
          13Hve.//)
           WRITE(ITTY,3)
         3 FORMAT(11H1This comes/15H after the TEST/5H PAGE,
          19H command.)

     which would, in turn, generate the following  pages  of  text  when
     run.

     *****************  *****************  *****************
     *1A TRAILING    *  *1A TRAILING    *  *1This comes    *
     * command hasn't*  * command is now*  * after the TEST*
     * been issued.  *  * active.       *  * PAGE command. *
     *****************  *               *  *****************
                        *               *
                        *****************


                                     Appendix A



                         FORMAT Program Development History
                         ------ ------- ----------- -------

      May 1980
          Original release of the FORMAT program through DECUS library.

      August 1980
          (correction) Empty lines were being discarded when multiple  spacing
          in  nofill  mode.  A line represented by merely a semicolon to right
          of a command was being discarded when in nofill mode.

      August 1983
          The following  commands  were  added  to  support  paging  on  video
          terminals.   The  general  function of each group of new commands is
          listed at the top.

          screen top  screen bottom  1st statement new statement
          .TOP        .BOTTOM        .GROUP        .DEFINE PREFACE
          .DEFINE TOP .DEFINE BOTTOM .DEFINE GROUP .RESUME PREFACE
          .NO TOP     .NO BOTTOM     .NO GROUP
          .RESUME TOP .RESUME BOTTOM .RESUME GROUP

          select paging    page characteristics  other
          .PAGING          .PAGE LENGTH          .END DEFINITION
          .NO PAGING       .PAGE CARRIAGE        .PAGE POSITION
          .PAGE            .NO PAGE CARRIAGE
          .TEST PAGE
          .TEST SPACING

          (change) The .LENGTH command has been renamed  .OUTPUT  LENGTH,  the
          .BEGIN  command  has been renamed .TEXT, and the .FORMAT command has
          been renamed .CONTINUE, but the previous names are still recognized.

          (change) A preface line is no longer cancelled by a .TEXT command.

          (extension) The .COMMENT command has been added to allow  commenting
          of the source file.

          (extension) The  .BLANK  and  .SKIP  commands  now  accept  negative
          arguments  to allow skipping to within the indicated number of lines
          at the bottom of the page on a video terminal.

          (extension) The .PARAGRAPH command  now  accepts  a  third  argument
          which is the number of additional lines for which there must be room
          on the page.  A new page is generated if there is not enough space.

          (extension) The  dollar  signs  appearing  within  the  range  of  a
          .PROGRAM  command,  as  well  as  in  the  text defined by the .TOP,
          .BOTTOM, .GROUP and .PREFACE commands, can now  be  followed  by  an
          equal  sign  to change the number of the next statement or by a plus
          or minus sign to temporarily modify the value which is  copied  into
          the output.




                                     Appendix B



                       List of Files Included in this Package
                       ---- -- ----- -------- -- ---- -------

      ABSTRA.RNO  Abstract  containing  a  short  description  of  the  FORMAT
                  program.

      FMTD10.FOR  A  version  of  the  FMTASK  and  FMTEND  routines  for  the
                  DECsystem10  and  DECsystem20 computers.  The FMTASK routine
                  asks for the user to specify the input file  and  opens  it,
                  then  asks for the user to specify the output file and opens
                  it.  The FMTEND routine closes the files when they are done.
                  These routines are simple and can be modified easily for use
                  on other computers.

      FORMAT.DOC  The instruction manual.  This  was  produced  by  using  the
                  FROFF word processor to process the rough form of the manual
                  in the FORMAT.RNO file.

      FORMAT.FOR  The system independent portion of the FORMAT program.   This
                  must  be  loaded  with  a  version  of the FMTASK and FMTEND
                  routines customized for the computer  on  which  the  FORMAT
                  program will be used.

      FORMAT.GET  File containing the results which are expected when the test
                  cases  in  the  FORMAT.TRY  file are processed by the FORMAT
                  program.

      FORMAT.KEY  Data  file  which  when  processed  by  the  KEYWRD  program
                  produces the BLOCK DATA routine which defines the vocabulary
                  of commands recognized by the FORMAT program.

      FORMAT.RNO  The rough form of the instruction manual.  This is meant  to
                  be processed by the FROFF word processor.

      FORMAT.TRY  A group of test cases which when  processed  by  the  FORMAT
                  program  should  produce  a file identical to the FORMAT.GET
                  file.