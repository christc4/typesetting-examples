

                   Vax Conversion Team Project Plan
                   Vax Conversion Team Project Plan

         Events in a Conversion from a Dec-10 to a Vax-11/780
         Events in a Conversion from a Dec-10 to a Vax-11/780


                                  by

                           Charles Anthony
                           Charles Anthony
                        Richard A. Farrenkopf
                        Richard A. Farrenkopf
                            David Russell
                            David Russell












                              CHAPTER 1

                       OVERVIEW OF PROJECT PLAN
                       OVERVIEW OF PROJECT PLAN



1.1  INTRODUCTION
     INTRODUCTION

     This  document  will  discuss  a  project  to  convert  Corporate
Purchasing's   application  systems  from  a  Dec-10  computer  system
(PDCF::) to a Vax-11/780 to be installed in a new NR05 Data Center.  A
team   was  put  together  to  aid  in  this  process  whose  specific
responibilities are discussed below.



1.2  GOAL
     GOAL

     The goal of the Vax  conversion  team  is  to  provide  technical
support  to  assist  in  intelligent  decison  making in the migration
process.  This will include developing  a  project  plan  for  initial
conversion   decisions  and  events  that  are  necessary  before  the
Corporate Purchasing Mis  programming  staff  is  able  to  begin  the
conversion  of  any specific systems.  It is also to act as a resource
for specific technical  problems.   We  will  work  with  Data  Center
representatives in order to make decisions about hardware and software
resources.  This will include setting up  user-accounts,  user-quotas,
the  residence of data files, programs, libraries, etc.  It is also to
develop guidelines for naming conventions for files and programs,  and
systems.  We shall also serve as a communications link between project
leaders so as to ensure a cohesive translation of systems.   We  shall
provide   common  application  tools  for  the  programming  and  user
community such as  a  front-end  system.   We  also  plan  to  provide
training  seminars  as  it  becomes  necesary  to  ensure  the  proper
education of the programming staff in efficient a manner as possible.



1.3  TASKS
     TASKS


     1.  Achieve optimum level of expertise on Vax
         Achieve optimum level of expertise on Vax

              In order to be able to provide the  level  of  technical
         support  that  is  needed  in such a conversion effort, it is
         imperative  that  the  conversion  team  become   initimately
         familiar  with  both Vax software and hardware.  This inludes
         both  formal  training  courses  and  'hands-on'  experience.
         Formal  training  courses  included  a Vax Utilities/Commands
         Course, a  Datatrieve  Programming  Course,  a  Vax-11  Cobol
OVERVIEW OF PROJECT PLAN                                      Page 1-2
OVERVIEW OF PROJECT PLAN


         Course,  and  a  Systems  Manager's  Course.   These  courses
         provided us with a firm but very broad understanding  of  the
         Vax  and  its  capabilities.   We are expanding this knowlege
         through the process of solving specific problems we  know  to
         exist as will be explained later as a seperate task.

     2.  Provide training for other members of programming staff
         Provide training for other members of programming staff

              This  initially  will  consist  of  ensuring  that   all
         necessary  personnel attend formal training courses.  However
         this responsiblity will grow  as  we  get  further  into  the
         conversion  process.   The  basic reason for this is that the
         formal courses in Bedford are forced to cover  a  very  great
         deal  of material in a relatively short period of time.  Thus
         the conversion team feels it is necessary to complement  this
         training  with  our  own  internal  mini-presentaions.  These
         presentaions will be meant to serve as a medium  for  sharing
         vital details necessary to us that might have been overlooked
         by the formal training.  They are not  meant  to  and  cannot
         serve  as a substitute for 'hands-on' experience, but will be
         an open forum for the presentation and discussion of the  Vax
         software tools available to us.  We will also prepare written
         documentaion of information we feel will be  helpful  to  the
         programming  staff.  A copy of all this documentation will be
         included in a seperate chapter.

     3.  Investigate other Dec Vax sites
         Investigate other Dec Vax sites

              Since our MIS group started off  generally  lacking  Vax
         expertise,  we  found  it necesary to look around the general
         Digital community looking for groups  who  had  gone  through
         some  type  of  conversion  process  or  simply  had  any Vax
         experience or advice they could offer.  Although  so  far  we
         have  been  unable to find any groups who have had experience
         with a converion project of the size we are  undertaking,  we
         were  able to find many users who offered us valuable advice.
         We are continuing to pursue this task actively.

     4.  Determine Structure of Major Master Files
         Determine Structure of Major Master Files

              We identified three main  master  files  that  currently
         existed to support our Purchasing applications.  In order for
         these systems to continue to exist and  continue  to  support
         our users, we realized that we needed to develop a comparable
         database on our new Vax.  The three files we identified  were
         the  Master-Parts  File,  the  Bill-Of-Material File, and the
         Vendor-Master File which all existed on the  Decsystem-10  as
         random    access    files.    Initially   because   of   time
         considerations  we  did  not  consider  Vax-11  DBMS  as   an
         alternative for our implementation.  We narrowed our decision
         to a choice between relative and indexed RMS file structures.
         A  full  discussion  of  this  is found in a chapter entitled
         'MASTER FILES'.

     5.  Determine Necessary Software for Vax
         Determine Necessary Software for Vax

              We compiled a list of all software we thought  would  be
         applicable  for  our  Vax  environment.   Not  all  of it was
         immediatley necessary but we  thought  it  would  be  a  good
OVERVIEW OF PROJECT PLAN                                      Page 1-3
OVERVIEW OF PROJECT PLAN


         investment  for  the  future.   A  seperate  chapter has been
         devoted to this subject.

     6.  Evaluation of 1032 vs DATATRIEVE
         Evaluation of 1032 vs DATATRIEVE

              In migrating our application systems from a Decsystem-10
         to a Vax-11/780, we are faced with the problem of reproducing
         the functionality that our users both  required  and  enjoyed
         with their previous systems.  This includes machine interface
         in  terms  of  user-friendly  screens  and   data   retrieval
         capabilities.   Corporate Purchasing utilized 1022 to a great
         extent on the  DECsystem-10.   Comparable  functionality  was
         available   through   two  products  on  the  Vax,  1032  and
         Datatrieve.  Our decision around this is discussed at  length
         in a seperate chapter.

     7.  Assist Data-Center
         Assist Data-Center

              The Data Center for Corporate Purchasing has not as  yet
         been  fully staffed.  Because of this, this team is needed to
         assist the Data Center in such areas as  software  selection,
         designing  security  around user-accounts, designing security
         around  Common   Data   Dictionary   Directories,   designing
         system-specific  startup  and  login  files,  getting network
         availability on the Digital  Business  Network,  and  general
         support.   We  will  be  working  with  the Data Center Staff
         during the installation  of  our  software  and  attending  a
         DEC-START  seminar  presented  by Internal Software Services.
         These general tasks will be documented in a seperate  chapter
         as the specifics are accomplished.

     8.  Write Menu-Driven Front-End System for Vax
         Write Menu-Driven Front-End System for Vax

              The user community of Corporate Purchasing was  used  to
         and  very  much  liked a front-end system that existed on the
         Decsystem-10.  The source code of this system, which belonged
         to the spec-control group, was unavailable to us for security
         reasons.  We thus undertook the project of  writing  our  own
         front-end  system  for  our Vax.  The details of this project
         are left for another chapter.













                              CHAPTER 2

                      DOCUMENTATION AND TRAINING
                      DOCUMENTATION AND TRAINING



2.1  PURPOSE AND USE OF TENVAX
     PURPOSE AND USE OF TENVAX



     The DECsystem-10 does not write tapes in a standard ANSI labelled
format that is recognizable by the Vax/Vms operating system.  Thus any
tapes written on the Dec-10 using Backup or Copy will not be  able  to
be  read  by  the  Vax.  In order to solve this problem, a utility was
written which will easily transfer data files between a Dec-10  and  a
Vax.   Tenvax can copy files from a Dec-10 disk structure to a Vax/Vms
       Tenvax can copy files from a Dec-10 disk structure to a Vax/Vms
formatted tape.  It can also copy files from a Vax/Vms formatted  tape
formatted tape
to   a   Dec-10  disk  structure.   (This  document  will  only  cover
transferring files from the Dec-10 to the Vax).  The only  restriction
                                                 The only  restriction
for  this is that files be written in an Ascii format with no imbedded
for  this is that files be written in an Ascii format with no imbedded
computational fields.  These  files  may  contain  fixed  or  variable
computational fields.  These  files  may  contain  fixed  or  variable
length  records  and  may  span more that one tape volume.  A detailed
length  records  and  may  span more that one tape volume
discussion of the use of Tenvax follows.

     As is mentioned above some preperation of a file may be  required
before  it  is transferred through Tenvax.  Cobol programs should have
no line-numbers which might have been left on by an editor.  It is not
the  end  of  the world if line numbers are left on;  nevertheless you
will save yourself needless work in removing them on the Vax  side  if
you  make  sure  they are removed initially.  Data files which contain
Comp fields however are  quite  a  different  story.   A  field  in  a
                                                       A  field  in  a
Computational  format  cannot be directly brought over from the Dec-10
Computational  format  cannot be directly brought over from the Dec-10
to the Vax.  This is primarily  because  of  the  difference  in  word
to the Vax.  This is primarily  because  of  the  difference  in  word
length  between  the  two  machines.   Also the blocking factor of the
length  between  the  two  machines.   Also the blocking factor of the
files should be changed to 0 (i.e un-blocked files) before any attempt
files should be changed to 0 (i.e un-blocked files) before any attempt
is made to bring them over.
is made to bring them over

     A detailed example of transferring a Cobol  program  (MYPROG.CBL)
and  two  data  files  (FILE1.DAT and FILE2.DAT) follows.  The program
contains no line numbers.  The first data file(FILE1.DAT)  is  sixbit,
block 2, and contains no Comp Fields.  The second data file(FILE2.DAT)
is Sixbit, block 10, and does contain Comp fields.   Both  data  files
contain  fixed  length  250 character records and are assumed to be in
sequential or random-access organization.  If you wish to transfer  an
indexed  file,  the examples below would have to be changed to reflect
this (access mode is indexed....move  low-values  to  key...etc..   or
pack the ISAM file depending upon the existence of comp fields).
DOCUMENTATION AND TRAINING                                    Page 2-2
DOCUMENTATION AND TRAINING


     1.  Prepare files for Tenvax
         Prepare files for Tenvax

              Since the file MYPROG.CBL contains no line  numbers,  it
         requires  no  preparation.   A  data file which contains Comp
                                      A  data file which contains Comp
         fields or is Sixbit or has a blocking  factor  other  than  0
         fields or is Sixbit or has a blocking  factor  other  than  0
         does require preparation.  FILE1.DAT contains no Comp Fields.
         does require preparation.  FILE1.DAT contains no Comp Fields.
         Thus this file can be converted with a system-utility  called
         Thus this file can be converted with a system-utility  called
         CIP.   The  following  sequence of commands converts the file
         CIP
         FILE1.DAT(block 2, sixbit, record 250) to FILE1.VAX (block 0,
         ascii, record 250).

                1. RUN PUB:CIP
                    *PUR8:FILE1.VAX_PUR8:FILE1.DAT
                    blocking for input file: 2
                    mode of input file: S
                    blocking for output file: 0
                    mode of input file: A
                    record size: 250
                    2400 records copied
                    *^c

              It is critical to note that  the  above  process  worked
              It is critical to note that  the  above  process  worked
         because  FILE1.DAT  contained no COMP fields.  If CIP is used
         because  FILE1.DAT  contained no COMP fields.  If CIP is used
         for files which do contain COMP  fields,  these  fields  will
         for files which do contain COMP  fields,  these  fields  will
         remain  as  computational in the output file and the Vax will
         remain  as  computational in the output file and the Vax will
         not understand them.   The  second  file  we  must  transport
         not understand them.   The  second  file  we  must  transport
         (FILE2.DAT)  is just such a file.  In order to transport this
         (FILE2.DAT)  is just such a file.  In order to transport this
         file, a Cobol program should be written to sequentially  read
         file, a Cobol program should be written to sequentially  read
         the  file  and  write  a block 0, Ascii file that contains no
         the  file  and  write  a block 0, Ascii file that contains no
         Comp fields.  An example follows:
         Comp fields
                 2. IDENTIFICATION DIVISION.
                    PROGRAM-ID. FILCVT.
                    AUTHOR. Rick Farrenkopf
                    DATE-WRITTEN. MAY 13,1983
                    REMARKS. Dec-10 TO Vax Conversion.
                    ENVIRONMENT DIVISION.
                    CONFIGURATION SECTION.
                    SOURCE-COMPUTER. DECsystem-10.
                    OBJECT-COMPUTER. DECsystem-10.
                    INPUT-OUTPUT SECTION.
                    FILE-CONTROL.
                         SELECT INPUT-FILE
                                ASSIGN TO DSK001
                                ACCESS MODE IS SEQUENTIAL
                                RECORDING MODE IS SIXBIT.
                         SELECT OUTPUT-FILE
                                ASSIGN TO DSK002
                                ACCESS MODE IS SEQUENTIAL
                                RECORDING MODE IS ASCII.
                    DATA DIVISION.
                    FILE SECTION.
          
                    FD   INPUT-FILE
                         BLOCK CONTAINS 10 RECORDS
                         RECORD CONTAINS 250 CHARACTERS
                         LABEL RECORDS ARE STANDARD
                         VALUE OF IDENTIFICATION IS "FILE2 DAT"
                         DATA RECORD IS INPUT-FILE-RECORD.
                    01   INPUT-FILE-RECORD.
DOCUMENTATION AND TRAINING                                    Page 2-3
DOCUMENTATION AND TRAINING


                      02 INPUT-1         PIC 9(4) USAGE IS COMP.
                      02 INPUT-2         PIC 9(6) USAGE IS COMP.
                      02 INPUT-3         PIC X(238).

                    FD   OUTPUT-FILE
                         BLOCK CONTAINS 0 RECORDS
                         RECORD CONTAINS 248 CHARACTERS
                         LABEL RECORDS ARE STANDARD
                         VALUE OF IDENTIFICATION IS "FILE2 VAX"
                         DATA RECORD IS OUTPUT-FILE-RECORD.
                    01   OUTPUT-FILE-RECORD.
                      02 OUTPUT-1        PIC 9(4).
                      02 OUTPUT-2        PIC 9(6).
                      02 OUTPUT-3        PIC X(238).
                            
                            |
                            |
                            V
                    PROCEDURE DIVISION.
                    OPEN-FILES.
                          OPEN INPUT INPUT-FILE.
                          OPEN OUTPUT OUTPUT-FILE.
                    LOOP.
                          READ INPUT-FILE AT END,
                                  GO TO END-OF-PROGRAM.
                          MOVE INPUT-1 TO OUTPUT-1.
                          MOVE INPUT-2 TO OUTPUT-2.
                          MOVE INPUT-3 TO OUTPUT-3.
                          WRITE OUTPUT-FILE-RECORD.
                          GO TO LOOP.
                    END-OF-PROGRAM.
                          CLOSE INPUT-FILE.
                          CLOSE OUTPUT-FILE.
                          STOP RUN.

              We now have 3 file ready to be brought over.   They  are
         MYPROG.CBL,  FILE1.VAX,  and  FILE2.VAX.  One should note the
         difference in record length between the input and output file
         (250  and  248  characters respectively).  This difference is
         caused by the fact that the input file has  comp  fields  and
         the output file does not.

     2.  Mount an IT scratch tape
         Mount an IT scratch tape
               .MOUNT MTA:TAPE/VID:"1600 BPI IT SCRATCH TAPE FOR RICK"/WE

     3.  Copy files to tape with Tenvax
         Copy files to tape with Tenvax
               .R TENVAX
               Welcome to TENVAX, version 2.0. Type HELP for assistance.
               Tape Drive:  TAPE:
               ... at beginning of volume

               TENVAX function:  WRITE
               Files:  MYPROG.CBL,FILE1.VAX,FILE2.VAX
               Block Size <8192>: <cr>
               ... at beginning of volume, assuming new volume set
               Volume Set Name <NONAME>: RICK
               Volume Set Tape Density <1600>: <cr>
               ... writing PUR8:MYPROG.CBL[4040,20273]
               ... writing PUR8:FILE1.VAX[4040,20273]
DOCUMENTATION AND TRAINING                                    Page 2-4
DOCUMENTATION AND TRAINING


               ... writing PUR8:FILE2.VAX[4040,20273]
               ... at end of volume set

               TENVAX function:  REWIND
               ... at beginning of volume

               TENVAX function:  DIRECT
               Files <*.*>: <cr>
               ... searching tape
               ... volume RICK
               MYPROG.   CBL    13-MAY-83
               FILE1.    VAX    13-MAY-83
               FILE2.    VAX    13-MAY-83
               ... at end of volume set

               TENVAX function:  REWIND
               ... at beginning of volume

               TENVAX function:  EXIT

              .DISMOUNT/RELEASE TAPE:

     4.  Copy files onto Vax at NR02
         Copy files onto Vax at NR02

              After you are finished with the above step,  you  should
         request  that  the tape be sent to you through the mail.  You
         should then clearly mark on the  tape  the  volume  set  name
         (internal  label  of tape), the density, your name, your DTN,
         the fact that it was written with TENVAX, and the area on the
         Vax  you wish the files to be copied.  You may then give them
         to me and I will take them up to NR02 for  you.   You  should
         then allocate a tape drive with the following command:

         $ ALLOCATE MFA0:  (NR02 has 2 drives MFA0 and MFA1)

         You should then call the NR02 Data Center at  Ext.   4225  or
         4496  and request that your tape be mounted on the tape drive
         that you have allocated.  You should then issue the following
         commands:

         $ MOUNT MFA0: RICK TAPE:  (RICK=vol-label; TAPE:=log-name)
         $ COPY TAPE:*.* [RICK]*.*
         $ DISMOUNT TAPE:
         $ DEALLOCATE MFA0:

         These commands copy all of the files from the tape TAPE:   to
         the user-area [RICK].

     5.  Replace Computational fields
         Replace Computational fields

              If you want to replace the Comp fields you took out, you
         should  write  another program similar to the one above to do
         this.


     The files you will end up with on the Vax will be RMS  sequential
     The files you will end up with on the Vax will be RMS  sequential
files.   If  you  wish  to  convert  them  to  RMS relative or indexed
files.   If  you  wish  to  convert  them  to  RMS relative or indexed
organizations,  you  should  use  the  FDL(File  Definition  Language)
organizations,  you  should  use  the  FDL(File  Definition  Language)
utilities  to  accomplish  this.   This  topic  will  be  covered in a
utilities  to  accomplish  this.   This  topic  will  be  covered in a
DOCUMENTATION AND TRAINING                                    Page 2-5
DOCUMENTATION AND TRAINING


seperate document.  However, I feel it necessary  to  comment  on  one
seperate document
aspect  of  FDL  utilities  here.  Tenvax by default produces variable
length 8188 byte records (in other  words  very  long  records  mostly
padded  with  spaces.)  A  Cobol  program  can  handle  this  fine but
Datatrieve seems to have problems.   If  you  wish  to  use  the  file
directly out of Tenvax, I recommend the following:

     1.  Determine actual length of record in bytes

     2.  Create Fdl file for fixed length records

              This step will be talked about in a seperate document in
         more  detail.   In  this step, you need to create an FDL file
         specifying that your output file fixed length  records  of  a
         certain length.

     3.  Create output file with above specifications.

         CONVERT/FDL=OUTPUT.FDL/TRUNCATE/EXCEPTIONS INPUT.VAR OUTPUT.FIX
         CONVERT/FDL=OUTPUT.FDL/TRUNCATE/EXCEPTIONS INPUT.VAR OUTPUT.FIX

              This step  copies  long  variable  length  records  from
         input.var  to  fixed  length  records  in  output.fix.   This
         effectively truncates spaces which were padded at the end  of
         the   records   by   Tenvax.   By  doing  a  file  comparison
         (differences) between input.var and  output.fix,  you  should
         see  that  these files are reported as identical (differences
         ignores trailing spaces).


     The entire process of TENVAX assumes that no  network  link  from
our  Dec-10  at  PDCF:   to  our Vax exists.  When a network link does
become available, the Tenvax step may be eliminated.



2.2  DIGITAL COMMAND LANGUAGE
     DIGITAL COMMAND LANGUAGE

2.2.1  User Authorization File
       User Authorization File


     1.  User Name
         User Name

              One to twelve characters naming a  record  in  the  user
         authorization  file.   Each  username  on  a  system  must be
                                Each  username  on  a  system  must be
         unique.
         unique

     2.  Password
         Password

              One to thirty-one phantom characters controlling  access
         to system.

     3.  User Identification Code
         User Identification Code

              Two octal numbers between 0 and 377 separated  by  comma
         and   enclosed   in   brackets   in   format   [100,200]   or
         [GROUP,MEMBER].  The UIC is used to determine your  right  to
         access  data  files or to communicate with other processes on
         your system.  System UICs are by default  between  [0,x]  and
         [10,x].  Usually each user has a unique UID.
DOCUMENTATION AND TRAINING                                    Page 2-6
DOCUMENTATION AND TRAINING


     4.  Process Name

              One to fifteen characters identifying  your  process  to
         other  users.   Usually  your  process  is  the  same as your
         username.

     5.  Account Name

              One to eight characters identifying users whose computer
         usage is combined for billing purposes.

     6.  Privileges
         Privileges

              This is a list of protected system  operations  you  are
         allowed to perform.

     7.  Resource Limits
         Resource Limits

              Decimal integers determining how much of certain  system
         resources you can consume.

     8.  Default Device and Directory Specification
         Default Device and Directory Specification

              Names the device and directory where by default you keep
         your   files.   Each  user  typically  has  his  own  default
         directory.




2.2.2  File Specification
       File Specification

          Node::Device:[Directory]Name.Typ;Version
          Node::Device:[Directory]Name.Typ;Version

          Node        1 to 6 characters
          Device      4 to 16 characters
          Directory   1 to 9 characters
          Name        0 to 9 characters
          Type        0 to 3 characters
          Version     integer, 1 to 32767



2.2.3  Three Levels Of Protection
       Three Levels Of Protection


     1.  Volume Protection
         Volume Protection

     2.  Directory Protection (System,Owner,Group,World)
         Directory Protection (System,Owner,Group,World)

     3.  File Protection (System,Owner,Group,World)
         File Protection (System,Owner,Group,World)



     The default protection for files is  (S:RWED,O:RWED,G:RWED,W:RE).
The  default  protection  for directories is (S:RWE,O:RWE,G:RWE,W:RE).
In order to delete a directory, you need both D and W.
DOCUMENTATION AND TRAINING                                                        Page 2-7
DOCUMENTATION AND TRAINING


      System    Group = 0 to 10 (octal)          Member = does not matter
      Owner     Group = match group UIC of file  Member = match member 
      Group     Group = match group UIC of file  Member = does not matter
      World     Group = does not matter          Member = does not matter

      Read      File = type,copy,etc.     Directory = find files with wildcard
      Write     File = update file        Directory = can create files in dir
      Execute   File = run file,not copy  Directory = need exact name for dir
      Delete    File = delete file        Directory = can delete dir

      (execute does not allow copy;read implies execute)
      EDT needs only Read to edit a file since it creates a new copy of it.
      You should protect files against delete and directories against write
      You should protect files against delete and directories against write

     Each disk has an MFD that  catalogs  all  user  file  directories
     Each disk has an MFD that  catalogs  all  user  file  directories
(UFD's).   Your  default  directory  is one of many UFDs.  It catalogs
(UFD's)
files  and   subdirectories.    Subdirectories   catalog   files   and
subdirectories.  Up to eigth levels of directories are possible.

MFD                     ______________
level 0                |   000000    |
                       ---------------
                              |
              -------------------------------------
              |                                   |
         ------------                        -------------
UFD     |   RICK     |                       |  CHARLIE  |
level 1 -------------                        -------------
              |
         ------------
SFD     | RICK.COBOL |
level 2 -------------




2.2.4  Logical Names
       Logical Names

     Logical names  are  composed  of  1  to  63  characters  and  are
     Logical names  are  composed  of  1  to  63  characters  and  are
primarily used to achieve device and file independence in programs and
primarily used to achieve device and file independence in programs and
convenience.  There are three logical names tables:   Process,  Group,
convenience.  There are three logical names tables:   Process,  Group,
and System.  Through the Group and System logical name tables, logical
and System.  Through the Group and System logical name tables, logical
names can be retained even after the process defining them terminates.
names can be retained even after the process defining them terminates.
They  never require a substitution operator (see symbols) except for a
They  never require a substitution operator (see symbols) except for a
colon (:) if the logical name is the left part of a file specification
colon (:) if the logical name is the left part of a file specification
( $ TYPE COB:PROGRAM.COB)
( $ TYPE COB:PROGRAM.COB)
       DEFINE Logical-name Equivalence-name
       DEFINE Logical-name Equivalence-name
       DEFINE COB SYS$SYSDEVICE:[COBOL.PROGRAMS]
       DEFINE COB SYS$SYSDEVICE:[COBOL.PROGRAMS]

       DEASSIGN Logical-name
       DEASSIGN Logical-name

      SHOW LOGICAL/process or group or system
      SHOW LOGICAL Logical-name       Runs program. Recursive tranlation
      SHOW TRANSLATION Logical-name   Runs no program. No recursion
      Do not put colons in logical name definitions.

     You can only use one logical name for a file  specification.   In
other words, the following is illegal:
          DEFINE THERE [RICK]
DOCUMENTATION AND TRAINING                                    Page 2-8
DOCUMENTATION AND TRAINING


          DEFINE FILE A.DAT
          DIRECT THERE:FILE



2.2.5  Symbols
       Symbols

     Symbols are primarily used for command  synonyms.   Each  process
stores  symbols  in one of two tables:  local and global.  Symbols are
                                                           Symbols are
always process private and are deleted when  the  process  terminates.
always process private and are deleted when  the  process  terminates.
Symbols  may require various substitution operators depending on how a
particular symbol is used.  Symbols get values in four possible ways:

     1.  PATH = "SET DEFAULT" or FOO = 7
         PATH = "SET DEFAULT"    FOO = 7

     2.  INQUIRE FOO
         INQUIRE FOO

     3.  @ COMPROC FOO (P1 -> P8)
         @ COMPROC FOO (P1 -> P8)

     4.  READ FILE FOO (local only)
         READ FILE FOO

      Path == "SET DEFAULT"     Global symbol
      A = 2                     Local symbol
      SHOW SYMBOLS/LOCAL
      SHOW SYMBOLS/GLOBAL
      DELETE/SYMBOL/LOCAL symbol
      DELETE/SYMBOL/GLOBAL symbol

     There are four places where DCL expects to find a symbol.  In the
following examples, the highlited areas are expected to be symbols:

     1.  PATH RICK
         PATH

              Path is here the first text  on  a  command  line.   Dcl
         expects  to  find  a  symbol here (a command synonym symbol).
         Dcl looks in its symbol table for the symbol automatically.

     2.  IF ANSWER THEN ...
            ANSWER

              For example, IF ANSWER .EQS.  "YES" THEN ...

     3.  A = FOO
             FOO

              Foo here is expected to be a symbol.  If you say A =  4,
         DCL  is smart enough to not require 3 to be a symbol;thus the
         number 3 is assigned to A.  In this example, foo  must  be  a
         symbol or else you would need quotes.

     4.  WRITE SYS$OUTPUT ANSWER
                          ANSWER

              If you want text output, you must use quotes eg.   WRITE
         SYS$OUTPUT "HELLO"


     Everywhere else, the system does not expect  a  symbol.   If  you
want something interpreted as a symbol, you must use an apostrophe(').
      X = "FILE.DAT;"
                    "
      DELETE X 
          This does not work since DCL does not expect a symbol  here.
          This does not work
DOCUMENTATION AND TRAINING                                    Page 2-9
DOCUMENTATION AND TRAINING


          DCL expects a file specification here.
      DELETE 'X'
          The apostrophes force symbol substitution  where  DCL  would
          normally do none.


      DEFINE X FILE.DAT;
      DELETE X
      D
          This works because DCL expects a file specification after  a
          This works
          DELETE.   Since  a  logical  name is a substitute for a file
          name ...  we're ok.

     The order of symbol translation is as follows:

     1.  Apostrophe Substitution

     2.  Command Synonym Substitution

     3.  Automatic Expression Evaluation


     For example, consider the following:
      SAY = "WRITE"
      PLACE = "SYS$OUTPUT"
      MESSAGE = "HELLO"

      SAY 'PLACE' MESSAGE,"RICK"

          SAY   SYS$OUTPUT MESSAGE,"RICK"
          WRITE SYS$OUTPUT MESSAGE,"RICK"
          WRITE SYS$OUTPUT "HELLO","RICK"



2.2.6  Sample Login.Com File
       Sample Login.Com File

$ SET NOVERIFY
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!       The following command procedure defines logical names and symbols for
! processes created by [RICK]. The procedure displays information about the
! current process and the exits.
!       If the current procedure is executing as a batch job, this command 
! procedure is ignored.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
$ IF F$MODE() .EQS. "BATCH" THEN GOTO END
$
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!       Define logical names:
$
$ DEFINE EDTINI [RICK]EDTINI.EDT
$ DEFINE CDD$DEFAULT CDD$TOP.TYMSHR.RICK
$
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
$
!       Define command synonym symbols
$
$ CLEAN*UP == "@[RICK.COMPROC]CLEANUP.COM"
$ C*LEAR == "TYPE [RICK]CLEAR.SCR"
$ COB*OL == "COBOL/LIST/MAP/COPY_LIST"
DOCUMENTATION AND TRAINING                                   Page 2-10
DOCUMENTATION AND TRAINING


$ COMP*ILE == "@[RICK.COMPROC]COMPILE.COM"
$ COP*Y == "COPY/LOG"
$ DA*Y == "SHOW DAYTIME"
$ DEL*ETE == "DELETE/CONFIRM"
$ DI*RECTORY == "DIRECTORY/OWNER/PROTECTION/SIZE=USED"
$ DISPLAY == "WRITE SYS$OUTPUT"
$ DTR == "MCR DTR32"
$ DKILL == "DELETE/NOCONFIRM"
$ EDT == "EDIT/EDT"
$ ER*ASE == "TYPE [RICK.REGIS]CLEAR.REG
$ FED == "MCR FED"
$ FUT == "MCR FUT"
$ K*JOB == "@[RICK.COMPROC]KJOB"
$ LI*BRARY == "LIBRARY/TEXT"
$ LIST == "@[RICK.COMPROC]TYPE"
$ NET*WORK == "SHOW NETWORK"
$ ON == "TYPE [RICK]ON.VT
$ OFF == "TYPE [RICK]OFF.VT
$ PA*TH == "@[RICK.COMPROC]PATH"
$ PJ == "SHOW PROCESS"
$ PRI*NT == "PRINT/NAME=NR05/NOTIFY"
$ REV == "TYPE [RICK]REV.VT
$ REVOFF == "TYPE [RICK]REVOFF.VT
$ SOS == "EDIT/SOS"
$ SU*BMIT == "SUBMIT/NOTIFY/NOPRINT"
$ WH*O == "SHOW USERS"
$
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
$ SET CONTROL=T
$ SET TERMINAL/VT100
$ SET PROTECTION = (S:R,O:RWED,G:RE,W:R)/DEFAULT
$ TYPE CLEAR.SCR
$ REV
$
$
$ END:
$ EXIT



2.3  VAX-11 RECORD MANAGEMENT SERVICES
     VAX-11 RECORD MANAGEMENT SERVICES

     Vax-11 RMS  disk  files  reside  on  Files-11  disks.   The  term
Files-11  refers  to  the  logical  structure  given  to  the disk:  a
hierarchical organization of files, their data,  and  the  directories
needed to gain access to them.  The VAX/VMS file system implements the
disk structure and provides access control to the files located on the
disk.   VAX-11  RMS  provides  the  organization  of the files and the
method of access to the data within the files.

     A Vax-11 RMS file is a collection of  logically  related  records
that  are  treated as a unit and arranged in a useful order.  For disk
                                                              For disk
files, the smallest unit of transfer between Vax-11  RMS  buffers  and
files, the smallest unit of transfer between Vax-11  RMS  buffers  and
the  disk  is  a block.  Two or more blocks can be grouped together to
the  disk  is  a block.  Two or more blocks can be grouped together to
form buckets.  A bucket is a storage structure consisiting of  from  1
form buckets.  A bucket is a storage structure consisiting of  from  1
to  32  blocks, which is used for building and processing relative and
to  32  blocks, which is used for building and processing relative and
indexed files.
indexed files.
DOCUMENTATION AND TRAINING                                   Page 2-11
DOCUMENTATION AND TRAINING


     The manner in which RMS builds a files is called is organization.
     The manner in which RMS builds a files is called is organization.
RMS   provides   three   different  file  organizations:   Sequential,
RMS   provides   three   different  file  organizations:   Sequential,
Relative, and Indexed.   File  organization  determines  the  physical
Relative, and Indexed
arrangement  of  records  in a file.  File organization is related to,
but distinct from, the record access mode.  The  latter  is  concerned
with  the  manner  in  which  the records in the file are inserted and
retrieved.  The purpose of file organization is to arrange the records
in  an  orderly manner so that you can access them in the quickest and
most feasible way.  You can select the type of  file  organization  at
                    You can select the type of  file  organization  at
file-creation time;  it cannot be changed therafter.
file-creation time;  it cannot be changed therafter.



2.3.1  File Organization
       File Organization

2.3.1.1  Sequential File Organization -
         Sequential File Organization

     Records appear in  consecutive  sequence.   The  order  in  which
records  appear  is  the  order  in  which the records were originally
written to the file by an application program or RMS utility.  You can
only add records to the end of the file.



2.3.1.2  Relative File Organization -
         Relative File Organization

     RMS structures the files as a series of fixed-size record  cells.
Cell size is based on the maximum length permitted for a record in the
file.  These cells are numbered from 1 (the first) to n (the last).  A
cell's number represents its location relative to the beginning of the
file.  Each cell in a relative  file  can  contain  a  single  record.
There  is  no  requirement  however  that every cell contain a record.
Empty cells can be interspersed among cells containing records.
         ---------------------------          ------
        |record|record|      |      | ...    |record|
        |  1   |  2   | empty| empty|        |  n   |
         ---------------------------          ------

     Since cell numbers in a relative file are  unique,  they  can  be
used  to  identify  both a cell and the record (if any) occupying that
cell.  Thus record #1 occupies the first cell in the file,  record  #6
occupies  the sixth cell, etc.  When a cell number is used to identify
a record, it is also known as a relative record number.

     To access a record in a relative file in a random  mode  (I  will
     To access a record in a relative file in a random  mode  (I  will
discuss  modes  of  access  later),  you must know the relative record
discuss  modes  of  access  later),  you must know the relative record
number (key) of the record.  One  method  of  keeping  track  of  each
number (key) of the record.  One  method  of  keeping  track  of  each
record's  cell  is  to  store records using a numeric value within the
record's  cell  is  to  store records using a numeric value within the
record.  For example, you could make an account number  equivalent  to
record.  For example, you could make an account number  equivalent  to
the  relative  record number.  Although each record in a relative file
the  relative  record number
is assigned to a fixed-length cell, the actual size of the  individual
records  can vary in length (that is, different size records can be in
the same file).
DOCUMENTATION AND TRAINING                                   Page 2-12
DOCUMENTATION AND TRAINING


2.3.1.3  Indexed File Organization -
         Indexed File Organization

     The location of records  in  the  indexed  file  organization  is
transparent  to the program.  RMS completely controls the placement of
records in an indexed file.  The presence of keys in  the  records  of
the  file governs this placement.  A key is a field that is present in
                                   A key is a field that is present in
every record of the file.  The location and length of  this  field  is
every record of the file.  The location and length of  this  field  is
identical  in  all  records.   When creating an indexed file, the user
identical  in  all  records.   When creating an indexed file, the user
decides which field or fields in the file's records are to be  a  key.
decides which field or fields in the file's records are to be  a  key.
Selecting  such  fields  indicates  to  RMS  that the contents (ie key
Selecting  such  fields  indicates  to  RMS  that the contents (ie key
value) of those fields in any particular record written  to  the  file
value) of those fields in any particular record written  to  the  file
can  be  used  by  a  program  to  identify that record for subsequent
can  be  used  by  a  program  to  identify that record for subsequent
retrieval.  A key is a  field  within  each  record  definded  by  its
retrieval.  A key is a  field  within  each  record  definded  by  its
location  and  length.   A  key  can  be  a character string, a packed
location  and  length.   A  key  can  be  a character string, a packed
decimal number, a 2 or 4 byte unsigned binary number, or a 2 or 4 byte
decimal number, a 2 or 4 byte unsigned binary number, or a 2 or 4 byte
signed integer.  When identifying the location and length of character
signed integer
string keys, you can define simple or segmented keys.  A simple key is
                                      segmented keys
a  single  contiguous  string  of  characters in the record.  Integer,
binary, and packed decimal keys are always simple keys.   A  segmented
key, however, can consist of from two to eight strings;  these strings
do not need to be contigous.  When  processing  records  that  contain
segmented keys, Vax-11 RMS treats the seperate segments as a logically
contigous string.  At least one key must be  defined  for  an  indexed
                   At least one key must be  defined  for  an  indexed
file...the  primary  key.  Optionally additional keys (alternate keys)
file...the  primary  key.  Optionally additional keys (alternate keys)
can be defined.  An alternate key value can also be used as a means of
can be defined.  An alternate key value can also be used as a means of
identifying  a  record  for  retrieval.   Each  alternate  key is also
identifying  a  record  for  retrieval.   Each  alternate  key is also
defined by its location and length within the record.
defined by its location and length within the record.

     As programs write records into and indexed  file,  RMS  builds  a
tree-structured  table  known  as  an  index.   An index consists of a
series of entries each of which contain a  key  value  copied  from  a
record  that  a  program  wrote into the file.  Stored within each key
value is a pointer to the location in the  file  of  the  record  from
which the value was copied.  RMS builds and maintains a seperate index
                             RMS builds and maintains a seperate index
for each key defined for the file.  An index  is  the  structure  that
for each key defined for the file.  An index  is  the  structure  that
allows  the records to be retrieved randomly.  Each index is stored in
allows  the records to be retrieved randomly.  Each index is stored in
the file.
the file.
                       Primary Key Values
                 -------------------------
                 |   |   |   |   |   |   |
                 -------------------------
                   /       \
                  /         \      ___________
                 /           ------|  Data   |
       ----------                  |  Record |
       ! Data   |                  ----------
       | Record |
       ---------

     There are three key characteristics you can define for a  primary
or  secondary  key.  The first is whether duplicate values are allowed
for the key value (you can specify this for  a  primary  or  secondary
key).   The  second  is  whether  the value of the keyed fields can be
changed (you can specify this only for a secondary  key).   The  third
characteristic  you  can  set  is whether the value for the key can be
null (you can specifiy this only for an alternate key).
DOCUMENTATION AND TRAINING                                   Page 2-13
DOCUMENTATION AND TRAINING


     1.  Duplicate values allowed for Primary and Secondary key
         Duplicate values allowed for Primary and Secondary key

     2.  Values for Alternate keys can change
         Values for Alternate keys can change

     3.  Values for Alternate keys can be null
         Values for Alternate keys can be null


     When you specify that  duplicate  key  values  are  allowed,  you
     When you specify that  duplicate  key  values  are  allowed,  you
indicate  that  more  that  one record in an indexed file can have the
indicate  that  more  that  one record in an indexed file can have the
same value for that key.   Such  records,  therefore,  have  the  same
same value for that key.   Such  records,  therefore,  have  the  same
record  identifier.   Only the first record with a duplicate key value
record  identifier.   Only the first record with a duplicate key value
can be retrieved  randomly;   subsequent  records  must  be  retrieved
can be retrieved  randomly;   subsequent  records  must  be  retrieved
sequentially.   This  capability  is applicable only to indexed files.
sequentially.   This  capability  is applicable only to indexed files.
In Relative files, the record identifier that  represents  a  relative
In Relative files, the record identifier that  represents  a  relative
record number is always unique.
record number is always unique.

     When you specify that key values can change,  you  indicate  that
records  can  be  updated  with a modified value in the key;  however,
this characteristic is limited to alternate keys.

     The third key characteristic that you can specify is the null-key
value,  which indicates that when the record is put into the file, the
key value may be a null value.  This characteristic is also limited to
alternate keys.

     You can also declare the opposite of these characteristics;  that
is, you can specify that for a given key, duplicate key values are not
allowed, key values cannot change, and there is no null  value.   When
                                                                  When
duplicate  key  values are not allowed, Vax-11 RMS rejects any request
duplicate  key  values are not allowed, Vax-11 RMS rejects any request
to put a record into the file when that record contains  a  key  value
to put a record into the file when that record contains  a  key  value
that  is already present in another record.  Similary, when key values
that  is already present in another record
cannot change, Vax-11 RMS does not allow  your  program  to  update  a
record  by modifying the key value.  Records whose keys cannot be null
values always have an entry in the appropriate alternate index.

     Vax-11 RMS uses a logical storage structure called a  bucket  for
     Vax-11 RMS uses a logical storage structure called a  bucket  for
building  and  processing relative and indexed files.  A bucket, which
building  and  processing relative and indexed files.  A bucket, which
is a unit of contiguous transfer between Vax-11 RMS  buffers  and  the
is a unit of contiguous transfer between Vax-11 RMS  buffers  and  the
disk,  can  contain  from  1 to 32 blocks.  You specifiy the number of
disk,  can  contain  from  1 to 32 blocks.  You specifiy the number of
blocks in a bucket when you build the file.  Since buckets  are  units
blocks in a bucket when you build the file.  Since buckets  are  units
of  transfer,  large  buckets  help  provide  good disk throughput for
of  transfer,  large  buckets  help  provide  good disk throughput for
sequential operations, but require more buffer space in programs  that
sequential operations, but require more buffer space in programs  that
process  them.  These buffers are areas of internal memory that Vax-11
process  them
RMS uses to read and write blocks of data.   Record  processing  under
RMS  appears  to  your  program  as  the  movement of records directly
between a file and the program itself.  This is in fact not the  case.
Transparently  to  your program, Vax-11 RMS reads and writes blocks or
buckets of a files into or from an I/O  buffer.   Records  within  the
buffer  are  then made available to the program.  The transfer of data
                                                  The transfer of data
between a file and I/O buffers depends  on  the  file's  organization.
between a file and I/O buffers depends  on  the  file's  organization.
For  sequential  files,  RMS  reads  and  writes  a block or series of
For  sequential  files,  RMS  reads  and  writes  a block or series of
blocks.  For relative and indexed files, RMS reads and writes buckets.
blocks.  For relative and indexed files, RMS reads and writes buckets.

     When processing indexed files, you cannot insert records  into  a
full  bucket.   Doing  this will cause a bucket split which results in
                                         bucket split
additional overhead.  To avoid bucket splits, you can specify that the
initial  loading of records will not completely fill the data or index
buckets.  You should do this if you know that  your  application  will
require random insertions into the database.
DOCUMENTATION AND TRAINING                                   Page 2-14
DOCUMENTATION AND TRAINING


2.3.2  Record Access Modes
       Record Access Modes

     A record access mode is the method of  inserting  and  retrieving
     A record access mode is the method of  inserting  and  retrieving
records  in  a file.  Access mode is different from file organization,
records  in  a file.  Access mode is different from file organization,
which is the physical arrangement of records in the file.  Vax-11  RMS
which is the physical arrangement of records in the file.  Vax-11  RMS
provides   three   record   access   modes:    sequential,  random  by
provides   three   record   access   modes:    sequential,  random  by
key-value/relative record-number, and random by record file address.
key-value/relative record-number, and random by record file address.

     Although you cannot change  the  file  organization  once  it  is
     Although you cannot change  the  file  organization  once  it  is
established  at  file-creation  time, you can change the record access
established  at  file-creation  time, you can change the record access
mode each time the file is used.  This  means,  for  example,  that  a
mode each time the file is used
relative  file  can  be processed in sequential record access mode one
time and in random by key (relative record number) record access  mode
the next time.
       ----------------------------------------------------------
       |  Record Access      |               File               |
       |  Mode Permitted     |          Organization            |
       |---------------------|----------------------------------|
       |---------------------|----------------------------------|
       |                     |  Sequential | Relative | Indexed |
       ----------------------------------------------------------
       | Sequential          |     Yes     |   Yes    |  Yes    |
       ----------------------------------------------------------
       | Random by Relative  |             |          |         |
       | Record Number       |     No      |   Yes    |  No     |
       ----------------------------------------------------------
       | Random by Key Value |     No      |   No     |  Yes    |
       ----------------------------------------------------------
       | Random by Record's  |             |          |         |
       | File Address        |     Yes     |   Yes    |  Yes    |
       ----------------------------------------------------------



2.3.2.1  Sequential Access -
         Sequential Access

     In sequential access, record storage or  retrieval  starts  at  a
designated  point  in  the  file and continues through the file.  When
using the sequential record access mode, a program issues a series  of
requests  to  Vax-11  RMS  to retrieve or store the next record in the
file.



2.3.2.1.1  Sequential Access To Sequential Files -
           Sequential Access To Sequential Files

     In a sequential file, record are adjacent to each other.  To read
a particular record within the file using sequential access mode, your
program must open the file and successively read the records preceding
this  record.   Each  record can be retrieved only by first retrieving
                Each  record can be retrieved only by first retrieving
all the records that physically precede it.   Sequential  access  does
all the records that physically precede it
not  allow  you to backspace to a record that was already passed.  You
have to restart at the first record by either reopening  or  rewinding
the  file,  or  by  switching  access modes.  In addition, you can add
records only to the end of the file.
DOCUMENTATION AND TRAINING                                   Page 2-15
DOCUMENTATION AND TRAINING


2.3.2.1.2  Sequential Access To Relative Files -
           Sequential Access To Relative Files

     Relative files also permit sequential access even if some of  the
fixed  length  cells in the file do not contain records.  Empty cells,
representing records that were never  written  or  records  that  were
deleted,  can occur in a relative file.  Vax-11 RMS recognizes whether
                                         Vax-11 RMS recognizes whether
successive record cells in  a  relative  file  are  empty  or  contain
successive record cells in  a  relative  file  are  empty  or  contain
records;   Vax-11  RMS  ignores  the  empty  cells  and  searches,  in
records;   Vax-11  RMS  ignores  the  empty  cells  and  searches,  in
succession, for cells that contain  records.   When  using  sequential
succession, for cells that contain  records
access  for  writing records to a relative file, Vax-11 RMS places the
new record in the empty cell whose relative number is one higher  than
that  used for the previous write or read request.  New records cannot
be written into cells that already contain records.  If you attempt to
write into a cell already occupied by a record, the attempt will fail.
You can, however, request Vax-11 RMS to update an existing record.



2.3.2.1.3  Sequential Access to Indexed Files
           Sequential Access to Indexed Files

     In an indexed file, Vax-11  RMS  uses  one  or  more  indexes  to
     In an indexed file, Vax-11  RMS  uses  one  or  more  indexes  to
determine  the  order in which to process records in sequential access
determine  the  order in which to process records in sequential access
mode.  The entries in an index are arranged in ascending order by  key
mode.  The entries in an index are arranged in ascending order by  key
values.   Thus,  an index represents a logical ordering of the records
values.   Thus,  an index represents a logical ordering of the records
in the file.  If you define more that one key for the file, each index
in the file.  If you define more that one key for the file, each index
associated  with  a key will represent a different logical ordering of
associated  with  a key will represent a different logical ordering of
the records in the file.  Your program, then, can use  the  sequential
the records in the file.  Your program, then, can use  the  sequential
access mode to retrieve records in the order represented by any index.
access mode to retrieve records in the order represented by any index.

     When reading records form an indexed  file  in  sequential  mode,
     When reading records form an indexed  file  in  sequential  mode,
your  program  must initially specify to Vax-11 RMS a key of reference
your  program  must initially specify to Vax-11 RMS a key of reference
(for example, primary key, first alternate key, second alternate  key,
(for example, primary key, first alternate key, second alternate  key,
and so on).  Therafter, Vax-11 RMS uses the index associated with that
and so on).  Therafter, Vax-11 RMS uses the index associated with that
key of reference to retrieve records  in  the  same  sequence  as  the
key of reference to retrieve records  in  the  same  sequence  as  the
entries  in the index.  Each successive record that Vax-11 RMS returns
entries  in the index
in response to your program's read request contains  a  value  in  the
specified key field that is equal to (when duplicate keys are allowed)
or greater than that of the previous record returned.

     In contrast to a sequential  read  request,  a  sequential  write
     In contrast to a sequential  read  request,  a  sequential  write
request  to  an  indexed  file  does  not  require a key of reference.
request  to  an  indexed  file  does  not  require a key of reference.
Rather, Vax-11 RMS uses the stored definition of the  primary  key  to
Rather, Vax-11 RMS uses the stored definition of the  primary  key  to
place  the  record in the file and the definition of alternate keys to
place  the  record in the file and the definition of alternate keys to
place entries for the record in  the  alternate  indexes.   When  your
place entries for the record in  the  alternate  indexes.   When  your
program  issues  a  series  of  sequential  write requests, Vax-11 RMS
program  issues  a  series  of  sequential  write requests, Vax-11 RMS
verifies that each successive record  contains  a  key  value  in  the
verifies that each successive record  contains  a  key  value  in  the
primary  key  field  that  is  equal  to  or  greater than that of the
primary  key  field  that  is  equal  to  or  greater than that of the
preceding record.
preceding record.



2.3.2.2  Random Access -
         Random Access

     In random  access,  your  program,  not  the  file  organization,
determines  the order in which record processing occurs.  Each program
                                                          Each program
request for a record must include  the  relative  record  number  (for
request for a record must include  the  relative  record  number  (for
relative  files)  or  the  key  of  reference  plus the key value (for
relative  files)  or  the  key  of  reference  plus the key value (for
indexed files) of the particular record to be accessed.  Random access
indexed files) of the particular record to be accessed.
is  supported  for  all  relative  and indexed files.  Vax-11 RMS also
DOCUMENTATION AND TRAINING                                   Page 2-16
DOCUMENTATION AND TRAINING


permits random access by relative record number for sequential records
residing on disk devices containing fixed length records.



2.3.2.2.1  Random Access To Relative Files -
           Random Access To Relative Files

     Unlike    sequential    access    which    always    follows    a
one-record-after-the-other  pattern, random access follows no specific
pattern.  Your program randomly identifies any record within the  file
by  means of the relative record number.  Vax-11 RMS then retrieves or
inserts that record.  Your program may then make  successive  requests
for accessing or retrieving records from anywhere within the file.



2.3.2.2.2  Random Access To Indexed Files -
           Random Access To Indexed Files

     Each of your program's get requests in random access mode  to  an
     Each of your program's get requests in random access mode  to  an
indexed  file  must specify both a key value and the index that Vax-11
indexed  file  must specify both a key value and the index that Vax-11
RMS must search (for  example,  primary  index,  first  alternate  key
RMS must search (for  example,  primary  index,  first  alternate  key
index, second alternate key index, and so on).  When Vax-11 RMS finds,
index, second alternate key index, and so on)
by means of an index, the record that matches the key value, it  reads
the  record  and  passes  it  to  your  program.  Random access can be
accomplished on any key by any of the following methods.

     1.  Exact match of key values
         Exact match of key values

     2.  Approximate match of key values
         Approximate match of key values

              This is a record key value that is either  greater  than
         or equal to your program supplies key value.

     3.  Generic match of key values
         Generic match of key values

              Generic match is applicable to  string  data  type  keys
         only.   A  generic match is a match of some number of leading
         characters  in  the  key.   You  determine  the   number   by
         specifiying a search key smaller than the entire field.

     4.  Combination of Approximate and Generic Match
         Combination of Approximate and Generic Match


     In contrast to get requests which require your  program-specified
key  value,  program requests to insert records randomly in an indexed
                     requests to insert records randomly in an indexed
file do not require the seperate specification of a  key  value.   All
file do not require the seperate specification of a  key  value.   All
keys  (primary and any alternate key values) are in the record itself.
keys  (primary and any alternate key values) are in the record itself
When  an  indexed  file  is  opened,  Vax-11  RMS  retrieves  all  key
definitions  stored  in the file.  Thus, Vax-11 RMS knows the location
and length of each key field in a record.  After writing a record into
                                           After writing a record into
the file, Vax-11 RMS examines the key values in the record and creates
the file, Vax-11 RMS examines the key values in the record and creates
new entries in the appropriate alternate indexes.  In this way, Vax-11
new entries in the appropriate alternate indexes.  In this way, Vax-11
RMS ensures that the record can be retrieved by any of its key values.
RMS ensures that the record can be retrieved by any of its key values.
DOCUMENTATION AND TRAINING                                   Page 2-17
DOCUMENTATION AND TRAINING


2.3.3  RMS Utilities
       RMS Utilities

2.3.3.1  Introduction -
         Introduction

     The Vax-11  RMS  utilities  are  EDIT/FDL,  CREATE/FDL,  CONVERT,
                                      EDIT/FDL   CREATE/FDL   CONVERT
CONVERT/RECLAIM,  and  ANALYZE/RMSFILE.   They  let  the  user design,
CONVERT/RECLAIM        ANALYZE/RMSFILE
create, populate, and analyze data files.  I will  discuss  the  first
three utilities only as these are the most important.



2.3.3.2  Edit/Fdl -
         Edit/Fdl

     The FDL editor, EDIT/FDL creates and  modifies  FDL  files.   FDL
files  provide  specifications  for  Vax-11  RMS  data  files;   these
specifications are then used by certain  utilitities  to  create  data
files.  The command to invoke FDL is as follows:

      EDIT/FDL FDL-FILE-SPEC

      The FDL-FILE-SPEC specifies the name  of  the  FDL  file  to  be
      created, modified, or optimized.

     As is mentioned above, the File Definition Language  (FDL)  is  a
special-purpose language that is used to write specifications for data
files.  An FDL file  consists  of  a  collection  of  file  attributes
grouped  into  related  sections.   The  section  headings  are called
primary attributes.  Attributes within a section are called  secondary
attributes.   Certain secondaries can have a third level of attributes
called  qualifiers.   A  completed  FDL  file  consists  of  attribute
keywords  followed  by  their  assigned values.  Lowercase letters are
legal anywhere;  they are equivalent to uppercase letters.  I will  go
over each primary attribute in the following paragraphs.

     1.  Title Primary Attribute
         Title Primary Attribute

              This primary attribute is a string that you can place at
         the beginning of the FDL file.  The character string that you
         supply is for comment purposes only and  can  be  up  to  132
         characters long.

     2.  Ident Primary Attribute
         Ident Primary Attribute

              This primary attribute contains the date and time of the
         creation  of  the  FDL  file  and  specifies  the name of the
         creating utility.

     3.  System Primary Attribute
         System Primary Attribute

              This  primary  attribute  identifies  the  name  of  the
         operating  system  that you are using to create the FDL file.
         It takes no value.

     4.  File Primary Attribute
         File Primary Attribute

              This primary attribute takes no value.  It  has  several
         important secondary attributes.
DOCUMENTATION AND TRAINING                                   Page 2-18
DOCUMENTATION AND TRAINING


         1.  Name

                  The   NAME   secondary   attribute   is   the   file
             specification  of  the  data file to be created from this
             FDL file.  If you supply a creating utility with  a  name
             for  the  data  file,  that  name  will  override the one
             specified here.

         2.  Organization
             Organization

                  The organization attribute defines the type of  file
             organization.   Its  value  must  be one of the following
             keywords:  Sequential, Relative, or Indexed.


     5.  Record Primary Attribute
         Record Primary Attribute

              The  record   primary   attribute   contains   secondary
         attributes  that  define  records.  The record keyword itself
         takes no value;  it serves only to begin the record section.

         1.  Carriage-Control

                  The carriage-control attribute must be  one  of  the
             following  keyword:   carriage-return,  fortran, none, or
             print.  Carriage-return is the default and specifies that
             each record is preceded by a line feed and is followed by
             a carriage return.

         2.  Format
             Format

                  The format sets the record format for the data file.
             Its value should be either fixed for fixed-length records
                                        fixed
             or variable for variable length records.
                variable

         3.  Size
             Size

                  The size attribute sets the maximum record  size  in
             bytes.   With  fixed-length  records,  this  value is the
             length of every record in the file.  With variable-length
             records,  this  value  is  the longest record that can be
             placed in the file.


     6.  Area Primary Attribute
         Area Primary Attribute

              The area primary takes a value that must be a number  in
         the  range  of 0 to 254.  The number identifies the area.  To
         define multiple areas for an indexed file, you must specify a
         seperate area section for each area.

         1.  Allocation
             Allocation

                  The allocation attribute sets the number  of  blocks
             that  you  will  initially  allocate from this area.  Its
             value  must  be  an  integer  in  the  range  of   0   to
             4,294,967,295.   The  default  is  0 which means that the
             system will not allocate space for this area.
DOCUMENTATION AND TRAINING                                   Page 2-19
DOCUMENTATION AND TRAINING


         2.  Best-Try-Contiguous

                  This is a switch that controls whether the area will
             be  allocated  contiguously if there is enougth space for
             it.  If the switch is set to  yes  and  there  is  enough
             space   for   the   area,  the  area  will  be  allocated
             contigously.  If the switch is set to yes  and  there  is
             not  enough space, the area is allocated noncontiguously.
             If the switch is set to the default of no, the  attribute
             has no effect.

         3.  Bucket Size
             Bucket Size

                  The bucket-size attribute sets the number of  blocks
             per  bucket  for this area.  Its value must be an integer
             in the range of 0 to 32.  The default value is  0,  which
             means  that  the  bucket  size  specified  by the current
             rms-default will be used.

         4.  Extension

                  The extension attribute sets the  number  of  blocks
             for  the  default  extension  quantity for the area.  The
             extension is the amount of space that the system will add
             to the sequential end of the area when the area is filled
             up.  The value must be an integer in the range  of  0  to
             65,535.  The default is 0, which means that the extension
             size will be determined by the system whenever  the  area
             requires extending.


     7.  Key Primary Attribute
         Key Primary Attribute

              The primary attribute key takes a value that must be the
         number of the key.  The key value for the primary key must be
         0.  The key value for alternate keys can be numbered  from  1
         to 254.  The most important secondary attributes follow:

         1.  Changes
             Changes

                  The changes attribute is a switch.  When it  is  set
             to  yes,  it  allows a Vax-11 RMS access method to change
             the value of the key.  Such a change is an error with the
             primary  key, so the default setting for the primary keys
             is no.  With alternate keys the default setting  is  yes,
             which allows changes to the key's value.

         2.  Data-Area

                  The data-area attribute identifies the area in which
             you  will  place the data records in an indexed file with
             multiple areas.  The value is an integer in the range  of
             1  to 254, which must be the same as that assigned to the
             area in an area section.  This value  is  used  when  the
             data  level  and  the index levels are placed in seperate
             areas, or when each key is placed in its own area.
DOCUMENTATION AND TRAINING                                   Page 2-20
DOCUMENTATION AND TRAINING


         3.  Data-Fill
             Data-Fill

                  This attribute sets the percentage of the  bytes  in
             each  data  bucket  in  this area what you wish populated
             initially.  If you anticipate that many records  will  be
             inerted  randomly  into  this  file, this value should be
             less than 100% of the bytes.  The default value  is  100%
             and the minimum value is 50%.

         4.  Duplicates
             Duplicates

                  The duplicates attribute is a switch  that  controls
             whether  duplicate keys are allowed in the indexed files.
             For primary keys, the default  setting  is  no,  but  for
             alternate  keys  the  default  setting is yes.  When this
             switch is set to yes, this attribute specifies that there
             can  be  more  than one record with the same specific key
             value.  When this attribute is set to no, duplicate  keys
             are  not allowed, and any attempt to write a record where
             the key would be a duplicate will result in an error.

         5.  Index-Area

                  This attribute identifies the area in which you will
             place  the  index levels other than level 1 in an indexed
             file with multiple areas.  The value is an integer in the
             range  of 1 to 254, which must be the same number as that
             assigned to the area in an area section.  This  value  is
             used when the data levels and the index levels are placed
             in seperate areas, or when each key is placed in its  own
             area.

         6.  Index-Fill
             Index-Fill

                  This attribute sets the percentage of bytes in  each
             index level bucket that you wish populated initially.  If
             you  anticipate  that  many  records  will  be   inserted
             randomly  into  the  file, this value should be less that
             100%.  The default value is 100% and the minimum value is
             50%.

         7.  Level1-Index-Area

                  This attribute identifies the area in which you will
             place  the level 1 index in an indexed file with multiple
             areas.  The value is an integer in the range of 1 to 254,
             which  must  be  the  same number as that assigned to the
             area in an area section.  This value  is  used  when  the
             data  levels  and the index levels are placed in seperate
             areas, or when each key is placed in its own area.

         8.  Name

                  The name attribute assigns a name  to  a  key.   The
             value  is a string from 1 to 32 characters long.  This is
             an optional value.
DOCUMENTATION AND TRAINING                                   Page 2-21
DOCUMENTATION AND TRAINING


         9.  Prologue
             Prologue

                  The  prologue   attribute   defines   the   internal
             structure  level  of  an  indexed  file.  There are three
             different structure levels.  A prologue 3 can only have a
             primary  key (no alternate keys) and the primary key must
             be of the string type.  Prologue 3 gives you  the  option
             of  compressing keys, indexes, and data.  You can use the
             CONVERT/RECLAIM utility to reclaim buckets from  prologue
             3  files.   Prologue  1  and  2  files do not allow these
             options.

                  To specifiy a Prologue 3 file, assign the value 3 to
             this  attribute.   To  specifiy  a  Prologue 1 to 2 file,
             assign  the  value  2.   There  is  no  user  discernible
             difference between Prologue 1 and 2 files.

        10.  Length
             Length

                  The length attribute sets the length of the  key  in
             bytes.

        11.  Position
             Position

                  The position attribute defines the byte position  if
             the  beginning  of  the key field within the record.  The
             first position is 0.  Primary  keys  work  best  if  they
             start at position 0.

        12.  Type
             Type

                  The type attribute specifies the type  of  the  key.
             There are 6 different type of keys.

             1.  BIN2 --> 2 byte unsigned number (0 to 65,535)

             2.  BIN4 --> 4 byte unsigned number (0 to 4,294,967,295)

             3.  DECIMAL --> Packed decimal (1 to 16 bytes)

             4.  INT2 --> 2 byte signed integer (-32,768 to +32767)

             5.  INT4 --> 4 byte  signed  integer  (-2,147,483,648  to
                 +2,147,483,647)

             6.  STRING --> 1 to 255 string of Ascii characters






2.3.3.2.1  Sample Fdl File -
           Sample Fdl File

     The following is a sample FDL file.

TITLE   Sample FDL File

IDENT   27-JUN-1983 15:22:21    VAX-11 FDL Editor
DOCUMENTATION AND TRAINING                                   Page 2-22
DOCUMENTATION AND TRAINING


SYSTEM
        SOURCE                  VAX/VMS

FILE
        NAME                    INPUT.DAT
        ORGANIZATION            indexed

RECORD
        CARRIAGE-CONTROL        carriage-return
        FORMAT                  fixed
        SIZE                    80

AREA 0
        ALLOCATION              235
        BEST-TRY-CONTIGUOUS     yes
        BUCKET-SIZE             3
        EXTENSION               23

AREA 1
        ALLOCATION              7
        BEST-TRY-CONTIGUOUS     yes
        BUCKET-SIZE             3
        EXTENSION               0

KEY 0
        CHANGES                 no
        DATA-AREA               0
        DATA-FILL               75
        DUPLICATES              no
        INDEX-AREA              1
        INDEX-FILL              75
        LEVEL1-INDEX-AREA       1
        NAME                    PART-NUMBER
        PROLOGUE                2
        SEG0-LENGTH             9
        SEG0-POSITION           0
        TYPE                    string



2.3.3.3  Create/Fdl -
         Create/Fdl

     The Create Utility uses the specifications  in  an  existing  FDL
file to create a new , empty data file.

      CREATE/FDL=OUTPUT.FDL OUTPUT.DAT
      CREATE/FDL=OUTPUT.FDL OUTPUT.DAT


           OUTPUT.FDL specifies the FDL file from which to create  the
      data  file.   OUTPUT.DAT specifies the empty output file that is
      created.


           The following switches are recommended:

      /LOG.........display file specification of data file created
DOCUMENTATION AND TRAINING                                   Page 2-23
DOCUMENTATION AND TRAINING


2.3.3.4  Convert/Fdl -
         Convert/Fdl

     The Convert Utility copies records from one or more files  to  an
output  file, changing the record format and file organization to that
of the output file.  The input files themselves do  not  change.   The
output data file can already exist or a convert can create it.  If you
                                                                If you
want to create an output file with different characteristics than  the
want to create an output file with different characteristics than  the
input  file,  you  specifiy  an  FDL file specification in the command
input  file,  you  specifiy  an  FDL file specification in the command
line.  To create an output file with the same characteristics  as  the
line.
first  input  file,  you  omit the /FDL qualifier.  If the output file
exists, it can be either empty or it  can  contain  records.   If  the
output  file  is sequential, the specifying the /APPEND qualifier will
cause the new record from the input file to be added  sequentially  to
the  end  of  the output file.  If the existing output file is indexed
and it contains records, then specifying  the  /MERGE  qualifier  will
cause the new records from the input file to be merged in their proper
order.

     Conversions in which the length of the input records exceeds  the
maximum length of the fixed length of the output records will cause an
exception condition.  Conversions of short fixed-length  records  into
longer  fixed-length  records  will  also cause an exception.  You can
avoid these exception conditions by specifying the /TRUNCATE qualifier
when  going  from long input records to shorter output records, and by
specifying  the  /PAD  qualifier  to  pad  the  output  records   when
converting  from  short  input  records to longer output records.  The
/PAD qualifier allows you to specify the pad character.

     To keep a copy of the exception records, you create an exceptions
file  with  the  /EXCEPTIONS-FILE qualifier.  The exceptions file is a
sequential file with variable length records.  It receives a  copy  of
any  record  that cannot be placed in the output data file.  Exception
files are given the EXC file type by default.

     CONVERT can also be used to reformat an indexed file that has had
     CONVERT can also be used to reformat an indexed file that has had
many  record  deletions and insertions.  The file's file specification
many  record  deletions and insertions.  The file's file specification
is used as both the input and the output file specification.  In  such
is used as both the input and the output file specification.
a  case the output file will have a version number that is one greater
than the highest exisiting version of the input file.

      CONVERT/FDL=OUTPUT.FDL/EXCEPTIONS-FILE=OUTPUT.EXC INPUT.DAT OUTPUT.DAT
      CONVERT/FDL=OUTPUT.FDL/EXCEPTIONS-FILE=OUTPUT.EXC INPUT.DAT OUTPUT.DAT

      This command will create a file (OUTPUT.DAT)  according  to  the
      file  specifications  in  OUTPUT.FDL  and  with the data records
      found in INPUT.DAT.  The newly created output file will have the
      name specified by the output file spec;  this name overrides any
      file name specified in the FDL file.

      CONVERT/TRUNCATE/EXCEPTIONS-FILE=OUTPUT.EXC VARFILE.DAT FIXFILE.DAT
      CONVERT/TRUNCATE/EXCEPTIONS-FILE=OUTPUT.EXC VARFILE.DAT FIXFILE.DAT

      This command copies records from a  variable-length  file  to  a
      file with fixed-length records and truncates records longer than
      the fixed length.  Any records that are truncated are copied  to
      the exceptions file.

      CONVERT INDEXED.DAT INDEXED.DAT
      CONVERT INDEXED.DAT INDEXED.DAT

      This  command  creates  the  output  file  INDEXED.DAT  with   a
      version-number  one  higher  that  that  of the input file.  The
DOCUMENTATION AND TRAINING                                             Page 2-24
DOCUMENTATION AND TRAINING


      output is  a  copy  of  the  input  file,  but  it  is  a  clean
      copy...bucket splits and rrvs disappear, and pointers to deleted
      records are reclaimed.



           The following switches are recommended:

      /EXCEPTIONS-FILE.....create error report
      /READ-CHECK..........reads input file twice
      /NOSHARE.............lock input file while converting
      /STATISTICS..........display statistics about conversion
      /WRITE-CHECK.........check new records on disk with memory



2.4  VAX-11 COBOL
     VAX-11 COBOL

2.4.1  Vax-11 Cobol Examples
       Vax-11 Cobol Examples

2.4.1.1  Indexed File / Simple Primary Key Read -
         Indexed File / Simple Primary Key Read

FILE-CONTROL.
     SELECT EMPLOYEE-FILE
     SELECT EMPLOYEE-FILE
            ASSIGN TO "PROG1.DAT"
            ASSIGN TO "PROG1.DAT"
            ORGANIZATION IS INDEXED.
            ORGANIZATION IS INDEXED.

DATA DIVISION.
FILE SECTION.

FD      EMPLOYEE-FILE
FD      EMPLOYEE-FILE
        RECORD CONTAINS 26 CHARACTERS
        RECORD CONTAINS 26 CHARACTERS
        LABEL RECORDS ARE STANDARD
        LABEL RECORDS ARE STANDARD
        VALUE OF ID IS EMPLOYEE-FILE-ID
        VALUE OF ID IS EMPLOYEE-FILE-ID
        DATA RECORD IS EMPLOYEE-RECORD
        DATA RECORD IS EMPLOYEE-RECORD
        ACCESS MODE IS DYNAMIC
        ACCESS MODE IS DYNAMIC
        RECORD KEY IS EMPLOYEE-BADGE-NUMBER.
        RECORD KEY IS EMPLOYEE-BADGE-NUMBER.

01      EMPLOYEE-RECORD.
01      EMPLOYEE-RECORD.
  02    EMPLOYEE-BADGE-NUMBER          PIC 9(6).
  02    EMPLOYEE-BADGE-NUMBER          PIC 9(6).
  02    EMPLOYEE-NAME.
  02    EMPLOYEE-NAME.
    03  EMPLOYEE-NAME-LAST             PIC X(10).
    03  EMPLOYEE-NAME-LAST             PIC X(10).
    03  EMPLOYEE-NAME-FIRST            PIC X(10).
    03  EMPLOYEE-NAME-FIRST            PIC X(10).

WORKING-STORAGE SECTION.
01      EMPLOYEE-FILE-ID               PIC X(12).

PROCEDURE DIVISION.
INITIAL-PARAGRAPH.
        DISPLAY "You must start off with a paragraph name".
OPEN-FILES.
        OPEN I-O EMPLOYEE-FILE.

ADD-A-RECORD.
        INITIALIZE EMPLOYEE-RECORD.
        INITIALIZE EMPLOYEE-RECORD.
        ACCEPT EMPLOYEE-BADGE-NUMBER.
        ACCEPT EMPLOYEE-NAME-LAST.
        ACCEPT EMPLOYEE-NAME-FIRST.
        WRITE EMPLOYEE-RECORD INVALID KEY,
        WRITE EMPLOYEE-RECORD INVALID KEY,
DOCUMENTATION AND TRAINING                                             Page 2-25
DOCUMENTATION AND TRAINING


              STOP RUN.
              STOP RUN.

TYPE-A-RECORD.
        INITIALIZE EMPLOYEE-RECORD.
        INITIALIZE EMPLOYEE-RECORD.
        ACCEPT EMPLOYEE-BADGE-NUMBER.
        ACCEPT EMPLOYEE-BADGE-NUMBER.
        READ EMPLOYEE-FILE INVALID KEY,
        READ EMPLOYEE-FILE INVALID KEY,
             DISPLAY "No such employee as ", EMPLOYEE-BADGE-NUMBER
             DISPLAY "No such employee as ", EMPLOYEE-BADGE-NUMBER
             GO TO SOMEWHERE.
             GO TO SOMEWHERE.
        DISPLAY EMPLOYEE-BADGE-NUMBER,"  ",EMPLOYEE-NAME.
        DISPLAY EMPLOYEE-BADGE-NUMBER,"  ",EMPLOYEE-NAME.



2.4.1.2  Indexed File / Alternate Key -
         Indexed File / Alternate Key

FILE-CONTROL.
     SELECT EMPLOYEE-FILE
     SELECT EMPLOYEE-FILE
            ASSIGN TO "PROG1.DAT"
            ASSIGN TO "PROG1.DAT"
            ORGANIZATION IS INDEXED.
            ORGANIZATION IS INDEXED.

DATA DIVISION.
FILE SECTION.

FD      EMPLOYEE-FILE
FD      EMPLOYEE-FILE
        RECORD CONTAINS 26 CHARACTERS
        RECORD CONTAINS 26 CHARACTERS
        LABEL RECORDS ARE STANDARD
        LABEL RECORDS ARE STANDARD
        VALUE OF ID IS EMPLOYEE-FILE-ID
        VALUE OF ID IS EMPLOYEE-FILE-ID
        DATA RECORD IS EMPPLOYEE-RECORD
        DATA RECORD IS EMPPLOYEE-RECORD
        ACCESS MODE IS DYNAMIC
        ACCESS MODE IS DYNAMIC
        RECORD KEY IS EMPLOYEE-BADGE-NUMBER
        RECORD KEY IS EMPLOYEE-BADGE-NUMBER
        ALTERNATE RECORD KEY IS EMPLOYEE-NAME-LAST WITH DUPLICATES.
        ALTERNATE RECORD KEY IS EMPLOYEE-NAME-LAST WITH DUPLICATES.

01      EMPLOYEE-RECORD.
  02    EMPLOYEE-BADGE-NUMBER          PIC 9(6).
  02    EMPLOYEE-NAME.
    03  EMPLOYEE-NAME-LAST             PIC X(10).
    03  EMPLOYEE-NAME-FIRST            PIC X(10).

PROCEDURE DIVISION.
INITIAL-PARA.
    |
    V
READ-A-RECORD.
       INITIALIZE EMPLOYEE-RECORD.
       INITIALIZE EMPLOYEE-RECORD.
       ACCEPT WS-ACCEPT-LAST-NAME.
       MOVE WS-ACCEPT-LAST-NAME TO EMPLOYEE-NAME-LAST.
       READ EMPLOYEE-FILE
       READ EMPLOYEE-FILE
            KEY IS EMPLOYEE-NAME-LAST
            KEY IS EMPLOYEE-NAME-LAST
            INVALID KEY,
            INVALID KEY,
                    DISPLAY "No such employee as ", EMPLOYEE-NAME-LAST
                    DISPLAY "No such employee as ", EMPLOYEE-NAME-LAST
                    GO TO SOMEWHERE.
                    GO TO SOMEWHERE.
       DISPLAY EMPLOYEE-BADGE-NUMBER,"  ",EMPLOYEE-NAME.

DUPL-NAME-LOOP.
       INITIALIZE EMPLOYEE-RECORD.
       INITIALIZE EMPLOYEE-RECORD.
       READ EMPLOYEE-FILE NEXT RECORD AT END,
       READ EMPLOYEE-FILE NEXT RECORD AT END,
             GO TO LEAVE-LOOP.
             GO TO LEAVE-LOOP.
       IF WS-ACCEPT-LAST-NAME IS EQUAL TO EMPLOYEE-NAME-LAST,
       IF WS-ACCEPT-LAST-NAME IS EQUAL TO EMPLOYEE-NAME-LAST,
             DISPLAY EMPLOYEE-BADGE-NUMBER,"  ",EMPLOYEE-NAME
             DISPLAY EMPLOYEE-BADGE-NUMBER,"  ",EMPLOYEE-NAME
             GO TO DUPL-NAME-LOOP
             GO TO DUPL-NAME-LOOP
DOCUMENTATION AND TRAINING                                             Page 2-26
DOCUMENTATION AND TRAINING


       ELSE,
       ELSE,
             GO TO LEAVE-LOOP.
             GO TO LEAVE-LOOP.



2.4.1.3  Indexed File / Start Verb -
         Indexed File / Start Verb

FILE-CONTROL.
     SELECT EMPLOYEE-FILE
     SELECT EMPLOYEE-FILE
            ASSIGN TO "PROG1.DAT"
            ASSIGN TO "PROG1.DAT"
            ORGANIZATION IS INDEXED.
            ORGANIZATION IS INDEXED.

DATA DIVISION.
FILE SECTION.

FD      EMPLOYEE-FILE
FD      EMPLOYEE-FILE
        RECORD CONTAINS 26 CHARACTERS
        RECORD CONTAINS 26 CHARACTERS
        LABEL RECORDS ARE STANDARD
        LABEL RECORDS ARE STANDARD
        VALUE OF ID IS EMPLOYEE-FILE-ID
        VALUE OF ID IS EMPLOYEE-FILE-ID
        DATA RECORD IS EMPPLOYEE-RECORD
        DATA RECORD IS EMPPLOYEE-RECORD
        ACCESS MODE IS DYNAMIC
        ACCESS MODE IS DYNAMIC
        RECORD KEY IS EMPLOYEE-BADGE-NUMBER
        RECORD KEY IS EMPLOYEE-BADGE-NUMBER
        ALTERNATE RECORD KEY IS EMPLOYEE-NAME-LAST WITH DUPLICATES.
        ALTERNATE RECORD KEY IS EMPLOYEE-NAME-LAST WITH DUPLICATES.

01      EMPLOYEE-RECORD.
  02    EMPLOYEE-BADGE-NUMBER          PIC 9(6).
  02    EMPLOYEE-NAME.
    03  EMPLOYEE-NAME-LAST             PIC X(10).
    03  EMPLOYEE-NAME-FIRST            PIC X(10).

WORKING-STORAGE SECTION.
01      WS-ACCEPT-LAST-NAME            PIC X(80).
01      NUL                            PIC X(80).
01      WS-STR-TRIM-LENGTH             PIC S9(9) USAGE IS COMP.

PROCEDURE DIVISION.
INITIAL-PARA.
    |
    V
READ-A-RECORD.
       INITIALIZE EMPLOYEE-RECORD.
       ACCEPT WS-ACCEPT-LAST-NAME.
       MOVE WS-ACCEPT-LAST-NAME TO EMPLOYEE-NAME-LAST.
       CALL "STR$TRIM" USING BY DESCRIPTOR NUL
                             BY DESCRIPTOR WS-ACCEPT-LAST-NAME
                             BY REFERENCE WS-STR-TRIM-LENGTH.
        START EMPLOYEE-FILE    (key is equal to/ key is greater than)
        START EMPLOYEE-FILE    (key is equal to/ key is greater than)
              KEY IS NOT LESS THAN EMPLOYEE-NAME-LAST
              KEY IS NOT LESS THAN EMPLOYEE-NAME-LAST
              INVALID KEY,
              INVALID KEY,
                      DISPLAY "No such employee like ", WS-ACCEPT-LAST-NAME
                      DISPLAY "No such employee like ", WS-ACCEPT-LAST-NAME
                      GO TO SOMEWHERE.
                      GO TO SOMEWHERE.

DUPL-NAME-LOOP.
DUPL-NAME-LOOP.
       INITIALIZE EMPLOYEE-RECORD.
       INITIALIZE EMPLOYEE-RECORD.
       READ EMPLOYEE-FILE NEXT RECORD AT END,
       READ EMPLOYEE-FILE NEXT RECORD AT END,
             GO TO LEAVE-LOOP.
             GO TO LEAVE-LOOP.
       IF WS-ACCEPT-LAST-NAME IS EQUAL TO EMPLOYEE-NAME-LAST(1:WS-STR-TRIM-LENGTH),
       IF WS-ACCEPT-LAST-NAME IS EQUAL TO EMPLOYEE-NAME-LAST(1:WS-STR-TRIM-LENGTH),
             DISPLAY EMPLOYEE-BADGE-NUMBER,"  ",EMPLOYEE-NAME
             DISPLAY EMPLOYEE-BADGE-NUMBER,"  ",EMPLOYEE-NAME
             GO TO DUPL-NAME-LOOP
             GO TO DUPL-NAME-LOOP
DOCUMENTATION AND TRAINING                                                       Page 2-27
DOCUMENTATION AND TRAINING


       ELSE,
       ELSE,
             GO TO LEAVE-LOOP.
             GO TO LEAVE-LOOP.



2.4.1.4  Relative File -
         Relative File

FILE-CONTROL.
       SELECT EMPLOYEE-FILE
       SELECT EMPLOYEE-FILE
              ASSIGN TO "PROG0.DAT"
              ASSIGN TO "PROG0.DAT"
              ORGANIZATION IS RELATIVE.
              ORGANIZATION IS RELATIVE.
DATA DIVISION.
FILE SECTION.
FD      EMPLOYEE-FILE
FD      EMPLOYEE-FILE
        RECORD CONTAINS 26 CHARACTERS
        RECORD CONTAINS 26 CHARACTERS
        LABEL RECORDS ARE STANDARD
        LABEL RECORDS ARE STANDARD
        VALUE OF ID IS EMPLOYEE-FILE-ID
        VALUE OF ID IS EMPLOYEE-FILE-ID
        DATA RECORD IS EMPLOYEE-RECORD
        DATA RECORD IS EMPLOYEE-RECORD
        ACCESS MODE IS DYNAMIC
        ACCESS MODE IS DYNAMIC
        RELATIVE KEY IS REL-KEY.
        RELATIVE KEY IS REL-KEY.
01      EMPLOYEE-RECORD.
  02    EMPLOYEE-BADGE-NUMBER   PIC 9(6).
  02    EMPLOYEE-NAME           PIC X(20).
WORKING-STORAGE SECTION.
01      WS-FUNCTION             PIC X(10).
  88    FUNCTION-TYPE   VALUE "T","TY","TYP","TYPE".
  88    FUNCTION-ADD    VALUE "A","AD","ADD".
01      REL-KEY                 PIC 9(6).
01      REL-KEY                 PIC 9(6).
01      EMPLOYEE-FILE-ID        PIC X(12).
PROCEDURE DIVISION.
OPEN-FILES.
        OPEN I-O EMPLOYEE-FILE.
REQUEST-FUNCTION.
        DISPLAY "FUNCTION? " WITH NO ADVANCING.
        ACCEPT WS-FUNCTION.
        IF WS-FUNCTION IS EQUAL TO SPACES,
                GO TO END-OF-PROGRAM.
        IF FUNCTION-TYPE,
                GO TO TYPE-FUNCTION.
        IF FUNCTION-ADD,
                GO TO ADD-FUNCTION.
        DISPLAY "Only type or add is valid".
        GO TO REQUEST-FUNCTION.
TYPE-FUNCTION.
        INITIALIZE EMPLOYEE-RECORD.
        DISPLAY "Badge Number? " WITH NO ADVANCING.
        ACCEPT REL-KEY.
        ACCEPT REL-KEY.
        READ EMPLOYEE-FILE INVALID KEY,
        READ EMPLOYEE-FILE INVALID KEY,
                DISPLAY "No such employee as ", REL-KEY
                DISPLAY "No such employee as ", REL-KEY
                GO TO REQUEST-FUNCTION.
                GO TO REQUEST-FUNCTION.
        DISPLAY EMPLOYEE-BADGE-NUMBER,"  ",EMPLOYEE-NAME.
        GO TO REQUEST-FUNCTION.
ADD-FUNCTION.
        INITIALIZE EMPLOYEE-RECORD.
        DISPLAY "Badge Number? " WITH NO ADVANCING.
        ACCEPT EMPLOYEE-BADGE-NUMBER.
        DISPLAY "Name? " WITH NO ADVANCING.
        ACCEPT EMPLOYEE-NAME.
        MOVE EMPLOYEE-BADGE-NUMBER TO REL-KEY.
        MOVE EMPLOYEE-BADGE-NUMBER TO REL-KEY.
DOCUMENTATION AND TRAINING                                   Page 2-28
DOCUMENTATION AND TRAINING


        WRITE EMPLOYEE-RECORD INVALID KEY,
        WRITE EMPLOYEE-RECORD INVALID KEY,
                DISPLAY "INVALID KEY ON WRITE"
                DISPLAY "INVALID KEY ON WRITE"
                STOP RUN.
                STOP RUN.
        GO TO REQUEST-FUNCTION.
END-OF-PROGRAM.
        CLOSE EMPLOYEE-FILE.
        STOP RUN.



2.4.1.5  Variable Length Record -
         Variable Length Record

DATA DIVISION.
FILE SECTION.

FD      FILE-OUT
FD      FILE-OUT
        RECORD VARYING 1 TO 80 CHARACTERS DEPENDING ON LEN
        RECORD VARYING 1 TO 80 CHARACTERS DEPENDING ON LEN
        VALUE OF ID IS OUT-FILE-NAME.

01      OUT-REC         PIC X(80). 

WORKING-STORAGE SECTION.

01  DATA-STRING                         PIC X(80).
01  LEN                                 PIC 9(05) COMP.
01  NUL                                 PIC X(80).

PROCEDURE DIVISION.
010-START.
        OPEN OUTPUT FILE-OUT.
        INITIALIZE OUT-REC.
        MOVE LINE-01 TO DATA-STRING.
        PERFORM 100-WRITE THRU WRITE-EXIT.
100-WRITE.
        CALL "STR$TRIM" USING BY DESCRIPTOR NUL
        CALL "STR$TRIM" USING BY DESCRIPTOR NUL
                              BY DESCRIPTOR DATA-STRING
                              BY DESCRIPTOR DATA-STRING
                              BY REFERENCE LEN.
                              BY REFERENCE LEN.
        MOVE DATA-STRING TO OUT-REC.
        MOVE DATA-STRING TO OUT-REC.
        WRITE OUT-REC.
        WRITE OUT-REC.
WRITE-EXIT.
        EXIT.



2.4.1.6  Copy From Dictionary -
         Copy From Dictionary

PROG3                                                           27-Jun-1983 
Source Listing                                                  27-Jun-1983 

    1         IDENTIFICATION DIVISION.
    2         PROGRAM-ID. PROG3 IS INITIAL PROGRAM.
    3         AUTHOR. Richard A. Farrenkopf.
    4         INSTALLATION. Vax-11/780 for Corporate Purchasing.
    5         DATE-WRITTEN. June 20,1983.
    6         DATE-COMPILED.
    7         SECURITY. This program requires no security.
    8         
    9         ENVIRONMENT DIVISION.
   10         CONFIGURATION SECTION.
DOCUMENTATION AND TRAINING                                             Page 2-29
DOCUMENTATION AND TRAINING


   11         SOURCE-COMPUTER. Vax-11.
   12         OBJECT-COMPUTER. Vax-11
   13                      Memory Size 2000 words.
   14         INPUT-OUTPUT SECTION.
   15         FILE-CONTROL.
   16             SELECT EMPLOYEE-FILE
   17                     ASSIGN TO "PROG2.DAT"
   18                     ORGANIZATION IS INDEXED.
   19         
   20         DATA DIVISION.
   21         FILE SECTION.
   22         FD  EMPLOYEE-FILE
   23             RECORD CONTAINS 26 CHARACTERS
   24             LABEL RECORDS ARE STANDARD
   25             VALUE OF ID IS EMPLOYEE-FILE-ID
   26             DATA RECORD IS EMPLOYEE-RECORD
   27             ACCESS MODE IS DYNAMIC
   28             RECORD KEY IS EMPLOYEE-BADGE-NUMBER
   29             ALTERNATE RECORD KEY IS EMPLOYEE-NAME-LAST WITH DUPLICATES.
   30         
   31         COPY "CDD$TOP.TYMSHR.RICK.CDD-EMPLOYEE-RECORD FROM DICTIONARY.
              COPY "CDD$TOP.TYMSHR.RICK.CDD-EMPLOYEE-RECORD FROM DICTIONARY.
   32L       
   33L        CDD$TOP.TYMSHR.RICK.CDD-EMPLOYEE-RECORD
   3          C
   34L       
   35L        01  EMPLOYEE-RECORD.
   3
   36L            02  EMPLOYEE-BADGE-NUMBER    PIC 9(6).
   37L            02  EMPLOYEE-NAME.
   38L                03  EMPLOYEE-NAME-FIRST  PIC X(10).
   39L                03  EMPLOYEE-NAME-LAST   PIC X(10).
   40         
   41         



2.4.2  Inter-Program Communication
       Inter-Program Communication

2.4.2.1  The Call Statement -
         The Call Statement

        A Call statement transfers the run  unit's  execution  control
from  the  calling program to the beginning of the called subprogram's
Procedure Division.   The  first  time  the  called  subprogram  gains
execution  control,  its state is that of a fresh copy of the program.
Thereafter, each time it is called, its state is the same as the  last
exit  from that program except when the called program has the Initial
clause.



2.4.2.2  The Exit Program Statement -
         The Exit Program Statement

        To return execution control to the calling program, the called
subprogram  executes  an Exit Program statement.  You can include more
than one Exit Program statement in a subprogram.  On executing an Exit
Program statement, control returns to the next statement following the
calling program's Call statement.  For example,

        IDENTIFICATION DIVISION.           IDENTIFICATION DIVISION.
        PROGRAM-ID. MAIN                   PROGRAM-ID. SUB1 INITIAL.
        ENVIRONMENT DIVISON.               ENVIRONMENT DIVISION.
DOCUMENTATION AND TRAINING                                   Page 2-30
DOCUMENTATION AND TRAINING


        DATA DIVISION.                     DATA DIVISION.
        PROCEDURE DIVISION.                PROCEDURE DIVISION.
        BEGIN.                           / BEGIN.
              !                         /         !
              !                        /          !
              V                       /           !
              CALL "SUB1".-----------/            !
              DISPLAY "BACK".                     !
              STOP RUN.    \                      V
                            \--------------------EXIT PROGRAM.




2.4.2.3  Accessing Another Program's Data Division. -
         Accessing Another Program's Data Division.

     1.  External Clause
         External Clause

                The External Clause is one method of passing arguments
         among   programs.    External  data  can  be  shared  between
         calling/called seperately compiled programs.  For example, in
         the  following  Working-Storage Section entry, the data items
         in COMMON-RECORD are available to any program  in  the  image
         that  also  describes  COMMON-RECORD and its data items.  The
         description of  the  data-items  must  be  identical  in  all
         programs in which they are defined.

         IDENTIFICATION DIVISION.          IDENTIFICATION DIVISION.
         PROGRAM-ID. MAIN.                 PROGRAM-ID. SUB1.
         ENVIRONMENT DIVISON.              ENVIRONMENT DIVISION.
         DATA DIVISION.                    DATA DIVISION.
         WORKING-STORAGE SECTION.          WORKING-STORAGE SECTION.
         01  COMMON-RECORD EXTERNAL.       01   COMMON-RECORD EXTERNAL.
           02 A     PIC 9(2) COMP.           02 A   PIC 9(2) COMP.
           02 B     PIC 9(2) COMP.           02 B   PIC 9(2) COMP.
           02 C     PIC 9(2) COMP.           02 C   PIC 9(2) COMP.
         01 C-RES  PIC 99.
         PROCEDURE DIVISION.                PROCEDURE DIVISION.
         BEGIN.                             BEGIN.
            MOVE 1 TO A.                       ADD A,B GIVING C.
            MOVE 1 TO B.                       EXIT PROGRAM.
            CALL "SUB1".
            MOVE C TO C-RES.
            DISPLAY C-RES.
            STOP RUN.  

     2.  The Using Giving Phrase
         The Using Giving Phrase

                Another  way  to  access  a  calling  program's   Data
         Division  is to use a Call statement and a Procedure Division
         Using phrase, both containing an equal number of  data-names.
         The  order  in which Using identifiers appear in both calling
         and called programs determines the correspondence  of  single
         sets  of  data  available  to  the  called  subprogram.   The
         correspondence is by  position,  not  by  name.   The  Giving
         phrase  allows  the  subprogram to return a value through the
         data item in the Giving clause.  For example,
         IDENTIFICATION DIVISION.          IDENTIFICATION DIVISION.
         PROGRAM-ID. MAIN.                 PROGRAM-ID. SUB1
DOCUMENTATION AND TRAINING                                   Page 2-31
DOCUMENTATION AND TRAINING


         ENVIRONMENT DIVISON.              ENVIRONMENT DIVISION.
         DATA DIVISION.                    DATA DIVISION.
         WORKING-STORAGE SECTION.          LINKAGE SECTION.
         01 A      PIC 9(2) COMP.          01 X     PIC 9(2) COMP.
         01 B      PIC 9(2) COMP.          01 Y     PIC 9(2) COMP.
         01 C      PIC 9(2) COMP.          01 Z     PIC 9(2) COMP.
         01 C-RES  PIC 99.
         PROCEDURE DIVISION.               PROCEDURE DIVISION USING X,Y,Z.
         BEGIN.                            BEGIN.
            MOVE 1 TO A.                      ADD X,Y GIVING Z.
            MOVE 1 TO B.                      EXIT PROGRAM.
            CALL "SUB1" USING A,B,C.
            MOVE C TO C-RES.
            DISPLAY C-RES.
            STOP RUN.  

              In  this  format,  the  CALL  statement  can  make  data
         available  to  the  called  program  by four argument passing
         mechanisms.  A called Cobol subprogram  must  have  arguments
         passed to it by one of the first two mechanisms (by reference
         or by content).  In other words, procedures written in  Cobol
                          In other words, procedures written in  Cobol
         can  only accept arguments passed by REFERENCE or by CONTENT.
         can  only accept arguments passed by REFERENCE or by CONTENT
         Passing by Reference is the default for Cobol.

         1.  Reference
             Reference

                  The By Reference mechanism passes the address of the
             argument  to  the  called  program.   The  called program
             references the same storage area for the data item as the
             calling   program.    This  mechanism  ensures  that  the
             contents of the  parameter  in  the  calling  program  is
             identical at all times with the contents of the parameter
             in the called program.  Normally this parameter is passed
             as PIC S9(9) COMP.

         2.  Content
             Content

                  The By Content mechanism copies the  argument  to  a
             temporary   location,  and  passes  the  address  of  the
             temporary location to the called program.  This mechanism
             ensures   that  the  called  program  cannot  change  the
             original contents of the argument.

         3.  Value
             Value

                  This mechanism passes the  value  of  the  argument.
             Normally it is passed as PIC S9(9) COMP.

         4.  Descriptor
             Descriptor

                  This mechanism passes the address of the data item's
             descriptor and is normally passed as PIC X(--).


DOCUMENTATION AND TRAINING                                   Page 2-32
DOCUMENTATION AND TRAINING


2.4.3  Calling The Run Time Library And System Services
       Calling The Run Time Library And System Services

     The Run Time Library is a set of routines that do special  things
you  might  not  ordinarily  be  able  to  do.   There  are 9 types of
routines.

     1.  LIB$ - General Purpose Procedures
         LIB$ - General Purpose Procedures

     2.  STR$ - String Manipulation Procedures
         STR$ - String Manipulation Procedures

     3.  SCR$ - Terminal Screen Procedures
         SCR$ - Terminal Screen Procedures

     4.  COB$ - Cobol-specific Support Procedures
         COB$ - Cobol-specific Support Procedures

     5.  OTS$ - Language Independant Support Procedures
         OTS$ - Language Independant Support Procedures

     6.  MTH$ - Mathematical Procedures
         MTH$ - Mathematical Procedures

     7.  BAS$ - Basic-specific Support Procedures
         BAS$ - Basic-specific Support Procedures

     8.  FOR$ - Fortran-specific Support Procedures
         FOR$ - Fortran-specific Support Procedures

     9.  PL1$ - PL1-specific Support Procedures
         PL1$ - PL1-specific Support Procedures


     All System-Services begin with SYS$ and do other types of things.
     All System-Services begin with SYS$
Both types of routines (RTL and System Services) are called in similar
ways.  When reading a description of these procedures you must  figure
out  how  to  pass  it  its  parameters  (whether by reference, value,
descriptor, or content).  The following table will attempt to help you
with this decision.
       |---------------------|-------------------------------------|
       | Calling Mechanism   |  Words to look for  | Picture       |
       |---------------------|---------------------|---------------|
       |---------------------|---------------------|---------------|
       |                     |                     |               |
       |  Reference          |  "Address of ..."   | PIC S9(9) COMP|
          Reference                                  PIC S9(9) COMP
       |---------------------|---------------------|---------------|
       |                     |  "Value","Mask",    |               |
       |  Value              |  "Number"           | PIC S9(9) COMP|
          Value                                      PIC S9(9) COMP
       |                     |omission of "address"|               |
       |                     |  when in doubt...   |               |
       |---------------------|---------------------|---------------|
       |                     |                     |               |
       |  Descriptor         |  "Address of a      | PIC X(..)     |
          Descriptor                                 PIC X(..)
       |                     |   descriptor"       |               |
       |---------------------|---------------------|---------------|
       |                     |                     |               |
       |  Content            |  "The contents of"  |               |
       |---------------------|---------------------|---------------|

     The Vax-11 procedure calling standard requires that a status code
be returned from an external procedure to indicate success or failure.
The status code is returned to  the  calling  program  as  a  function
result.   To  use the status code from a Cobol program you must do two
things.  First, you must call the external  procedure  as  a  function
(use  the  ...giving  phrase).  Second, declare the variable receiving
the status code in the range of PIC S9(5) COMP to PIC S9(9) COMP.  You
check  for  success  or  failure  of  an  external  procedure  with  a
DOCUMENTATION AND TRAINING                                   Page 2-33
DOCUMENTATION AND TRAINING


SUCCESS/FAILURE test of the status value in 2 ways.
    WORKING-STORAGE SECTION.
    WORKING-STORAGE SECTION.
    01    STAT   PIC S9(9) COMP.
    01    STAT   PIC S9(9) COMP.
        | 
        |
        V
        V
        
        CALL "SUB" USING ... GIVING STAT.
        CALL "SUB" USING ... GIVING STAT.
        IF STAT IS FAILURE, HANDLE ERROR.
        IF STAT IS FAILURE, HANDLE ERROR.


    WORKING-STORAGE SECTION.
    WORKING-STORAGE SECTION.
    01    STAT         PIC S9(9) COMP.
    01    STAT         PIC S9(9) COMP.
    01    STATUS-CODE  PIC S9(9) COMP VALUE IS EXTERNAL STATUS-CODE.
    01    STATUS-CODE  PIC S9(9) COMP VALUE IS EXTERNAL STATUS-CODE.
        |
        |
        V
        V
        CALL "SUB" USING ... GIVING STAT.
        CALL "SUB" USING ... GIVING STAT.
        IF STAT IS EQUAL TO STATUS-CODE, HANDLE ERROR.
        IF STAT IS EQUAL TO STATUS-CODE, HANDLE ERROR.

     Status codes for system services,  run-time  library  procedures,
and   record   management   services   follow  the  naming  convention
FACILITYCODE$STATUSCODE.  Specific status codes are listed  with  each
procedure  in  the  appropriate  reference  manual.   An examples of a
specific system service and  testing  for  specific  error  conditions
follows:

IDENTIFICATION DIVISION.
PROGRAM-ID. GETMSG.
DATA DIVISION.
WORKING-STORAGE SECTION.
01      MESSAGE-ID              PIC 9(9) COMP.
01      MESSAGE-LENGTH          PIC 9(9) COMP.
01      MESSAGE-TEXT            PIC X(132).
01      MASK                    PIC 9(9) COMP VALUE 15.
01      OUT-ARRAY               PIC X(4).
01      MESSAGE-ID-DIS          PIC X(4).
01      MSG-1                   PIC X(15) VALUE "Buffer Overflow".
01      MSG-2                   PIC X(17) VALUE "Message Not Found".
01      STAT                    PIC S9(9) COMP.
01      STAT                    PIC S9(9) COMP.
01      SS$BUFFEROVF            PIC S9(9) COMP VALUE EXTERNAL SS$BUFFEROVF.
01      SS$BUFFEROVF            PIC S9(9) COMP VALUE EXTERNAL SS$BUFFEROVF.
01      CAN-BE-CALLED-ANYTHING  PIC S9(9) COMP VALUE EXTERNAL SS$MSGNOTFND.
01      CAN-BE-CALLED-ANYTHING  PIC S9(9) COMP VALUE EXTERNAL SS$MSGNOTFND.

PROCEDURE DIVISION.
BEGIN.
        DISPLAY "Enter a message number " WITH NO ADVANCING.
        ACCEPT MESSAGE-ID-DIS AT END,
                STOP RUN
        END-ACCEPT.

        MOVE MESSAGE-ID-DIS TO MESSAGE-ID.
        INITIALIZE MESSAGE-TEXT.

        CALL "SYS$GETMSG" USING BY VALUE      MESSAGE-ID
        CALL "SYS$GETMSG" USING BY VALUE      MESSAGE-ID
                                BY REFERENCE  MESSAGE-LENGTH
                                BY REFERENCE  MESSAGE-LENGTH
                                BY DESCRIPTOR MESSAGE-TEXT
                                BY DESCRIPTOR MESSAGE-TEXT
                                BY VALUE      MASK
                                BY VALUE      MASK
                                BY REFERENCE  OUT-ARRAY
                                BY REFERENCE  OUT-ARRAY
                          GIVING STAT.
                          GIVING STAT.

        EVALUATE STAT
        EVALUATE STAT
DOCUMENTATION AND TRAINING                                             Page 2-34
DOCUMENTATION AND TRAINING


                 WHEN SS$BUFFEROVF DISPLAY MSG-1
                 WHEN SS$BUFFEROVF DISPLAY MSG-1
                 WHEN CAN-BE-CALLED-ANYTHING DISPLAY MSG-2
                 WHEN CAN-BE-CALLED-ANYTHING DISPLAY MSG-2
                 WHEN OTHER DISPLAY MESSAGE-TEXT(1:MESSAGE-LENGTH)
                 WHEN OTHER DISPLAY MESSAGE-TEXT(1:MESSAGE-LENGTH)
        END-EVALUATE.
        END-EVALUATE.

        GO TO BEGIN.

     A short list follows just to give you an idea of  what  types  of
procedures are available for you to call on.

     1.  LIB$DISABLECTRL:  Disable control-y
         LIB$DISABLECTRL:

     2.  LIB$DOCOMMAND:  Execute DCL command
         LIB$DOCOMMAND:

     3.  LIB$FINDFILE:  Directory of a file
         LIB$FINDFILE:

     4.  MTH$SQRT:  Square-root of a number
         MTH$SQRT:

     5.  STR$TRIM:  Trim trailing blanks and tabs from string
         STR$TRIM:

     6.  STR$UPCASE:  Convert string to uppercase
         STR$UPCASE:




2.4.4  Dec-10 Cobol Vs Vax-11 Cobol
       Dec-10 Cobol Vs Vax-11 Cobol

     Besides the already mentioned differences (RMS  file  access  and
RTL/System  Service  Library  Procedures), Vax-11 Cobol has many other
differences.  I will briefly point out some new features and then talk
about  some  of the differences.  One should note that the term Dec-10
Cobol is used mainly to refer to ANSII-68 Cobol.  Vax-11  Cobol  is  a
subset  of  Cobol-81  standards  of which many are similar to ANSII-74
Cobol.



2.4.4.1  New Features -
         New Features

     1.  Delimited Scope Statements
         Delimited Scope Statements

              There  are  certain  statements  now  that  are   called
         delimited  scope  statements.  This basically means that they
         can be terminated with special END- scope  terminators.   For
         example,  the  following  If  statements are identical.  Note
         that the end-if statement takes the place of the period after
         the  first perform no-routine statement.  This is the purpose
         of end-if.  It delimits or marks the  end  of  the  statement
         just  as the period does in the second if statement.  Some of
         the statements that can be delimited in this way  are  listed
         here:   add  (end-add),  compute  (end-compute), if (end-if),
         perform (end-perform), read (end-read), write(end-write).

         IF WS-VALUE IS EQUAL TO "Y",
               PERFORM YES-ROUTINE
         ELSE,
               PERFORM NO-ROUTINE
         END-IF.
DOCUMENTATION AND TRAINING                                             Page 2-35
DOCUMENTATION AND TRAINING


         IF WS-VALUE IS EQUAL TO "Y",
               PERFORM YES-ROUTINE
         ELSE,
               PERFORM NO-ROUTINE.

     2.  Evaluate
         Evaluate

              This verb selects a program action based on one or more
         conditions. It can be
         used to eliminate confusing nested If..Else statements. It
         can be used as 
         follows:

         ACCEPT WS-RESPONSE.
         EVALUATE WS-RESPONSE
              WHEN "ADD"    PERFORM ADD-ROUTINE
              WHEN "CHANGE" PERFORM CHANGE-ROUTINE
              WHEN "DELETE" PERFORM DELETE-ROUTINE
              WHEN "EXIT"   PERFORM EXIT-ROUTINE
              WHEN OTHER    GO TO INVALID-RESPONSE
         END-EVALUATE.

     3.  Failure
         Failure

              This is a reserved word now used to test  return  status
         codes  of  Cobol  and  non-Cobol  procedures  for  success of
         failure conditions.  The data-item tested must be a  longword
         Comp integer (PIC S9(9) COMP).

         IF WS-RETURN-STATUS IS FAILURE ...

     4.  Initialize
         Initialize

              This statement is used to set  selected  types  of  data
         fields  to  predetermined  values.   One  of  its  uses is to
         'clear'  data-items.   It  will  move  zeros  to  a   numeric
         data-item or spaces to an alphanumeric item.

         INITIALIZE EMPLOYEE-RECORD.

     5.  Inspect
         Inspect

              This statement replaces the examine verb on  the  Dec-10
         and  is much more powerfull.  For example, the following code
         converts  alphabetic  phone   exchanges   to   numeric   (ie.
         8-ADG-4120 becomes 8-234-4120).

         INSEPECT WS-PHONE-NUMBER CONVERTING
                  "ABCDEFGHIJKLMNOPRSTUVWXY" TO 
                  "222333444555666777888999"
                  AFTER INITIAL "-".

     6.  Merge
         Merge

              This  statement  combines  two   or   more   identically
         sequenced files on a set of key values.
DOCUMENTATION AND TRAINING                                             Page 2-36
DOCUMENTATION AND TRAINING


     7.  Perform
         Perform

              In Vax-11 Cobol, the perform  verb  is  more  powerfull.
         Especially  nice  is  the  feature  of the in-line perform as
         follows:

         PERFORM VARYING WS-ITEM FROM 1 BY 2 UNTIL WS-ITEM > 7
                 MOVE CHARA(WS-ITEM) TO CHARB(WS-ITEM)
                 MOVE CHARC(WS-ITEM) TO CHARD(WS-ITEM)
         END-PERFORM.

     8.  Reference Modification
         Reference Modification

              This allows you to reference a specified part of a  data
         item.  An example follows:

         01   TEXT-MESSAGE     PIC X(7) VALUE "ABCDEFG".
         01   NUM              PIC 9 VALUE 4.

         DISPLAY TEXT-MESSAGE(1:NUM).
                             /   |
            position to start    |-> number of characters
            This displays "abcd". 

         DISPLAY TEXT-MESSAGE(1:) will display the whole string.




2.4.4.2  Vax-11 Cobol Differences -
         Vax-11 Cobol Differences

     1.  The length of Comp data items is different.
         The length of Comp data items is different.

           PIC S9(1)  COMP <--> PIC S9(4)  COMP --> 2 BYTES=WORD
           PIC S9(1)  COMP <--> PIC S9(4)  COMP --> 2 BYTES=WORD
           PIC S9(5)  COMP <--> PIC S9(9)  COMP --> 4 BYTES=LONGWORD
           PIC S9(5)  COMP <--> PIC S9(9)  COMP --> 4 BYTES=LONGWORD
           PIC S9(10) COMP <--> PIC S9(18) COMP --> 8 BYTES=QUADWORD
           PIC S9(10) COMP <--> PIC S9(18) COMP --> 8 BYTES=QUADWORD

     2.  Accept treats everything as alphanumeric.
         Accept treats everything as alphanumeric.

              This means that if you Accept a PIC 9 data-item you  can
         not  do  arithmetic  with  it.   If  you want to do this, the
         following is suggested:

         WORKING-STORAGE SECTION.
         01     WS-ACCEPT     PIC X(6).
         01     WS-NUM        PIC 9(6).

         PROCEDURE DIVISION.
         START-PROGRAM.
                Accept Ws-Accept at end,
                       display "This is typed upon a control-z".
                Unstring Ws-Accept delimited by spaces into Ws-Num.

     3.  You must start Procedure Division with paragraph.
         You must start Procedure Division with paragraph.

     4.  If you use sections, must section whole program.
         If you use sections, must section whole program.
DOCUMENTATION AND TRAINING                                             Page 2-37
DOCUMENTATION AND TRAINING


     5.  Copy statement is more powerfull
         Copy statement is more powerfull

         COPY MP-RECORD IN "[RICK.LIBRARY]MIS"
         COPY MP-RECORD IN "[RICK.LIBRARY]MIS"
         COPY "CDD$TOP.TYMSHR.RICK.CDD-MP-RECORD" FROM DICTIONARY
         COPY "CDD$TOP.TYMSHR.RICK.CDD-MP-RECORD" FROM DICTIONARY

     6.  Select statement is more powerfull
         Select statement is more powerfull

         INPUT-OUTPUT SECTION.
         FILE-CONTROL.
              SELECT EMPLOYEE-FILE
                     ASSIGN TO ".MST"
                     ORGANIZATION IS INDEXED.

         DATA DIVISION.
         FILE SECTION.
         FD      EMPLOYEE-FILE
                 RECORD CONTAINS 26 CHARACTERS
                 LABEL RECORDS ARE STANDARD
                 VALUE OF ID IS EMPLOYEE-FILE-ID
                 DATA RECORD IS EMPLOYEE-RECORD
                 ACCESS MODE IS DYNAMIC
                 RECORD KEY IS EMPLOYEE-BADGE-NUMBER.

         01      EMPLOYEE-RECORD.
           02    EMPLOYEE-BADGE-NUMBER     PIC X(6).
           02    EMPLOYEE-NAME.
             03  EMPLOYEE-NAME-FIRST       PIC X(10).
             03  EMPLOYEE-NAME-LAST        PIC X(10).

         WORKING-STORAGE SECTION.
         01      EMPLOYEE-FILE-ID.
           02    EMPLOYEE-FILE-NAME        PIC X(9).
           02    EMPLOYEE-FILE-EXT         PIC X(3).

         PROCEDURE DIVISION.
         INITIAL-PARAGRAPH.
                 Display "Starting PROG3 v1.0".
         OPEN-FILE.
                 DISPLAY "Enter file-name: " with no advancing.
                 Accept Employee-File-Name.
                 Display "Enter file-ext:  " with no advancing.
                 Accept Employee-File-Ext.
                 Open I-O EMPLOYEE-FILE.

     7.  Cannot SET data-items that are not indexed
         Cannot SET data-items that are not indexed

         WORKING-STORAGE SECTION.
         01     WS-FAMILY.
           02    WS-CHILDREN OCCURS 4 TIMES INDEXED BY WS-INDEX.
             03  WS-CHILD-NAME   PIC X(20).
             03  WS-CHILD-AGE    PIC 99.
         01      WS-COUNTER      PIC 99.
         01      WS-COUNTER      PIC 99.
         PROCEDURE DIVISION.
         START-PROGRAM.
               SET WS-INDEX TO 1.  (this is legal)
               move 1 to ws-index  (this is illegal)

               MOVE 1 TO WS-COUNTER   (this is legal)
               ADD 1 TO WS-COUNTER    (this is legal)
               ADD 1 TO WS-COUNTER    (this is legal)
DOCUMENTATION AND TRAINING                                             Page 2-38
DOCUMENTATION AND TRAINING


               set ws-counter up by 1 (this is illegal)
               set ws-counter up by 1 (this is illegal)
               set 1 to ws-counter    (this is illegal)

     8.  "Today" no longer exists
         "Today" no longer exists

         ACCEPT WS-DATA-ITEM FROM DATE        
              --> YYMMDD (DD is day of week)
         ACCEPT WS-DATA-ITEM FROM DAY         
              --> YYDDD  (DDD is day of year)
         ACCEPT WS-DATA-ITEM FROM TIME        
              --> HHMMSSZZ (ZZ is hundreth of second)
         ACCEPT WS-DATA-ITEM FROM DAY-OF-WEEK 
              --> D (D is day of week 1(Mon) to 7(Sun)

     9.  Channel numbers are not used on the Vax
         Channel numbers are not used on the Vax

              Instead of CHANNEL(1) is TOP-OF-PAGE use the following:

         ENVIRONMENT DIVISION.
         SPECIAL-NAMES.
               C01 IS TOP-OF-PAGE.

         PROCEDURE DIVISION.
                WRITE REPORT-FILE-RECORD AFTER TOP-OF-PAGE.

    10.  Watch out for SD record size
         Watch out for SD record size

    11.  "Memory Size" is only documentary
         "Memory Size" is only documentary

    12.  Data-items should be initialized (not necessarily spaces)
         Data-items should be initialized (not necessarily spaces)

    13.  Before Reading a record, Initialize it
         Before Reading a record, Initialize it

                SELECT EMPLOYEE-FILE
                       ASSIGN TO "PROG2.DAT"
                       ORGANIZATION IS INDEXED.

         DATA DIVISION.
         FILE SECTION.
         FD      EMPLOYEE-FILE
                 RECORD CONTAINS 26 CHARACTERS
                 LABEL RECORDS ARE STANDARD
                 VALUE OF ID IS EMPLOYEE-FILE-ID
                 DATA RECORD IS EMPLOYEE-RECORD
                 ACCESS MODE IS DYNAMIC
                 RECORD KEY IS EMPLOYEE-BADGE-NUMBER.

         01      EMPLOYEE-RECORD.
           02    EMPLOYEE-BADGE-NUMBER      PIC X(6).
           02    EMPLOYEE-NAME.
             03  EMPLOYEE-NAME-FIRST        PIC X(10).
             03  EMPLOYEE-NAME-LAST         PIC X(10).

         PROCEDURE DIVISION.
         INITIAL-PARAGRAPH.
                 Display "Starting PROG3 v1.0".
         DUPL-NAME-LOOP.
                 Initialize Employee-Record.
                 Read Employee-File next record at end,
DOCUMENTATION AND TRAINING                                             Page 2-39
DOCUMENTATION AND TRAINING


                         display "reached end-of-file"
                         go to end-of-program.
                 Display Employee-badge-number,"  ",Employee-Name.
                 Go to Dupl-Name-Loop.

    14.  Display-6 and Display-7 are not needed
         Display-6 and Display-7 are not needed

              The default for Vax-11  Cobol  data-items  is  USAGE  IS
         DISPLAY.  There is no such thing as display-6 or display-7.

    15.  Watch value of id...filenames can be 9 characters long
         Watch value of id...filenames can be 9 characters long




2.4.4.3  Suggested Conversion Strategy -
         Suggested Conversion Strategy

     The following is a general strategy for converting a Dec-10 Cobol
program to a Vax-11 Cobol program.  The conversion team feels that the
order of this process  is  important  so  that  a  organized  flow  of
conversion will occur.

     1.  Decide of Structure of Data Files
         Decide of Structure of Data Files

              The first step we feel is to analyze  the  current  data
         files  being accessed and decide on the organization you wish
         to produce on the Vax.  We recommend using indexed  files  in
         all  cases  for  major  master  files.   If you decide to use
         alternate keys to  access  the  file,  you  should  carefully
         consider how many are really needed (anything more than 4 can
         begin to seriously downgrade performance).  In this step  you
         should  produce finalized file descriptions and put them into
         a Cobol text library or the Data Dicionary.

     2.  Comment out Dentry, Macros, 1022
         Comment out Dentry, Macros, 1022

              We feel that the first step should  be  to  convert  the
         native  Cobol  code  from  Ansii-68 to Vax-11 Ansii-81 Cobol.
         Therefore, forget about Dentry, Macros, and  1022  calls  for
         now.  These problems should be solved at later steps.  First,
         make the program compile with no fatal errors.

     3.  Access Data Files
         Access Data Files

              After the Cobol code has been  converted,  go  back  and
         look at the 1022 calls and find out what types of access were
         being done.  Reproduce this access  through  RMS.   One  must
         remember  that  we  are  not using an inverted file structure
         like we had  with  1022.   One  can  do  complicated  'finds'
         through callable Datatrieve but unless you know the beginning
         of an indexed key, the program will basically end up doing  a
         sequential read of the file.  Therefore, one should weigh the
         necessity of doing such inquiries.  If they are needed,  then
         one has the option of using Callable Datatrieve.

     4.  Convert Dentry to FMS
         Convert Dentry to FMS
DOCUMENTATION AND TRAINING                                             Page 2-40
DOCUMENTATION AND TRAINING


              The next step should be to  replace  the  commented  out
         Dentry  calls  with  real  FMS calls.  This of course entails
         building an FMS screen to your  required  specifications  and
         then putting in the Cobol calls to access the screen.

     5.  Replace Macros
         Replace Macros

              We have acquired from Internal Software  Support  macros
         that  run  on  the Vax.  These macros are very similar to the
         ones we had on the Dec-10.  We have not  exercized  them  all
         but they seem to work well.  Thus, any functionality you need
         from these macros should be easily implemented.

     6.  Test Program Input and Output
         Test Program Input and Output

              Before you  retire  to  the  Pub,  we  feel  you  should
         thoroughly  test the program on the Dec-10 and the Vax to see
         that accurate results from the program are still  obtainable.
         This is not to say that you shouldn't be testing the accuracy
         of your conversion as you go along.













                                   CHAPTER 3

                                  MASTER FILES
                                  MASTER FILES



     As was mentioned earlier, we identified three main  master  files
that  we  had  to  implement  on the Vax.  The following is a detailed
description of what was done for each Master-file.



3.1  MASTER-PARTS FILE
     MASTER-PARTS FILE

     The Master-Parts File is the fundamental manufacturing file  most
systems  are  driven off.  It is a random-access sixbit file keyed via
part-number through a randomizing routine.  Its format on  the  Dec-10
is  sixbit,block  2 with 378 characters per record.  It contains basic
information about each part such as description,  major-supplier,  and
standard-cost.

     Our desire was to reproduce this file on  the  Vax  in  the  best
possible structure with as little conversion effort as possible.  This
basically became a decision of making the file's organization relative
(random-access)   or  indexed.   We  decided  to  utilize  an  indexed
organization for several reasons.



3.1.1  Format Of File On Vax
       Format Of File On Vax


     1.  Randomizing Routine

              The Randomizing Routine was  an  un-supported  piece  of
         software that served its purpose but was still clumsy to use.
         By restructuring the Master-Parts file into an indexed  file,
         we were able to do away with this routine and access the file
         directly.

     2.  File Maintenance

              We were able to do  away  with  manual  file  maintenece
         programs.

     3.  Datatrieve

              Datatrieve is a software package that allows  very  easy
         access  and formatting of data on a Vax.  However it does not
         function on a relative file.  Thus by using an  indexed  file
MASTER FILES                                                  Page 3-2
MASTER FILES


         structure, we obtain the ability to utilize this product.

     4.  Keys

              An indexed-file structure allowed us the capability  for
         multi-key   access.   In  other  words,  we  were  no  longer
         restricted to using the part-no as the only way  to  directly
         retrieve information about parts.




3.1.2  Steps Required To Convert File
       Steps Required To Convert File

     The first  step  in  converting  the  Master-Parts  File  was  to
overcome  the  problem  of  Comp  fields which are used.  A field in a
Computational format could not be directly brought from the Dec-10  to
the  Vax  because  of  the  difference  in word-length between the two
machines.   Therefore,  as  a  first  step  a  program   was   written
(PDCF::PUR8:MPFCVT.CBL[4040,20273]   to  read  the  file  sequentially
building  a  0-blocked  Ascii  file  converting  all  Comp  fields  to
numeric-display  format.   The  new  Master-Parts  file  will  only be
"chained" to a Bill-Of-Material  file.   Thus  all  other  chains  are
zeroed  out.   The  chain to the Bom file, known as 'MP-BOM-CHAIN' was
kept intact as is discussed below.

     Our next problem was to move our newly created data file from the
Dec-10  to  the  Vax.   This was difficult because the Dec-10 does not
write tapes in  a  standard  ANSI  labelled  format,  instead  writing
unlabeled  Ascii  tapes  in  a strange format.  We thus used a utility
called Tenvax which runs on the Dec-10 and writes  Vax  ANSI  labelled
magtapes.

     This resulted in a sequential Ascii file on the Vax.  We wrote  a
conversion  program  on  the  Vax  (MPFBUILD.COB)  to replace the Comp
fields in the  file.   We  then  used  the  RMS  FDL  utilities  (File
Definition  Language)  to  convert  this  sequential  Ascii file to an
indexed Ascii  file  with  one  key  and  all  necessary  optimization
criteria.

     The following shows the detail of the above process.

     1.  RUN PUR8:MPFCVT[4040,20273]
         RUN PUR8:MPFCVT[4040,20273]

              This program runs on the Decsystem-10 and takes as input
         MPF.MFG and outputs a file called MPF.VAX.

     2.  R TENVAX
         R TENVAX

              This step copies MPF.VAX onto a Vax-readable tape.

     3.  $COPY
         $COPY

              This step copies MPF.VAX from the tape to a user-area on
         the VAX.

     4.  $RUN [RICK.COBOL]MPFBUILD
         $RUN [RICK.COBOL]MPFBUILD
MASTER FILES                                                  Page 3-3
MASTER FILES


              This step takes as input MPF.VAX and builds a sequential
         file MPF.MFG.

     5.  $CONVERT/FDL=[RICK.LIBRARY]MPF.FDL MPF.MFG MASTPART.DAT
         $CONVERT/FDL=[RICK.LIBRARY]MPF.FDL MPF.MFG MASTPART.DAT

              This step builds an  indexed  file  called  MASTPART.DAT
         according  to  the  specifications  in  the  MPF.FDL file and
         containing the data that was in MPF.MFG




3.2  BILL OF MATERIAL FILE
     BILL OF MATERIAL FILE

     The Bill-Of-Material file is parts list of components  needed  to
build  a manufactured or assembled part.  It is a random-access sixbit
file on the Dec-10 and is linked to the Master-Parts file through  the
Bom-chain.  This Bom-chain always points to the 'header' record of the
latest eco for the parent part.  In this 'header' record is a bom-code
(which  is  1  to signify the 'header' record), the latest eco number,
and the parent part-number.  After this 'header' record is the list of
'detail'  records  which  itemize  how  the  particular parent part is
built.  On each 'detail' record is a bom-code (which is 2 to signify a
'detail'  record), a component part-number, a quantity field revealing
how much of that component it takes to build the parent  part,  and  a
'chain'  linking  this  component  part back to the Master-Parts file.
This is used in order to quickly find out detailed  information  about
the detail part such as its cost.



3.2.1  Format Of File On Vax
       Format Of File On Vax

     Because of the  way  this  file  is  structured,  we  decided  to
implement  this file as a relative structured file.  This is primarily
because of the need to preserve the order of the  records  within  the
file (header-record,detail-record, detail-record,...).  If we tried to
implement this file as indexed, we would  have  had  to  determined  a
unique  way  to identify a bom record given a part number.  This could
have been done by keeping the latest Eco  on  the  Master-Parts  File.
Nevertheless  indexing  this file woult have re-organized the order of
the file and presented us with additional problems we  felt  were  not
desirable.



3.2.2  Steps Required To Convert File
       Steps Required To Convert File

     In order to reproduce this file on the  Vax,  another  conversion
program   was   written  (PDCF::PUR8:BOMCVT.CBL[4040,20273]).   As  is
discussed above, the Master-Parts File and Bill-Of-Material  file  are
connected  via  a  chain.   The  chain on the Master-Parts File always
points to the latest ECO on the BOM file.  Previous ECO's are found by
using  another  chain  on  the header-record called 'BOM-HEADER-CHAIN'
which points to another header-record in the BOM file representing  an
older  bill-of-material  for  the  same  part.   When  these files are
brought over to the Vax, they become sequential files  and  thererfore
must  be  relinked.   Since it was impossible to distinguish a current
eco from a previous eco except for the way the files are  chained,  it
MASTER FILES                                                  Page 3-4
MASTER FILES


was  necesary  to  create a BOM file containing only the latest eco's.
Thus this program reads the Master-Parts  file  sequentially,  looking
for  the  latest  eco Boms for all parts.  It builds a new Bom file of
only the latest eco Boms,  gets  rid  of  all  c-filled  and  d-filled
records,  and  zeros  out  the  forward and backward chains.  Also the
'BOM-COMPONENT-MPF-CHAIN' which links a detail part to the MPF will no
longer  contain a cell-address of a random Master-Parts file.  Instead
it will contain a part-number which will be the same  as  a  component
part-number  and  will  be  used  as a key to the indexed Master-Parts
file.

     We the brought this file over to the Vax using the Tenvax utility
which  resulted  in a sequential Ascii file.  This left us now with an
indexed Master-Parts File keyed  via  part-number,  and  a  sequential
Bom-file.   In  order to create a link betwen the two files, we had to
write another program 'BOMBUILD' which does the  following.   The  BOM
file  is read sequentially looking for header-records (BOM-CODE of 1).
As this is  done  the  program  is  writing  the  Bom-records  in  the
sequential  files  to  a  new  relative file.  When a header record is
found, the address (or cell-number) of that record is written  to  the
'MP-BOM-CHAIN'  of  the  Master-Parts  Files,  thus  establishing  the
necessary link.  At the same time,  this  program  replaces  any  Comp
fields that were taken out in order to transport the file.

     The following shows the detail of the above process.

     1.  RUN PUR8:BOMCVT[4040,20273]
         RUN PUR8:BOMCVT[4040,20273]

              This program runs on the Decsystem-10 and takes as input
         BOM.MFG and outputs a file called BOM.VAX

     2.  R TENVAX
         R TENVAX

              This step copies BOM.VAX onto a Vax-readable tape.

     3.  $COPY
         $COPY

              This step copies BOM.VAX from the tape to a user-area on
         the VAX.

     4.  $RUN [RICK.COBOL]BOMBUILD
         $RUN [RICK.COBOL]BOMBUILD

              This step takes as input BOM.VAX and builds  a  relative
         file  BILLMATL.DAT  appropriately  linked to the Master-Parts
         File.


     Thus our end result was to have the Master-Parts File exist as an
index  file  with one key (part-number) and the Bill-Of-Material files
exist as a  relative  file  keyed  by  a  chain  that  exists  on  the
Master-Parts File.












                              CHAPTER 4

                         VAX-11/780 SOFTWARE
                         VAX-11/780 SOFTWARE



     The only software that comes with the purchase of a Vax-11/780 is
the  VAX/VMS  Operating  System.   All  other software must be ordered
seperately.  Below is the before-mentioned list of all the software we
feel  may  be applicable for our environment along with the respective
ordering option numbers and distribution media.

     1.  VAX-11 Cobol --> Opt# QE099-AY --> Floppy disk
         VAX-11 Cobol

              A high-performance, interactive language processor based
         on on the ANSI X3.23-1974 standard.

     2.  VAX-11 Datatrieve --> Opt# QE074-AM --> 9-Track Magtape
         VAX-11 Datatrieve

              A comprehensive data management tool that provides  both
         interactive and program-callable access to data in sequential
         and indexed file organizations.  It  consists  of  query  and
         report-writing facilities, a business graphics capability,and
         has local and distributed high-level data  access  facilities
         to  retrive  data  stored  by  RMS  and  VAX-11 DBMS files on
         VAX/VMS.

     3.  VAX-11 Database Management System --> Comes with QE074-AM
         VAX-11 Database Management System

              Vax-11 DBMS is a full scale  CODASYL-compliant  database
         management system.

     4.  VAX-11 Common Data Dictionary --> Comes with QE074-AM
         VAX-11 Common Data Dictionary

              A central repository for data about data.  It integrates
         VAX  information  management  products  using a single set of
         data descriptions as a common resource.

     5.  DECnet-VAX --> Opt# QED03-AY --> Floppy Disk
         DECnet-VAX

              DECnet-VAX allows a suitably configured  VAX/VMS  system
         to  participate  as  a  Phase  III  DECnet  node  in computer
         newtorks.

     6.  VAX-11 FMS --> Opt# QE701-AY --> Floppy Disk
         VAX-11 FMS

              VAX-11 Forms Management System is a set of utilities and
         subroutines  that  provide  sophisticated  screen  formatting
         capabilities for application programs written in a variety of
         standard programming languages.
VAX-11/780 SOFTWARE                                           Page 4-2
VAX-11/780 SOFTWARE


     7.  VAX-11 DECMAIL --> Opt#
         VAX-11 DECMAIL

              A stand-alone single node mail and filing  system  which
         can  create, edit, send, and process messages on a single VAX
         computer system.

     8.  DX/VMS Facility --> Opt# QE707-YY --> Floppy Disk
         DX/VMS Facility

              This is a DX/VMS  WPS-8  to  host  utility  which  is  A
         Fortran  IV-PLUS  software package that executes on a VAX/VMS
         operating system.  It enables a WPS-8 word processing  system
         to  communicate  with  the  VAX/VMS host over an asynchronous
         terminal interface.

     9.  VAX-11 Basic --> Opt# QE095-AY --> Floppy Disk
         VAX-11 Basic

              A superset of BASIC-PLUS-2

    10.  VAX-11 FORTRAN --> Opt# QE100-AY --> Floppy Disk
         VAX-11 FORTRAN

              An implementaion of FORTRAN-77.

    11.  Code Management --> Opt# QE007-AY --> Floppy Disk
         Code Management

              A set of commands to help software developers manage the
         files of an on-going project.

    12.  VAX-11 DECalc --> Opt# QE310-AY --> Floppy Disk
         VAX-11 DECalc

              An  interactive  applications  package   for   creating,
         editing,  and  manipulating  the  electronic equivalent of an
         accountant's spreadsheeet.  General  applications  categories
         include loans and investments, advertising and sales, general
         business, and engineering.

    13.  VAX-11 ReGIS Graphics --> Opt# QE118-Ay --> Floppy Disk
         VAX-11 ReGIS Graphics

              A collection of subroutines conforming to  the  standard
         VAX/VMS   calling  interface  and  designed  to  support  the
         graphics capabilities of the VT125.

    14.  ALL-IN-1
         ALL-IN-1

              Digital's ALL-IN-1 system is  a  comprehensive  software
         package  that  operates on a VAX computer.  ALL-IN-1 combines
         many smaller software packages under one  menu  to  create  a
         total  office  automation  system.   These  packages  include
         document processing, electronic mail, desk management  (phone
         directory  and  calendar management), information management,
         tailored business applications, and program development.













                              CHAPTER 5

                   EVALUATION OF 1032 VS DATATRIEVE
                   EVALUATION OF 1032 VS DATATRIEVE



     1022 is  a  database  managenment  system  for  Decsystem-10  and
Decsystem-20  operating  systems.  1022 allows complete flexibility in
terms of managing data  with  extensive  reporting  capabilities.   It
allows  a user to interactiveley query a database without any previous
thought about the structure of the data.  It also give the  programmer
some very elegant data manipulation techniques with which to work.  It
is a system that is not replacable in the Dec-10/20 environment  since
there is no other software available that has its power.

     Software House, the developers of 1022, has developed  a  similar
product  for the Vax/Vms operating system.  This product, called 1032,
emulates 1022 in terms of its basic concepts and user interface.  Like
1022,  1032  is a very powerfull tool which is easy to use and yet has
extreme power.  1032 has almost identical commands  and  functionality
as  1022.   Unlike  the  situation with 1022 however, there is another
product which performs very similar functions of 1032.   This  product
is called Datatrieve and is Digital developed.

     Datatrieve develops an immediate advantage because of  the  above
statement.   Because  it is Digital developed, we would obviously save
money by using Datatrieve instead of 1032  (Software  House  quoted  a
price  of  40,000 dollars for 1032).  The question that then arises is
if Datatrieve truly can satisfy the basic needs  that  1022  satisfied
and 1032 could potentially satify;  if so, what are the advantages and
disadvantages of each?

     As I see it, 1032 has three main advantages.  First and foremost,
I  think  one can safely say that 1022 applications could be converted
much easier to 1032 that Datatrieve.  This is obviously  because  1022
and  1032 are very similar products.  Although Software House admitted
that 1022 and 1032 were not completely upward compatible,  one  cannot
deny that 1022 to 1032 migration would be the easier route.  Secondly,
I feel that  the  user-interface  of  1032  is  better  than  that  of
Datatrieve.   The commands are more English-like and data manipulation
is more 'natural'.  One must keep im mind however that I  was  a  long
time  user  of  1022 and therefore would naturally find 1032 easier to
understand.  Nevertheless, our users  are  pretty  much  in  the  same
situation   and   thus  would  find  1032  more  attractive.   Lastly,
Datatrieve does not have the power of 'keying' data-elements in a file
like  1032  does.   This  feature can often be valuable especially for
online applications.  If a  user  suddenly  becomes  interested  in  a
particular  data-element, that data-element can 'instantly' be 'keyed'
and  thus  allow  quick  access  via  that   data-element.    Although
Datatrieve  allows inquiry via any data-element in a file, information
EVALUATION OF 1032 VS DATATRIEVE                              Page 5-2
EVALUATION OF 1032 VS DATATRIEVE


retrieval is dramatically slowed down  if  that  data-elemant  is  not
'keyed'.   'Keying' a data-element in Datatrieve is more difficult and
time-consuming than 1032 and also more costly to maintain.

     Nevertheless, I  feel  that  the  advantages  of  Datatrieve  far
outweigh  those  of 1032.  The basic functionality is the same in both
products.   Both  can  retrieve   data   interactively   through   any
data-element  in  a  file  and  can consequently update or delete that
data.  Both  allow  high-level  program  interface  for  sophisticated
programmer  applications.  1032 however has some serious shortcomings.
Datatrieve accesses RMS files directly whereas 1032 utilized  its  own
'bundled'  file  structure.   This  would mean that certain data files
would either be exclusively 'owned' by 1032 or else would have  to  be
duplicated.   Also  Datatrieve  currently  supports  forms  interface,
graphics, and  distributed  data  processing  over  a  network.   1032
currently does none of this.

     Finally and in summary, I feel that purchsing 1032  would  'lock'
us  into  a  dependence  on  Software  House  that  I  think  would be
un-healthy.  Since both products perform similar functions, we do  not
'need'  1032.   Both  products are in their infancy and will gradually
improve.   Digital  is  making  a  commitment   to   Vax   Information
Architecure  of  which  Datatrieve  seems  to be an integral part.  By
staying within  this  architecture,  we  will  benefit  from  advances
Digital  will  make and at the same time keep in tune with forthcoming
products.












                              CHAPTER 6

                     MENU-DRIVEN FRONT-END SYSTEM
                     MENU-DRIVEN FRONT-END SYSTEM



6.1  SYSTEM OVERVIEW
     SYSTEM OVERVIEW

     Our front-end system for the Vax will be modeled  after  some  of
the concepts of the current front-end system that exists for Corporate
Purchasing on the Decsystem-10.  It will be a menu-driven system  that
will  provide  easy interface to application systems as well as a high
degree of security.  When a  user  logs  onto  our  Vax,  he  will  be
immediately  greeted  by  a  menu  which  will show any systems he has
access to.  He may then select a system and make further decisions  on
the specific program or programs he wishes to exercise.



6.2  DATA FILES
     DATA FILES

     The front-end system will utilize two files  to  determine  valid
users  and  their  corresponding valid systems.  The first will be the
USER-FILE or 'FEUSER.DAT'.  The second will  be  the  PROGRAM-FILE  or
'FEPROGRAM.DAT".



6.2.1  USER-FILE
       USER-FILE

     This file will be indexed with one primary key, badge-number, and
no  secondary  keys.  The following describes the data elements within
the file.

     1.  BADGE NUMBER
         BADGE NUMBER

              This field will correspond to the  badge-number  of  the
         user desiring access to a system.  It will be the primary key
         of the file and will be 6 numeric characters in length or PIC
         9(6).  This field must be unique.

     2.  PASSWORD
         PASSWORD

              This field will correspond to the user's  password.   It
         should  be  know  only to the user as it the most fundamental
         piece of information to ensure the security  of  the  systems
         that  are  run  from  the  front-end  system.  Each user will
         always have the ability to change their password for security
         purposes.    It   will  be  a  maximum  of  six  alphanumeric
         characters in length or PIC X(6).
MENU-DRIVEN FRONT-END SYSTEM                                  Page 6-2
MENU-DRIVEN FRONT-END SYSTEM


     3.  FIRST NAME
         FIRST NAME

              This field will correspond to the user's first name  and
         will  be  fifteen  alphanumeric  characters  in length or PIC
         X(15).

     4.  LAST NAME
         LAST NAME

              This field will correspond to the user's last  name  and
         will  be  fifteen  alphanumeric  characters  in length or PIC
         X(15).

     5.  MAIL STOP
         MAIL STOP

              This field will correspond to the user's  mail-stop  and
         will  be  fifteen  alphanumeric  characters  in length or PIC
         X(15).

     6.  PHONE NUMBER
         PHONE NUMBER

              This field will correspond to  the  user's  phone-number
         and will be seven numeric characters in length or PIC 9(7).

     7.  COST CENTER
         COST CENTER

              This field will correspond to the user's cost-center and
         will be four alphanumeric characters in length or PIC X(4).

     8.  MANAGER'S FIRST NAME
         MANAGER'S FIRST NAME

              This field will correspond to  the  first  name  of  the
         user's  cost-center  manager and will be fifteen alphanumeric
         characters in length or PIC X(15).

     9.  MANAGER'S LAST NAME
         MANAGER'S LAST NAME

              This field will correspond  to  the  last  name  of  the
         user's  cost-center  manager and will be fifteen alphanumeric
         characters in length or PIC X(15).

    10.  MANAGER'S MAIL STOP
         MANAGER'S MAIL STOP

              This field will  correspond  to  the  mail-stop  of  the
         user's  cost-center  manager and will be fifteen alphanumeric
         characters in length or PIC X(15).

    11.  DATE ADDED
         DATE ADDED

              This field will correspond to the date  upon  which  the
         user was first added to the front-end system as a valid user.
         It will be six numeric characters in length or PIC  9(6)  and
         will be in the format YY/MM/DD.

    12.  SYSTEM
         SYSTEM

              This field will correspond to a particular  system  that
         the  user  is  able to access.  It will occur 20 times within
         the file thus allowing up to 20 possible systems a  user  can
         access.  It will be four alphanumeric characters in length or
MENU-DRIVEN FRONT-END SYSTEM                                  Page 6-3
MENU-DRIVEN FRONT-END SYSTEM


         PIC X(4).

    13.  SECURITY
         SECURITY

              This field will  correspond  to  the  security  that  is
         associated  with  a particular system for that user.  It will
         be used to distinguish the types of  things  a  user  can  do
         within  a  given  system.   For  a  user  to  gain  access to
         particular programs within a system, his security must be the
         same  or  greater  than  the security which will exist on the
         program file for programs within that system.  It will  occur
         20  times  corresponding to the 20 possible different systems
         and will be one numeric character in length or  PIC  9.   Its
         possible values are as follows.

         1.  0 = No access

         2.  3 = Inquiry access

         3.  5 = Update mode for adds and changes

         4.  7 = Update mode for adds, changes, and deletes


    14.  USER ACCESS FLAG
         USER ACCESS FLAG

              This field will correspond to a flag used to quickly and
         easily remove a user's access from getting past the front-end
         system.  It will be one alphanumeric character in  length  or
         PIC  X.  Valid users would always have an access flag of 'Y'.
         Invalid users would have an access flag of 'N'.




6.2.2  PROGRAM FILE
       PROGRAM FILE

     This file will be indexed with one primary key.   This  key  will
consist  of  two  seperate data-elements.  One will be the system-name
which corresponds to the same system-name data-element  found  in  the
user-file.   The  other part of the key will be an option-number which
will differentiate systems and  their  corresponding  programs.   This
file  will  contain  information  about  all  possible systems and the
respective programs that users in the  user-file  could  access.   The
following describes each data element found in the program-file.

     1.  SYSTEM
         SYSTEM

              This field will correspond to  a  system  name  that  is
         currently available for the Corporate Purchasing community to
         use.  It will be a partial key of the program-file  and  will
         be four alphanumeric characters in length or PIC X(4).

     2.  OPTION NUMBER
         OPTION NUMBER

              This field will correspond to an option  number  that  a
         user  will  select from his menu.  There will be two types of
         records in the program file.  The  first  will  be  a  system
         record,  which  for  a particular system will be unique.  The
MENU-DRIVEN FRONT-END SYSTEM                                  Page 6-4
MENU-DRIVEN FRONT-END SYSTEM


         system record will be identified by an option-number of 50 or
         greater.   The  other type of record will be a program record
         which will be identified by an option-number of less than 50.
         For  a  particular system there can be up to twenty programs,
         thus up to twenty program records.  This field will be  three
         numeric characters in length or PIC 9(3).

     3.  TITLE
         TITLE

              This field will correspond to the title of a  system  or
         the  title  of a program depending on the type of record.  It
         will be thirty  alphanumeric  characters  in  length  or  PIC
         X(30).

     4.  DEVICE
         DEVICE

              This field will correspond to a physical device.  For  a
         system  record,  it  will  identify the device that the major
         data-file for the system redides on.  For a  program  record,
         it  will identify the device that the program resides on.  It
         will be six characters in length or PIC X(6).

     5.  USERNAME
         USERNAME

              This field will correspond to the account or area  where
         either  the  major  data file resides for a system or where a
         program resides for a program  record.   It  will  be  twelve
         alphanumeric characters in length or PIC X(12).

     6.  FILENAME
         FILENAME

              This field will correspond to the filename of the  major
         data  file  for  a  system or the filename of a program for a
         program record.  It will be nine alphanumeric  characters  in
         length or PIC X(9).

     7.  FILE TYPE
         FILE TYPE

              This field will correspond to the file extension for the
         file.   If the record pertains to a system, this data element
         will contain 'DAT'.  For a program record, this data  element
         will  contain  'EXE'  to refer to a Cobol program or 'DTR' to
         refer  to  a  Datatrieve  procedure.   It   will   be   three
         alphanumeric characters in length or PIC X(3).

     8.  SECURITY
         SECURITY

              This field will be used to screen out unauthorized users
         from   whole  systems  or  from  particular  programs  within
         systems.  If the  security  value  for  a  system  record  is
         greater  than  the  security  value  for  this  system in the
         user-file, then the user  is  denied  access  to  the  entire
         system.   If  the  security  value  for  a  program record is
         greater than the security value for the corresponding  system
         in  the  user-file,  then  the  user is denied access to that
         particular program within that system.  This feature  can  be
         used  to  allow  users to run programs to retrieve data for a
         particular system but not to update  the  data.   This  field
         will be one numeric character in length or PIC 9.
MENU-DRIVEN FRONT-END SYSTEM                                  Page 6-5
MENU-DRIVEN FRONT-END SYSTEM


     9.  PROGRAM ACCESS-FLAG
         PROGRAM ACCESS-FLAG

              This field will be used to turn off the availability  of
         a  particular  program  or a whole system for the entire user
         commmunity.   It  could  be  used  if  a  particular  program
         develops  a  serious  problem  for  example.   It will be one
         alphanumeric character in length or PIC X.  It will  normally
         be  set  to  'Y'.   It  will  be set to 'N' if the particular
         program or system is to be shut down.

    --------
