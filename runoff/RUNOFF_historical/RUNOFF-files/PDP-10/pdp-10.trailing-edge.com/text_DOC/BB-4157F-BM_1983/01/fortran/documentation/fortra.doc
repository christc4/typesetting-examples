


   FORTRAN-20 -- Changes from V6 to V7
   February 1983






























   COPYRIGHT (C) 1983 BY
   DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.


   THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
   ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
   INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
   COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
   OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
   TRANSFERRED.

   THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
   AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
   CORPORATION.

   DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
   SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
   FORTRA.DOC - FORTRAN-20 Version 7                               Page 2


                                  CONTENTS
           1.0     SUMMARY  . . . . . . . . . . . . . . . . . . . . . . 3
           1.1       Bibliography . . . . . . . . . . . . . . . . . . . 3
           2.0     NEW FEATURES . . . . . . . . . . . . . . . . . . . . 5
           2.1       Summary Of Enhancements To The Product . . . . . . 5
           2.2       Character Data . . . . . . . . . . . . . . . . . . 6
           2.2.1       Features Supported For Character Data  . . . . . 6
           2.2.2       Internal Representation Of Character Data  . . . 9
           2.2.3       FORDDT Support For Character Data  . . . . . . . 9
           2.2.3.1       Character Mode For TYPE And ACCEPT Commands   10
           2.2.3.2       Declaration Of Character Array Bounds  . . .  10
           2.3       IF THEN ELSE . . . . . . . . . . . . . . . . . .  10
           2.4       DO WHILE And END DO Statements . . . . . . . . .  11
           2.5       Expressions On Output Lists  . . . . . . . . . .  12
           2.6       Intrinsic And Generic Functions  . . . . . . . .  12
           2.7       Multi-record Internal Files  . . . . . . . . . .  13
           2.8       FORTRAN-77 DO Loop Semantics . . . . . . . . . .  13
           2.9       Assumed-Size Array Declarators . . . . . . . . .  14
           2.10      ASSIGN Of FORMAT Statement Numbers . . . . . . .  14
           2.11      INTRINSIC And EXTERNAL Statements  . . . . . . .  14
           2.12      SAVE Statement . . . . . . . . . . . . . . . . .  14
           2.13      Support Of Null Argument Lists For Functions . .  15
           2.14      FORTRAN-77 Statement Ordering Rules  . . . . . .  15
           2.15      Minor Syntax Extensions  . . . . . . . . . . . .  16
           2.16      Constant Expressions . . . . . . . . . . . . . .  16
           2.17      FORTRAN-77 PARAMETER Statements  . . . . . . . .  16
           2.18      Expressions As Specifier Values In OPEN And I/O 
                     Statements . . . . . . . . . . . . . . . . . . .  17
           2.19      Type Checking For Function And Subroutine 
                     Arguments  . . . . . . . . . . . . . . . . . . .  17
           2.20      New Functionality In ERRSET  . . . . . . . . . .  21
           2.21      Utility Subroutine To Get A Free Unit Number . .  22
           2.22      Additional Runtime Warnings  . . . . . . . . . .  22
           2.23      G-Floating Support . . . . . . . . . . . . . . .  22
           2.24      Native TOPS-20 Command Interface . . . . . . . .  23
           2.24.1      Interactive Command Syntax . . . . . . . . . .  23
           2.24.2      SWITCH.INI . . . . . . . . . . . . . . . . . .  25
           2.24.3      Old Batch Control Files  . . . . . . . . . . .  26
           3.0     RESTRICTIONS . . . . . . . . . . . . . . . . . . .  27
           3.1       FORTRAN-77 Features Not Supported  . . . . . . .  27
           3.2       Other Restrictions . . . . . . . . . . . . . . .  27
           4.0     KNOWN BUGS AND DEFICIENCIES  . . . . . . . . . . .  28
           4.1       Known Bug In G-floating  . . . . . . . . . . . .  28
           4.2       Mandatory Patches For Related Products . . . . .  29
           4.3       Known Deficiencies In Related Products . . . . .  29
           5.0     COMPATIBILITY WITH PREVIOUS VERSIONS . . . . . . .  30
           5.1       Incompatibilities Between Versions 6 And 7 . . .  30
           5.2       Compiler "FORTRAN-77" Switch . . . . . . . . . .  37
           5.3       FOROTS Interface . . . . . . . . . . . . . . . .  38
           5.4       Subprogram Calling Conventions . . . . . . . . .  38
           5.5       Changes In The FORTRAN/DBMS Interface  . . . . .  39
           5.6       Using DBMS With FORTRAN V7 . . . . . . . . . . .  39
           5.7       Incompatibilities Between Versions 5A And 6  . .  40
           6.0     INTERNAL CHANGES . . . . . . . . . . . . . . . . .  45
   FORTRA.DOC - FORTRAN-20 Version 7                               Page 3


   FORTRAN-20 --  Changes from V6 to V7
   February 1983






   1.0  SUMMARY


   Version 7 of FORTRAN-20  is  a  development  release  of  the  FORTRAN
   compiler, FOROTS, FORLIB, and FORDDT.

   FORTRAN-20 version 7 supports the FORTRAN-77 standard  at  the  subset
   level.  It also supports most of the features from the FORTRAN-77 full
   language  standard  (see  section  3.1  below).   Character  data   is
   supported in accordance with the FORTRAN-77 full language standard.

   Note that you must use LINK version 5.1 (or later) for linking the REL
   files generated by this version of FORTRAN.



   1.1  Bibliography


   The FORTRAN language and this  implementation  are  described  in  the
   reference manual:

        FORTRAN-10/20 Language Manual - AA-N383A-TK

   Two copies of this manual are enclosed with this release package.

   The installation procedures for this tape are described in:

        TOPS-20 FORTRAN Installation Guide - AA-P344A-TM

   A copy of this installation is enclosed with this release package.

   There is also a booklet  that  provides  quick  reference  information
   about FORTRAN-10/20 version 7:

        TOPS-10/20 FORTRAN Reference Card - AV-P529A-TK

   Two copies of this booklet are enclosed with this release package.

   The algorithms and accuracy of the math routines  in  FORLIB  will  be
   described in:

        TOPS-10/20 Common Math Library Reference Manual - AA-M400A-TK

   This manual will be available from SDC in May 1983.

   FORTRAN-10/20 Version 7 is based on the FORTRAN-77 standard:
   FORTRA.DOC - FORTRAN-20 Version 7                               Page 4


   American  National  Standard  Programming  Language  FORTRAN  -   ANSI
   X3.9-1978

   Copies of this standard may be obtained from:
           American National Standards Institute
           1430 Broadway
           New York, N.Y. 10018


   1.2     Monitors

   This version of Fortran will run on

         o  2060 systems running TOPS-20 release 5.0, 5.1, or later

         o  2040 systems running TOPS-20 release 4.1, release  5.0,  5.1,
            or later

         o  2020 systems running TOPS-20 release 4.1 or later


   1.3     Related System Software

   The following system software must be used with FORTRAN version 7:


        LINK 5.1(2027)
        GALAXY 4


   The following system software must be used to build FORTRAN Version  7
   from sources:


        BLIS10  7.5(227)
        MACRO  53.1(1152)
        MAKLIB 2.2(104)


   The following optional software may be used with FORTRAN Version 7:


        SORT 4.3(476)
        DBMS 6(363)

        Note that edit 476 of SORT is required in order to call SORT from
        FORTRAN  on  TOPS-20  KL  model  B processors.  SORT 4.4(500) was
        shipped on autopatch tape  4.  If  you  have  not  yet  installed
        Autopatch  tape   4, you should install SORT edit 476 if you want
        to use SORT with  FORTRAN  V7.   (This  SORT  patch  is  required
        because the FORTRAN V7 FORSRT will cause SORT to be merged into a
        non-zero section on Tops-20 KL model  B  processors.)  This  SORT
        patch is listed in section 4.2 below.
   FORTRA.DOC - FORTRAN-20 Version 7                               Page 5


   2.0  NEW FEATURES

   2.1  Summary Of Enhancements To The Product


   The following is a summary of the major features that in FORTRAN-10/20
   version 7 that were not in version 6:

        1.  Character data at the FORTRAN-77 full language level.

            Supported features include character  assignments,  character
            relationals,   substrings,   concatenation,   and   character
            functions  and  arguments,  including  functions  and   dummy
            arguments  of length *.  Character data is supported in DATA,
            COMMON, and EQUIVALENCE statements, and in formatted, binary,
            and image mode I/O.  See section 2.2 below for more details.

        2.  IF THEN ELSE

        3.  DO WHILE and END DO statements

        4.  Expressions on output lists

        5.  Intrinsic  and  generic  functions  at  the  FORTRAN-77  full
            language level

        6.  Internal files ( single-record and multi-record )

        7.  FORTRAN-77 DO loop semantics

        8.  Assumed-size array declarators

        9.  ASSIGN of FORMAT statement numbers

       10.  INTRINSIC statement;  FORTRAN-77 semantics for  the  EXTERNAL
            statement

       11.  SAVE statement

       12.  Support of null argument lists for functions

       13.  Support of FORTRAN-77 statement ordering rules.

       14.  Minor syntax extensions required by the FORTRAN-77 standard

       15.  Compiletime constant expressions in  declarations,  as  array
            bounds and string bounds

       16.  FORTRAN-77 PARAMETER statements

       17.  Expressions as specifier values in  OPEN  statements  and  in
            control information lists in I/O statements
   FORTRA.DOC - FORTRAN-20 Version 7                               Page 6


       18.  Optional linktime typechecking of subprogram arguments

       19.  New functionality in the ERRSET subroutine

       20.  Utility subroutine to get a free unit number

       21.  Additional runtime warnings

       22.  G-floating double precision numbers

       23.  Native TOPS-20 command interface for the compiler




   2.2  Character Data

   2.2.1  Features Supported For Character Data -

   FORTRAN-10/20 version 7 supports character data as  specified  by  the
   full  language  FORTRAN-77  standard.   This  includes support for the
   following features (please see the FORTRAN-10/20 Language  Manual  for
   more information about these features):

        1.  Character constants and symbolic constants

        2.  Character variables and arrays

        3.  Character relational expressions

        4.  Character assignment statements

            Note that in addition to  meeting  the  requirements  of  the
            FORTRAN-77   standard,   version  7  supports  the  following
            extensions:
             o  Version 7 supports the assignment of character  constants
                to  non-character variables.  This is an extension to the
                FORTRAN-77 standard.  It is supported  for  compatibility
                with previous versions.
             o  Version 7 supports assignment statements in  which  there
                is  overlap  between  the left and right hand sides.  The
                results  of  such  an  assignment  will  be  as  if   the
                expression  on  the  right  hand  side were assigned to a
                temporary and  then  the  value  of  the  temporary  were
                assigned to the left hand side.


        5.  Substring reference and definition

            Note that the user  may  optionally  specify  that  substring
            bounds   checking   be  performed  at  execution  time.   The
            /DEBUG:BOUNDS switch enables both array bounds and  substring
            bounds checking.
   FORTRA.DOC - FORTRAN-20 Version 7                               Page 7


        6.  Character expressions, including the concatenation operator

            Note that version 7 extends the FORTRAN-77 standard to  allow
            concatenation  of  formal parameters that are length *.  This
            extension is also provided by VAX FORTRAN.

        7.  Character variables and constants in DATA statements

            FORTRAN version 7 supports the  initialization  of  character
            variables,  arrays,  and  substrings  to  character  constant
            values as specified by  the  FORTRAN-77  standard.   It  also
            supports   the  use  of  character  constants  to  initialize
            non-character  variables.   This  is  an  extension  to   the
            FORTRAN-77  standard,  which  is  supported for compatibility
            with previous versions.

        8.  Character variables, array elements, arrays,  and  substrings
            in input lists

            According to the FORTRAN-77 standard, the A  edit  descriptor
            is  the only legal edit edit descriptor for input/output list
            items if type character.  Version 7 extends the  standard  to
            allow  the  G edit descriptor as well.  The G edit descriptor
            behaves like the A edit descriptor for  list  items  of  type
            character.   Note  that  R  edit descriptors (which are a DEC
            extension to the standard) are NOT  supported  for  character
            data.

        9.  Character  constants,  variables,  array  elements,   arrays,
            substrings, and expressions in output lists

            (Note:  Character data is supported in formatted, binary, and
            image  mode  files.   It is not supported in dump mode files,
            because character data does not necessarily begin on  a  word
            boundary.  )

       10.  Character functions (intrinsic functions, external functions,
            and statement functions that return values of type character)

            In the object code for a call to a  character  function,  the
            character  descriptor  for the return value is passed as what
            is normally the first argument.  If you write a  function  of
            type character in assembly language, you can use

                   DMOVE AC,@0(16)

            to load AC with a byte pointer to the location to  which  the
            result  should  be  returned, and AC+1 with the length of the
            result expected by the caller.  The first  explicit  argument
            is obtained from @1(16).

       11.  Dummy and actual arguments of type character

            FORTRAN-10/20 extends the  standard  to  provide  support  of
            character  constants  as  actual  arguments  corresponding to
   FORTRA.DOC - FORTRAN-20 Version 7                               Page 8


            dummy arguments that are  integer,  real,  double  precision,
            complex,  or  logical  as well as character.  This support is
            provided by means of a limited type checking facility that is
            supported  by  LINK version 5.1.  Note that this feature only
            works when both caller and callee  have  been  compiled  with
            FORTRAN  version  7.   If  a  subprogram was compiled with an
            earlier version of FORTRAN, it will not contain the REL  file
            blocks  that  LINK  uses  to  recognize that a fix-up must be
            performed on the character argument.

            This feature does not work when  the  name  of  the  function
            called is itself a dummy argument, and therefore is not known
            at compiletime or linktime.

            If an actual argument is of  type  character  and  is  not  a
            constant,  then  the  corresponding  dummy  must  be  of type
            character.  If a dummy argument is of  type  character,  then
            the corresponding actual must be of type character.

            Actual arguments  may  be  longer  than  corresponding  dummy
            arguments.    Length  *  may  be  used  for  character  dummy
            arguments

       12.  FORTRAN-77 intrinsic functions that operate on character data

            LEN, INDEX, CHAR, ICHAR, LGE, LGT, LLE, LLT

       13.  Character variable names, array element names,  array  names,
            and substring names in EQUIVALENCE statements

            It  is  illegal  to  equivalence  a  numeric  variable  to  a
            character  variable.   This  is  a  restriction  in  both the
            FORTRAN-77 standard and VAX FORTRAN.  This helps  to  enforce
            transportable coding practices.

            The error message for EQUIVALENCE of a numeric variable to an
            unaligned character variable is fatal.  The error message for
            EQUIVALENCE of a numeric variable to a word-aligned character
            variable is non-fatal.

       14.  Character variables and arrays in COMMON blocks

            If a character variable or character array  is  in  a  COMMON
            block,  all  of  the entities in that common block must be of
            type character.  This is a restriction in both the FORTRAN-77
            standard  and  VAX  FORTRAN.  Specification of a COMMON block
            that contains both character and numeric data will result  in
            a  non-fatal  warning  message.   All  variables  other  than
            character variables will always begin  on  a  word  boundary.
            Thus  if  a  COMMON block erroneously contains both character
            and numeric data, there may be unused character positions.

       15.  Character variables and array names in namelists

            Version 7 supports substrings in namelist input, but  not  in
   FORTRA.DOC - FORTRAN-20 Version 7                               Page 9


            namelist output.

       16.  Character variables and expressions  as  the  values  of  the
            specifiers in OPEN and CLOSE statements

       17.  Character  constants,   character   arrays,   and   character
            variables as format specifiers


   Version 7 will not support global optimization of program  units  that
   contain  character  data.   If the user specifies the /OPTIMIZE switch
   for such a program the following warning diagnostic will be issued:

   %FTNCHO Global optimization not yet supported with character data - /OPT ignored
   This message will be issued once for  each  subprogram  that  contains
   character data.



   2.2.2  Internal Representation Of Character Data -

   Character strings are represented in 7-bit  ASCII.   Therefore,  there
   are  5  characters  per  word  and the collating sequence is the ASCII
   collating sequence.

   The  object  code  generated  by  FORTRAN-10/20  version  7   includes
   descriptors   for   character  variables,  primaries,  and  subprogram
   arguments.  The form of a character data descriptor is:


           0               17 18                   35
           ------------------------------------------
           !            byte pointer                !
           ------------------------------------------
           !          character count               !
           ------------------------------------------

   This is the same format of descriptor as is used for COBOL  subroutine
   arguments.

   Note that a one word global byte pointer can be used in the first word
   when running in an extended addressing environment.

   The DDT/FORDDT symbol table entry for a character  variable  specifies
   the location of its character data descriptor.



   2.2.3  FORDDT Support For Character Data -

   FORTRA.DOC - FORTRAN-20 Version 7                              Page 10


   2.2.3.1  Character Mode For TYPE And ACCEPT Commands -

   A mode to enable ACCEPT and TYPE for character data has been added  to
   FORDDT.

   In FORDDT version 7, /C  means  character  data  mode,  indicating  to
   FORDDT  that  the symbol table pointer is pointing to a character data
   descriptor, rather than at the character variable itself.   Note  that
   /C  was  used  by  earlier versions of FORDDT to indicate COMPLEX data
   mode, which is now indicated by /X.

   If the ACCEPT command has a bare array name followed  by  a  character
   constant,  all  the  array  elements will be filled with the character
   constant, truncated or space-padded in accordance with the  rules  for
   character constants as per the ANSI standard.

   For example, if the FORTRAN source program contains the declaration:
           CHARACTER*3 C1

   You can type out the contents of C1 from FORDDT by saying:
           TYPE C1/C

   You can store 'ABC' in C1 from FORDDT by saying:
           ACCEPT C1/C 'ABC'




   2.2.3.2  Declaration Of Character Array Bounds -

   If a program has not been compiled with the /DEBUG  switch,  a  FORDDT
   user  must  declare  his  array  dimensions  at  runtime.  For numeric
   arrays, the FORDDT "DIMENSION"  and  "DOUBLE"  commands  provide  this
   capability.

   In version 7, there is a new FORDDT command "CHARACTER" which is  used
   to  declare  the  dimensions of a character array.  The syntax of this
   command is identical to that of the "DIMENSION"  command.   Note  that
   the  string  length for the array elements is always determined by the
   user's program.  It cannot be declared in FORDDT.



   2.3  IF THEN ELSE


   Version 7 supports the Block IF, ELSE IF, ELSE, and END IF  statements
   as specified by the full FORTRAN-77 standard.

   FORTRA.DOC - FORTRAN-20 Version 7                              Page 11


   2.4  DO WHILE And END DO Statements


   The DO WHILE and  END  DO  statements  are  useful  for  writing  well
   structured programs.

   DO WHILE / END DO support involves the following enhancements  to  the
   FORTRAN 77 standard:

        1.  Optional  statement  label  in  the  indexed  (standard)   DO
            statement.

            The syntax of the indexed DO statement is:

                 DO [s[,]] v=e1,e2[,e3]

            where s is the label of the  statement  that  terminates  the
            loop.   If  s is omitted, then the loop must be terminated by
            an END DO statement as discussed below.

        2.  DO WHILE statement

            The DO WHILE statement has the syntax:

                 DO [s[,]] WHILE (e)

            where s is the label of the  statement  that  terminates  the
            loop.   If  s is omitted, then the loop must be terminated by
            an END DO statement as discussed below.

            e is a logical expression which is tested at the beginning of
            each  execution  of  the  loop,  including the first.  If the
            value of the expression is true, then the statements  in  the
            body  of  the loop are executed;  if the expression is false,
            control transfers to the statement following the loop.

        3.  END DO statement

            The END DO statement has the form:

                 END DO

            An END DO statement terminates the range of a DO or DO  WHILE
            statement.   The END DO statement must be used to terminate a
            DO block if the DO or DO WHILE statement does not  contain  a
            statement  label.   It may also be used as a labeled terminal
            statement if the DO or DO  WHILE  statement  does  contain  a
            terminal statement label.

   FORTRA.DOC - FORTRAN-20 Version 7                              Page 12


   2.5  Expressions On Output Lists


   An output list item can be any of the following:  A variable name,  an
   array  element  name,  a  character substring name, an array name, any
   other expression.

   (Note:  FORTRAN-20  supports  output  list  expressions  that  include
   concatenation  of  operands  of length *.  This is an extension of the
   ANSI standard that is also supported by VAX FORTRAN.)



   2.6  Intrinsic And Generic Functions


   FORTRAN  version  7  supports  all  intrinsic  and  generic  functions
   described in section 15.10 of the FORTRAN-77 standard.

   The following intrinsic functions are new in version 7:

        1.  Truncation for double precision - DINT

        2.  Nearest whole number - ANINT, DNINT

        3.  Nearest integer - NINT,IDNINT

        4.  Positive difference for double precision - DDIM

        5.  Double precision product (of real arguments) - DPROD

        6.  Character functions:

            1.  Conversion from character to integer - ICHAR

            2.  Conversion from integer to character - CHAR

            3.  Length of character entity - LEN

            4.  Location of substring - INDEX

            5.  Character comparisons - LGE, LGT, LLE, LLT


   The following generic function names have been added:
   ACOS, AINT, ANINT, ASIN, COSH, CMPLX, DBLE, DIM, LOG, LOG10, MAX, MIN,
   NINT, REAL, SINH, TAN, TANH.

   The second arument to CMPLX is now optional.

   The generic function name INT has been extended to  support  arguments
   that  are  COMPLEX  and INTEGER (in V6 it only handled REAL and DOUBLE
   PRECISION).

   FORTRA.DOC - FORTRAN-20 Version 7                              Page 13


   2.7  Multi-record Internal Files


   Internal files provide a means of  transferring  and  converting  data
   from  internal  storage  to  internal storage.  The functionality that
   they provide  is  similar  to  that  provided  by  ENCODE/DECODE.   An
   internal  file  is  a  character  variable,  character  array element,
   character array, or character substring.   If  a  character  array  is
   used, each array element is a record in the file.  Reading and writing
   records is accomplished by sequential  access  formatted  input/output
   statements.




   2.8  FORTRAN-77 DO Loop Semantics


   The behavior of DO loops in the FORTRAN-77  standard  is  incompatible
   with  that of the earlier FORTRAN-66 standard.  Version 6 (and earlier
   versions) handled DO  loops  in  accordance  with  the  old  standard.
   Version 7 supports the new standard.

   There are two differences between FORTRAN-77 DO loops  and  FORTRAN-66
   DO loops:

        1.  In FORTRAN-77, zero trip loops are possible;  previously  all
            loops executed at least once

        2.  In FORTRAN-77, the loop index is always available after  loop
            exit;  previously it was not


   Implied DO loops in I/O statements also follow the FORTRAN-77 DO  loop
   rules.   Therefore,  the implied DO loop index will be available after
   loop exit.  The only exception to this is when an error or end-of-file
   condition occurs during execution of the I/O statement.  In that case,
   the value of the implied DO variable is indeterminate.

   FORTRAN version 7 also provides  support  of  the  old-style  DO  loop
   semantics.   The  compiletime  switch  /F66 (or /NOF77) may be used to
   specify this.  Specification of /F66 results in the following:

        1.  All DO  loops  execute  at  least  once.   (If  /F66  is  not
            specified, zero-trip semantics are used.)

        2.  There is no guarantee that the loop index will  be  available
            after  loop  exit.  (If /F66 is not specified, the loop index
            will always be available after loop exit.)


   (Note that the /F66 switch also affects the behavior of  the  EXTERNAL
   statement.)
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 14


   2.9  Assumed-Size Array Declarators


   In an array declarator for a dummy array, the upper bound of the  last
   dimension  may  be specified by an *.  Note that an assumed-size array
   cannot be used as an I/O list element, or in any other  context  where
   the length of the array must be known.  This is in accordance with the
   FORTRAN-77 standard.



   2.10  ASSIGN Of FORMAT Statement Numbers


   Scalar variables that have been ASSIGNed FORMAT statement numbers  can
   be used as format specifiers in I/O statements.

   FORTRAN version 7 does not allow the assignment  of  FORMAT  statement
   numbers  to  subscripted  variables;   nor  does it allow the use of a
   subscripted variable as a format specifier.  This  restriction  is  in
   the FORTRAN-77 standard.




   2.11  INTRINSIC And EXTERNAL Statements


   The INTRINSIC statement  is  used  to  identify  a  symbolic  name  as
   representing an intrinsic function.  It permits the name to be used as
   an actual argument.

   In version 7, if the name of  an  intrinsic  function  appears  in  an
   EXTERNAL statement, that name is subsequently treated as the name of a
   user  defined  function.   This  is  accordance  with  the  FORTRAN-77
   standard.   (See  section  8.7  of the standard.) This is incompatible
   with previous versions of FORTRAN-20

   If the /F66 switch is specified at compiletime, then if  an  intrinsic
   function name appears in an EXTERNAL statement (and is not preceded by
   * or &) that name will still refer to the intrinsic function.



   2.12  SAVE Statement


   A SAVE statement is used to retain the definition of  a  variable,  an
   array,  or a named common block after the execution of a RETURN or END
   statement.

   In fact, FORTRAN-20 usually retains the definitions of all  variables,
   arrays,  and common blocks.  The only exception to this is in the case
   of overlays.
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 15


   In version 7, if a FORTRAN overlay contains any local  variables  that
   are SAVEd, all writable storage in that overlay will be preserved.  If
   a named COMMON block is SAVEd, the overlay that contains  that  common
   block will be preserved.  Blank COMMON is always preserved.

   LINK support of writable overlays is  required  for  support  of  this
   feature.  This is provided by LINK version 5.1.



   2.13  Support Of Null Argument Lists For Functions


   In version 6 it was possible to define an  external  function  with  a
   null argument list, but there was no way to reference such a function.
   Furthermore, the form of the declaration  was  incompatible  with  the
   FORTRAN-77  standard.   In  version  6  there  was no way to declare a
   statement function that had a null argument list.

   In version 7 we support the following:

        1.  The form:

                 fun()

            may be used to reference a  function  with  a  null  argument
            list.


        2.  Statement functions with null argument lists may be declared.
            A   null,   parenthesized   argument   list  appears  in  the
            declaration.

        3.  Parentheses may optionally be used for null argument lists in
            FUNCTION statements.

            The standard requires the parentheses.   Version  6  supports
            FUNCTION  statements  with  null argument lists, but does not
            allow parentheses.  Version 7 supports both forms.




   2.14  FORTRAN-77 Statement Ordering Rules


   Version 7 has relaxed some of the statement ordering restrictions that
   were  imposed  by previous versions.  Version 7 supports the statement
   ordering  rules  specified  by  section  3.6  of  the  full   language
   FORTRAN-77 standard.

   In  addition,  DATA  statements,  PARAMETER   statements,   and   type
   declarations  may  appear  in  any  order  as  long  as  there  are no
   interdependencies.  This extension to the standard is  also  supported
   by VAX FORTRAN.
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 16


   2.15  Minor Syntax Extensions


   Version 7 includes the following minor  extensions  for  compatibility
   with the FORTRAN-77 standard:

        1.  The comma is optional in  the  following:   DATA  statements,
            COMMON  statements,  assigned GOTO, after statement number in
            DO statements.

        2.  Parentheses may optionally be used for null argument lists in
            SUBROUTINE and CALL statements.

            Null subroutine argument lists were supported in  version  6,
            but parentheses were not allowed.

        3.  Statement numbers are  legal  on  non-executable  statements.
            These  statement numbers are ignored and are not available at
            execution time.

        4.  Exponentiation  to  an  integer  power  is  allowed  in   the
            subscript expressions in data statements.





   2.16  Constant Expressions


   FORTRAN Version 7  supports  constant  expressions  in  the  following
   constructs:  Array declarators, PARAMETER statements, implied-DO lists
   in DATA statements.




   2.17  FORTRAN-77 PARAMETER Statements


   FORTRAN version 7 supports PARAMETER statements in accordance with the
   FORTRAN-77  standard,  with  the  exception  that  we  do  NOT support
   compiletime expressions  that  involve  multiplication,  division,  or
   exponentiation of COMPLEX data.

   FORTRAN version 7 PARAMETER statement  support  differs  from  FORTRAN
   Version 6 in the following ways:

        1.  In FORTRAN-77, the data type of a PARAMETER is determined  by
            its   symbolic   name.    This   is   incompatible  with  the
            implementation of PARAMETER that was supported under  version
            6.   Under  version  6 the type was determined by the type of
            the constant.
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 17


        2.  In FORTRAN-77, the list of parameters  must  be  enclosed  in
            parentheses.   Under  version  6,  the  list of parameters is
            never enclosed in parenthees.

        3.  In FORTRAN-77,  the  parameter  may  be  set  to  a  constant
            expression.  FORTRAN version 6 only support simple constants.


   If the list of parameters is not enclosed in parentheses, the compiler
   assumes  that  it  is  not  a FORTRAN-77 PARAMETER statement.  In this
   case, it handles it compatibly with FORTRAN version 6,  by  using  the
   data  type  of  the  constant  rather  than that of the symbolic name.
   (Note:  If the list of parameters is not enclosed in parentheses,  and
   if  the  data  type  of the constant and the symbolic name differ, the
   compiler will issue  a  warning  message.   This  warning  message  is
   suppressed when the user compiles with the /F66 switch.)

   In version 7 (as in FORTRAN-77), PARAMETER statements may precede type
   declaration  statements  except  for those statements that specify the
   type of the parameter.

   FORTRAN-77  PARAMETER  statements  are  implemented  as  specified  by
   section  8.6  of  the FORTRAN-77 standard, with the exception that the
   compiletime expression cannot  contain  multiplication,  division,  or
   exponentiation of COMPLEX values.



   2.18  Expressions As Specifier Values In OPEN And I/O Statements


   Version 7 supports expressions as the values  of  specifiers  in  OPEN
   statements and control information lists.

   Integer expressions are supported as external unit identifiers, record
   numbers, and the values of all numeric OPEN statement specifiers.

   Character expressions are supported as format identifiers and  as  the
   values of all character OPEN statement specifiers.




   2.19  Type Checking For Function And Subroutine Arguments


   LINK version 5.1 provides a limited type checking capability.  FORTRAN
   version  7  will  generate  REL  file blocks to take advantage of this
   capability.

   The primary reason for implementing type checking in FORTRAN version 7
   and  LINK  version  5.1  is to provide support for character constants
   which are passed as actual arguments that correspond to numeric  dummy
   arguments.   This  feature  worked  in  FORTRAN  version 6 because the
   argument passing mechanism for quoted strings was by the word  address
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 18


   of the string.  This argument passing mechanism was changed in FORTRAN
   version 7 in order to support FORTRAN  77  character  data;   the  new
   argument   passing   mechanism  involves  passing  the  address  of  a
   descriptor for the string.  If the formal is numeric, then the pointer
   to  the  descriptor  will  be  changed  to  a pointer to the string at
   LINKtime.  Note that this feature only  works  when  both  caller  and
   callee have been compiled with FORTRAN version 7.  If a subprogram was
   compiled with an earlier version of FORTRAN, it will not  contain  the
   REL  file  blocks  that  LINK  uses to recognize that a fix-up must be
   performed on the character argument.

   FORTRAN version 7 will also support a new option to the DEBUG  switch.
   This  option  will  have the form /DEBUG:ARGUMENTS.  If this option is
   specified, FORTRAN will generate REL file  blocks  that  specify  that
   illegal  argument  type  mismatches  should  result in non-fatal error
   messages at load time.

   With FORTRAN version 7  and  LINK  version  5.1,  the  following  type
   checking will be performed:

        1.  If either the  caller  or  the  callee  does  not  have  LINK
            argument   descriptor   blocks,  no  type  checking  will  be
            performed.  Therefore, no type checking will be performed  on
            calls the involve old REL files.

        2.  If an actual argument  is  "passed  by  descriptor"  and  the
            corresponding  formal  is  "passed by address" then LINK will
            transform the actual argument  into  a  "passed  by  address"
            argument  in some cases.  This argument fixup was implemented
            in LINK in order to  provide  FORTRAN  support  of  character
            constants passed as actuals to numeric dummies.  Before doing
            the fixup, LINK checks that all of the  following  conditions
            are  true;  if any is not, it gives a non-fatal error message
            and does not do the fixup:
             -  The argument must be a constant.
             -  The byte pointer word in the  descriptor  in  the  user's
                image must be word aligned.
             -  The string must be in the same section  as  the  argument
                block.

            If all of the above are true, LINK puts the word  address  of
            the string into the argument block in place of the address of
            the  descriptor  for  the  string.   LINK  also  changes  the
            argument  type  code  in  the  argument block from 15 (string
            descriptor) to 17 (ASCIZ string).

            The fixup of character constants passed as actuals to numeric
            formals  will  be  done  whether  or  not  the user specified
            /DEBUG:ARGUMENTS when compiling his FORTRAN program.

        3.  If the user specified  /DEBUG:ARGUMENTS  when  compiling  his
            FORTRAN  program,  non-fatal error messages will be issued at
            LINK time for the following cases:
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 19


            1.  If the argument counts in the caller and callee disagree.

            2.  If a subroutine is called as a function or vice versa

            3.  If an actual argument is a constant and the value of  the
                corresponding  dummy  argument is potentially modified by
                the subprogram.  (Note that  if  the  dummy  argument  is
                passed   as  an  actual  to  another  subprogram,  it  is
                potentially modified.)

            4.  If the length of a character actual is less than that  of
                the  corresponding character dummy.  This is only checked
                if the length of the actual is known at compile time.

            5.  If the following associations  of  actual  argument  data
                types with dummy argument data types occur:

                Actual                     Associated Dummy
                Argument Type              Argument Type
                ------------               -------------

                Alt return label           Logical
                Alt return label           Integer
                Alt return label           Real            
                Alt return label           Double Precision
                Alt return label           G-floating      
                Alt return label           Complex         
                Alt return label           Character       

                Logical                    Alt return label
                Logical                    Integer
                Logical                    Real            
                Logical                    Double Precision
                Logical                    G-floating      
                Logical                    Complex         
                Logical                    Character       

                Integer                    Alt return label
                Integer                    Logical
                Integer                    Real            
                Integer                    Double Precision
                Integer                    G-floating      
                Integer                    Complex         
                Integer                    Character       

                Real                       Alt return label
                Real                       Logical
                Real                       Integer         
                Real                       Double precision
                Real                       G-floating      
                Real                       Complex
                Real                       Character       

                Double Precision           Alt return label
                Double Precision           Logical
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 20


                Double Precision           Integer         
                Double Precision           Real
                Double Precision           G-floating      
                Double Precision           Complex         
                Double Precision           Character       

                G-Floating                 Alt return label
                G-Floating                 Logical
                G-Floating                 Integer         
                G-Floating                 Real            
                G-Floating                 Double Precision
                G-Floating                 Complex         
                G-Floating                 Character       

                Complex                    Alt return label
                Complex                    Logical
                Complex                    Integer         
                Complex                    Real
                Complex                    Double Precision
                Complex                    G-floating      
                Complex                    Character       

                Character                  Alt return label
                Character                  Logical
                Character                  Integer         
                Character                  Real            
                Character                  Double Precision
                Character                  G-floating
                Character                  Complex         

                Octal                      Alt return label
                Octal                      Double Precision
                Octal                      G-floating
                Octal                      Complex
                Octal                      Character

                Hollerith                  Character

                Double Octal               Alt return label
                Double Octal               Logical
                Double Octal               Integer         
                Double Octal               Real            
                Double Octal               Character

                Note that in FORTRAN programs, all  arguments  that  have
                data type "character" will be "pass by descriptor", while
                all other argument  types  will  be  "pass  by  address".
                Therefore  if the actual argument is a character constant
                and the dummy is any other type, the FORTRAN special case
                action described in item 2 above will be performed.

                All combinations of data type (e.g.  octal, double octal)
                not listed in the above table are ignored.

   FORTRA.DOC - FORTRAN-20 Version 7                              Page 21


   2.20  New Functionality In ERRSET


   The functionality of ERRSET has been enhanced in version 7.  Version 7
   provides  ERRSET trapping for additional classes of errors in addition
   to those trapping in version 6.  Also, in  version  7,  the  user  can
   write his own fixup routines for arithmetic exceptions.

   The calling sequence for ERRSET is:

   Call:
           CALL ERRSET (N)
   or      CALL ERRSET (N, I)
   or      CALL ERRSET (N, I, SUBR)

   where   N = max number of error messages to type

           I = which error this call applies to.  One of:
                  -1 any of the following
                   0 integer overflow
                   1 integer divide check
                   2 input integer overflow
                   3 input floating overflow
                   4 floating overflow
                   5 floating divide check
                   6 floating underflow
                   7 input floating underflow
                   8 library routine error 
                   9 output field width too small
                   21 FORLIB warnings
                   22 non-standard usage warnings
                      ( These warnings are described in
                           section 2.24 below.)
                   23 Array and substring bounds violations

               If I is not specified, -1 is assumed

           SUBR = routine to call on the trap

                  The effect is as if

                      CALL SUBR (I, IPC, N2, ITYPE, UNFIXED, FIXED)

                  were placed in the program just after the instruction causing
                  the trap.
                           I = error number of trap, same as above
                           IPC = PC of trap instruction for
                                   error numbers 0, 1, 4, 5, and 6
                                   ( Note: Error 0 - integer overflow - can 
                                   occur in a jump instruction such as AOJA;
                                   in that case, the value of IPC will
                                   be incorrect. This is due to a permanent
                                   restriction in the hardware. )
                                Otherwise,  PC of FOROTS call
                           N2 = 2nd error number (reserved for DEC)
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 22


                           ITYPE = data type of value
                           UNFIXED = value returned by the processor
                           FIXED =  value after fixup
                                   SUBR can change this value.

                  If SUBR is not specified, no routine is called on the APR trap.



   2.21  Utility Subroutine To Get A Free Unit Number


   FORTRAN V7 provides an additional  FORTRAN-supplied  subroutine  which
   can  be used to get an unused unit number.  The routine FFUNIT ("First
   free unit") is called by:

        CALL FFUNIT(IUNIT)

   where IUNIT is an integer variable which will be set by FFUNIT to  the
   first available unit number.

   If there are no available unit numbers, IUNIT is set to -1.



   2.22  Additional Runtime Warnings


   FOROTS version 7 issues warning messages for a number of  non-standard
   usages for which the results may be unexpected.  These warnings may be
   disabled by using the ERRSET function with error number 22.

   FOROTS version 7 issues warnings for the following:

        1.  Data  type   mismatches   between   format   specifiers   and
            corresponding  I/O  list elements.  ( Bad data will be stored
            in the I/O list elements.  )

        2.  Writing beyond the end of a fixed length record.   (The  data
            is truncated.)

        3.  Input to Hollerith fields of FORMAT statements.  (This  works
            in V7, but we may de-support it in the future.)




   2.23  G-Floating Support


   FORTRAN-20 version 7 provides support for G-floating double precision.
   This  is  a  new  double  precision number format that has an exponent
   range of 2.8D-309 to 8.9D+307.  This number format is  supported  only
   on KL model B processors.
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 23


   G-floating is an alternative internal  format  for  double  precision.
   The user specifies whether he wants the old format of double precision
   ("D-floating") or the G-floating format by means  of  a  command  line
   switch   to   the  FORTRAN  compiler.   /GFLOATING  means  G-floating;
   /DFLOATING means the old double precision format.  The default is  the
   old format.

   LINK will issue a type mismatch warning whenever a  user  attempts  to
   pass  a  G-floating  actual argument to a D-floating dummy argument or
   vice-versa.  This warning will be issued  regardless  of  whether  the
   program was compiled with /DEBUG:ARGUMENTS.

   G-floating is not supported on the KS or the KL model A.



   2.24  Native TOPS-20 Command Interface


   The FORTRAN-20 version 7 compiler runs native mode  on  TOPS-20.   The
   compiler's command line interface has been modified to provide support
   of long file names, "?",  and  command  recognition.   The  FORTRAN-20
   command  language  that  is supported is in accordance with a standard
   that we are developing for all native TOPS-20 compilers.  This is  the
   first product to meet this standard.

   The syntax for the EXEC commands COMPILE, LOAD, EXECUTE, and DEBUG  is
   not  affected  by  the  new  command  scanner.   The EXEC does not yet
   support long file names in these commands.



   2.24.1  Interactive Command Syntax -

   If a user invokes the FORTRAN compiler by saying:
        @FORTRA

   the version 7 compiler prompts by saying:
        FORTRAN>

   The user should then enter a command line  of  one  of  the  following
   forms:    (Note:    Square  brackets  are  used  to  delimit  optional
   elements.)

        1.  <source-file-spec> [ switches ]

            If no switches are specified, the compiler  produces  a  .REL
            file,  with  the  same filename as the source file.  The user
            must use a /LISTING switch to get a listing file.

        2.  <source-file-spec>+<source-file-spec>+...[ switches ]

            The sources files are treated as if  they  were  concatenated
            prior to the beginning of compilation.
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 24


            If no switches are specified, the compiler  produces  a  .REL
            file,  with  the same filename as the last source file in the
            list.  The user must use a /LISTING switch to get  a  listing
            file.

        3.  /TAKE:<file-spec> [/ECHO]

            The compiler reads the file specified as  the  command  input
            stream.  The /TAKE command is legal in take files.  A maximum
            nesting depth of 10 take files is supported.

            The /ECHO switch will cause commands to be displayed on  TTY:
            as they are executed.

        4.  /RUN:<file-spec> [/OFFSET:<integer>]

            This command can be used to start  up  another  program  (for
            example,  LINK).  It causes an exit from the FORTRAN compiler
            and the start of execution of the program  indicated  by  the
            file-spec,  with  the  additional  option  of  starting  that
            program at an offset relative to the normal starting address.

        5.  /HELP

            Prints the help file, FORTRA.HLP.

        6.  /EXIT


   The  version  7  compiler  supports  the  following   switches.    All
   compilation switches will accept non-ambiguous abbreviations.

        1.  Binary switch

            This switch may be used to specify an binary file name.   For
            example:
                 FORTRAN>FOO/BINARY:FUM

            will compile the source file  FOO.FOR  producing  the  binary
            file FUM.REL.

            The switch /NOBINARY may be used to compile a program without
            producing an object file.

        2.  Listing switch

            This switch is used to produce a listing file.  The user  may
            specify the filename for the listing file.  If no filename is
            specified, the listing file has  the  same  filename  as  the
            source file, and extension .LST.

            For example:
                 FORTRAN>FOO/LISTING:FUM

            compiles FOO.FOR and produces a listing file called  FUM.LST.
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 25


            (It also produces an object file called FOO.REL.)

            Note that the list switch may be abbreviated.  /L  and  /LIST
            are both legal abbreviations.

        3.  ABORT switch.

            This switch is most useful when used in conjunction with with
            the /TAKE command.  It causes the compiler to exit at the end
            of a compilation that contains errors.

        4.  All of the switches that are described in chapter 15  of  the
            FORTRAN V6 manual.  This includes the following:
            /CROSSREF
            /DEBUG
            /EXPAND
            /INCLUDE
            /LNMAP
            /MACROCODE -  /MACHINE-CODE is now the preferred form of this
                           switch. /M also works.
            /NOERRORS
            /NOWARN
            /OPTIMIZE - /O is an abbreviation for /OPTIMIZE
            /SYNTAX

        5.  FORTRAN-77 switches

            /F77  -  Means  compile  DO  loops  and  EXTERNAL  statements
            compatibly with the F77 standard.  This is the default.

            /F66  or  /NOF77  -  Means  compile  DO  loops  and  EXTERNAL
            statements  compatibly  with  the  F66 standard.  This switch
            also suppresses  the  warning  message  that  is  issued  for
            old-style PARAMETER statements (see section 2.17 above).

        6.  G-floating switch

            /GFLOATING - Means  use  the  G-floating  format  for  double
            precision.  This switch may be abbreviated /G or /GFLOAT.

        7.  No options switch

            The /NOOPTIONS switch causes the user's SWITCH.INI file to be
            ignored.  (See section 2.20.3 below.)




   2.24.2  SWITCH.INI -

   FORTRAN V7 supports the  same  format  of  SWITCH.INI  files  as  were
   supported  by  FORTRAN  V6.  The compiler reads the file SWITCH.INI in
   the user's logged in directory on logical PS:   to  determine  default
   compilation switch values.
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 26


   There are two types of lines in a SWITCH.INI file.

        1.  Lines that specify default switch values.

            These lines consist of a product name followed by a  list  of
            switches.   The switch values then become the user's defaults
            for that product.  These default switch values are overridden
            if the user types a conflicting switch in a command line.

            For example, if the SWITCH.INI file in your  PS:   logged  in
            directory contains the line:
                   FORTRA /OPTIMIZE/NOWARN:DIM

            then when you run the FORTRAN compiler, it  will  always  run
            the  global  optimizer  and it will always suppress the "DIM"
            warning  diagnostic  (unless  you   specify   /NOOPTIONS   or
            /NOOPTIMIZE or /WARN in the command line).

            Either FORTRA or FORTRAN may be used as the product name  for
            the FORTRAN compiler.

        2.  Lines that define "options".

            These lines are used to define an option  name  that  can  be
            used in place of a list of switches.  The form of such a line
            in SWITCH.INI is:
                 <program-name>:<option-name>/switch/switch.../switch

            If a user has such a line in his SWITCH.INI, he can then  use
            "/OPTION:<option-name>"  as  a  way  to  specify  the list of
            switches.  For example, if a user's SWITCH.INI  contains  the
            line:
                 FORTRA:MYOPT /OPTIMIZE/NOWARN:(DIM,CHO)

            then he can compile a fortran program FOO with  the  switches
            specified by saying:
                 FORTRAN>MYPROG/OPTION:MYOPT



   In previous versions of FORTRAN, if the compiler  was  invoked  by  an
   EXECUTE,  COMPILE,  LOAD,  or DEBUG command, the user's SWITCH.INI was
   ignored.   This  deficiency  has  been  corrected  in  version  7   of
   FORTRAN-20.



   2.24.3  Old Batch Control Files -

   In order to keep old batch control files working, FORTRAN V7  supports
   the  most  commonly used forms of the old TOPS-10 style command syntax
   (as well as the new TOPS-20 style syntax) when  running  under  batch.
   Note  that  this  feature  works  only  under batch.  It does NOT work
   interactively, nor does it work under "DO"  or  "MIC".   In  addition,
   only the most commonly used of the old forms are supported.  We cannot
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 27


   guarantee that this feature will be supported for all future versions.
   We  encourage  users  to  convert their batch control files to the new
   command syntax.

   The following command line formats are supported under batch:

   *<rel-file-name>=<list of source-file-names>
   *<rel-file-name>,<listing-file-name>=<list of source-file-names>
   *,<listing-file-name>=<list of source-file-names>
   *=<list-of-source-file-names>
   *,=<list-of-source-file-names>

   Switches may be specified before or after any file name in the command
   line.   The effect of a switch is not dependent on its position in the
   command line.  Logical device names may be used  in  the  file  names.
   PPN's are not supported.

   Some illegal TOPS-10 style command  lines  may  produce  unpredictable
   results.



   3.0  RESTRICTIONS

   3.1  FORTRAN-77 Features Not Supported


   FORTRAN-10/20 version 7 supports the subset level FORTRAN-77 standard.
   It also supports most of the features in the the full level FORTRAN-77
   standard.

   The following features from the full level standard are not  supported
   by FORTRAN version 7:

        1.  The INQUIRE statement is not supported by version 7.

        2.  In version 7, comment lines and blank lines  may  not  appear
            between  an initial line and its first continuation line, nor
            may they appear between two continuation lines.

        3.  In version 7,  the  compiletime  expression  in  a  PARAMETER
            statement   cannot   contain   multiplication,  division,  or
            exponentiation of COMPLEX data.




   3.2  Other Restrictions


   Version 7 will not support global  optimization  of  subprograms  that
   contain  character  data.   If the user specifies the /OPTIMIZE switch
   for such a subprogram the warning diagnostic "/OPT  ignored"  will  be
   issued.
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 28


   4.0  KNOWN BUGS AND DEFICIENCIES

   4.1  Known Bug In G-floating


   There is a compiler bug which affects programs that are compiled  /GFL
   and have exponentiation of the form:

           R ** I

   where R is a single or double precision real  constant  and  I  is  an
   integer  constant.   Unless the program is compiled /OPT, the bug only
   occurs when both R and I are constants  or  symbolic  constants.   The
   compiler generates the wrong value for such an expression.

   This bug is fixed by edit 1724 which will be in the first autopatch of
   FORTRAN V7.

   The following procedure may  be  used  to  fix  the  compiler  in  the
   meantime if you wish to use /GFLOATING.  User input is in lower case.
       @filddt
       FILDDT>get fortra/p
       [3908 symbols loaded from file]
       [Looking at file FORTRA.EXE.1]

       expgf/   DMOVE 4,DPNEGN#+12   dmove 4,pat..
       gstep1+7/   DMOVE 1,DPNEGN#+12   dmove 1,pat..
       gover+5/   DMOVE 1,DPNEGN#+12   dmove 1,pat..
       pat../   0   200140,,0
       pat..+1/   0   0
       pat..+2/   0   pat..:   
       ^Z
       @;done

   If you prefer to make a source patch to the compiler, the module  that
   should  be  changed  is  CNSTCM.MAC.   Note  that  you should save the
   original source for autopatch.
   File 1) V7AC:CNSTCM.MAC[4,504]  created: 1812 12-Jan-1983
   File 2) DSK:CNSTCM.MAC[4,714]   created: 1054 03-Feb-1983

   1)1             CNSTCV= BYTE (3)0(9)6(6)0(18)1707       ; Version Date: 4-Jan-83
   1)      
   ****
   2)1             CNSTCV= BYTE (3)0(9)6(6)0(18)1724       ; Version Date: 3-Feb-83
   2)      
   **************
   1)1     ***** End Revision History *****
   ****
   2)1     ***** End V7 Development *****
   2)      
   2)      1724    CKS     3-Feb-83
   2)              EXPGF was copied from EXPRL and G-ized.  Unfortunately, it
   2)              wasn't G-ized enough.  Change 1.0 to 200140000000.
   2)      
   2)      ***** End Revision History *****
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 29


   **************
   1)1             F1=201400       ;FLOATING POINT ONE
   1)              G1=200140       ;[761] GFLOATING 1.0
   1)
   ****
   2)1             F1=201400000000 ;[1724]FLOATING POINT ONE
   2)              G1=200140000000 ;[1724] GFLOATING 1.0
   2)      
   **************
   1)3             DMOVE   RH,[EXP 1.0,0]  ;Floating 1 to RH-RL
   1)              MOVM    T,C2L           ;|exponent| to T
   ****
   ;**;[1724] @ EXPGF + 2L, change 1 line, CKS, 3-Feb-83
   2)3             DMOVE   RH,[EXP G1,0]   ;[1724]Floating 1 to RH-RL
   2)              MOVM    T,C2L           ;|exponent| to T
   **************
   1)3             DMOVE   TH,[EXP 1.0,0]  ;Else get reciprocal of result
   1)              GFDV    TH,RH           ;Underflow impossible
   ****
   ;**;[1724] @ GSTEP1 + 8L, change 1 line, CKS, 3-Feb-83
   2)3             DMOVE   TH,[EXP G1,0]   ;[1724]Else get reciprocal of result
   2)              GFDV    TH,RH           ;Underflow impossible
   **************
   1)3             DMOVE   TH,[EXP 1.0,0]  ;For exponent < 0, get reciprocal
   1)              GFDV    TH,RH           ;of wrapped overflow
   ****
   ;**;[1724] @ GOVER + 5L, change 1 line, CKS, 3-Feb-83
   2)3             DMOVE   TH,[EXP G1,0]   ;[1724]For exponent < 0, get reciprocal
   2)              GFDV    TH,RH           ;of wrapped overflow
   **************



   4.2  Mandatory Patches For Related Products


   Edit 476 of SORT (PCO 20-SORT-197) is required in order to  call  SORT
   from  FORTRAN  on  TOPS-20  KL  model B processors.  SORT 4.4(500) was
   shipped on autopatch tape  4.  If you have not yet installed Autopatch
   tape  4, you should install SORT edit 476 if you want to use SORT with
   FORTRAN V7.  This SORT patch is required because the FORTRAN V7 FORSRT
   will  cause  SORT  to  be merged into a non-zero section on Tops-20 KL
   model B processors.



   4.3  Known Deficiencies In Related Products



        1.  There are several deficiencies in the compile-class commands.
            These  are  due  to bugs in the TOPS-20 EXEC.  These problems
            occur in TOPS-20 releases 4.1, 5.0, and 5.1.
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 30


            1.  If the /NOBINARY  switch  is  given  to  a  compile-class
                command,  it  is  ignored.  Edit 938 (PCO 20-EXEC-186) to
                the TOPS-20 EXEC fixes this problem.

            2.  If the /NOWARNING switch  is  given  to  a  compile-class
                command,  it  is  ignored.  Edit 947 (PCO 20-EXEC-195) to
                the TOPS-20 EXEC fixes this problem.

            3.  The /ABORT  switch,  although  present  in  the  list  of
                switches  given  in  response  to a ?, is not recognized.
                The /ABORT and /ALGOL switches are  not  in  alphabetical
                order.   Edit  944  (PCO 20-EXEC-192) to the TOPS-20 EXEC
                fixes this problem.

            4.  If a /LIST switch is given with /NOCREF, no list file  at
                all is produced.

            The above deficiencies exist in field image TOPS-20  releases
            4.1, 5.0, and 5.1.

        2.  Do not install TOPS-20 edit 2819 (CTCO 607.1).

            TOPS-20 edit 2819 is  a  bad  edit  which  can  cause  system
            crashes  when  EXTEND  instructions are used.  If you observe
            system crashes when running G-floating programs, this TOPS-20
            edit  may  be  the  cause,  and  its  removal  will solve the
            problem.

            TOPS-20 edit 2873 (PCO 20-MONITO-512) is a  replacement  edit
            for  the  original  problem.   This PCO is in TOPS-20 release
            5.1.




   5.0  COMPATIBILITY WITH PREVIOUS VERSIONS

   5.1  Incompatibilities Between Versions 6 And 7



         o  Changes in the behavior of OPEN statements

            1.  OPEN statements with no FORM  or  MODE  specifier  behave
                differently  in  version  7  than  they did in version 6.
                This  change  only  affects   programs   that   do   file
                positioning operations (BACKSPACE or SKIPRECORD) of files
                opened with no FORM or MODE specifier.

                If an OPEN statement  does  not  specify  FORM  or  MODE,
                version  6 allows the FORM= attribute to be determined by
                the  first  IO  statement  executed.   Version  7  always
                determines  whether  a  file  is FORMATTED or UNFORMATTED
                when  an  OPEN  statement  is  executed.   If  the   OPEN
                statement  does not include a FORM= or a MODE= specifier,
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 31


                it defaults in accordance with the  FORTRAN-77  standard.
                The default is:

                 o  If the OPEN statement  specifies  ACCESS='DIRECT'  or
                    ACCESS='RANDOM'  or ACCESS='RANDIN', then UNFORMATTED
                    (BINARY)

                 o  Otherwise, FORMATTED (ASCII)


                In order to minimize the impact of this  incompatibility,
                FORTRAN   version   7   will  support  formatted  I/O  to
                unformatted files and unformatted I/O to formatted files.
                After  such an I/O operation has occurred to a file, that
                file will be considered to be a "mixed form" file and all
                file  positioning operations ( BACKSPACE and SKIPRECORD )
                will be illegal.

                For example, version  7  will  issue  a  fatal  error  at
                runtime for the following:

                   OPEN(UNIT=1, FILE='FOO') ! Formatted OPEN
                   READ (UNIT=1) X         ! Unformattted READ; this makes the
                                           !  the file have "mixed form"
                   SKIPRECORD (UNIT=1)     ! It is illegal to do SKIPRECORD
                                           ! to a mixed form file



                The user can  fix  his  program  by  modifying  the  OPEN
                statement to include the FORM specifier.

                This functionality is NOT affected by the /F66 switch.

            2.  The behavior of OPEN on a connected unit has been changed
                to satisfy the requirements of the FORTRAN-77 standard.

                If the OPEN statement contains a "STATUS=OLD"  specifier,
                then  its  behavior depends on whether the file specified
                by the OPEN is the same file that is currently  connected
                to  the  unit.   If it is a different file, the connected
                file is closed and the new file is opened.  If it is  the
                same  file,  the file is not closed, and the file pointer
                is not moved.  This is a requirement  of  the  FORTRAN-77
                standard.   This  behavior  is  not  affected by the /F66
                switch.

                Version 6 did not check for the  case  where  the  second
                OPEN  refers  to  the  same  file  as the first OPEN.  It
                always closes the file and reopens it.

            3.  In FORTRAN version 6, if the RECORDSIZE specification  in
                an  OPEN  statement for a BINARY file conflicted with the
                record size actually found in  the  file,  no  error  was
                indicated.   In  version  7  this  is  a fatal error.  In
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 32


                addition, if a type 2, or continuation-type LSCW (logical
                segment  control  word)  is  found  in a file for which a
                RECORDSIZE specification has been given,  this  too  will
                yield  a  fatal error, as files written with a RECORDSIZE
                specification should not have type 2 LSCWs.   This  error
                was also not detected by version 6.


         o  Changes in the behavior of I/O statements

            1.  Changes in formatted I/O

                The treatment of special characters  in  formatted  files
                has  been  changed  in  order to enable users to read and
                write character variables that contain these  characters,
                and to improve the performance of formatted I/O.

                 o  Formatted input for files OPENed  with  fixed  length
                    records

                    In version 7, when formatted input  is  done  from  a
                    file  with  fixed  length records, all characters are
                    read exactly as they appear in the file.  The  number
                    of  characters read is always equal to the RECORDSIZE
                    (RECL) specified in the  OPEN  statement.   Thus,  in
                    version  7, A-format input from a fixed length record
                    will read NUL, CR, LF, FF, or VT if those  characters
                    are  within  the  record length specified in the OPEN
                    statement.

                    This differs from version 6 in two ways:

                    1.  Version 6 always terminates record input when  it
                        encounters  CR,  LF, FF, or VT, regardless of the
                        RECORDSIZE.

                    2.  Version 6 ignores NULs.


                 o  Formatted input for files OPENed with variable length
                    records

                    In version 7, A-format input from a  variable  length
                    record  reads  all  NULs  that  are  interior  to the
                    record.  Version 6 ignores them.  (Note:  Since  line
                    terminators  terminate the record, version 7 does not
                    read them.  )

                    As in version 6,  leading  NULs  in  variable  length
                    records  are  still  ignored.   This  is necessary in
                    order to support variable length input  from  a  file
                    that  was  written with fixed length output.  This is
                    because fixed length  records  are  word-aligned  and
                    inter-record gaps contain NULs.
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 33


                 o  A-format output (for both fixed and  variable  length
                    records)

                    In  version  7,  A-format  output  writes   out   all
                    characters    exactly   as   they   appear   in   the
                    corresponding I/O  list  variables.   In  version  6,
                    blanks  were substituted for NULs.  This is no longer
                    done.

                 o  Padding of fixed length records

                    In version 7, fixed length records in formatted files
                    are  padded  with blanks.  In previous versions, they
                    were padded with NULs.  (The user can specify the pad
                    character  desired  by  using  PADCHAR=  in  his OPEN
                    statement.  Space is the default.)


            2.  Change in the default BLOCKSIZE for formatted magtapes

                The default blocksize for formatted magtapes is different
                in  version  7  than  it  was  in  version  6.  Version 6
                interpreted the monitor default  (512)  to  be  character
                count.  Version 7 interprets it to be a word count.

                The most obvious effect of this change will occur if  you
                write a tape with a version 7 program (without specifying
                blocksize) and attempt  to  read  it  with  a  version  6
                program.   In  that  case,  the  records  on the tape are
                longer than the program expects and  data  is  lost.   In
                this case, the version 6 program should specify BLOCKSIZE
                = 2560 (5 X 512).

                Note that this change is not a problem for users who want
                to  use  version  7  programs  to  read  tapes written by
                version 6.  There is no problem with reading a tape whose
                actual blocksize is shorter than the program expects.


            3.  Change in multi-record ENCODE/DECODE

                In previous versions of FORTRAN, the character  count  in
                ENCODE  and  DECODE statements was interpreted as a total
                string count, and a  "/"  format  or  indefinite  repeat,
                which  for normal files causes a new record to be read or
                written, aligned the record  pointer  to  the  next  word
                boundary.   In  V7, the count specified is interpreted as
                an internal record size in characters, and "/" format  or
                indefinite repeat cause the record pointer to be advanced
                to the next internal record.


         o  New Runtime Warning Messages
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 34


            1.  In FORTRAN V6 and all previous  versions,  Hollerith  and
                quoted  string input to FORMAT statements was allowed and
                not flagged with any warning.  FORTRAN  V7  will  give  a
                warning  message,  as it is illegal according to the ANSI
                Standard, and some future version  of  the  compiler  may
                compile  or  pool FORMATs, thus disallowing Hollerith and
                quoted string input altogether.

                This warning may be disabled with the ERRSET function.

            2.  In  FORTRAN  V6,  data  type  mismatches  between  format
                specifiers  and  I/O  list  items  were  ignored.  FOROTS
                Version 7 issues a warning for this.  This warning may be
                disabled with the ERRSET function.


         o  Changes that affect assembly language subprograms


            1.  In FORTRAN V6, if a quoted string is an  actual  argument
                to a MACRO subprogram, the argument block that is pointed
                to by AC 16 contains the address of the ASCIZ string.  In
                FORTRAN  V7, the argument block contains the address of a
                two-word descriptor block, in which the first word  is  a
                byte  pointer  to  the string (which will in fact be word
                aligned and ASCIZ) and the second word is the  length  of
                the string.

            2.  In FORTRAN V6 and previous  versions,  calls  to  ALCHN.,
                DECHN.,  FUNCT.,  ALCOR.,  and DECOR.  could have indexed
                arguments  and   ACs   specified   as   arguments.    For
                performance  reasons,  this  capability has been removed.
                Users were warned about this upcoming change  in  the  V6
                manual.

            3.  In versions 6 and before (all the way back to LIB40),  an
                instruction  followed  by  JFCL works as follows:  If the
                instruction is  "JFCL  0,addr",  do  not  type  an  error
                message,  fix  up the result of the instruction, and jump
                to addr.  If the instruction is "JOV addr",  do  type  an
                error  message,  do  fix up the result, and jump to addr.
                The behavior of JOV is different under version 7:  do NOT
                type an error message, do NOT fix up the result, and jump
                to addr.  This makes JOV behave the same under  the  trap
                handler  as  it  does under the hardware.  "JFCL 0," will
                not change.


         o  Changes in the behavior of declarations

            1.  In version 7, if the name of  an  intrinsic  function  is
                specified  in  an EXTERNAL statement that name is treated
                as the name of a user-defined function.   In  version  6,
                the  function name is treated as the name of an intrinsic
                function.  (In version 6, this kind of EXTERNAL statement
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 35


                was  used  to  allow  the  intrinsic  function name to be
                passed as a subprogram argument.)

                If the /F66 switch is specified, EXTERNAL statements  are
                processed compatibly with version 6.

            2.  FORTRAN version 7  supports  the  FORTRAN-77  syntax  and
                semantics  for  PARAMETER  statements.  This is different
                from the version  6  implementation;   however,  the  old
                syntax/semantics also works under version 7 except that a
                warning is issued when it  is  used.   (This  message  is
                suppressed  in the /F66 compilation switch is specified.)
                In particular:
                 o  In version 7, the list of parameters must be enclosed
                    in   parentheses.    If   it   is   not  enclosed  in
                    parentheses, a warning message is issued.
                 o  In version 7, the  data  type  of  the  PARAMETER  is
                    determined   by   its   symbolic   name,  unless  the
                    parentheses  around  the  parameter  list  have  been
                    omitted.   If the parentheses have been omitted, then
                    the data type is determined in the same way as it was
                    in version 6, which is by the type of the constant.


            3.  In Version 7, a type declaration of a generic function is
                ignored.   This  is  in  accordance  with  the FORTRAN-77
                standard.  This functionality is not affected by the /F66
                switch.

                The  interpretation  of  type  declarations  of   generic
                functions  by  FORTRAN Version 6 was not consistent.  For
                example, if SIN was declared to be  double  precision  it
                was  subsequently  treated  as a user function name.  The
                compiler did no type checking on its arguments and a call
                to "SIN" (not "SIN.") was generated.  However, if SIN was
                declared to be real  it  was  treated  as  a  non-generic
                library  function  name.   The  compiler checked that its
                argument in all subsequent calls was real, and a call  to
                "SIN." was generated.


         o  DO loops

            Under FORTRAN version 7, the iteration count for  a  DO  loop
            may  be  zero.   Under  version 6, all loops were executed at
            least once.  The /F66 switch may be specified at  compiletime
            to cause DO loops to be executed compatibly with version 6.

         o  FORDDT

            1.  In version 7 of FORDDT, /C is used  for  CHARACTER  mode.
                In  version  6, /C was used for COMPLEX mode.  In version
                7, /X is used for COMPLEX mode.

   FORTRA.DOC - FORTRAN-20 Version 7                              Page 36


         o  Compiler command interface

            The command interface to the version  7  compiler  is  now  a
            TOPS-20 style interface.  See section 2.21 above.

         o  Old  version  5A  constructs  that  generate  warnings  under
            version 6

            FORTRAN-10/20 version 6 issues warning messages for a  number
            of constructs that are fatal in version 7.

            1.  In FORTRAN version 5A the character  '/'  could  be  used
                instead  of ':' to separate the upper and lower bounds in
                a dimension declarator.  In version 6, use of '/'  causes
                a  non-fatal  warning  message  to  be issued.  Version 7
                supports constant expressions in array declarations,  and
                therefore  in  version  7  the  '/'  will be treated as a
                division operator.

            2.  In version 5A the character '#' could be used to separate
                the unit and record numbers in random I/O statements.  In
                version 6, this use of '#'  causes  a  non-fatal  warning
                message  to be issued.  In version 7 the '#' is parsed as
                a .NE.  operator in the expression for the  unit  number;
                this   then   results  in  the  fatal  error  "Relational
                expression illegal as UNIT specifier".

            3.  In version 5A, a subscripted reference could be  used  in
                an  assigned  GOTO  statement.   This  feature  was never
                documented.  In version 6, use of this feature  causes  a
                non-fatal  warning  message  to  be issued.  In version 7
                this will be illegal.  (This is because in FORTRAN-77 the
                comma  in  an  assigned  GOTO  is  optional.  Without the
                comma, use of a subscripted reference in an assigned GOTO
                is ambiguous.)


         o  Other

            1.  The error numbers associated with certain  fatal  runtime
                errors   have   changed,   and  some  errors  which  were
                previously warnings are now fatal.   In  particular,  all
                errors  whose first error number was 799 in version 6 now
                have 97 as the first  error  number;   all  errors  whose
                first  number  was  899 now have 98.  All errors in these
                two error classes are now fatal.

            2.  In  FORTRAN  V6,  quoted  literals  could  be  passed  as
                arguments  to  numeric  formals.   In  FORTRAN  V7, those
                quoted literals are treated as character  constants,  and
                are  passed  by  descriptor.   In  most  cases,  V7  will
                continue to support passing these  constants  to  numeric
                formals.   A LINKtime fixup will be done to support this.
                Note that this feature only works when  both  caller  and
                callee  have  been compiled with FORTRAN version 7.  If a
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 37


                version 7 program calls a subprogram  that  was  compiled
                with  an  earlier version of FORTRAN, the subprogram will
                not contain  the  REL  file  blocks  that  LINK  uses  to
                recognize   that  a  fix-up  must  be  performed  on  the
                character argument.

                If the name of the  function  being  called  is  a  dummy
                argument, then the LINKtime fixup cannot be done.





   5.2  Compiler "FORTRAN-77" Switch


   There will be a compiletime switch which will specify whether  certain
   constructs  should  be  interpreted  compatibly  with  the  FORTRAN-77
   standard or compatibly with previous versions  of  FORTRAN.   The  two
   values of this switch are:

        /F77 - FORTRAN-77 compatible

        /F66 (or /NOF77) - Version 6 compatible

   The default value of this switch is /F77.

   The following constructs will  behave  differently  depending  on  the
   value of this switch:

        1.  DO loops

            When /F77 is specified, 0-trip loops are possible.  When /F66
            is specified, all DO loops execute at least once.

            When /F77  is  specified,  the  loop  index  will  always  be
            available  after loop exit.  When /F66 is specified, there is
            no guarantee that the loop index will be available after loop
            exit.

        2.  Use of intrinsic function names in EXTERNAL statements

            If the name of an instrinsic function appears in an  EXTERNAL
            statement, but is not preceded by * or &:

            1.  When /F77 is specified, the name is subsequently  treated
                as the name of a user defined function.

            2.  When /F66 is specified, the  name  still  refers  to  the
                intrinsic function.


        3.  PARAMETER statements

            The   warning   message   for   non-parenthesized   PARAMETER
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 38


            statements is suppressed when /F66 is specified.




   5.3  FOROTS Interface


   Programs that are compiled with FORTRAN version  7  must  be  executed
   with FOROTS version 7 and FORLIB version 7.  If you inadvertantly load
   version 6 FORLIB/FOROTS with a .REL file that  was  generated  by  the
   version 7 compiler the you may get the runtime error:

        ?Data in IO list but not in format

   Other errors may also occur.

   In most cases, programs that were compiled with FORTRAN version 6 will
   work  with FORLIB/FOROTS version 7;  however, we cannot guarantee that
   this is always true.  In you encounter a problem  running  a  V6  .REL
   file with the new FORLIIB/FOROTS, you must recompile.

   MACRO programs that search FORPRM.UNV should be reassmebled  with  the
   version 7 FORPRM in order to use version 7 FORLIB and FOROTS.



   5.4  Subprogram Calling Conventions


   In most cases subprograms compiled under version 6 can  be  called  by
   subprograms  compiled  under version 7 and vice-versa.  The exceptions
   to this are:

        1.  If a subprogram is compiled with version 7,  it  cannot  pass
            character or quoted string arguments to a subprogram compiled
            with an earlier version of FORTRAN.

            The LINKtime  fixup  of  actual  arguments  that  are  quoted
            strings  only  works  when  both  caller and callee have been
            compiled  with  FORTRAN  version  7.   If  a  subprogram  was
            compiled  with  an  earlier  version  of FORTRAN, it will not
            contain the REL file blocks that LINK uses to recognize  that
            a fix-up must be performed on the character argument.

        2.  If a  version  7  subprogram  has  dummy  arguments  of  type
            character,  it cannot be called by a subprogram compiled with
            an earlier version of FORTRAN.

        3.  Subprograms that do  I/O  must  be  compiled  with  the  same
            version  of FORTRAN.  We cannot guarantee that FOROTS version
            7 will always work when called by subprograms  compiled  with
            the version 6 compiler.

   FORTRA.DOC - FORTRAN-20 Version 7                              Page 39


   5.5  Changes In The FORTRAN/DBMS Interface


   The interface between FORTRAN Version 7 and  DBMS  differs  from  that
   used  by  FORTRAN  versions  6  and  5A.  After a site has built a new
   DBMSF.EXE according to the  build  procedures  supplied  with  FORTRAN
   version, that new DBMSF.EXE will not work with FORTRAN versions 5A and
   6.

   If you want to run FORTRAN version 6 programs with the new  DBMSF.EXE,
   you must install the following patch in FORTRAN version 6:
   File 1) DSK:FOROTS.V6A[4,1474]  created: 2240 02-Jan-1983
   File 2) V6:FOROTS.MAC[4,250]    created: 1210 18-Nov-1981

   At DBMS%%+2,

   1)5     %%FUNC: PUSH    P,T1            ;PUSH T1, JUST LIKE FORINI
   1)              JRST    %FUNCT          ;AND GO TO HISEG ENTRY
   1)      IFE FTSHR,<
   ****
   2)5     IFE FTSHR,<
   **************

   At INIT%,

   1)6             MOVE    T1,[JRST %%FUNC] ;GET ADDRESS OF FUNCT. ENTRY
   1)              MOVEM   T1,.JBBLT##     ;STORE WHERE DBMS CAN FIND IT
   1)              SETZ    F,              ;CLEAR FLAGS
   ****
   2)6             SETZ    F,              ;CLEAR FLAGS
   **************

   If you want to run FORTRAN version 5A programs with the new DBMSF.EXE,
   you must install the following patch in FORTRAN version 5A:

   File 1) DSK:FOROTS.V5A[4,1474]  created: 1216 22-Dec-1982
   File 2) V5A:FOROTS.MAC[4,246]   created: 1545 27-Oct-1977

   1)1             MOVE    T1,[JRST FUNCT%]        ;PUT A JRST TO FUNCT%
   1)              MOVEM   T1,.JBBLT##     ;WHERE DBMS CAN KNOW ABOUT IT
   1)              MOVEI   T1,LOW.SZ(P4)   ;GET THE END OF THE STATIC AREA
   ****
   2)1             MOVEI   T1,LOW.SZ(P4)   ;GET THE END OF THE STATIC AREA
   **************



   5.6  Using DBMS With FORTRAN V7


   The FORTRAN/DBMS interface has been thoroughly  reworked  for  FORTRAN
   V7.   Instead  of  the  DBMS  files being merged into FORLIB, they are
   placed in a separate file called SYS:DBMSF.REL, which is  searched  by
   LINK  after  FORLIB.REL  if  the  program  contains DBMS calls.  Under
   normal circumstances, FOROTS and DBMS will be loaded as  two  separate
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 40


   sharable  segments, FOROT7.EXE and DBMSF.EXE.  In order to provide the
   ability to load DBMS with the user's program, a new  switch  has  been
   provided  - %DBSNS - which if it is defined before FORLIB is searched,
   will force the loading of DBMS with the user's program.

   Examples:

   1.  Sharable FOROTS and DBMS (the default action):

           @LOAD program

   causes the user program to be loaded to use  the  sharable  FOROT7.EXE
   for calls to FOROTS and sharable DBMSF.EXE for calls to DBMS.

   2.  Sharable FOROTS with DBMS loaded with the user's program:

           @LINK
           *program/DEFINE:%DBSNS/G

   causes the user program to be loaded with DBMS  to  use  the  sharable
   FOROT7.EXE for calls to FOROTS.

   3.  Sharable DBMS with FOROTS loaded with the user's program:

           @LINK
           *program/OTS:NONSHARE/G

   causes the user program to be loaded with FOROTS to use  the  sharable
   DBMSF.EXE for calls to DBMS.

   4.  Nonsharable DBMS and FOROTS:

           @LINK
           *program/OTS:NONSHARE/DEFINE:%DBSNS/G

   causes the user program to be loaded with both DBMS  and  FOROTS,  and
   thus use no sharable high segment.



   5.7  Incompatibilities Between Versions 5A And 6


   There were a number of changes introduced between versions 5A and 6 of
   FORTRAN.   If  your  site  is  converting  directly from version 5A to
   version 7, you should also be aware of the following:

        1.  The constructs '' and 0H which were legal in version  5A  are
            illegal in versions 6 and 7.

            In version 5A, '' produced a string of 5 spaces.  In versions
            6  and 7, a string of one space (' ') should be used for this
            purpose.

            In version 5A, 0H produced a word of nulls.   In  versions  6
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 41


            and  7,  a numeric 0 should be used to initialize a Hollerith
            string with nulls.  In version 7,  CHAR(0)  can  be  used  to
            represent the character NUL.

        2.  No routine may do UUOs in  a  FORTRAN  program.   FOROTS  and
            PA1050  do  not  coexist  peacefully.  (In particular, PA1050
            considers FOROTS's memory management  to  be  illegal  memory
            references.)  FOROTS,  FORDDT,  and  DDT  are  all completely
            native mode, so  the  only  UUOs  encountered  in  a  FORTRAN
            program will be in user-supplied MACRO subroutines.

        3.  In version 5A, partially written files could be closed by the
            exec   @CLOSE   command  when  a  Fortran  program  has  been
            interrupted by ^C.  Since Fortran programs now run in  native
            mode  and  use  PMAP,  the @CLOSE command does not close disk
            files.  (This is true  of  all  native  programs.)  To  close
            partially written disk files in a version 6 or 7 program, use

            @REENTER
            Do you want to close all files?  (Y or N):Y
            @

            instead of:

            @CLOSE

        4.  Numeric differences

            There were a number of changes made between versions 5A and 6
            to  improve  the  numeric accuracy of results.  These changes
            can  propagate  through  a  calculation  to  produce   larger
            differences in final results.

             o  The mathematical functions in FORLIB were  rewritten  for
                increased accuracy.

             o  The floating point input and output  routines  of  FOROTS
                were made more accurate, so that the numbers they produce
                (both internally and externally) are more accurate  (and,
                therefore different) than those produced by version 5A.

             o  The maximum number of  digits  encoded  by  the  floating
                point output routine was increased in version 6 over that
                encoded by version 5A.  Thus printing with  format,  say,
                E30.20 will produce different results with version 6 than
                with version 5A:  for  both  real  and  double  precision
                numbers  the  number  of non-zero digits has increased to
                20.

             o  Integer division by 0 now returns  the  largest  possible
                integer  value  having  the  sign  of  the numerator.  In
                version 5A, the value returned was the numerator.

   FORTRA.DOC - FORTRAN-20 Version 7                              Page 42


        5.  In FORTRAN versions 6 and 7  the  default  interpretation  of
            blanks  in  formatted  files  is  BLANK=NULL,  unless no OPEN
            statement has been executed.  This is a  requirement  of  the
            FORTRAN-77  standard.   It is incompatible with version 5A in
            which blanks are always treated as 0's.

        6.  A string of consecutive linefeeds is treated as one  linefeed
            by 5A;  version 6 treats them as multiple records.

        7.  The functions DFIX  and  IDFIX  have  been  replaced  by  the
            equivalent IDINT.

        8.  DIALOG input may be terminated by a carriage return.  Altmode
            invokes  command recognition and so does not terminate dialog
            input.  If it is necessary  to  type  extremely  long  dialog
            responses, either type over the line boundary without hitting
            carriage return, or use - (hyphen) at the end of the line  as
            a continuation character.

        9.  In versions 6 and 7, when a READ takes the ERR=  branch,  the
            file  is  positioned after the erroneous record.  A BACKSPACE
            may be used to position the file before the erroneous record;
            otherwise  the  next  READ  will get the record after the one
            with the error.  This is different  than  version  5A,  which
            leaves the file positioned before the erroneous record.

            If it is desired to reread the erroneous record  and  specify
            an ERR= branch, you can now use REREAD with an ERR= branch.

       10.  The BLOCKSIZE parameter of the OPEN statement specifies  tape
            block  size  in  bytes.   In  version  5A,  the block size is
            specified in words.

       11.  If RECORDSIZE is specified when opening a file, and the  file
            contains records that are not of the specified size, behavior
            will differ between version 5A and version 6.   In  formatted
            mode  5A  reads  until  it  finds  a  CRLF, 6 reads until the
            specified  number  of  characters   have   been   read.    In
            unformatted  mode  5A  reads  until the I/O list is satisfied
            (and no farther), 6 reads until the specified number of words
            have  been  read.   Reading  BINARY-mode files with the wrong
            record size is fatal with both versions.

       12.  When reading list-directed I/O (* format), 5A reads '4* 5' as
            '5,5,5,5'.  6 reads it as ',,,,5' (4 null items followed by a
            5).  Files written with 5A can contain repeat counts followed
            by  spaces,  and  so  will  be  interpreted incorrectly by 6.
            Files written by 6 can be read by 5A.

       13.  FOROTS V6 does not  ignore  nulls  encountered  in  a  DECODE
            statement,  whereas V5A did.  Null is an illegal character in
            many of the conversion routines.
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 43


       14.  The action of the CLOSE statement has changed in  version  6,
            such  that specification of any file parameters (e.g.  FILE=)
            will cause a rename to be performed.  Version 5A only did the
            rename if it detected an actual change.

       15.  With version 6, recordsize is enforced for input files.   The
            actual  record size used is the record size specified, plus 2
            for the carriage return, line feed sequence, plus the padding
            necessary  to  bring the record to a word boundary.  Thus the
            formula is ((RECSIZ+6)/5)*5.  Records read using a RECORDSIZE
            specification  in the OPEN statement must have precisely this
            calculated number of characters.  FOROTS no longer stops upon
            reading  an  end-of-line  character,  nor  scans for them, in
            advancing  to  the  next  record.    However,   a   premature
            end-of-line  character  within  a  record  will terminate the
            characters read into the FOROTS internal record buffer.

       16.  CALL ERRSET (n) now tells FOROTS to print out n  warnings  of
            each  type.   ERRSET extensions...  CALL ERRSET(n,i) to set a
            limit for  a  specific  error,  CALL  ERRSET(n,i,x)  to  call
            subroutine  x  when  the  error  occurs,  after  FOROTS error
            actions have occurred.

       17.  Sequential files written with version 6 without a record size
            specified  are  not  padded  with  nulls  to a word boundary,
            whereas version 5A padded to a word boundary to be compatible
            with FORSE files.  This means that files written sequentially
            without a record size specified in the OPEN  statement  will,
            in general, not be readable as random-access files.

       18.  With Version 5A, BLOCKSIZE for  magtape  files  always  meant
            words,  and  the  default  was  128 words for TOPS-10 and 512
            words for TOPS-20.  With version 6, BLOCKSIZE  is  in  bytes,
            36-bit bytes for binary and image mode files, and 7-bit bytes
            for formatted (ASCII) files.  The default is still 128  words
            for  TOPS-10  (640  bytes  for  formatted files), but is 1000
            bytes for TOPS-20 (i.e., different blocksizes  for  formatted
            and unformatted files).

       19.  The definitions of X and T formats have changed from 66 to 77
            for  output  statements.   With  -77, T and X do not actually
            write blanks, they merely position the record pointer.   Only
            the  actual  data  sets  the  record  size, so that (A5,100X)
            writes a 5-character record whereas  (A5,100X,' ')  writes  a
            106 character record.

       20.  With list-directed and namelist I/O, logical  input  data  is
            strictly defined as an optional period, followed by a T or F,
            followed by any set of non-terminator characters.  There will
            no  longer  be  any diagnostic messages given for such trashy
            input.

       21.  The default field width for F (with no field width  supplied)
            for  output  is  dependent  on  the  type  of the variable in
            version 6, and expands for extremely  large  numbers,  rather
   FORTRA.DOC - FORTRAN-20 Version 7                              Page 44


            than  producing  asterisks.  In version 5A, the default field
            width was invariant for data type.

       22.  As an extension to the  ANSI  standard,  list-directed  input
            will  accept  any data type for any variable type, and do the
            kind of conversion done by the compiler.  This is  also  true
            for  data preceded with a repetition count (e.g.  2*5.6 input
            to a real variable and an integer variable will  provide  5.6
            to  the  real  variable  and 5 to the integer variable).  The
            exception is that if complex data is specified for  a  double
            precision  variable,  the  DOUBLE PRECISION value of the real
            part is transmitted to the  double  precision  variable  (the
            compiler  truncates  it  to a single precision value and sets
            the 2nd word of the double precision variable to 0).

       23.  With list-directed and NAMELIST I/O, certain  types  of  data
            with no delimiters are interpreted differently by versions 5A
            and  6.   For  instance,  with  version  5A,  -1-1  are  read
            differently  depending  on  whether  the target variables are
            integer or real:  it reads two values of minus 1 for integer,
            and  -1E-1 for real.  Version 6 always reads -1-1 as a single
            value (-1E-1) and converts it appropriately.

       24.  The ANSI standard specifies that random-access files have  no
            end.   Version  6  obeys  this  rule,  which is a change from
            version 5A.  Thus the END= branch will never  be  taken,  and
            should   not   be   used,  for  random-access  data  transfer
            statements.

       25.  For formatted data and  binary  unformatted  data,  the  ERR=
            branch will be taken for any unwritten record, whether in the
            middle or at the end of the file.  Since there is no  way  to
            know whether data has been written in an image mode file, the
            ERR= branch cannot be used for this purpose  for  image  mode
            files.

       26.  In version 6, dollar format is  defined  as  suppressing  the
            carriage  return  and  one  line  feed  (if  any)  that would
            normally appear if  the  next  data  transfer  were  a  WRITE
            statement,  or  the  automatic  <carriage return - line feed>
            sequence that would normally be inserted  by  FOROTS  if  the
            next data transfer were a READ statement.  Version 5A did not
            suppress the line feed for the succeeding WRITE.

       27.  There  is  no  support  in  version  6  for  KA10s   or   for
            F40-generated  code.   Also, support for the FOROTS version 1
            calling sequence has been removed.

   FORTRA.DOC - FORTRAN-20 Version 7                              Page 45


   6.0  INTERNAL CHANGES


   Both FOROTS and the  compiler  have  been  substantially  modified  to
   support  the new features that are in this release.  Complete revision
   histories are contained in REVHST.MAC (for the  compiler),  FORHST.MAC
   (for   FOROTS),  MTHHST.MAC  (for  the  math  library  routines),  and
   FORDDT.MAC (for FORDDT).

   [End of FORTRA.DOC]
    