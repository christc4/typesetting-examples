


              SED: A CRT EDITOR FOR TOPS-10 AND TOPS-20
            WRITTEN AND DOCUMENTED BY A Christopher Hall
                            February 1982

                    (Operating system:  TOPS-20)
                     (Terminal described: VT52)


                   HISTORICAL NOTE AND COMMERCIAL

     The first successful full-screen text editor was  developed  in
1967  at  the  Institute for Defense Analyses by Edgar T.  Irons and
Franz M.  Djorup for use on the CDC-6600 computer.  It was the first
editor to use function keys as editor commands.

     The Yale editor "E" was designed in 1970  by  Irons  and  Peter
Weiner  to  be  an  improvement  on  the  IDA editor, running on the
PDP-10.  It demonstrated  the  practicality  of  screen  editors  on
terminals of speeds as low as 2400 baud.

     The Rand editor "re" was conceived in  1974  by  Peter  Weiner,
based  on the Yale editor.  It was initially designed and written by
Walter Bilofsky, and modified by both  Weiner  and  Bilofsky  as  it
evolved.   The  Rand  editor is used on PDP-11 computers running the
UNIX operating system.  It is extremely powerful,  although  limited
to a small number of terminals.

     The author has worked with the Yale editor and the Rand  editor
for  the  past several years, and has made a number of modifications
and improvements to a version of the former.  The  editor  described
in this document was initially developed by the author in 1978 to be
a more tightly-written and better documented program than  the  Yale
editor,  but  it  has  evolved  into an entity in its own right.  It
incorporates useful features from both the Rand editor and the  Yale
editor  plus  several new ideas.  It runs on the PDP-10 under either
the TOPS-10 or TOPS-20 monitor (in native mode).

     The new editor, SED, has a number of features which distinguish
it  from its predecessors.  It is the first full-screen editor which
is easily adaptable to a wide range of terminals.  Also, it exploits
more  fully the capabilities of the terminal by letting the terminal
do the work whenever possible (and  it  knows  whether  or  not  the
terminal  is  equipped to do the job).  The editor has the usual set
of commands:  cursor movers,  display  window  movers,  inserts  and
deletes,  searches,  and line copiers;  all of which cause immediate
changes on the CRT screen when they are invoked.  In addition, there
are  a  number of shortcuts by which the sophisticated user can save
time and typing.

     SED is documented with  a  tutorial,  this  user's  manual,  an
installation   guide,  copious  comments  within  the  program,  and
software history files and suchlike for the serious hacker.



                         INTRODUCTION TO SED

     This document contains complete descriptions  of  all  the  SED
commands.   It  is  a  reference  manual,  good  for finding out the
details about things, but confusing as a learning tool.  If you  are
a  new  SED  user, the tutorial guide, DOC:SED.MAN would be a better
introduction to the editor.  But the  tutorial  will  only  get  you
started;   use  this reference manual when you feel comfortable with
the basic SED commands.

     Commands to SED are given  by  holding  down  the  key  labeled
'CNTR'  or  'CTRL'  and  typing a letter.  Also, some terminals have
special keys which are SED commands.  In this manual editor commands
are  notated  in  capital  letters  and  brackets.  For example, the
command used to advance 1 page (one screenful) in a file is given by
holding  the 'CONTROL' key and typing the letter 'Y';  it is notated
<ROLL-FORWARD-PAGES> or ^Y.  Think of the 'CONTROL' key as  a  shift
key.



                             RUNNING SED

     There are three ways of running the editor.  At  monitor  level
type

        @SED                    or
        @SED FILE.EXT           or
        @SED FILE.EXT=


     The first way will set up for editing the file  (and  alternate
file*) which were edited last time.  SED will return you to the same
position in the file that you were last.  If you are running SED for
the  first  time a cheery welcome message will appear.  You can then
use the <SET-FILE> command (described below) to get a file to edit.

     If you type the second form SED will put you at  the  beginning
of  FILE.EXT  (or whatever file you give).  The file you edited last
time will be the alternate file.  If  the  file  given  in  the  run
command does not exist SED will tell you so and give you last time's
file or the cheery message.

     If you use the third form SED will do as above, except that  if
the file does not exist the editor will create it.



--------------------

* SED allows you to toggle between any  two  files.   The  alternate
file  is  the  one  which  is  not  currently being edited.  See the
<SET-FILE> command.

                               - 1 -



                             THE CURSOR

     Run the editor and get the cheery message (don't  give  a  file
name).   There will be a blinking dash in the upper left-hand corner
of the screen;  that dash is called the cursor,  and  it  represents
your position in the file.

     You cannot do much with the cheery message, so why not create a
new file and play around with the editor?  Type the following:

             PAD-BLUE A B C D = ^B

one key after another (with no spaces in between).  The editor  will
create a file named ABCD containing the obvious message

        ; This file is ABCD.

Note that the cursor is still at the upper left of the screen.

     If you type a character it will appear where the cursor is  and
the cursor will move one space to the right.  The character you type
will replace the one at the cursor position.  If INSERT MODE  is  in
effect  (see  the  <INSERT-MODE>  command) the new character will be
inserted in the line, and the rest of the line moved one position to
the right.

     A carriage return will put the cursor at the start of the  next
line  on  the  screen, but will not affect the contents of the file.
There are other keys that simply move the cursor  around:   the  key
off to the right labeled HOME and the four arrow keys near it (which
move the  cursor  in  the  indicated  directions),  <TAB>  (^I)  and
<BACKTAB>  (^U).   There's  also  a  command (<LINE>) to move to the
beginning or the end of a line.  Linefeed is  NOT  merely  a  cursor
mover, however (see the section on <CLEAR-LINE> or <ERASE-LINE>).

     Type something.  If you make a mistake  use  the  <CURSOR-LEFT>
key  to  back up over the bad character, and type the correct one on
top of it.  If you put in  one  character  too  many,  position  the
cursor  to  it  and  type  <DELETE-SPACES>  (^S).   There is a whole
spectrum of commands for inserting and deleting characters and lines
of  text,  moving  around  within the file, and other useful things.
Read on.












                               - 2 -



                      FORMAT OF EDITOR COMMANDS

     SED does not exist by cursor movements alone.  There is a whole
raft of commands, which have the following form:

           <COMMAND>
     or    <ENTER><parameter><COMMAND>
     or    <ENTER><COMMAND>                (TOKEN FORMAT)
     or    <ENTER><cursor movement><COMMAND>


     The <ENTER> key  is  PAD-BLUE.   A  parameter  is  a  piece  of
information that is used by a command.  For instance, if you want to
insert blank lines in a file the parameter is the  number  of  lines
you  want  to  insert.  Most commands have default parameters;  that
is, if you simply issue the command without  specifying  parameters,
SED  will  use  a  pre-set value for each parameter.  <INSERT-LINES>
(^D) will insert 1 line until you tell it otherwise, which you do by
using the second form of command.  If you say

        <ENTER>5<INSERT-LINES>

SED will insert 5 lines.  From that point on whenever you say

        <INSERT-LINES>

SED will insert 5 lines, until you change it again.

     Certain pairs of commands share parameters.  If you say

        <ENTER>5<INSERT-LINES>

and later say

        <DELETE-LINES>

SED will delete  5  lines  because  it  shares  its  parameter  with
<INSERT-LINES> (<DELETE-LINES> = ^F).

     There  are  two  other  command  formats:   tokens  and  cursor
movement.   Both  are shortcuts for the advanced user, so if you are
just starting out don't worry about them for now.

     For the experienced or the curious,  tokens  work  as  follows:
the  format  <ENTER><COMMAND>  tells the editor either to look for a
"token" (see below) or to do something special, the nature of  which
is  dependent  on  the  command.  For example, <ENTER><PERCENT> will
move to the end of  the  file;   it's  a  shorthand  way  of  saying
<ENTER>100<PERCENT>.   Also, <ENTER><PUT> will insert text which has
previously been deleted into the  file;   it  is  the  only  way  of
recovering  that information.  The special functions of this command
format are described in detail with each command.


                               - 3 -



     A token can be thought of as "the word at the cursor position."
Actually  the  formal  definition  is:   the  string  of  characters
starting  at  the  cursor  location  and  extending  to  the   first
nonalphabetic,  nonnumeric  character.   Thus  the  location  of the
cursor is important, and it need not be at the start  of  an  actual
word.  Sometimes SED is interested in the token itself, for instance
for the search command;  sometimes it  is  only  interested  in  the
length of the token, like for <DELETE-SPACES>.

     Also, the token for the <SET-FILE> (^B) command  is  different.
When  doing  a <SET-FILE>, which sets up a new file for editing, the
parameter is expected to be a  filespec.   Since  filespecs  usually
consist  of  at  least a name and an extension, the usual token will
not work, since it will recognize only the file name  (and  stop  on
the  ".").   So  for  the  <SET-FILE>  command a token is defined as
extending from the cursor position to the next space, tab, comma, or
control  character.   All  other  characters  will  be  legal  token
characters.

     Tokens, of course, don't  give  you  anything  you  don't  have
already;   they  just  save  some  typing.   If  all  the  above  is
confusing, forget about it for now.

     The last command format is cursor movement.  With  this  format
you  type  <ENTER>,  move  the cursor around using any of the cursor
movement commands to get to a different row  and/or  column  on  the
terminal  screen.   Then  type  a  non-cursor movement command.  The
command will take as  its  parameters  the  difference  in  rows  or
columns  (or  both).  Often both changes are useful;  you can delete
three lines and the first 8 spaces of the next line by typing

        <ENTER><RETURN><RETURN><RETURN><TAB><DELETE-LINES>

Cursor movement is not meaningful with every command,  however,  and
an  error  message will result from using it at the wrong time.  But
usually it is used for what you think it ought to  be,  and  illegal
when you can't see any reason for doing it.

     Parameters can be edited:  an entire parameter can be  canceled
by  typing  <RESET>  (which  is  invoked  by  DELETE).   The  latest
character of the parameter can be deleted by typing <CURSOR-LEFT> or
<DELETE-CHARACTER>  (BKSP).  The latest word of the parameter can be
erased by <BACKTAB> (^U) or <ERASE-WORD> (KEYPAD-.), and  the  whole
parameter erased by <ERASE-LINE> (^J).










                               - 4 -



                       COMMANDS TO THE EDITOR

     This section describes all the commands to  SED,  telling  what
they  are, how they are (normally) invoked, what types of parameters
they accept, and any special attributes they have.

     Each entry in this section describes one  command,  or  two  if
they  are  related  and  share a parameter value.  The format of the
entries in this sections is:

COMMAND NAME(S)                 CONTROL CHAR(S) WHICH INVOKE

        STARTING NOMINAL
        TYPE OF PARAMETER EXPECTED
        CURSOR MOVEMENT DEFINED (NONE, CHANGE OF ROW, COLUMN, BOTH)
        TOKEN (NONE, TOKEN, OR SPECIAL)


DESCRIPTION OF THE ACTION TAKEN BY THE COMMAND

EXAMPLE: A LINE OR TWO BEFORE AND AFTER EDITING

































                               - 5 -



***************************************************************************
The  commands  on  this  page  and the next (through <LINE>) are the
cursor movement commands.  They have no effect on  the  file;   they
are  used  to  move the cursor around on the terminal screen.  These
commands can be used in a  parameter  to  define  a  region  of  the
screen, between where the cursor was when you typed <ENTER> to where
it was when you typed a non-cursor movement command.

***************************************************************************
<CURSOR-RIGHT> - <CURSOR-LEFT> - <CURSOR-UP> - <CURSOR-DOWN>


     Moves the cursor in the indicated  direction.   If  the  cursor
goes  off  the  edge of the screen it will wrap around and appear at
the other side.



***************************************************************************
<CURSOR-HOME>                                   PAD-BLK


     Moves the cursor to the upper left-hand corner of the screen.



***************************************************************************
<UP-TAB> - <DOWN-TAB>                           PAD-8 PAD-2


     Moves the cursor up or down six lines.   Exactly  the  same  as
typing six <CURSOR-UP> or <CURSOR-DOWN>s.



***************************************************************************
<CARRIAGE-RETURN>                               ^M


     Moves the cursor to the start of the  next  line  (ie,  does  a
CARRIAGE  RETURN,  LINEFEED).   If  the cursor started on the bottom
line of the screen the screen will roll up one line, a new line will
appear  at  the  bottom  of  the  screen,  and  the  cursor  will be
positioned at the start of it.

     In   INSERT    mode    (see    the    <INSERT-MODE>    command)
<CARRIAGE-RETURN>  will  actually  insert  a  <CRLF>  at  the cursor
location.

     Switches relevant to <CARRIAGE-RETURN>:  /ROLL and  /ICR.   See
the <SWITCH> command.



                               - 6 -



***************************************************************************
<TAB> - <BACKTAB>                               ^I ^U


     Moves  to  the  next  tab  stop  in  the  forward  or  backward
direction.  Tab stops are normally 8 spaces apart.

     Tabs can be set to be any constant distance  apart,  using  the
<SWITCH> command.  For example, to set tabs every 6 columns, type

        <ENTER>T:6<SWITCH>

     If the /NOTABS switch has been set (see the <SWITCH>  section),
then  <TAB>  and <BACKTAB> function in terms of words of text rather
than screen position.  The table below explains what happens:

CURSOR AT:           TAB MOVES TO:           BACKTAB MOVES TO:

within the line      start of next word      start of previous word
start of line        start of next word      end of previous line
last word of line    end of line             start of previous word
beyond end of line   next 8-space tab stop   start of last word of line

     If you want a TAB command which actually inserts a TAB into the
file you are editing, see <REAL-TAB>.



***************************************************************************
<BEGIN-LINE> - <END-LINE>                       PAD-4 PAD-6


     <BEGIN-LINE> moves the cursor to the beginning of the  line  it
is on.  <END-LINE> moves the cursor to the end of the line it is on.



***************************************************************************
<LINE>                                          (none)


     <LINE> does the functions of <BEGIN-LINE> and  <END-LINE>:   it
moves  the  cursor  to  the  beginning  or the end of the line.  The
cursor moves to the beginning of the line,  unless  it  was  already
there,  in  which case it moves to the end of the line.  Thus <LINE>
will usually move to the beginning, and  <LINE><LINE>  will  usually
move to the end.  It's not as hard to do as it is to describe.

     If <LINE> is  typed  within  a  parameter  it  acts  as  cursor
movement, moving to the beginning or the end of the line as above.




                               - 7 -



***************************************************************************
<ROLL-BACK-PAGES> - <ROLL-FORWARD-PAGES>        ^Q ^Y

        Starting nominal: 1 page
        Parameter: number (pages to roll)
        Cursor move: illegal
        Token: meaningless

     Advances or backs up the given number of  pages  (screens-full)
of  the  file.  Won't move before the start or beyond the end of the
file:  use <INSERT-LINES> to extend file, not one of the rolls.   Or
just type on the last line on the screen.









***************************************************************************
<ROLL-BACK-LINES> - <ROLL-FORWARD-LINES>        ^W ^T

        Starting nominal: 1/3 page
        Parameter: number (lines to roll)
        Cursor move: lines only; spaces ignored
        Token: causes scanning to begin

     Same as above, but movement is in terms of lines.

     Scanning is  started  by  typing  <ENTER><ROLL-BACK-LINES>  (or
<ENTER><ROLL-FORWARD-LINES>).   A roll will occur (using the current
nominal), the editor will delay for a short time, then it will  roll
again.   This  continues  until  the  start  or  end  of the file is
reached, or until you type any character.  When scanning  stops  the
cursor is left in the middle of the screen to indicate that scanning
is over.
















                               - 8 -



***************************************************************************
<PERCENT-GOTO>                                  ^P

        Starting nominal: 0 percent
        Parameter: number between 0 and 100 (percent distance into file)
        Cursor move: illegal
        Token: acts same as 100 percent

     Displays the file starting the given percent into  it.   Typing
<ENTER>50<PERCENT-GOTO>  will  display  the  file  starting  mid-way
through.  <ENTER>100<PERCENT-GOTO> (or  just  <ENTER><PERCENT-GOTO>)
will  display the last several lines of the file, with the cursor at
the end of the last line.

     <PERCENT-GOTO> is very much faster than a <ROLL> command, since
it  does  not  count lines of text.  It can also be used to speed up
searching, by <GOTO>ing a place near where you expect  a  match  and
then doing the search.





***************************************************************************
<SLIDE-LEFT> - <SLIDE-RIGHT>                    ^K ^L

        Starting nominal: 8 spaces
        Parameter: number (spaces to slide)
        Cursor move: spaces only; lines ignored
        Token: takes length of token

     Moves screen  window  left  or  right  within  the  file.   For
example,  after  a  nominal <SLIDE-RIGHT>, the first 8 characters of
each line will not appear on the screen (they will be off  the  left
of  the  window),  and  each  line  displayed  will  show  character
positions 9 through 88.

     The window can be slid right an unlimited amount, but it cannot
be  slid  left past the left margin.  The cursor will always stay on
the line it is on at the start of the slide;  if  the  character  it
pointed  to  is out of the window the cursor will point to the first
character on that line that is on the screen.












                               - 9 -



***************************************************************************
<INSERT-LINES> - <DELETE-LINES>               ^D ^F

        Starting nominal: 1 line
        Parameter: number (lines to insert/delete)
        Cursor move: lines; spaces counted from left margin
        Token: takes size of token, plus 1

     <INSERT-LINES> adds the given number of  lines  at  the  CURSOR
POSITION  (the  given  number  of spaces are also added, if they are
asked for by a cursor move.  Thus if the cursor is on line 5  column
8,  and  you type <ENTER><CURSOR-DOWN><INSERT-LINES>;  then one line
and 8 spaces will be added to the file.  The result will be to split
line  5,  moving  everything after the cursor one line down.  If, in
the same position, you type  <ENTER><CARRIAGE-RETURN><INSERT-LINES>;
then  one line (and no spaces) will be added, and the result will be
to split the line and put the stuff after the  cursor  on  the  next
line,  starting at the left margin.  That last command could also be
made by typing <ENTER>1<INSERT-LINES>.

     <DELETE-LINES>  removes  lines  (and   spaces,   using   cursor
movement) analogously.  The deleted material is not thrown away, but
is stored in the DELETE BUFFER.  It can  be  replaced  in  the  file
using  the  <PUT>  command.   So if you <DELETE-LINES> accidentally,
type <ENTER><PUT> to get the lines back.

     Deletes of any size are permitted.  However, if more than about
50 lines are deleted, the delete buffer will overflow and it will be
written out  on  disk.   Everything  will  work  normally,  although
perhaps  a  little  more slowly.  However, there will be a new file,
nnnCLS.TMP (where nnn is your job number)  sitting  around  in  your
area.

     Overflowing the delete buffer has its  advantages.   nnnCLS.TMP
is  just another file, and can be edited the same as any other file.
It will stay around until it is overwritten by another large delete.
Thus  suppose  you  do  a 100-line delete, then a 1-line delete, and
then realize that part of those  100  lines  should  not  have  been
deleted.  You cannot type <ENTER><PUT> to restore those lines, since
what you will get is the single latestly-deleted line.  But you  can
get  into the nnnCLS.TMP file (using the <SET-FILE> command), <PICK>
up the desired lines, return to your original file,  and  <PUT>  the
lines back in.

     Another use of the delete buffer is to split a  file  into  two
pieces  (as long as one piece is large enough to overflow the delete
buffer).  To create two files, one containing the  first  100  lines
and  the  other  the  remainder, go to the beginning of the file and
type <ENTER>100<DELETE-LINES>.  Then  exit  the  editor  and  rename
nnnCLS.TMP to whatever you want;  it contains the first 100 lines.




                              - 10 -



EXAMPLE: The cursor is on the word "and"; you type <ENTER>2<INSERT-LINES>

BEFORE: This is the thing of the gig
        and the gig is where it's at

AFTER:  This is the thing of the gig


        and the gig is where it's at

If you then do a <DELETE-LINES> the two blank lines will be removed.
Now say the cursor is on the "f" and you type <INSERT-LINES>:

BEFORE: Pack my box with five dozen liquor jugs.

AFTER:  Pack my box with

        five dozen liquor jugs.

Two blank lines have been inserted at the cursor position.

***************************************************************************
<DELETE-CHARACTER>                              BKSP

        No parameters

     Deletes the character to the  left  of  the  cursor.   If  that
character  is  a tab, <DELETE-CHARACTER> deletes the entire tab.  At
the beginning of a line <DELETE-CHARACTER> has no effect.

     If typed in a parameter, <DELETE-CHARACTER> will  still  delete
the   character   before   the   cursor.    Thus,  in  a  parameter,
<DELETE-CHARACTER> and <CURSOR-LEFT> have the same effect.

     Deleted stuff can be gotten back by typing <ENTER><HELP>.

***************************************************************************
<ERASE-WORD>                                    KEYPAD-.

        No parameters

     Deletes the word to the left of the  cursor.   <ERASE-WORD>  at
the beginning of a line deletes the last word on the previous line.

     A  word  is   a   string   of   alphanumerics   or   a   single
non-alphanumeric followed by zero or more spaces or tabs.

     <ERASE-WORD> deletes words in  parameters,  too.   Thus,  in  a
parameter, <ERASE-WORD> and <BACKTAB> have the same effect.

     Deleted stuff can be gotten back by typing <ENTER><HELP>.



                              - 11 -



***************************************************************************
<INSERT-SPACES> - <DELETE-SPACES>               ^A ^S

        Starting nominal: 1 space
        Parameter: number (spaces to insert/delete)
        Cursor move: spaces;
                     change in line causes rectangular insert/delete
        Token: uses size of token, plus 1

     Adds spaces (to add a string, see <PUT>) or deletes  characters
starting  at  the  cursor position.  The deleted stuff can be gotten
back by typing <ENTER><HELP>.

     EXAMPLE:  The cursor is at "t" of the word "thing";   you  type
<ENTER>4<INSERT-SPACES>:

BEFORE: This is the thing of the gig

AFTER:  This is the     thing of the gig

Then you move to the "o" of "of" and type <DELETE-SPACES>:

AFTER:  This is the     thing he gig

     A rectangular <INSERT-SPACES> works as follows:  say  you  type
<ENTER><DOWN><DOWN><RIGHT><RIGHT><INSERT-SPACES>.     Your    cursor
movement has defined a rectangle  whose  opposite  corners  are  the
starting  and  ending  cursor positions (in this case, three rows by
two columns).  That rectangle  will  be  filled  with  spaces.   For
example,  say  the  cursor  starts  at  the "o" of "of" and you type
<ENTER><DOWN><DOWN><RIGHT><RIGHT><INSERT-SPACES>.  The  cursor  ends
after the "f" of "five".

BEFORE: This is the thing of the gig,
        and the gig is where it's at.
        Pack my box with five dozen liquor jugs.
        Quick brown fox jumped over the lazy dog.

AFTER:  This is the thing   of the gig,
        and the gig is whe  re it's at.
        Pack my box with f  ive dozen liquor jugs.
        Quick brown fox jumped over the lazy dog.


     Rectangular <DELETE-SPACES> works in a similar  manner,  except
that  all  the  characters within the rectangle are removed from the
file.

     If you just move the cursor up  or  down,  with  no  change  in
column  position,  you will work with a rectangle whose width is the
same as last time (which is useful if you  can  remember  what  last
time's parameter was).


                              - 12 -



***************************************************************************
<SEARCH-FORWARD> - <SEARCH-BACK>                ^R ^E

        Starting nominal: none
        Parameter: string (search key)
        Cursor move: spaces (change of lines illegal)
        Token: uses token

     Searches for the given string, from the cursor position to  the
end of the file, or from the cursor position to the beginning of the
file.  When the key is found, a page from the file is displayed with
the  line containing the match one-third of the way down the screen.
If the match is on the page displayed at the start of the search the
cursor simply moves to the first character of the match.

     While the editor is searching the cursor  lives  at  the  upper
left of the screen, to show that it's still working.

     A search can be aborted at any time by typing RUBOUT.  This  is
useful,  for  example,  when your key was erroneously typed in lower
case and the file is  entirely  upper  case.   The  screen  will  be
restored to its pre-search status.

     CONTROL-?  and CONTROL-LEFT-ARROW are wild  search  characters;
they  will  match  any single character in their position.  Thus the
command

        <ENTER>THE^O?E<SEARCH-FORWARD>

(see the section on <ENTER-CONTROL-CHARACTER> to find out why  ^O  ?
sets  up  a  CONTROL-?)  will  match  on THESE, THERE, THEME, or THE
ERROR, among other things.

     A useful feature:  <ENTER>^OJGIG<SEARCH-FORWARD>  searches  for
the next line that begins with GIG.

HINT:  Searches will go faster if the first character of the key  is
uncommon.  Thus searching for "XECUTE" will be faster than searching
for "EXECUTE", and will accomplish the same thing.

     If the /CASE switch is set  searches  are  case-dependent;   if
/NOCASE they are case-independent (ie, "t" will match "t" or "T").

     You can use the <RECALL> command to get back  your  current  or
previous search key.  See the section on <RECALL>.









                              - 13 -



***************************************************************************
<SUBSTITUTE>                                    ESC-S

        Starting nominals: none
        Parameters: Sstring, Rstring, or number
        Cursor move: illegal
        Token: illegal

     <SUBSTITUTE> searches forward from the cursor  position  for  a
string  (the  key)  and  substitutes  another string (the substitute
string) for it.  You can tell <SUBSTITUTE> how many times to  repeat
the process.

     There are three types of parameters to <SUBSTITUTE>:

        <ENTER>Sstring1
        <ENTER>Rstring2
        <ENTER>number

     The first sets up string1 as the search key.  The  string  must
be  preceded  by  the letter "S" (or "s").  The search key is shared
with the <SEARCH-FORWARD> and <SEARCH-BACKWARD> commands.

     The second parameter sets up string2 as the entity  to  replace
occurrences  of  string1.  The string must be preceded by the letter
"R" (or "r").  String2 may be null, meaning  that  string1  will  be
deleted wherever it is found.

     The third parameter tells how many times to perform the  search
and substitute.

     Searching is done the same as for  the  <SEARCH>  commands,  so
wild  characters,  case  independence, and aborting the command with
RUBOUT all work.

     One, two, or all three of these  parameters  may  be  given  at
once, in any order.  The command

        <ENTER>SFOO<ENTER>Rfoo<ENTER>1000<SUBSTITUTE>

will change all occurrences of "FOO" to "foo" from the cursor to the
end of the file (well, 1000 times, anyway).

     Following the above command with

        <ENTER>SFUBAR<ENTER>1000<SUBSTITUTE>

will change all occurrences of "FUBAR"  to  "foo".   Note  that  the
substitute key was not given, so it defaulted to its latest setting.

     Sometimes it is useful to set up the  parameters,  think  about
them,  and  perform  the substitute when everything looks right.  If
the numeric parameter is omitted, them <SUBSTITUTE> will set up  the

                              - 14 -



key and substitute string, but will not execute.  Thus the commands

        <ENTER>SGIG<ENTER>RTHING<SUBSTITUTE>
        <ENTER>1<SUBSTITUTE>
        <SUBSTITUTE>
        <ENTER>10<ENTER>STHIS<SUBSTITUTE>
        <SUBSTITUTE>

works as follows:

1) Only sets up the parameters.
2) Does one <SUBSTITUTE> since there was a numeric parameter.
3) Also does one <SUBSTITUTE>.
4) Changes the search key to "THIS" and does 10 iterations.
5) Also does 10 iterations.

Note:  <SUBSTITUTE> is the only command for which multiple  <ENTER>s
are  legal.   For  other commands, all <ENTER>s except the first one
are ignored.



































                              - 15 -



***************************************************************************
<PICK>                                          ^V

        Starting nominal: 1 line
        Parameter: number of lines
        Cursor move: lines; spaces counted from left margin
        Token: uses token

     Copies lines and/or partial lines from the file into  the  pick
buffer.   The  file is not changed.  Words (instead of lines) can be
<PICK>ed using cursor movement or token picks.

     If a pick of more than 100 lines is done, the pick buffer  will
overflow and be written out on disk.  Everything will work normally,
though.  Picks of any size are permitted.  However, there will be  a
new file, nnnPIK.TMP, sitting around on disk.

     The same discussion about overflow of the delete buffer applies
to overflow of the pick buffer.

EXAMPLES:  Say the cursor is at the start of the first line of:

        Pack my box with five dozen liquor jugs.
        Quick brown fox jumped over the lazy dog.
        Now is the time for all good people to
        come to the aid of their party.

If you type <ENTER>2<PICK> you will load the pick buffer with

        Pack my box with five dozen liquor jugs.
        Quick brown fox jumped over the lazy dog.

There's a carriage return at the end of each line.   You  can  avoid
picking  the  last carriage return by using cursor movement:  typing
<ENTER><END-LINE><PICK> will load

        Pack my box with five dozen liquor jugs.

into the pick buffer, without the trailing carriage return.

     If  you  type <ENTER><RIGHT><RIGHT><RIGHT><RIGHT><RIGHT><RIGHT>
<PICK> (6 RIGHTs) you will load

        Pack m

And if you type  <ENTER><DOWN><RIGHT><RIGHT><RIGHT><PICK>  you  will
pick up

        Pack my box with five dozen liquor jugs.
        Qui




                              - 16 -



     Normally, <PICK>  clears  the  pick  buffer  each  time  before
writing it.  However, there is a switch, /APPND, which causes <PICK>
to  append  to   the   buffer.    It   works   as   follows:    Type
<ENTER>/APPND<SWITCH>  to  tell  SED  to  append to the pick buffer.
When you do your first <PICK> after setting the  /APPND  switch  the
pick  buffer  will  be cleared and the text put into it.  The second
<PICK> will be added at the end of the first, and so  on.   You  can
<PUT>  the buffer and then continue appending to it if you want.  To
stop appending type the /NOAPPND switch.  To clear  the  buffer  and
keep appending type the /APPND switch again.

EXAMPLE:  Suppose the text is (again):

        Pack my box with five dozen liquor jugs.
        Quick brown fox jumped over the lazy dog.
        Now is the time for all good people to
        come to the aid of their party.

If you type <ENTER>/AP<SWITCH> and then <PICK> the  4th  line,  then
the 3rd, 1st, and 2nd lines, then <PUT>, you get:

        come to the aid of their party.
        Now is the time for all good people to
        Pack my box with five dozen liquor jugs.
        Quick brown fox jumped over the lazy dog.

inserted into the file.  The lines are sorted, for reason unknown.

     Typing more <PICKS> will continue to append.  If you then  type
<ENTER>/AP<SWITCH> and do two <PICK>s, just the text from those last
two <PICK>s will be in the buffer.

     You can append any kind of <PICK> to the buffer;   full  lines,
partial  lines,  single  words,  or a <PICK> using a <MARK> will all
work.

     The /APPND and /NOAPPND switches do not affect the contents  of
the pick buffer directly;  they just tell the following <PICK>s what
to do.















                              - 17 -



***************************************************************************
<PUT>                                           ^G

        Starting nominal: none
        Parameter: string (read into pick buffer)
        Cursor move: spaces (change of lines illegal)
        Token: causes DELETE buffer to be PUT

     <PUT> writes text from either the pick  buffer  or  the  delete
buffer  into  the file, at the cursor location.  The contents of the
buffer is not changed.  The normal use of this command is to  <PICK>
something,  move  to  a  new location, and <PUT> it by simply typing
<PUT>.  Or <DELETE-LINES> something, move, and insert it  by  typing
<ENTER><PUT>.

     PUT is also used to insert a  string  directly  at  the  cursor
position.  The string is given as the parameter.  If you type

        <ENTER><string><PUT>

then <string> will be inserted at the cursor location.   The  string
will  also  be  stored  in  the  pick  buffer, so it can be inserted
somewhere else by simply typing <PUT>.

     EXAMPLE:  The cursor is at the "t" of the  word  "thing";   you
type  <ENTER><RIGHT><RIGHT><RIGHT><RIGHT><RIGHT><RIGHT><PICK>,  thus
loading "thing " into the pick buffer using  cursor  movement.   The
cursor is still at "thing".  Now type <PUT>:

BEFORE: This is the thing of the gig
        and the gig is where it's at

AFTER:  This is the thing thing of the gig
        and the gig is where it's at

Now do a <LINE> to get to  the  beginning  of  that  line  and  type
<DELETE-LINES> (with the starting nominal of 1 already set up):

AFTER:  and the gig is where it's at

The deleted line has been loaded into  the  delete  buffer.   Typing
<DOWN><ENTER><PUT> restores that line beneath the other one:

AFTER:  and the gig is where it's at
        This is the thing thing of the gig

Now  position  the  cursor  to  the  "w"   of   "where"   and   type
<ENTER>NOT<PUT>:

AFTER:  and the gig is NOT where it's at
        This is the thing thing of the gig



                              - 18 -



***************************************************************************
<MARK>                                          PAD-7

        No Parameters
        Token: cancels mark

     This command extends the  <PICK>  and  <DELETE-LINES>  commands
using  cursor  movement  to  work with arbitrarily large sections of
text.  When MARK is typed SED stores the  current  cursor  position.
You  can then move to any other part of the file and type <PICK> (or
<DELETE-LINES>), and all the text between the mark  and  the  ending
cursor  position  will be picked up (or deleted).  It doesn't matter
whether the ending cursor position is before or after the mark.

     Thus the <MARK> command temporarily changes  the  effect  of  a
<PICK>  or  <DELETE-LINES>  without a parameter.  When the <PICK> or
<DELETE> has been done, the mark is  forgotten  and  those  commands
perform normally again.

     Typing <ENTER><MARK> will  cancel  the  mark  and  restore  the
screen  to  the way it was when you typed <MARK> (so <MARK> can also
be used as a place-holder:  <MARK>, move around (but don't  <PICK>),
then <ENTER><MARK> to return to the marked position).

     The mark is also forgotten if you type any command which alters
the  file  (including  typing  a  character).   Every  other command
retains the mark.  You can get to the ending position  any  way  you
want:  <ROLLS>, <PERCENT-GOTO>, and <SEARCHES> are probably the most
useful ways.

     Say the nominal number of lines to pick is 1.  If you type:

        <MARK>
        <ENTER>10<ROLL-FORWARD-PAGES>
        <PICK>

then 10  screens-full  (say  around  240  lines)  of  text  will  be
<PICK>ed.   Those  lines  can  be PUT in the normal way.  If you now
type another <PICK> you will pick up 1 line.















                              - 19 -



***************************************************************************
<INSERT-MODE>                                   PAD-ENT

        No Parameters

     This command toggles the editor between normal type-in mode and
insert  mode.   In normal mode when you type a character it replaces
the one at the cursor position.  In insert mode the new character is
placed  before  the  one  at  the cursor and the rest of the line is
moved one position to the right.

     If the editor is in normal mode, typing <INSERT-MODE> will  put
it  in  insert  mode.  Then typing <INSERT-MODE> will put the editor
back in normal mode.

     If you type the wrong character you can  delete  it  using  the
<DELETE-CHARACTER> command (see below).

     Character strings can also be inserted in the  file  using  the
PUT command, by typing <ENTER>string<PUT>.

     Switches relevant to <INSERT-MODE>:  /BEEP, /ICR,  and  /IMODE.
See the <SWITCH> command.




***************************************************************************
<SAVE-FILE>                                     (none)

        No parameters

     Saves the current file without exiting.

     BEWARE:  <SAVE-FILE> is designed to work quickly,  so  it  does
not   eliminate   nulls  or  trailing  spaces  from  the  file.   So
<SAVE-FILE><ABORT> is not the same as <EXIT>.  If you  have  changed
the file be sure to end the session with an <EXIT>.
















                              - 20 -



***************************************************************************
<SET-FILE>                                      ^B

        Starting nominal: none
        Parameter: string (filespecs)
        Cursor move: spaces (change of lines illegal)
        Token: uses filespec token

     Looks up and displays the given file.  Saves previous  file  on
disk.   Saves  position in previous file.  If new file is not found,
returns to the previous file.  A backup file is  made  if  /BACK  is
set, else not.

     The   filespec   parameter    is    in    the    usual    form:
DEV:<DIR>FILE.EXT.   DEV:   can  be a real or defined device.  <DIR>
defaults to your connected directory.  If EXT is  missing  SED  will
try  some extensions until one succeeds:  none, the extension of the
previous file, MAC, TXT, RNO, FOR, CBL, DAT.

     All of the switches described for the <SWITCH> command  can  be
given  along with the file specs (for example, DSKD:FOO.BAR/NOTABS).
Particulatly relevant are /AGAIN:, /GOTO:, and /RCUR.

     <SET-FILE> with no parameter will return to the previous  file,
to  the  same  page  and  cursor  position  as was last set up.  The
current file will then become the new previous file.  Thus  you  can
toggle  back  and  forth  between  two files, after setting them up,
simply by typing <SET-FILE>s.

     To create a file, end the filespec parameter with an  "=".   If
the  file  exists  it will be looked up as usual, but if it does not
exist a file with a clever message will be materialized and  set  up
for editing.  SED will not overwrite an existing file.

     Exception:  if you <SET-FILE> to your current file (so you  can
look  at two different places in the same file), the editor will not
save the file.  This is so the change  of  file  pointers  can  take
place  as  quickly  as  possible.   The  file will be saved when you
<SET-FILE> to a different file or <EXIT> the editor.

     The file is only saved on a <SET-FILE> or an <EXIT>;  otherwise
changes  are made only to the in-core image of the file.  During the
save all nulls  are  removed  from  the  file  (they  are  added  in
abundance during editing), and trailing spaces are removed from each
line.

     To abort the editor and forget all  changes,  use  the  <ABORT>
command.  The file will be the way it was before you edited it.

     Appendix B tells how to move back and forth through a  list  of
files.



                              - 21 -



***************************************************************************
<EXIT> - <ABORT>                                ^Z ^C

        Parameters or token causes Exit and Go (EXIT only)

     Saves the current file and exits to the monitor.

     The editor writes the file nnnSED.TMP (where nnn  is  your  job
number)  containing  the  names  and  status  of  the last two files
edited.  The next time you run the editor the latest of these  files
will  be  automatically set up, with display and cursor position the
same as they were upon exit.

     If any parameter is typed (or a token, ie, just  <ENTER><EXIT>)
the  editor  will exit as above and run COMPIL.  COMPIL will execute
the last compile-class command.

     Unless told otherwise (see the  <SWITCH>  command)  the  editor
creates  a backup file, with extension .BAK, containing the file the
way it was before editing.

     <ABORT> does not save the file - the file is as it  was  before
the editing session.

     The editor can be re-entered after a mistaken <EXIT> or <ABORT>
by typing REENTER.


***************************************************************************
<RESET>                                         DELETE

        Starting nominal: none
        Parameter: ^ (up arrow) is the only meaningful parameter
        Cursor move: undefined
        Token: causes rewrite of single line

     This command is used to cancel an entered parameter, reset  the
cursor  position, rewrite a single line, or re-do the entire screen.
It is useful if you don't trust what you see.  If  you  ever  get  a
"Timesharing  ends"  message while you're editing, you'll appreciate
being able to <RESET>.

     Also, it's useful to be able to cancel a parameter  you  really
don't want.

To:                                     Type:

  Cancel a parameter                     <RESET>
  Re-position the cursor                 <RESET>
  Rewrite the line the cursor is on      <ENTER><RESET>
  Re-do the entire screen                <ENTER>^<RESET>



                              - 22 -



***************************************************************************
<REWRITE>                                       PAD-5

        No parameters

     Rewrites the entire terminal screen without changing  anything.
<REWRITE>  does the same thing as <ENTER>^<RESET>, above.  <REWRITE>
is commonly used to repair a screen which has been messed  up  by  a
system message or something.



***************************************************************************
<ENTER-CONTROL-CHARACTER>                       ^O

        No parameters

     Causes the next character typed to be a  control  character  (a
character, now, not a command).  Has no effect on commands.  Thus if
you type in your file

                ABC<ENTER-C-C>D

the characters A, B, C, and CONTROL-D will be placed in the file.

     <ENTER-C-C> also works within parameters, so

        <ENTER>ABC<ENTER-C-C>D<PUT>

will put A, B, C, CONTROL-D into the file.

     Note:  this command is the way to get a TAB or a FORMFEED (page
mark)  into a file.  For a TAB type <ENTER-C-C>I, and for a formfeed
type <ENTER-C-C>L.



***************************************************************************
<REAL-TAB>                                      PAD-0

        No Parameters

     The    <REAL-TAB>    command    is    identical    to    typing
<ENTER-CONTROL-CHARACTER>I.  It replaces the character at the cursor
with a tab character (or inserts it, if  the  editor  is  in  insert
mode).  <REAL-TAB> also can be used to put a tab in a parameter.

     See also the <TAB> command, which just moves the cursor  around
but does not change the file you are editing.





                              - 23 -



***************************************************************************
<ERASE-LINE>                                    ^J

        No Parameters
        If typed in a parameter, erases entire parameter

     The <ERASE-LINE> command deletes all characters from the cursor
position to the end of the line.  It is also used to erase an entire
parameter.

     Deleted stuff can be gotten back by typing <ENTER><HELP>.

EXAMPLES: The cursor is on the "h" of "the" and you type <ERASE-LINE>:

BEFORE: This is the thing of the gig
        and the gig is where it's at

AFTER:  This is t
        and the gig is where it's at

You type <ENTER>THING and wanted to  type  <ENTER>12.   <ERASE-LINE>
will erase the parameter "THING" and let you start again:

BEFORE: >THING
AFTER:  >


***************************************************************************
<CLEAR-LINE>                                    (none)

        No Parameters

     Clears out the entire line which the cursor  moves  onto.   The
contents  of  the line is not saved.  <CLEAR-LINE> won't work if the
cursor starts on the last line of the screen.  This is  a  dangerous
command,  but  useful  for cleaning out a lot of garbage and leaving
blank lines behind.

     Note:  <CLEAR-LINE> is almost the same as <ERASE-LINE> but  not
as useful.  It is included for compatibility, but is obsolete.

EXAMPLE: The cursor is on the word "thing"; you type <CLEAR-LINE>

BEFORE: This is the thing of the gig
        and the gig is where its at
        This is another thing of the gig

AFTER:  This is the thing of the gig

        This is another thing of the gig

Now the cursor is where the "is" used to be on the second line.


                              - 24 -



***************************************************************************
<SWITCH>                                        ^N

        Starting nominal: none
        Parameter: string (switch name or names)
        Cursor move: undefined
        Token: query of nominal parameter settings
        No Parameter: query of position and file status

     This command is used to tailor the operation of the  editor  to
the user and to get status information.  The default setting of each
switch is denoted as on (+) or off (-) where it is  meaningful.   To
turn  a  switch off type "NONAME" ("NOCASE", "NOUPPER", etc.) as the
parameter.  You only have to type enough of the switch name to  make
it unique ("T" is good enough for TABS).

     You can set more than one switch in one command  by  separating
them with slashes, for example <ENTER>TABS:6/CASE/BACK<SWITCH>.

-APPND  causes <PICK>s to append to the PICK buffer,  not  overwrite
        it,  until  /NOAPPND  or  another  /APPND is typed.  See the
        <PICK> command.

+BACKUP causes a backup file to be made on exit.  The file  has  the
        extension .BAK.  /NOBACKUP causes no backup file to be made.

-BEEP   causes the terminal to beep once when entering  INSERT  mode
        and  twice when entering replace mode, instead of displaying
        a message on the screen.

+CASE   make searches case-dependent, ie, the key "THE" is different
        from  the  key  "the".   The  opposite switch, /NOCASE, will
        cause the key "THE" to match the first occurrence of  "THE",
        "the", "tHe", &c.

-DTABS  causes tabs to identify themselves.  With /DTABS  set,  each
        tab  displays  as  a  highlighted  "I" followed by one fewer
        space than usual.  Thus the columns on the screen are  still
        aligned properly.

+HELP   Enables on-line help when <ENTER><ENTER> is typed.

+ICR    Causes a carriage return typed in insert mode  to  insert  a
        carriage return.  /NOICR just positions the cursor.

+INVRT  tells the <CASE> command to  invert  case.   /NOINVRT  tells
        <CASE> to use the setting of the /RAISE switch.

-ISAVE:n Causes an incremental save of your file every  n  commands.
        Default is n=0 (ie, no incremental saves) (#).




                              - 25 -



+ITABS   If you type something beyond the end of  a  line  SED  will
        insert  spaces  so the character is properly positioned.  If
        /ITABS is set SED will try to use as many tabs  as  possible
        instead of spaces.  /NOITABS causes SED to use only spaces.

-JOURN  Starts  a  journal.   See  Appendix D  for  information   on
        journaling.

 LENG:n causes SED to think your terminal is n lines long.  Good for
        limiting  the  amount  of  information  written  on  a  slow
        terminal.

+LINEFD enables the <LINEFEED> command, as distinct from the  cursor
        down command.  If this switch is off <LINEFEED> will perform
        a cursor down.

 LMAR:n Sets the left margin to be column n.   Default  is  1.   See
        Appendix C to find out about margins.

-PAGE   causes <SWITCH> to output your position as PAGE-LINE, rather
        than  LINES  from  start  of  file.   Pages are delimited by
        formfeeds (^L).

 PROG:FILE sets up the name of the program to be run when  you  type
        <ENTER><EXIT>.   The  default  is  the  latest compile-class
        command.  The switch /PROG:SYS:RUNOFF.EXE will cause  RUNOFF
        to be run instead.

+RAISE  is used by the <CASE> command if /NOINVRT  is  set.   /RAISE
        tells  <CASE> to change lower case to upper.  /NORAISE tells
        <CASE> to change upper case to lower.

-READ   makes the file read-only.  /READ is the opposite of /WRITE.

-RESET  causes the starting nominal parameters  to  be  reset  after
        each  command.  When set, <ENTER>5<INSERT-LINE><INSERT-LINE>
        will insert 6 lines.  Under  /NORESET  those  commands  will
        insert 10 lines.

 RMAR:n Sets the right margin to be column n.  Default is the  width
        of the screen.  See Appendix C to find out about margins.

+ROLL   causes the screen to roll one line if the cursor is  at  the
        bottom  of  the  screen  and  you type <CARRIAGE-RETURN.> If
        /NOROLL is set, the cursor will  move  to  the  top  of  the
        screen and there is no roll.

-SAVE:n  Causes an incremental save of your file every n  characters
        of typein.  Default is n=0 (ie, no incremental saves) (#).

-SHOW   causes <EXECUTE> to  display  as  it  is  working.   /NOSHOW
        updates the screen only when the <EXECUTE> is done.


                              - 26 -



-STRIP  causes EDIT line numbers to be stripped from the  file  when
        it is read in.  /NOSTRIP just marks the file read-only.

 TABS   makes <TAB> and  <BACKTAB>  use  the  usual  tab  positions.
        /NOTABS sets up word-wise TABS.  See the TAB/BACKTAB section
        (*).

-UPPER  causes all alphabetic characters to be  converted  to  upper
        case.   Useful  for  a  terminal whose shift lock shifts all
        characters.

 WIDTH:n causes SED to think the  terminal  is  n  characters  wide.
        Good  for  terminals which can change their widths, like the
        VT100.

+WRITE  allows the current file  to  be  altered.   If  turned  off,
        commands  which  change the file become illegal, so the file
        cannot be modified accidentally.

(#) /ISAVE and /SAVE should be used together.  When  either  becomes
zero the file is saved and both counters are reset.

(*) You can also type TABS:n to set up tab stops every n  positions.
Default is TABS:8.

     There are three other places you can use  these  switches:   as
part  of  the  monitor-level RUN command, in the <SET-FILE> command,
and in your SED.INIT file.  You can do things like

        @SED FILE.EXT/NOCASE/TABS:5
or
        <ENTER>FILE.EXT/GOTO:50<SET-FILE>

and if your SED.INIT contained the line

        /NOC/UP

SED will set switches for searching  independent  of  case  and  for
upper case characters each time it is run.

     There are a couple of switches which are not meaningful in  the
<SWITCH> command but can be used with the other three methods:

 AGAIN  used in a <SET-FILE> command.  If you are editing  FILE.FOO,
        typing   <ENTER>/AG<SET-FILE>   acts  the  same  as  if  the
        parameter were "FILE.FOO".  Also, /AG:nn acts  the  same  as
        /AG/G:nn  -  the numeric argument is a percentage of the way
        into the file.  Do not use explicit filespecs with /AGAIN.

 ALT    used when running SED.   Swaps  the  current  and  alternate
        files  you  were  editing  last time.  Also, /AL:nn acts the
        same as /AL/G:nn.


                              - 27 -



 GOTO:PERC used when running SED or doing a  <SET-FILE>.   The  file
        will  be displayed starting PERC percent of the way through.
        If /GOTO, no argument, is used  SED  will  use  the  current
        percent value.

-IMODE  puts SED in insert mode.  /NOIMODE puts it in replace  mode.
        This switch can also be used in execute buffers ($IM^SW).

-QUICK  causes the file not to display after the  <SET-FILE>.   This
        is  useful on a slow terminal when you are not interested in
        what is on the first page of display.

 RCUR   used with <SET-FILE>;  causes the current filespecs,  rather
        than  the alternate specs, to be replaced by the given ones.
        Useful for "keeping your finger" in one file (the alternate)
        while looking at several others.

 RECOV  typing SED/REC at monitor level tells  SED  to  recover  the
        previous  session  using  the  journal.   See Appendix D for
        information on journaling.

 X:NAME:txt  used in SED.INIT to set up an execute buffer named NAME
        with contents txt.  See the <EXECUTE> command for details.


     There are two other functions of the <SWITCH> command:  to  get
information  about  the  file  you  are  editing and to find out the
settings of the nominal parameter values.  You  get  the  former  by
typing just <SWITCH>, the latter by typing <ENTER><SWITCH>.

     The file information consists of the  current  file  name,  the
line  and position the cursor is on (that's the line and position in
the file, not the row and column on the screen), the percent through
the  file,  the name of the alternate file (if any), and the current
search key (if any).  For example,

FILE: SED.RNO  LINE: 534(67%) POS: 1 ALT: <CHALL>FOO.BAR

says that the current file is SED.RNO, the cursor is at the start of
the  534th  line,  which  is 67% through the file, and the alternate
file is FOO.BAR.

     To find out how many lines lie between a  given  line  and  the
beginning  of  the file, position the cursor to the desired line and
type <SWITCH>.  This function may not occur immediately,  since  the
editor  has  to go back to the beginning of the file and count every
line.

     Typing <ENTER><SWITCH>  will  give  you  the  settings  of  the
nominal  parameter  values.  The bottom line of the screen will look
something like:



                              - 28 -



RL:8, RP:1, PC:2, SL:8, IL:1, IS:3, PK:3,8, TB:8; KEY:th SUB:FOO

     This somewhat cryptic message  tells  you  that  the  following
values are set:

        LINES TO ROLL:         8
        PAGES TO ROLL:         1
        PERCENT-GOTO:          2
        SLIDE:                 8
        INSERT/DELETE LINES:   1 LINE AND 0 SPACES
        INSERT/DELETE SPACES:  3
        PICK:                  3 LINES AND 8 SPACES
        TAB SIZE:              8
        SEARCH KEY:            th
        SUBSTITUTE STRING:     FOO

     So if you type a <PERCENT-GOTO> command with no  parameter  you
will  go  to  the 2% point, a <DELETE-LINES> will delete 1 line (and
<INSERT-LINES> will insert 1 line), and a PICK will pick up 3 lines.

     Remember that you can use cursor movement to  tell  <PICK>  and
<INSERT/DELETE-LINES>  to  work  with  both  a number of lines and a
number of spaces;  thus they have two nominal values above.

     Tab size is not really a parameter but  is  controlled  by  the
/TABS  switch.   If word-wise tabs are in effect the tab size in the
above list will show up as the number "W".




***************************************************************************
<PUSH>                                          ^\

        No parameters

     Creates an inferior fork and runs the EXEC.  Popping  from  the
EXEC continues the editing session where it left off.
















                              - 29 -



***************************************************************************
<RECALL>                                        PAD-RED

        Starting nominal: none
        Parameter: type of thing to recall
        Cursor move: ignored
        Token: ignored

     Simulates an <ENTER> with the  latest  parameter  typed.   When
<RECALL>  is typed the latest parameter appears at the bottom of the
screen and the editor is placed in <ENTER> mode.  You can add to  or
delete  from the parameter and then pass that parameter to a command
by typing that command.

     The <RECALL> command is useful in three  instances:   when  you
have  typed  the wrong parameter to a command and want to correct it
with a minimum of typing, when you have given the right parameter to
the   wrong   command   (in   which   case   you   can   just   type
<RECALL><RIGHT-COMMAND>), and when you just want  to  see  what  the
latest parameter was.

     <RECALL> uses the first character of its  parameter  to  recall
some  specific  information.   Type <ENTER><char><RECALL> to get the
following:

        char    THING RECALLED

         F      Current Filespecs
         A      Alternate Filespecs
         S      Current Search Key
         O      Previous (Old) Search Key
         R      Substitute String

After you recall one of these things you can use it as if you  typed
it  in:   you  can  edit  it  and  fire  it off to any command.  For
example, <ENTER>F<RECALL><PUT> will put the current  filespecs  into
the file.

***************************************************************************
<HELP>                                          PAD-3

        No explicit parameters
        Token: Recovers from a delete command

     Asks for on-line help.  When <HELP> is typed SED asks  for  the
command to give help for and waits for you to type any command.  SED
then tells you something about the command  and  asks  for  another.
Typing  "G" or "g" instead of a command will return you to the file.
Try it.

     Typing <ENTER><HELP> will put back  the  text  deleted  by  the
latest    <DELETE-CHARACTER>,   <ERASE-WORD>,   <DELETE-SPACES>   or
<ERASE-LINE> command.

                              - 30 -



***************************************************************************
<CASE>                                          PAD-9

        Starting nominal: 1 character
        Parameter: number of characters
        Cursor move: characters and/or lines
        Token: uses token

     The <CASE> command changes the case  of  the  letters  starting
where the cursor is.  Two switches control way <CASE> works:  /INVRT
and /RAISE.  If /INVRT is set (default) then the  case  of  all  the
letters is inverted:  upper is changed to lower and lower to upper.

     If /NOINVRT is set then the setting of /RAISE is  used.   Lower
case  letters  will be changed to upper case if the /RAISE switch is
set;  if /NORAISE, upper case letters will be changed to lower case.

     Cursor movement can be used to make  <CASE>  work  across  more
than one line.

EXAMPLE: The cursor is at the start of "BOX" and you type
         <ENTER><RIGHT><RIGHT><RIGHT><CASE>:

BEFORE: PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS.
        QUICK BROWN FOX JUMPED OVER THE LAZY DOG.

AFTER:  PACK MY box WITH FIVE DOZEN LIQUOR JUGS.
        QUICK BROWN FOX JUMPED OVER THE LAZY DOG.

You then type <ENTER><RETURN><CASE>:

AFTER:  PACK MY box with five dozen liquor jugs.
        QUICK BROWN FOX JUMPED OVER THE LAZY DOG.


***************************************************************************
<WINDOW>                                        PAD-1

        No Parameters

     The <WINDOW> command allows two files to appear on the terminal
screen  at the same time.  The files each occupy half of the screen,
one on top of the other.

     Type <WINDOW> to divide the screen.  The file you are currently
editing  will  be  displayed  in  the  top window.  If you then do a
SET-FILE, the new file will appear in the  bottom  window.   Another
SET-FILE will get you back to the top window, and so on.

     To get back to normal, non-windowing operations, type  <WINDOW>
again.  The split screen will go away and the file you are currently
editing will occupy the entire screen.


                              - 31 -



***************************************************************************
<EXECUTE>                                       ^X

        Starting nominal: 0
        Parameter: number (iterations)
        No Parameter: closes execute buffer, if open
                      does nominal iterations, if buffer closed
        Cursor move: spaces (change of lines illegal)
        Token: opens execute buffer

     This command allows you to store a sequence of  commands  in  a
command  buffer,  and  later  execute that sequence as many times as
desired.  EDIT-like things like changing all occurrences of  XYZ  to
ABCD can be handled with this command;  but it is more powerful than
that:  ANY sequence of commands can be set up to be executed.  It is
easy  to do things like removing the first 16 spaces from every line
of the file, or causing each occurrence of JU&$ to be at  the  start
of a new line.

     <EXECUTE> is a complicated command.  This section explains  the
basics  of  how  to use one <EXECUTE> buffer.  The next two sections
deal with advanced <EXECUTE> features.

     The procedure for using the <EXECUTE> command  is  as  follows:
first  open the execute buffer by typing <ENTER><EXECUTE>.  From now
until the buffer is closed everything that you type  will  have  its
effect  on the file and the screen, and also be saved in the execute
buffer.  Do one iteration of the sequence.  Close the execute buffer
by typing only <EXECUTE>.

     When you want to execute that command sequence, figure out  how
many times you want to do it (a large number, if you want as many as
possible;  it will stop on an error like "Search failure").  For  10
iterations type

        <ENTER>10<EXECUTE>

The command sequence in the execute buffer will be issued 10  times,
just  as  if  you  had  typed the commands yourself.  Except for one
thing:  the display screen will not  change  until  the  execute  is
done.   This  saves  time.  However, every 8 times the entire buffer
has been executed, the terminal will beep so  you  can  tell  it  is
still working.  So there should be 2 beeps from the command above.

     When the execute is done the screen  will  be  re-displayed  to
show what it looks like after the last iteration.

     An <EXECUTE> can  be  aborted  early  by  typing  RUBOUT.   The
command  will  stop immediately and return control to you.  The file
will have been changed by the commands which have been issued before
you aborted the <EXECUTE>.



                              - 32 -



     Some helpful suggestions:  set up your nominals before you open
the command buffer.  For example, you might type

        <ENTER><EXECUTE>
        <ENTER>XYZ<SEARCH-FORWARD>
        ABC
        <EXECUTE>

which will set up to change XYZ's to ABC's.  Instead type

        <ENTER>XYZ<SEARCH-FORWARD>
        <CURSOR-UP>
        <ENTER><EXECUTE>
        <SEARCH-FORWARD>
        ABC
        <EXECUTE>

This does the same thing, although it requires more typing.  But the
benefit  is  that  the work of setting up the search key is not done
every time the command is iterated.   The  time  savings  from  this
gambit  can  be  enormous  for  a  complicated  sequence or a lot of
iterations (and you'll be just twiddling your thumbs  and  listening
to  beeps while all this happens).  There is another advantage:  the
nominals can be  changed,  resulting  in  a  similar  but  different
command  sequence  at  minimum setup cost.  For example, suppose the
lower sequence above had been typed.  Now change all XYZ's to ABC's:

        <ENTER>0<PERCENT>
        <ENTER>10000<EXECUTE>

Fine.  But it so happens that all xyz's want to be changed to ABC's,
too.  Just type:

        <PERCENT>
        <ENTER>xyz<SEARCH-FORWARD>
        <CURSOR-UP>
        <EXECUTE>

     This will search for  all  occurrences  (or  the  first  10000,
whichever  comes  first) of xyz and change them to ABC.  It iterates
10000 times because that is the  nominal  set  up  by  the  previous
<EXECUTE>.   The  <CURSOR-UP> is so the first match will be found by
the first iteration;  if the cursor were pointing at it, it would be
skipped.

     Note:  if xyz were wanted to be  changed  to  abc  (instead  of
ABC),  you would need to reload the execute buffer, since the ABC is
not a command nominal.  For  the  record,  an  absolutely  arbitrary
"change  all  occurrences of ??  to ??" command can be set up by the
following:




                              - 33 -



        <ENTER><STRING><SEARCH-FORWARD>
        <ENTER><length of above string><DELETE-SPACES>
        <ENTER><STRING1><PUT>

        <ENTER><EXECUTE>
        <SEARCH-FORWARD>
        <DELETE-SPACES>
        <PUT>
        <EXECUTE>


     This sets up <EXECUTE> to change all occurrences of  STRING  to
STRING1 (except the first two, which you have done yourself by hand.
The first sets up the command parameters and the  second  saves  the
commands  in  the  execute  buffer).   To  change  all  STRING2's to
STRING3's, type

        <ENTER><STRING2><SEARCH-FORWARD>
        <ENTER><length of above string><DELETE-SPACES>
        <ENTER><STRING3><PUT>

and then execute;  the rest has already been set up.

     Another use of the <EXECUTE> command is to do something to  the
same part of every line in the file.  For example, suppose you had a
batch output file and you wanted to pretty it up by removing all the
time  tags  -  the  first  16 characters of every line.  Move to the
start of the first line of the file and type

        <ENTER>16<DELETE-SPACES>
        <ENTER>1<ROLL-FORWARD-LINES>

That sets up the nominal parameter values.   Now  load  the  execute
buffer:

        <ENTER><EXECUTE>
        <DELETE-SPACES>
        <CURSOR-DOWN>
        <ROLL-FORWARD-LINES>
        <EXECUTE>

Then execute the sequence  by  typing  <ENTER>10000<EXECUTE>.   Note
that  the  <ROLL>  is necessary because without it, when the execute
got to last line on the screen the <DOWN> would position the  cursor
back  at the first line on the screen.  Note also that the <DOWN> is
not really needed for this particular sequence since the <ROLL> will
kick  the  cursor down a line (since the cursor is at the top of the
screen).  But if you were working with lines in the  middle  of  the
screen,  or deleting characters from the middle of a line, you would
want the <CURSOR-DOWN>.




                              - 34 -



                  MORE INFORMATION ABOUT <EXECUTE>

Sections:
        SETTING UP A BUFFER
        WRITING A BUFFER
        TWO WAYS OF READING THE CONTENTS OF A BUFFER
        FINDING OUT WHAT THE NAMES OF THE BUFFERS ARE
        KILLING A BUFFER
        SETTING UP EXECUTE BUFFERS IN SED.INIT
        EXAMPLES OF EXECUTE SEQUENCES

     There are a number of  execute  buffers  (normally  32),  so  a
variety  of  different command sequences can be set up and iterated.
Each buffer can be given a name up to five characters  long.   Names
can be defined or deleted as desired.  Buffers can be written either
by opening them and allowing commands to be stored, as described  in
the  previous  section,  or  directly  using the WRITE-BUFFER format
described below.  One buffer has a default  name:   null  (it's  the
buffer that was described in the basic <EXECUTE> section above).

     There are also conditional execute commands (such as IF and  DO
WHILE),  and  a way to connect an execute buffer to a command key or
sequence, so that pressing the key  will  execute  the  buffer  once
(thus   creating  your  own  meta-command).   Also,  execute  buffer
definitions can be stored in a disk file and read  in  when  needed.
All these things will be taken up in the next section.

     The <EXECUTE> command can be in one of the following formats:

        <ENTER>S<name><EXECUTE>     set up buffer with given name
        <ENTER>W<sequence><EXECUTE> write sequence into active buffer
        <ENTER>R<name><EXECUTE>     read name & contents of buffer
        <ENTER>R<EXECUTE>           read active buffer
        <ENTER>L<name><EXECUTE>     list contents of buffer
        <ENTER>L<EXECUTE>           list active buffer
        <ENTER>N<EXECUTE>           get list of buffer names
        <ENTER>K<name><EXECUTE>     kill buffer with given name
        <ENTER><EXECUTE>            open active buffer
        <ENTER><number><EXECUTE>    execute active buffer n times
        <EXECUTE>                   close or execute active buffer

     Note that the WRITE format (and READ and LIST with no argument)
works  with the active execute buffer, meaning the one that was most
recently set up (using the S format).  Originally the active  buffer
is the null buffer.

     All characters typed in these formats are meaningful.  So don't
put in any spaces unless you really want them.






                              - 35 -



***************************************************************************
SETTING UP A BUFFER

     The general procedure for working with an execute buffer is  to
set it up, write it, then execute it.

     To define and write a new buffer:  choose a  name,  say  "FOO",
and set up the buffer by typing

        <ENTER>SFOO<EXECUTE>

     Names can be up to five characters long and can consist of  any
printing characters.

     The S format is also used to set to a buffer which has  already
been  created.   A  buffer  must  be set before it is written (the W
format), read (R), listed (L), or executed.  The S format will  look
for  a  buffer of the given name and make it and its contents active
if it exists;  if no buffer by that name exists, it will create  one
(which is empty).  To set to the null buffer type <ENTER>S<EXECUTE>.

***************************************************************************
WRITING A BUFFER

     After creating the buffer named FOO you  can  write  a  command
sequence  into  it  in  the usual way, by typing <ENTER><EXECUTE> to
open the buffer, the desired sequence of commands, and <EXECUTE>  to
close  it.   Note  that setting up the buffer name with the S format
does NOT open the buffer.

     The execute buffer can also be written directly, without having
the  commands  take effect on the screen (using the W WRITE format).
The WRITE  format  works  with  the  active  buffer.   For  example,
following the above set command with

        <ENTER>W$THING^SF$5^DS$HACK^PT<EXECUTE>

will load the buffer names FOO with a  sequence  of  commands  which
searches  for  an  occurrence  of  "THING",  deletes it, and inserts
"HACK".  The buffer is loaded with the following command sequence:

        <ENTER>THING<SEARCH-FORWARD>
        <ENTER>5<DELETE-SPACES>
        <ENTER>HACK<PUT>

     Writing into the execute buffer requires a language to describe
the  editor  commands, since typing them directly will cause them to
take effect.  Appendix E is a list of the editor  commands  and  the
sequences that <EXECUTE> uses to describe them.  In general they are
"^" followed by two or three letters  which  describe  the  command.
<ENTER-PARAMETER> is a dollar sign.



                              - 36 -



     For another example, to load the active buffer with a  sequence
to  put  an  "X"  at  the  cursor  position,  move  to  the position
underneath, and roll the screen one line, type

        <ENTER>WX^CL^CD$1^RFL<EXECUTE>

This sets up the buffer with the following command sequences:

        X
        <CURSOR-LEFT>
        <CURSOR-DOWN>
        <ENTER>1<ROLL-FORWARD-LINES>

     Of course, the execute will run faster if  the  parameters  are
set up in advance, not in the sequence itself.

     The execute buffer does not have to be opened in order to write
it  using  the  W  format,  nor does it have to be closed afterward.
Those two formats apply only when you want to save commands as  they
are issued, as described in the previous section.

     After the buffer has been written it can  be  executed  in  the
normal fashion, by typing <ENTER><number><EXECUTE>.

     If you want to do the same series of commands several times  in
a  row,  you  can  give a repeat count.  For example, ^4(^CR) is the
same as ^CR^CR^CR^CR.  Any series of commands can be repeated up  to
2000 times.

     To put a real up-arrow in a buffer type "^^"  (two  up-arrows).
To  put  in  a  real dollar sign type "^$".  Within a repeat, a real
close parenthesis must be given as "^)".

     You can use cursor movement to read a  buffer  definition  from
the  file  you  are  editing,  so a useful way of experimenting with
execute buffers is to  put  the  buffer  definition  in  your  file,
preceded by the "W" for the WRITE format.  Position to the "W", move
the cursor to the end of the  line,  and  type  <EXECUTE>.   If  the
command  sequence  is not quite right, change it in the file and use
cursor movement to pick it up again.

***************************************************************************
TWO WAYS OF READING THE CONTENTS OF A BUFFER

     There are two formats for seeing what is in a buffer:   LISTing
and  READing.   LIST presents the buffer in a manner compatible with
the WRITE format;  READ presents it in a style  that  can  be  <PUT>
into execute files or SED.INIT.

     You   can   see   what   is   in    a    buffer    by    typing
<ENTER>L<name><EXECUTE>.   The  active  buffer can be read by typing
<ENTER>L<EXECUTE>.  The null buffer must be made active before it is
read  (using  the  S format).  Typing this command will cause a line

                              - 37 -



like

        W$THING^SF$5^DS$HACK^PT

to be put into the parameter buffer and  displayed  on  the  screen.
This  line can be treated just like a parameter that you have typed:
you can edit it and type <EXECUTE> again to load the edited  version
into  the  buffer, or use <PUT> to insert it into the file (where it
can  be  copied   or   modified   at   will   and   reloaded   using
<ENTER><END-LINE>(EXECUTE>.

     Similarly,   you   can   type    <ENTER>R<name><EXECUTE>    (or
<ENTER>R<EXECUTE> to read the active buffer).  This format gives you
a little more information:  READing the FOO buffer  will  cause  the
line

        /X:FOO:$THING^SF$5^DS$HACK^PT

to be put into the parameter buffer and  displayed  on  the  screen.
Again, you can treat this line like a parameter that you have typed.
In particular, it's useful to be able to store the command string in
SED.INIT  or  some  other file by doing a READ and a <PUT>.  More on
these switch files later (in the section on  reading  execute  files
from disk).

***************************************************************************
FINDING OUT WHAT THE NAMES OF THE BUFFERS ARE

     Typing <ENTER>N<EXECUTE> will  fill  the  bottom  line  of  the
screen with the names of the buffers.

***************************************************************************
KILLING A BUFFER

     If all the execute buffers are  set  up  and  you  try  to  SET
another one, SED will inform you that all the buffers are in use and
suggest you kill one of them.  You do that using the K  format:   to
kill the buffer FOO type

        <ENTER>KFOO<EXECUTE>

That name will go away and the buffer will be cleared, and  it  will
be available to be set to something new.

     The null buffer can be killed by typing <ENTER>K<EXECUTE>.

***************************************************************************
SETTING UP EXECUTE BUFFERS IN SED.INIT

     Frequently-used command sequences can be  put  in  SED.INIT  so
they will be set up automatically when SED is run.  An example of an
execute switch is:


                              - 38 -



        /X:NAME:$gig^PT^RT

which sets up execute buffer "NAME" with the command sequence to  do
a <PUT> and a carriage return.

     You can copy an execute buffer into SED.INIT (or any  file)  by
typing <ENTER>R<name><EXECUTE> and then <PUT>.

***************************************************************************
EXAMPLES OF EXECUTE SEQUENCES

        ^8($5^DS^CD)^RFL

(where the <ROLL-LINES> parameter is set  to  8).   This  deletes  5
characters  from  the same column of each of 8 lines, then rolls the
screen 8 lines.

        $^ECJ^EC?^EC?^EC?^ECM^SF^DL

This will delete all lines which are exactly three characters  long.
It  looks  for  lines  which have exactly three characters between a
linefeed (the end of the previous line) and a carriage return.

        ^SF^LN^PK^RT^FL^PT^RT^FL

(where some search key has been set up, the <PICK> parameter  is  1,
and the alternate file is the end of the current file).  This copies
all lines which contain a match of the search key to the end of  the
file.   It  searches  for  a  match,  gets to the start of the line,
<PICK>s the line, sets to the alternate file (which is  the  end  of
the current file), <PUT>s the line, and <SET-FILE>s back.  Note that
there will never be a search failure.  The alternate file could be a
separate  file,  but  then  the  two  files will have to be read and
written on disk for each <SET-FILE>, which will  slow  the  sequence
down  considerably.   The  set  of  matching  lines  can  easily  be
transferred from the end of the file to  any  other  file  when  the
execute has completed.

















                              - 39 -



                  ADVANCED EXECUTE BUFFER FEATURES

Sections:
        WRITING AND EXECUTING IN ONE COMMAND
        SETTING INITIAL PARAMETERS FOR AN EXECUTE
        CONNECTING EXECUTE BUFFERS TO TERMINAL KEYS
        READING EXECUTE BUFFERS FROM DISK
        CONDITIONAL EXECUTE STATEMENTS
        THE EXECUTE COUNTER

     The story of <EXECUTE> is not over yet.


                WRITING AND EXECUTING IN ONE COMMAND

     You can write a sequence of commands into the active buffer and
immediately  execute the buffer a given number of times by using the
X format:

        <ENTER>Xn:<sequence><EXECUTE> write buffer & execute n times

The X format is useful for doing a one-shot series of commands.


              SETTING INITIAL PARAMETERS FOR AN EXECUTE

     The START-UP construct allows  you  to  define  parameters  and
switches at the beginning of an execute.  The format of START-UP is:

START-UP  . . . . . . . . . . . ^ST( ... )

     The contents of the START-UP block is executed  only  once,  at
the  start  of  the  execute.   The  parameters  of  commands in the
START-UP block are set  up  but  the  commands  themselves  are  not
executed.   Thus  the  START-UP  block is used to initialize command
parameters.  Switches can  also  be  set  in  the  block  using  the
<SWITCH> command.

     For  example  the  construct  ^ST($1^IS$gig^SF)  will  set  the
<INSERT-SPACES>  parameter  and the search key, but will not perform
either command.

     Initializing can speed up an execute buffer a lot.  For example

        ^ST($THING^SF$2^DS)^SFGIG^DS

acts the same as

        $THING^SFGIG$2^DS

but is much more efficient since the parameters are set up  once  in
the  first case and once per iteration in the second.  Parsing those
parameters takes time.

                              - 40 -



     The START-UP block can also be used to set switches which  will
be in effect during the execute:

        ^ST($NC/T:8/NIM^SW)     or
        ^ST($NC+T:8+NIM^SW)

initializes for case-independent searches, tab length of 8,  and  no
INSERT  mode during the execute.  The second form above must be used
in SED.INIT or an indirect (.XCT) execute file, since  a  "/"  marks
the start of a new buffer definition or switch.

***************************************************************************
             CONNECTING EXECUTE BUFFERS TO TERMINAL KEYS

     You can set up any command sequence to call one iteration of an
execute  buffer.  A command sequence is a string of characters which
begins with a control character.  The action of the commands in  the
buffer  will  be displayed on the screen as it happens.  You can use
this capability, in effect, to define new commands to SED.

     There is one more EXECUTE format:

        <ENTER>B<EXECUTE>          connect active buffer to button

After you type this format  SED  will  ask  you  to  press  any  key
followed  by  the  letter  "G" (or "g").  SED will take the sequence
output by that key as the invocation of the currently active buffer.
Making  some other buffer active has no effect on this relationship.
Changing the contents of the buffer also has no effect, but remember
that  if  you  change  the buffer something new will happen when you
press the key.

     After you have typed <ENTER>B<EXECUTE> you can type any command
sequence  you  want.   The  sequence  can  be a control character, a
special key, or any string of characters which begins with a control
character.  If you type

        <ENTER>B<EXECUTE>
        <ESCAPE>XG

then the buffer would be executed  once  when  you  typed  <ESCAPE>X
(there  is  a  way  to make <ENTER>n<ESCAPE>X cause the buffer to be
executed n times;   see  the  section  about  the  execute  counter,
below).

     The sequence of  characters  can  even  be  one  which  already
invokes an editor command, so you can replace commands you don't use
with new ones of your own design.

     You can undefine a key by making its buffer active  and  typing
<ENTER>B<EXECUTE>G (ie, re-defining its key to nothing).



                              - 41 -



     The key definition can be set up with the buffer  in  SED.INIT.
The expanded format of the SED.INIT line is:

        /X:NAME,^[X:$gig^PT^RT

which sets up a buffer named NAME with <ENTER>gig<PUT><RETURN>,  and
assigns  it  to  the  sequence  <ESCAPE>X.   ("^["  ==  CONTROL-[ ==
<ESCAPE>.  All the stuff between the comma and the colon is taken as
the key definition.  The key definition can be omitted.

     Note:  RUBOUT (or DELETE) can be part of the command  sequence.
If you read the execute buffer the RUBOUT will appear as "^?".

***************************************************************************
                  READING EXECUTE BUFFERS FROM DISK

     There is yet another <EXECUTE> format:

        <ENTER>@FILE.EXT<EXECUTE>  read from the given file

This causes the buffer definitions and switches in  FILE.EXT  to  be
set  up.   The  previous definitions are erased.  Thus the disk file
can contain the definition of an entire special user environment.

     The disk file looks like a list of  switches.   SED  will  skip
characters  until  it finds a "/", so the first several lines can be
used for comments.  But be sure there's not a "/" in the comments.

     The default extension of this file is "XCT".

     You can set up and write execute buffers, and  then  when  they
are  working  properly you can put them in this file by Setting each
one up, doing a READ, and then a <PUT>.

     Here is an example of an execute file.  It sets up four special
keys  on  the  VT52  terminal  to  do  useful things for an assembly
language programmer:

        MACRO PROGRAMMER'S EXECUTES:
        BUTTON 4: TAB TO 4TH STOP AND ";"
        BUTTON 5: <CR> AND TAB
        BUTTON 6: ":" AND TAB
        BUTTON 9: DELETE PREVIOUS WORD

        /X:B4CM,^[?t:^3(^FCL32(^TA));
        /X:B5RT,^[?u:^RT^TA
        /X:B6RC,^[?v::^TA
        /X:B9DW,^[?y:^BT$^TB^DS






                              - 42 -



***************************************************************************
                   CONDITIONAL EXECUTE STATEMENTS

     In addition to the editor commands, the following are defined:

ITERATED-DO . . . . . . . . . . ^n ( ... )
DO-WHILE  . . . . . . . . . . . ^DW condition ( ... )

IF-CHARACTER  . . . . . . . . . ^IF condition ( ... )
IF-ROW  . . . . . . . . . . . . ^FR comparison ( ... )
IF-COLUMN . . . . . . . . . . . ^FC comparison ( ... )
IF-COUNTER  . . . . . . . . . . ^F. comparison ( ... )

EXIT-BLOCK  . . . . . . . . . . ^XB
CONTINUE-BLOCK. . . . . . . . . ^CB
EXIT-BUFFER . . . . . . . . . . ^XX

     The ITERATED-DO construct has already been described:   it  was
called  a "repeat block" in a previous section.  It causes the stuff
following in ()'s to be repeated the given number of  times  (up  to
2000).

     DO-WHILE and IF-CHARACTER perform or skip  the  stuff  in  ()'s
depending on the nature of the character at the cursor position.

     IF-ROW  and  IF-COLUMN  perform  or  skip  the  stuff  in  ()'s
depending on the row or column position of the cursor on the screen.
IF-COUNTER does likewise depending  on  the  value  of  the  Execute
counter (use of the counter is described below).

     EXIT-BLOCK  causes  control  to  leave  the   interior   of   a
conditional.   CONTINUE-BLOCK  causes the rest of the conditional to
be skipped.  These two behave the same inside an IF block;  in a  DO
block  EXIT stops iterating and CONTINUE ends the current iteration.
EXIT-BUFFER ends the current iteration of the execute buffer.

     Now for details.  DO-WHILE and IF-CHARACTER can check to see if
the character at the cursor is

            Some given character
        ^L  ALPHABETIC (A-Z, a-z)
        ^U  UPPER CASE (A-Z)
        ^N  NUMERIC (0-9)
        ^A  ALPHA-NUMERIC
        ^C  ANY CHARACTER
        ^S  SPACE OR TAB
        ^E  END OF LINE OR BEYOND

or .NOT.  any of those things (by  preceding  them  by  "^X").   Any
character is anything but space or TAB (same as "^X^S).




                              - 43 -



     You can say "if character is a space,  move  cursor  right"  by
"^IF^S(^CR)".   "Do  while  character  is not the letter 'A', cursor
right" is "^DW^XA(^CR)".

     IF-ROW, IF-COLUMN and IF-COUNTER check if the  current  row  or
column or the Execute counter is:

        En  EQUAL TO n
        Gn  GREATER THAN n
        Ln  LESS THAN n
        Nn  NOT EQUAL TO n

For example, you can say "If column is less than 64,  cursor  right"
by  "^FCL64(^CR)",  and  "If  it's  not  row  12,  cursor  down"  by
"^FRN12(^CD)".

     These constructs can be nested to a  depth  of  about  10,  and
intermingled as much as desired.

Examples:

    ^DW (^CR)       while character at cursor is " ", cursor right
    ^DW^X5(^CR)     while character is not a "5" move right
                    a.k.a. DO-UNTIL character is "5" ...
    ^DW^X^N(^CR)    until character is numeric move right
    ^FCE64(^RT)     if at column 64 do a RETURN
    ^FRG10(^CH)     if beyond row 10 go HOME
    ^IF^E(^RT)      if at or beyond end of line do a RETURN
    ^IF^X^E(^CR)    if not end of line move right
    ^1000(^PT)      PUT 1000 times

     EXIT- and CONTINUE-BLOCK are usually used inside a conditional,
along with an IF statement.  For example

        ^DW^X^E(^CR^FCG40(^XB))

will stop DOing when the end of the line  is  reached  or  when  the
column is greater than 40.

        ^1(^IF^S(^DS^PT^XB)^TB)

is an IF-THEN-ELSE statement.  If the character is a  space  or  TAB
SED deletes it, does a <PUT>, and skips the rest of the conditional;
else it TABs over.










                              - 44 -



***************************************************************************
                         THE EXECUTE COUNTER

     You can keep a count of something  and  use  that  count  as  a
command  parameter or the number of iterations of a DO.  The counter
constructs are:

CLEAR-COUNTER . . . . . . . . . ^C=
INCREMENT-COUNTER . . . . . . . ^C+
DECREMENT-COUNTER . . . . . . . ^C-
USE-COUNTER . . . . . . . . . . ^CT
ITERATE-COUNTER . . . . . . . . ^C.( ... )
IF-COUNTER  . . . . . . . . . . ^F.( ... )
SET-COUNTER . . . . . . . . . . ^SC

     The  counter  can  be  cleared,  incremented,  and  decremented
anywhere in the execute buffer.

     You can use  the  counter  as  a  parameter:   if  the  counter
contains  12,  then  "$^CT^DS"  will delete 12 spaces.  Or "$^CT^PT"
will <PUT> the characters "12" into  the  file.   The  counter  must
appear  alone  in a parameter;  you can't say "$123^CT45^PT".  Also,
the ^CT construct can appear only in a parameter.

     To  loop  <counter>  times  on  a   set   of   commands,   type
"^C.( ... )".   For  example  if  the counter contains 5, "^C.(^PT)"
will do 5 <PUT>s.

     The value of the counter can be used for conditional branching:
"^F.E10(^PT)" will do a <PUT> only if the counter contains 10.

     SET-COUNTER (^SC) sets the execute  counter  to  the  (numeric)
parameter  the user typed.  It is intended for execute buffers which
are assigned to keys  on  the  terminal.   If  ^SC  appears  at  the
beginning  of  the buffer and the user types <ENTER>17<KEY>, then 17
will be stored in  the  counter.   If  the  user  does  not  type  a
parameter,  the  same value as last time is used (the default is 1).
Non-numeric parameters cause an error.
For example the buffer

        ^SC^C-^ND$^ECL^C.(^SF)^RT

sets up a command to put the user at the start of some page  of  the
file  (where  pages are marked by formfeeds - CONTROL-L's).  Suppose
the user  types  <ENTER>4<KEY>.   The  counter  is  set  to  3,  and
CONTROL-L  is  searched  for 3 times [the construct $^ECL^C.(^SF) is
used rather than ^C.($^ECL^SF) because it is faster - the  parameter
is only processed once).  After the last search a carriage return is
done.  NO-DISPLAY (^ND - see next section) is set, so the action  is
displayed  only after the buffer is done executing.  Without ^ND all
the search targets would appear on the screen one by one.



                              - 45 -



***************************************************************************
    DEFERRING THE DISPLAY OF A BUFFER ATTACHED TO A TERMINAL KEY

NO-DISPLAY  . . . . . . . . . . ^ND

     Normally, the action  taken  by  an  execute  buffer  which  is
connected  to a terminal key is displayed step by step as the buffer
is processed.  If the NO-DISPLAY construct appears in a buffer,  the
screen will not be updated until the buffer has completed.  Then the
entire screen will be re-written.  This feature  is  useful  if  the
buffer  will  display  a  lot of parts of the file but you only care
about where it ends up.

     A buffer with ^ND in it acts the same as a  buffer  invoked  by
<ENTER>n<EXECUTE> with /NOSHOW set.



***************************************************************************
                     OUTPUTTING IMAGE CHARACTERS

OUTPUT  . . . . . . . . . . . . ^OU( ... )

     The OUTPUT construct is used  to  output  an  image  string  of
characters.   SED  will  send  to the terminal the ASCII argument to
^OU.  This construct can be used to cause things to  happen  to  the
terminal  that SED does not know about (for example, changing colors
on a graphics terminal).

     NOTE:  The text is output to the terminal screen.   It  is  not
put in the file.

     Control characters are  denoted  by  "^K".   <ESCAPE>  is  "$".
"^$", "^^", and "^)" denote "$", "^", and ")".
EXAMPLE:  ^OU($H$J(Running^)) outputs "<ESCAPE>H<ESCAPE>J(Running)".



















                              - 46 -



As an overall example, here is an  execute  buffer  which  lines  up
every comment line at the 4th tab position, or if the comment starts
after the 4th tab, it puts one space between the instruction and the
comment.  Also, comments which start before column 16 are assumed to
be subroutine headers, and are left alone.

     Note that if the search key were "'" the buffer would work with
BASIC programs;  if it were "!" it would work with FORTRAN, etc.

     One comment is handled by every iteration of this buffer.

        ^ST($;^SF$1^IS$IM^SW)
        ^SF
        ^FCG16(
                ^CL^C=
                ^DW^S(^CL^C+)
                ^CR
                $^CT^DS
                ^4(^FCL32(^TA))
                ^CL
                ^IF^X^S(^CR )
                )
        ^RT

The buffer first sets the search key to be ";",  the  parameter  for
<DELETE-SPACES> to be 1, and INSERT MODE to be in effect.

     SED finds a match.  If the match is not beyond the 16th column,
SED  does  a  carriage  return (one comment per line!) and stops the
iteration.  Else SED moves to the left of the  comment  symbol.   It
counts  up  all  spaces to the left of the comment, and then deletes
them.  Then SED puts in tabs until the comment starts at column 32.

     Then SED looks at the character to  the  left  of  the  comment
symbol.   If  it  is  not  a  space or tab (meaning that the comment
started beyond column 32, thus no tabs were  inserted  in  the  loop
above)  SED separates the comment from the instruction with a space.
SED then does a <RETURN> to end the iteration.

     Other sample execute buffers can be found in SED.XCT and  other
.XCT files.

     Incidentally, the  multi-line  format  above  can  be  used  in
SED.INIT  or  .XCT  files.  The indentation characters must be TABs.
When SED is reading a buffer definition all control  characters  are
ignored,  so  CARRIAGE  RETURNs,  LINEFEEDs,  and TABs can be put in
wherever you want.







                              - 47 -



                             APPENDICES

                    Appendix A. DEFAULT FILESPECS

     Files are always looked for on your connected directory  unless
you give an explicit device and/or directory name.

***************************************************************************
             Appendix B. LOOKING THROUGH A LIST OF FILES

     You can create a file containing a list of files and then  look
at  them  one  by one, moving one file forward or backward along the
list.  The easiest way to create this list of  files  is  using  the
DIRECT program (or command).  For example, type

        @DIR *.MAC,
        @@OUTPUT (TO FILE) LIST

This creates LIST.DIR with a list of the MACRO files in  your  area.
It  will  probably need a little editing since the full filespec (in
particular the file name) must appear  on  each  line.   Any  method
which sets up a list of files, one to a line, will do.

     If you then run SED and say <ENTER>@LIST.DIR<SET-FILE> (or  run
with  "@SED @LIST.DIR") (the default extension is "DIR") you will be
looking at the first file on  the  list.   Then  a  lone  <SET-FILE>
command  will  get  the next file on the list, and <ENTER><SET-FILE>
will get the previous one.  When you reach the beginning or  end  of
the list SED will toggle between the last two files it found.

     You can return to normal by typing <ENTER>filespecs<SET-FILE>.

NOTE:  The indirect file must reside in your connected directory.

     The indirect file (such as LIST.DIR above) can contain comments
(which start with "!" or ";").  Spaces and tabs are ignored, so they
can be put in anywhere.  Entirely blank lines can appear before  the
first filespec, but not between specs (use a lone comment symbol).

     Here is an example of an indirect <SET-FILE> file:

        ;LIST OF EXPERIMENTAL FILES

        EXP1.MAC        !FILE TO CHANGE ALL THE WORLD
        EXP2.MAC        ;FILE TO CHANGE ALL THE REST
        !
        EXP3A.MAC
        ;
        ;THE FOLLOWING ARE NOT VERY USEFUL:
        ;
        EXP8.MAC
        EXP15.MAC


                              - 48 -



             Appendix C. USING MARGINS AND SCREEN LIMITS

     This appendix discusses the action of four switches:  /LENGTH:,
/WIDTH:, /LMAR:, and /RMAR:.

     /LENGTH:  and /WIDTH:  set up the dimensions  of  the  terminal
display.   You  can  use  them  to  limit the amount of output.  For
example, for a lot of searching on a slow terminal,  set  /LENGTH:10
and  only  a  few  lines  around the search match will be displayed.
Also, SED can be adjusted for terminals which  change  widths,  like
the VT100, using the /WIDTH:  switch.

     /LMAR:  and /RMAR:  control how typed-in characters are entered
on  the  screen  and  in the file.  If you set, say, /LMAR:8, then a
<CARRIAGE-RETURN> or <BEGIN-LINE> command will move the  cursor,  on
the  screen  and in the file, to the eighth column.  The line in the
file will begin with eight spaces.  /LMAR:  is initially 1.

     You can move into that indented region using  <CURSOR-LEFT>  or
<DELETE-CHARACTER>.

     /RMAR:  sets up the right margin.  If you are  typing  in  text
and  exceed  the  right  margin then the word you are typing will be
moved to the next line.  SED will put in the  carriage  returns  for
you.  /RMAR:  starts as the width of the entire screen.

     /RMAR:  can be disabled by setting it larger  than  the  screen
width (like /RMAR:1000).


























                              - 49 -



          Appendix D. INCREMENTAL FILE SAVES AND JOURNALING

     There are a number of ways to recover editing sessions in  SED.
You  can  save the file you are editing automatically by setting the
/ISAVE:  and /SAVE:   switches.   Say  you  set  /ISAVE:30/SAVE:150.
Then after 30 commands or 150 characters of type-in, whichever comes
first, the file will be saved.  Then both counters are reset.

     /ISAVE:  and  /SAVE:   both  start  off  at  zero,  meaning  no
incremental  saves  (which is what these saves are called).  You can
tune SED's saving characteristics to your editing style.

     Of course, you can also save the file by simply exiting SED and
rerunning  it,  since  SED  will  put you back where you were in the
file.  This scheme is good if you want  to  save  only  at  specific
times (and can remember that it needs to be done).  There's also the
<SAVE-FILE> command, which saves the file without exiting SED.

     One thing to beware:  incremental  saves  and  the  <SAVE-FILE>
command  do  not  clean  up  the  file.  SED puts a lot of nulls and
trailing spaces into the file;  they are eliminated when the file is
saved  by  an <EXIT> or <SET-FILE> command.  But the other saves are
designed to take as little time as possible, so the nulls and spaces
are  left  in.  However, some programs will break if there are nulls
in the file.  So end your editing sessions  by  typing  <EXIT>,  not
<SAVE-FILE><ABORT>.

     Incremental saves can take a long time  for  large  files.   So
there  is  another  recovery mechanism:  journaling.  The journal is
the file SEDJRN.TMP, which holds the stream of  commands  which  you
typed  during your editing session.  If the computer crashes you can
recover your session by telling SED to read its  commands  from  the
journal  and  apply  them  to  the  unchanged  file (it is unchanged
because the system crashed before you exited).  A  few  commands  at
the  end  of the session will be lost, but you will get most of your
work back.

NOTE:  Journaling works only under TOPS-20 at this time.

ALERT:  Journaling does not work correctly under all conditions now.
It  fails  by  just  stopping  part  way through recovery, which, at
least, isn't fatal.  I find that it still works often enough  to  be
useful,  and  I  am gradually correcting the deficiencies.  However,
the journaling code is turned off in the distributed version of SED.
If  you  have  journaling  enabled,  please  be  aware that it fails
sometimes.

     Start journaling by typing the /JOURN switch (in  the  <SWITCH>
command,  in  the  monitor-level  RUN  command,  or  as  part  of  a
<SET-FILE>.  The journal will be started immediately, and  SED  will
remember  what  file  you  are editing and where you are in it.  The
journal is restarted every time the file is saved (on  a  <SET-FILE>
or incremental save).

                              - 50 -



     You don't have to worry about the journal unless  the  computer
crashes.   When  the  system  comes  up, type "SED/RECOV" at monitor
level.  SED will take its commands  from  the  journal,  update  the
file, and tell you when it's done.

     If you want  to  see  your  own  commands  being  performed  at
super-speed,  type "SED/RECOV/SHOW".  Watching your two-hour session
whiz by in a couple of minutes is very humbling, and  has  the  same
entertainment value as watching two shirts fight in a clothes dryer.

     Also,  if   you   recover   by   typing   "SED/REC/JOURN"   (or
"SED/REC/SHOW/JOURN") then the journal will be appended to after the
recovery is finished.  This also happens if /JOURN is  in  SED.INIT.
Note:   if,  after  recovery, you type <ENTER>JOURN<SWITCH> then the
journal file will be STARTED, not appended to.  When in  doubt  save
the file (by exiting, for example), and start with a fresh journal.

     If you put  the  /JOURN  switch  in  your  SED.INIT  file  then
journaling  will  be done automatically.  You can turn it off for an
editing session  by  typing  <ENTER>NOJOURN<SWITCH>  (as  you  might
expect).

































                              - 51 -



             Appendix E. TABLE OF EXECUTE COMMAND NAMES

        COMMAND             NAME    OTHER COMMANDS          NAME
        -------             ----    ----- ----------        ----
        ENTER-PARAMETER . . $       SET-FILE  . . . . . . . ^FL
                                    SWITCH  . . . . . . . . ^SW
CURSOR  CURSOR-UP . . . . . ^CU     WINDOW  . . . . . . . . ^WI
        CURSOR-DOWN . . . . ^CD     PUSH  . . . . . . . . . ^PU
        CURSOR-LEFT   . . . ^CL
        CURSOR-RIGHT  . . . ^CR     OTHER CONSTRUCTS        FORMAT
        CURSOR-HOME   . . . ^CH     ----- ----------        ------
        CARRIAGE-RETURN . . ^RT     START-UP  . . . . . . . ^ST( ... )
        TAB . . . . . . . . ^TB     IMAGE-OUTPUT  . . . . . ^OU( ... )
        BACKTAB . . . . . . ^BT     NO-DISPLAY  . . . . . . ^ND
        UP-TAB  . . . . . . ^UT
        DOWN-TAB  . . . . . ^DT     ITERATED-DO . . . . . . ^n( ... )
        BEGIN-LINE  . . . . ^LB     DO-WHILE  . . . . . . . ^DWc( ... )
        END-LINE  . . . . . ^LE     IF-CHARACTER  . . . . . ^IFc( ... )
        LINE  . . . . . . . ^LN     IF-ROW  . . . . . . . . ^FRc( ... )
                                    IF-COLUMN . . . . . . . ^FCc( ... )
ROLLS   ROLL-BACK-PAGES . . ^RBP    EXIT-BLOCK  . . . . . . ^XB
        ROLL-FORWARD-PAGES. ^RFP    CONTINUE-BLOCK. . . . . ^CB
        ROLL-BACK-LINES . . ^RBL    EXIT-BUFFER . . . . . . ^XX
        ROLL-FORWARD-LINES. ^RFL
        PERCENT-GOTO  . . . ^GO     CLEAR-COUNTER . . . . . ^C=
        SLIDE-LEFT. . . . . ^SL     INCREMENT-COUNTER . . . ^C+
        SLIDE-RIGHT . . . . ^SR     DECREMENT-COUNTER . . . ^C-
                                    SET-COUNTER . . . . . . ^SC
SEARCH  SEARCH-FORWARD  . . ^SF     USE-COUNTER . . . . . . ^CT
        SEARCH-BACKWARD . . ^SB     ITERATE-COUNTER . . . . ^C.( ... )
                                    IF-COUNTER  . . . . . . ^F.c( ... )
TEXT    INSERT-SPACES . . . ^IS
        DELETE-SPACES . . . ^DS     For DO-WHILE or IF-CHARACTER:
        INSERT-LINES  . . . ^IL
        DELETE-LINES  . . . ^DL           SOME GIVEN CHARACTER
        PICK  . . . . . . . ^PK       ^L  ALPHABETIC (A-Z, a-z)
        PUT   . . . . . . . ^PT       ^U  UPPER CASE (A-Z)
        INSERT-MODE . . . . ^IN       ^N  NUMERIC (0-9)
        DELETE-CHARACTER. . ^DC       ^A  ALPHA-NUMERIC
        CLEAR-LINE  . . . . ^LF       ^S  SPACE OR TAB
        ERASE-LINE  . . . . ^EL       ^E  END OF LINE OR BEYOND
        ERASE-WORD  . . . . ^EW
                                      ^X  .NOT. ONE OF THE ABOVE
OTHERS  ABORT . . . . . . . ^AB
        CASE  . . . . . . . ^CS     For IF-ROW, -COLUMN, -COUNTER:
        ENTER-CTRL-CHAR . . ^EC
        EXECUTE . . . . . . ^EX        En  EQUAL TO n
        EXIT  . . . . . . . ^XT        Gn  GREATER THAN n
        HELP  . . . . . . . ^HL        Ln  LESS THAN n
        MARK  . . . . . . . ^MK        Nn  NOT EQUAL TO n
        REAL-TAB  . . . . . ^TA
        RECALL  . . . . . . ^RC
        REWRITE . . . . . . ^RW
        SAVE-FILE . . . . . ^SV
                              - 52 -



                              EXAMPLE I
                  TERMINAL DEPENDENCIES OF THE VT52

     The VT52 has a numeric  keypad  to  the  right  of  the  normal
keyboard.  Four cursor movement keys are at the right of that keypad
and there  are  three  unidentified  buttons  above  the  pad.   The
leftmost  (blue)  unidentified  button  is  the <ENTER> command, the
rightmost one (BLACK)  is  <HOME>,  and  the  center  one  (RED)  is
<RECALL>.  The number keys in the pad can be used to invoke commands
which are not defined as control characters.  Do not use the red ESC
(SEL) key at the upper left of the keyboard.


VT52 EDITOR KEYBOARD

       Q    W    E    R    T    Y    U    I    O    P
.____.____.____.____.____.____.____.____.____.____.____.   .____.____.
!    !ROLL!ROLL!SRCH!SRCH!ROLL!ROLL!BACK!    !ENTR!PERC!   !ERAS!RE- !
!TAB !BK P!BK L!BACK!FORW!FW L!FW P!TAB !TAB !CCH !GOTO!...!LINE!SET !
!____!____!____!____!____!____!____!____!____!____!____!   !____!____!
       !INS !DEL !INS !DEL !    !ERAS!ERAS!SLID!SLID!      !         !
       !SPAC!SPAC!LINE!LINE!PUT !CHAR!LINE!LEFT!RGHT!   ...! RETURN  !
   .___!____!____!____!____!____!____!____!____!____!_.    !_________!
   !     !    !    !    !    !SET !    !RE- ! <  ! >  !    !RE- !
   !SHIFT!EXIT!EXCT!ABRT!PICK!FILE!SWCH!TURN! ,  ! .  ! ...!PEAT!
   !_____!____!____!____!____!____!____!____!____!____!    !____!
           Z    X    C    V    B    N    M

        NUMERIC PAD AT RIGHT     .____.____.____.____.
        OF NORMAL KEYBOARD:      !ENTR!RE- !    !CUR !
                                 !ARGS!CALL!HOME! UP !
                                 !____!____!____!____!
                                 !    !UP- !    !CUR !
                               7 !MARK!TAB !CASE!DOWN! 9
                                 !____!____!____!____!
                                 !BEG-!RE- !END-!CUR !
                               4 !LINE!WRIT!LINE!RIGT! 6
                                 !____!____!____!____!
                                 !WIN-!DOWN!    !CUR !
                               1 !DOW !TAB !HELP!LEFT! 3
                                 !____!____!____!____!
                                 !   REAL  !ERAS!INS !
                                 !   TAB   !WORD!MODE!
                                 !_________!____!____!










                              - 53 -



                             EXAMPLE II
                  TERMINAL DEPENDENCIES OF THE ADM2

     The ADM2 has a row of buttons above the normal keyboard.   They
send  the  sequences "^A LETTER RETURN", with a different LETTER for
each key.  If SED uses those keys, ^A cannot be the  <INSERT-SPACES>
command,  since  when  SED  receives  a ^A it will wait for two more
characters before it decides what to do.  Also, the ADM2 uses ^K and
^L for cursor movement, so the slide commands must be moved.  So the
leftmost 4 special keys stand for <INSERT-> and <DELETE-SPACES>  and
<SLIDE-LEFT>  and  <-RIGHT>.  <ENTER> and the commands which are not
invoked by control characters are set up on the right  side  of  the
extra keys.

ADM2 EDITOR KEYBOARD
.____.____.____.____.____.____/        \____.____.____.____.____.____.
!INS !DEL !SLID!SLID!    !    /        \    !    !ERAS!INS !RE- !ENTR!
!SPAC!SPAC!LEFT!RGHT! F5 ! F6 /  ...   \ F11!MARK!CHAR!MODE!CALL!ARGS!
!____!____!____!____.____.____/        \____!____!____!____!____!____!

       Q    W    E    R    T    Y    U    I    O    P
.____.____.____.____.____.____.____.____.____.____.____.   .____.____.
!    !ROLL!ROLL!SRCH!SRCH!ROLL!ROLL!BACK!    !ENTR!PERC!   !         !
!CTRL!BK P!BK L!BACK!FORW!FW L!FW P!TAB !TAB !CCH !GOTO!...!   TAB   !
!____!____!____!____!____!____!____!____!____!____!____!   !_________!
       !    !DEL !INS !DEL !    !CUR !CUR !    !    !           !CUR !
       ! XX !SPAC!LINE!LINE!PUT !LEFT!DOWN! XX ! XX !   ...     !DOWN!
.______!____!____!____!____!____!____!____!____!____!_.    .____!____!
!        !    !    !    !    !SET !    !RE- ! <  ! >  !    !         !
! SHIFT  !EXIT!EXCT!ABRT!PICK!FILE!SWCH!TURN! ,  ! .  ! ...! RETURN  !
!________!____!____!____!____!____!____!____!____!____!    !_________!
           Z    X    C    V    B    N    M
                                .____.____.____.
        PAD AT RIGHT            !    !CUR !    !
        OF NORMAL KEYBOARD:     !    ! UP !    !
                                !____!____!____!
                                !CUR !    !CUR !
                                !LEFT!HOME!RIGT!
                                !____!____!____!
                                !    !CUR !    !
                                !    !DOWN!    !
                                !____!____!____!












                              - 54 -



                INDEX OF EDITOR COMMANDS, BY COMMAND

PAGE  COMMAND    NAME                 EXPLANATION

 12     ^A       INSERT-SPACES        INSERT SPACES TO FILE
 16     ^B       SET-FILE             SET UP A FILE FOR EDITING
 22     ^C       ABORT                EXIT AND FORGET CHANGES
 10     ^D       INSERT-LINES         INSERT BLANK LINES IN FILE
 13     ^E       SEARCH-BACKWARD      SEARCH FROM CURSOR TO START OF FILE
 10     ^F       DELETE-LINES         DELETE LINES FROM FILE
 18     ^G       PUT                  PUT TEXT INTO FILE
  6     LEFT     CURSOR-LEFT          MOVE CURSOR LEFT
  7     ^I       TAB                  MOVE TO NEXT TAB STOP
 24     (none)   CLEAR-LINE           CLEAR LINE BELOW CURSOR
 24     ^J       ERASE-LINE           ERASE FROM CURSOR TO END OF LINE
  9     ^K       SLIDE-LEFT           SLIDE VIEWING WINDOW LEFT
  9     ^L       SLIDE-RIGHT          SLIDE VIEWING WINDOW RIGHT
  6     ^M       CARRIAGE-RETURN      GOOD OL' ASCII CARRIAGE RETURN
 25     ^N       SWITCH               SET SWITCHES OR QUERY STATUS
 23     ^O       ENTER-CTRL-CHAR      MAKE NEXT CHARACTER A CONTROL CHAR.
  9     ^P       PERCENT-GOTO         GO TO SOME PERCENT THROUGH THE FILE
  8     ^Q       ROLL-BACK-PAGES      MOVE VIEWING WINDOW BACK PAGES
 13     ^R       SEARCH-FORWARD       SEARCH FROM CURSOR TO END
 12     ^S       DELETE-SPACES        DELETE CHARACTERS FROM FILE
  8     ^T       ROLL-FORWARD-LINES   MOVE VIEWING WINDOW FORWARD LINES
  7     ^U       BACKTAB              MOVE TO PREVIOUS TAB STOP
 16     ^V       PICK                 PICK TEXT FROM FILE
  8     ^W       ROLL-BACKWARD-LINES  MOVE VIEWING WINDOW BACK LINES
 32     ^X       EXECUTE              PERFORM SEQUENCE OF EDITOR COMMANDS
  8     ^Y       ROLL-FORWARD-PAGES   MOVE VIEWING WINDOW FORWARD PAGES
 22     ^Z       EXIT                 EXIT AND SAVE CHANGES
  3     PAD-BLUE ENTER                PASS A PARAMETER TO A COMMAND
 22     DELETE   RESET                RESET SCREEN OR PARAMETER
 30     PAD-RED  RECALL               RECALL PREVIOUS PARAMETER
 20     PAD-ENT  INSERT-MODE          CHARACTER INSERT/REPLACE TOGGLE
 11     BKSP     DELETE-CHARACTER     ERASE CHARACTER TO LEFT OF CURSOR
 23     PAD-0    REAL-TAB             TYPE A REAL TAB IN THE FILE
 19     PAD-7    MARK                 MARK POSITION FOR PICK OR DELETE
 31     PAD-9    CASE                 CHANGE CASE OF LETTER AT CURSOR
 31     PAD-1    WINDOW               SET OR CLEAR SPLIT-SCREEN WINDOWING
  6     PAD-8    UP-TAB               MOVE THE CURSOR UP 6 LINES
  6     PAD-2    DOWN-TAB             MOVE THE CURSOR DOWN 6 LINES
 23     PAD-5    RE-WRITE             REWRITE THE SCREEN
 20     (none)   SAVE-FILE            SAVE THE CURRENT FILE
 30     PAD-3    HELP                 GIVE ON-LINE HELP
  7     PAD-4    BEGIN-LINE           MOVE THE THE BEGINNING OF THE LINE
  7     PAD-6    END-LINE             MOVE THE THE END OF THE LINE
 11     KEYPAD-. ERASE-WORD           ERASE THE WORD AT THE CURSOR
 29     ^\       PUSH                 PUSH TO EXEC CONTEXT
 14     ESC-S    SUBSTITUTE           SEARCH AND SUBSTITUTE




                              - 55 -



                ARTICULATED INDEX OF EDITOR COMMANDS

     The COMMAND  column  refers  to  the  control  character  which
invokes  the  desired  command.  UP, DOWN, LEFT, RIGHT, and HOME are
the five cursor movement keys, usually denoted by arrows on the  key
caps  (but see the terminal dependent section to make sure).  RUB is
the RUBOUT key, sometimes yclept DEL, for DELETE.  ESC is the ESCAPE
or  ALTMODE  key.   "PAD" means that the key is on a keypad which is
separate from the normal typewriter keyboard.

KEY         EXPLANATION                     COMMAND       PAGE

ABORT       EXIT AND FORGET CHANGES           ^C	   22
APPEND      APPENDING LINES TO PICK BUFFER    ^V	   16

BACKWARD    ROLL SCREEN BACKWARD LINE         ^W	   8
BACKWARD    ROLL SCREEN BACKWARD PAGES        ^Q	   8
BACKWARD    SEARCH BACKWARD                   ^E	   13
BEGINNING   MOVE TO BEGINNING OR END OF LINE  (none)	   7
BEGINNING   MOVE TO THE BEGINNING OF A LINE   PAD-4	   7

CASE        CHANGE CASE OF LETTERS            PAD-9	   31
CHANGES     EXIT AND FORGET CHANGES           ^C	   22
CHANGES     EXIT AND SAVE CHANGES             ^Z	   22
CHARACTER   DELETE THE PREVIOUS CHARACTER     BKSP	   11
CHARACTER   ENTER CONTROL CHARACTER           ^O	   23
CHARACTERS  DELETE CHARACTERS FROM FILE       ^S	   12
CLEAR       CLEAR LINE BELOW CURSOR           (none)	   24
COMMAND     EXECUTE COMMAND SEQUENCE          ^X	   32
CONTROL     ENTER CONTROL CHARACTER           ^O	   23
CURSOR      CLEAR LINE BELOW CURSOR           (none)	   24
CURSOR      MOVE CURSOR DOWN                  DOWN	   6
CURSOR      MOVE CURSOR HOME                  PAD-BLK	   6
CURSOR      MOVE CURSOR LEFT                  LEFT	   6
CURSOR      MOVE CURSOR RIGHT                 RIGHT	   6
CURSOR      MOVE CURSOR UP                    UP	   6

DELETE      DELETE CHARACTERS FROM FILE       ^S	   12
DELETE      DELETE LINES FROM FILE            ^F	   10
DELETE      DELETE THE PREVIOUS CHARACTER     BKSP	   11
DELETE      DELETE THE PREVIOUS WORD          KEYPAD-.	   11
DELETE      MARK POSITION FOR PICK OR DELETE  PAD-7	   19
DELETED     RESTORE DELETED LINES             ^G	   18
DISPLAY     RESET PARAMETER OR DISPLAY        DELETE	   22
DOWN        MOVE CURSOR DOWN                  DOWN	   6
DOWN        MOVE CURSOR DOWN 6 LINES          PAD-2	   6

EDIT        EDIT A NEW FILE                   ^B	   21
END         MOVE TO BEGINNING OR END OF LINE  (none)	   7
END         MOVE TO THE END OF A LINE         PAD-6	   7
ENTER       ENTER CONTROL CHARACTER           ^O	   23
ENTER       ENTER PARAMETER                   PAD-BLUE	   3
ERASE       ERASE FROM CURSOR TO END OF LINE  ^J	   24

                              - 56 -
KEY         EXPLANATION                     COMMAND       PAGE


EXEC        PUSH TO EXEC CONTEXT              ^\	   29
EXECUTE     EXECUTE COMMAND SEQUENCE          ^X	   32
EXECUTE     EXECUTE FEATURES - ADVANCED       ^X	   40
EXECUTE     MORE INFORMATION ABOUT EXECUTE    ^X	   35
EXIT        EXIT AND FORGET CHANGES           ^C	   22
EXIT        EXIT AND SAVE CHANGES             ^Z	   22

FILE        EDIT A NEW FILE                   ^B	   21
FILE        SAVE THE CURRENT FILE             (none)	   20
FILESPECS   DEFAULT FILESPECS                 Appendix	   48
FILESPECS   RECALL CURRENT FILESPECS          PAD-RED	   30
FORGET      EXIT AND FORGET CHANGES           ^C	   22
FORWARD     ROLL SCREEN FORWARD LINES         ^T	   8
FORWARD     ROLL SCREEN FORWARD PAGES         ^Y	   8
FORWARD     SEARCH FORWARD                    ^R	   13

GO TO       GO TO PERCENT IN FILE             ^P	   9

HELP        GIVE ON-LINE HELP                 PAD-3	   30
HOME        MOVE CURSOR HOME                  PAD-BLK	   6

INDIRECT    LOOKING THROUGH A LIST OF FILES   Appendix	   48
INSERT      INSERT LINES IN FILE              ^D	   10
INSERT      INSERT SPACES IN FILE             ^A	   12
INSERT      INSERT TEXT IN FILE               ^G	   18
INSERT      INSERT/REPLACE TOGGLE             PAD-ENT	   20

JOURNAL     INCREMENTAL SAVES AND JOURNALING  Appendix	   50

LEFT        MOVE CURSOR LEFT                  LEFT	   6
LEFT        SLIDE WINDOW LEFT                 ^K	   9
LINE        CLEAR LINE BELOW CURSOR           (none)	   24
LINE        ERASE FROM CURSOR TO END OF LINE  ^J	   24
LINE        MOVE TO BEGINNING OR END OF LINE  (none)	   7
LINE        MOVE TO THE BEGINNING OF A LINE   PAD-4	   7
LINE        MOVE TO THE END OF A LINE         PAD-6	   7
LINES       DELETE LINES FROM FILE            ^F	   10
LINES       INSERT LINES IN FILE              ^D	   10
LINES       PICK UP LINES OF FILE             ^V	   16
LINES       RESTORE DELETED LINES             ^G	   18
LINES       ROLL SCREEN BACKWARD LINE         ^W	   8
LINES       ROLL SCREEN FORWARD LINES         ^T	   8
LIST        LOOKING THROUGH A LIST OF FILES   Appendix	   48

MARGINS     USING MARGINS AND SCREEN LIMITS   Appendix	   49
MARK        MARK POSITION FOR PICK OR DELETE  PAD-7	   19
MOVE        MOVE CURSOR DOWN                  DOWN	   6
MOVE        MOVE CURSOR HOME                  PAD-BLK	   6
MOVE        MOVE CURSOR LEFT                  LEFT	   6
MOVE        MOVE CURSOR RIGHT                 RIGHT	   6
MOVE        MOVE CURSOR UP                    UP	   6
MOVE        MOVE TO NEXT TAB STOP             TAB	   7
MOVE        MOVE TO NEXT TAB STOP             ^I	   7

                              - 57 -
KEY         EXPLANATION                     COMMAND       PAGE


MOVE        MOVE TO PREVIOUS TAB STOP         ^U	   7

NEW         EDIT A NEW FILE                   ^B	   21
NEXT        MOVE TO NEXT TAB STOP             TAB	   7
NEXT        MOVE TO NEXT TAB STOP             ^I	   7

PAGES       ROLL SCREEN BACKWARD PAGES        ^Q	   8
PAGES       ROLL SCREEN FORWARD PAGES         ^Y	   8
PARAMETER   ENTER PARAMETER                   PAD-BLUE	   3
PARAMETER   RECALL PARAMETER                  PAD-RED	   30
PARAMETER   RESET PARAMETER OR DISPLAY        DELETE	   22
PERCENT     GO TO PERCENT IN FILE             ^P	   9
PICK        MARK POSITION FOR PICK OR DELETE  PAD-7	   19
PICK        PICK UP LINES OF FILE             ^V	   16
POSITION    MARK POSITION FOR PICK OR DELETE  PAD-7	   19
PREVIOUS    MOVE TO PREVIOUS TAB STOP         ^U	   7
PUSH        PUSH TO EXEC CONTEXT              ^\	   29

QUERY       SET SWITCHES OR QUERY STATUS      ^N	   25

RECALL      RECALL PARAMETER                  PAD-RED	   30
REPLACE     INSERT/REPLACE TOGGLE             PAD-ENT	   20
RESET       RESET PARAMETER OR DISPLAY        DELETE	   22
RESTORE     RESTORE DELETED LINES             ^G	   18
RETURN      CARRIAGE RETURN                   ^M	   6
REWRITE     REWRITE THE SCREEN                PAD-5	   23
RIGHT       MOVE CURSOR RIGHT                 RIGHT	   6
RIGHT       SLIDE WINDOW RIGHT                ^L	   9
ROLL        ROLL SCREEN BACKWARD LINE         ^W	   8
ROLL        ROLL SCREEN BACKWARD PAGES        ^Q	   8
ROLL        ROLL SCREEN FORWARD LINES         ^T	   8
ROLL        ROLL SCREEN FORWARD PAGES         ^Y	   8

SAVE        EXIT AND SAVE CHANGES             ^Z	   22
SAVE        SAVE THE CURRENT FILE             (none)	   20
SAVES       INCREMENTAL SAVES AND JOURNALING  Appendix	   50
SCAN        SCAN THE FILE BACKWARD            ^W	   8
SCAN        SCAN THE FILE FORWARD             ^T	   8
SEARCH      RECALL CURRENT/FORMER SEARCH KEY  PAD-RED	   30
SEARCH      SEARCH AND SUBSTITUTE STRINGS     ESC-S	   14
SEARCH      SEARCH BACKWARD                   ^E	   13
SEARCH      SEARCH FORWARD                    ^R	   13
SLIDE       SLIDE WINDOW LEFT                 ^K	   9
SLIDE       SLIDE WINDOW RIGHT                ^L	   9
SPACES      INSERT SPACES IN FILE             ^A	   12
SPLIT       SET OR CLEAR SPLIT-SCREEN WINDOW  PAD-1	   31
STATUS      SET SWITCHES OR QUERY STATUS      ^N	   25
STRINGS     SEARCH AND SUBSTITUTE STRINGS     ESC-S	   14
SUBSTITUTE  SEARCH AND SUBSTITUTE STRINGS     ESC-S	   14
SWITCHES    SET SWITCHES OR QUERY STATUS      ^N	   25

TAB         MOVE CURSOR DOWN 6 LINES          PAD-2	   6
TAB         MOVE CURSOR UP 6 LINES            PAD-8	   6

                              - 58 -
KEY         EXPLANATION                     COMMAND       PAGE


TAB         MOVE TO NEXT TAB STOP             TAB	   7
TAB         MOVE TO NEXT TAB STOP             ^I	   7
TAB         MOVE TO PREVIOUS TAB STOP         ^U	   7
TAB         PUT A REAL TAB IN THE FILE        PAD-0	   23
TEXT        INSERT TEXT IN FILE               ^G	   18

UP          MOVE CURSOR UP                    UP	   6
UP          MOVE CURSOR UP 6 LINES            PAD-8	   6

WINDOW      SET OR CLEAR SPLIT-SCREEN WINDOW  PAD-1	   31
WINDOW      SLIDE WINDOW LEFT                 ^K	   9
WINDOW      SLIDE WINDOW RIGHT                ^L	   9
WORD        DELETE THE PREVIOUS WORD          KEYPAD-.	   11









































                              - 59 -
   