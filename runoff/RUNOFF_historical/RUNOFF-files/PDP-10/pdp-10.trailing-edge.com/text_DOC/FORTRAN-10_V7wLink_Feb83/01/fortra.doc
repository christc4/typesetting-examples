


   FORTRAN-10 -- Changes from V6 to V7
   February 1983






























   COPYRIGHT (C) 1983 BY
   DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.


   THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
   ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
   INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
   COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
   OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
   TRANSFERRED.

   THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
   AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
   CORPORATION.

   DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
   SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
   FORTRA.DOC - FORTRAN-10 Version 7                               Page 2


                                  CONTENTS
           1.0     SUMMARY  . . . . . . . . . . . . . . . . . . . . . . 3
           1.1       Bibliography . . . . . . . . . . . . . . . . . . . 3
           2.0     NEW FEATURES . . . . . . . . . . . . . . . . . . . . 4
           2.1       Summary Of Enhancements To The Product . . . . . . 4
           2.2       Character Data . . . . . . . . . . . . . . . . . . 6
           2.2.1       Features Supported For Character Data  . . . . . 6
           2.2.2       Internal Representation Of Character Data  . . . 9
           2.2.3       FORDDT Support For Character Data  . . . . . . . 9
           2.2.3.1       Character Mode For TYPE And ACCEPT Commands  . 9
           2.2.3.2       Declaration Of Character Array Bounds  . . .  10
           2.3       IF THEN ELSE . . . . . . . . . . . . . . . . . .  10
           2.4       DO WHILE And END DO Statements . . . . . . . . .  10
           2.5       Expressions On Output Lists  . . . . . . . . . .  11
           2.6       Intrinsic And Generic Functions  . . . . . . . .  11
           2.7       Multi-record Internal Files  . . . . . . . . . .  12
           2.8       FORTRAN-77 DO Loop Semantics . . . . . . . . . .  12
           2.9       Assumed-Size Array Declarators . . . . . . . . .  13
           2.10      ASSIGN Of FORMAT Statement Numbers . . . . . . .  13
           2.11      INTRINSIC And EXTERNAL Statements  . . . . . . .  14
           2.12      SAVE Statement . . . . . . . . . . . . . . . . .  14
           2.13      Support Of Null Argument Lists For Functions . .  14
           2.14      FORTRAN-77 Statement Ordering Rules  . . . . . .  15
           2.15      Minor Syntax Extensions  . . . . . . . . . . . .  15
           2.16      Constant Expressions . . . . . . . . . . . . . .  16
           2.17      FORTRAN-77 PARAMETER Statements  . . . . . . . .  16
           2.18      Expressions As Specifier Values In OPEN And I/O 
                     Statements . . . . . . . . . . . . . . . . . . .  17
           2.19      Type Checking For Function And Subroutine 
                     Arguments  . . . . . . . . . . . . . . . . . . .  17
           2.20      New Functionality In ERRSET  . . . . . . . . . .  20
           2.21      Utility Subroutine To Get A Free Unit Number . .  22
           2.22      Additional Runtime Warnings  . . . . . . . . . .  22
           3.0     RESTRICTIONS . . . . . . . . . . . . . . . . . . .  22
           3.1       FORTRAN-77 Features Not Supported  . . . . . . .  22
           3.2       Other Restrictions . . . . . . . . . . . . . . .  23
           4.0     KNOWN BUGS AND DEFICIENCIES  . . . . . . . . . . .  23
           4.1       Execute-Only . . . . . . . . . . . . . . . . . .  23
           4.2       Mandatory Patches For Related Products . . . . .  25
           4.3       Known Deficiencies In Related Products . . . . .  25
           5.0     COMPATIBILITY WITH PREVIOUS VERSIONS . . . . . . .  26
           5.1       Incompatibilities Between Versions 6 And 7 . . .  26
           5.2       Compiler "FORTRAN-77" Switch . . . . . . . . . .  32
           5.3       FOROTS Interface . . . . . . . . . . . . . . . .  33
           5.4       Subprogram Calling Conventions . . . . . . . . .  33
           5.5       Using DBMS With FORTRAN V7 . . . . . . . . . . .  34
           5.6       Incompatibilities Between Versions 5A And 6  . .  34
           6.0     INTERNAL CHANGES . . . . . . . . . . . . . . . . .  38
   FORTRA.DOC - FORTRAN-10 Version 7                               Page 3


   FORTRAN-10 -- Changes from V6 to V7
   February 1983






   1.0  SUMMARY


   Version 7 of FORTRAN-10  is  a  development  release  of  the  FORTRAN
   compiler, FOROTS, FORLIB, and FORDDT.

   FORTRAN-10 version 7 supports the FORTRAN-77 standard  at  the  subset
   level.  It also supports most of the features from the FORTRAN-77 full
   language  standard  (see  section  3.1  below).   Character  data   is
   supported in accordance with the FORTRAN-77 full language standard.

   Note that you must use LINK version 5.1 (or later) for linking the REL
   files generated by this version of FORTRAN.



   1.1  Bibliography


   The FORTRAN language and this  implementation  are  described  in  the
   reference manual:

        FORTRAN-10/20 Language Manual - AA-N383A-TK

   Two copies of this manual are enclosed with this release package.

   The installation procedures for this tape are described in:

        TOPS-10 FORTRAN Installation Guide - AA-P345A-TB

   A copy of this installation is enclosed with this release package.

   There is also a booklet  that  provides  quick  reference  information
   about FORTRAN-10/20 version 7:

        TOPS-10/20 FORTRAN Reference Card - AV-P529A-TK

   Two copies of this booklet are enclosed with this release package.

   The algorithms and accuracy of the math routines  in  FORLIB  will  be
   described in:

        TOPS-10/20 Common Math Library Reference Manual - AA-M400A-TK

   This manual will be available from SDC in May 1983.

   FORTRAN-10/20 Version 7 is based on the FORTRAN-77 standard:
   FORTRA.DOC - FORTRAN-10 Version 7                               Page 4


   American  National  Standard  Programming  Language  FORTRAN  -   ANSI
   X3.9-1978

   Copies of this standard may be obtained from:
           American National Standards Institute
           1430 Broadway
           New York, N.Y. 10018


   1.2     Monitors

   This version of Fortran will run on TOPS-10 versions 7.01,  7.01A,  or
   later

   1.3     Related System Software

   The following system software must be used with FORTRAN version 7:


        LINK 5A(2027)
        GALAXY 2 or 4.1


   The following system software must be used to build FORTRAN Version  7
   from sources:


        BLIS10  7E(227)
        MACRO  53A(1152)
        MAKLIB 2B(104)
        SCAN    7D(623)
        HELPER 7D(47)


   The following optional software may be used with FORTRAN Version 7:


        SORT 4C(467)
        DBMS 5A(422)



   2.0  NEW FEATURES

   2.1  Summary Of Enhancements To The Product


   The following is a summary of the major features that in FORTRAN-10/20
   version 7 that were not in version 6:

        1.  Character data at the FORTRAN-77 full language level.

            Supported features include character  assignments,  character
            relationals,   substrings,   concatenation,   and   character
            functions  and  arguments,  including  functions  and   dummy
   FORTRA.DOC - FORTRAN-10 Version 7                               Page 5


            arguments  of length *.  Character data is supported in DATA,
            COMMON, and EQUIVALENCE statements, and in formatted, binary,
            and image mode I/O.  See section 2.2 below for more details.

        2.  IF THEN ELSE

        3.  DO WHILE and END DO statements

        4.  Expressions on output lists

        5.  Intrinsic  and  generic  functions  at  the  FORTRAN-77  full
            language level

        6.  Internal files ( single-record and multi-record )

        7.  FORTRAN-77 DO loop semantics

        8.  Assumed-size array declarators

        9.  ASSIGN of FORMAT statement numbers

       10.  INTRINSIC statement;  FORTRAN-77 semantics for  the  EXTERNAL
            statement

       11.  SAVE statement

       12.  Support of null argument lists for functions

       13.  Support of FORTRAN-77 statement ordering rules.

       14.  Minor syntax extensions required by the FORTRAN-77 standard

       15.  Compiletime constant expressions in  declarations,  as  array
            bounds and string bounds

       16.  FORTRAN-77 PARAMETER statements

       17.  Expressions as specifier values in  OPEN  statements  and  in
            control information lists in I/O statements

       18.  Optional linktime typechecking of subprogram arguments

       19.  New functionality in the ERRSET subroutine

       20.  Utility subroutine to get a free unit number

       21.  Additional runtime warnings

   FORTRA.DOC - FORTRAN-10 Version 7                               Page 6


   2.2  Character Data

   2.2.1  Features Supported For Character Data -

   FORTRAN-10/20 version 7 supports character data as  specified  by  the
   full  language  FORTRAN-77  standard.   This  includes support for the
   following features (please see the FORTRAN-10/20 Language  Manual  for
   more information about these features):

        1.  Character constants and symbolic constants

        2.  Character variables and arrays

        3.  Character relational expressions

        4.  Character assignment statements

            Note that in addition to  meeting  the  requirements  of  the
            FORTRAN-77   standard,   version  7  supports  the  following
            extensions:
             o  Version 7 supports the assignment of character  constants
                to  non-character variables.  This is an extension to the
                FORTRAN-77 standard.  It is supported  for  compatibility
                with previous versions.
             o  Version 7 supports assignment statements in  which  there
                is  overlap  between  the left and right hand sides.  The
                results  of  such  an  assignment  will  be  as  if   the
                expression  on  the  right  hand  side were assigned to a
                temporary and  then  the  value  of  the  temporary  were
                assigned to the left hand side.


        5.  Substring reference and definition

            Note that the user  may  optionally  specify  that  substring
            bounds   checking   be  performed  at  execution  time.   The
            /DEBUG:BOUNDS switch enables both array bounds and  substring
            bounds checking.

        6.  Character expressions, including the concatenation operator

            Note that version 7 extends the FORTRAN-77 standard to  allow
            concatenation  of  formal parameters that are length *.  This
            extension is also provided by VAX FORTRAN.

        7.  Character variables and constants in DATA statements

            FORTRAN version 7 supports the  initialization  of  character
            variables,  arrays,  and  substrings  to  character  constant
            values as specified by  the  FORTRAN-77  standard.   It  also
            supports   the  use  of  character  constants  to  initialize
            non-character  variables.   This  is  an  extension  to   the
            FORTRAN-77  standard,  which  is  supported for compatibility
            with previous versions.
   FORTRA.DOC - FORTRAN-10 Version 7                               Page 7


        8.  Character variables, array elements, arrays,  and  substrings
            in input lists

            According to the FORTRAN-77 standard, the A  edit  descriptor
            is  the only legal edit edit descriptor for input/output list
            items if type character.  Version 7 extends the  standard  to
            allow  the  G edit descriptor as well.  The G edit descriptor
            behaves like the A edit descriptor for  list  items  of  type
            character.   Note  that  R  edit descriptors (which are a DEC
            extension to the standard) are NOT  supported  for  character
            data.

        9.  Character  constants,  variables,  array  elements,   arrays,
            substrings, and expressions in output lists

            (Note:  Character data is supported in formatted, binary, and
            image  mode  files.   It is not supported in dump mode files,
            because character data does not necessarily begin on  a  word
            boundary.  )

       10.  Character functions (intrinsic functions, external functions,
            and statement functions that return values of type character)

            In the object code for a call to a  character  function,  the
            character  descriptor  for the return value is passed as what
            is normally the first argument.  If you write a  function  of
            type character in assembly language, you can use

                   DMOVE AC,@0(16)

            to load AC with a byte pointer to the location to  which  the
            result  should  be  returned, and AC+1 with the length of the
            result expected by the caller.  The first  explicit  argument
            is obtained from @1(16).

       11.  Dummy and actual arguments of type character

            FORTRAN-10/20 extends the  standard  to  provide  support  of
            character  constants  as  actual  arguments  corresponding to
            dummy arguments that are  integer,  real,  double  precision,
            complex,  or  logical  as well as character.  This support is
            provided by means of a limited type checking facility that is
            supported  by  LINK version 5.1.  Note that this feature only
            works when both caller and callee  have  been  compiled  with
            FORTRAN  version  7.   If  a  subprogram was compiled with an
            earlier version of FORTRAN, it will not contain the REL  file
            blocks  that  LINK  uses  to  recognize that a fix-up must be
            performed on the character argument.

            This feature does not work when  the  name  of  the  function
            called is itself a dummy argument, and therefore is not known
            at compiletime or linktime.

            If an actual argument is of  type  character  and  is  not  a
            constant,  then  the  corresponding  dummy  must  be  of type
   FORTRA.DOC - FORTRAN-10 Version 7                               Page 8


            character.  If a dummy argument is of  type  character,  then
            the corresponding actual must be of type character.

            Actual arguments  may  be  longer  than  corresponding  dummy
            arguments.    Length  *  may  be  used  for  character  dummy
            arguments

       12.  FORTRAN-77 intrinsic functions that operate on character data

            LEN, INDEX, CHAR, ICHAR, LGE, LGT, LLE, LLT

       13.  Character variable names, array element names,  array  names,
            and substring names in EQUIVALENCE statements

            It  is  illegal  to  equivalence  a  numeric  variable  to  a
            character  variable.   This  is  a  restriction  in  both the
            FORTRAN-77 standard and VAX FORTRAN.  This helps  to  enforce
            transportable coding practices.

            The error message for EQUIVALENCE of a numeric variable to an
            unaligned character variable is fatal.  The error message for
            EQUIVALENCE of a numeric variable to a word-aligned character
            variable is non-fatal.

       14.  Character variables and arrays in COMMON blocks

            If a character variable or character array  is  in  a  COMMON
            block,  all  of  the entities in that common block must be of
            type character.  This is a restriction in both the FORTRAN-77
            standard  and  VAX  FORTRAN.  Specification of a COMMON block
            that contains both character and numeric data will result  in
            a  non-fatal  warning  message.   All  variables  other  than
            character variables will always begin  on  a  word  boundary.
            Thus  if  a  COMMON block erroneously contains both character
            and numeric data, there may be unused character positions.

       15.  Character variables and array names in namelists

            Version 7 supports substrings in namelist input, but  not  in
            namelist output.

       16.  Character variables and expressions  as  the  values  of  the
            specifiers in OPEN and CLOSE statements

       17.  Character  constants,   character   arrays,   and   character
            variables as format specifiers


   Version 7 will not support global optimization of program  units  that
   contain  character  data.   If the user specifies the /OPTIMIZE switch
   for such a program the following warning diagnostic will be issued:

   %FTNCHO Global optimization not yet supported with character data - /OPT ignored
   This message will be issued once for  each  subprogram  that  contains
   character data.
   FORTRA.DOC - FORTRAN-10 Version 7                               Page 9


   2.2.2  Internal Representation Of Character Data -

   Character strings are represented in 7-bit  ASCII.   Therefore,  there
   are  5  characters  per  word  and the collating sequence is the ASCII
   collating sequence.

   The  object  code  generated  by  FORTRAN-10/20  version  7   includes
   descriptors   for   character  variables,  primaries,  and  subprogram
   arguments.  The form of a character data descriptor is:


           0               17 18                   35
           ------------------------------------------
           !            byte pointer                !
           ------------------------------------------
           !          character count               !
           ------------------------------------------

   This is the same format of descriptor as is used for COBOL  subroutine
   arguments.


   The DDT/FORDDT symbol table entry for a character  variable  specifies
   the location of its character data descriptor.



   2.2.3  FORDDT Support For Character Data -




   2.2.3.1  Character Mode For TYPE And ACCEPT Commands -

   A mode to enable ACCEPT and TYPE for character data has been added  to
   FORDDT.

   In FORDDT version 7, /C  means  character  data  mode,  indicating  to
   FORDDT  that  the symbol table pointer is pointing to a character data
   descriptor, rather than at the character variable itself.   Note  that
   /C  was  used  by  earlier versions of FORDDT to indicate COMPLEX data
   mode, which is now indicated by /X.

   If the ACCEPT command has a bare array name followed  by  a  character
   constant,  all  the  array  elements will be filled with the character
   constant, truncated or space-padded in accordance with the  rules  for
   character constants as per the ANSI standard.

   For example, if the FORTRAN source program contains the declaration:
           CHARACTER*3 C1

   You can type out the contents of C1 from FORDDT by saying:
           TYPE C1/C

   You can store 'ABC' in C1 from FORDDT by saying:
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 10


           ACCEPT C1/C 'ABC'




   2.2.3.2  Declaration Of Character Array Bounds -

   If a program has not been compiled with the /DEBUG  switch,  a  FORDDT
   user  must  declare  his  array  dimensions  at  runtime.  For numeric
   arrays, the FORDDT "DIMENSION"  and  "DOUBLE"  commands  provide  this
   capability.

   In version 7, there is a new FORDDT command "CHARACTER" which is  used
   to  declare  the  dimensions of a character array.  The syntax of this
   command is identical to that of the "DIMENSION"  command.   Note  that
   the  string  length for the array elements is always determined by the
   user's program.  It cannot be declared in FORDDT.



   2.3  IF THEN ELSE


   Version 7 supports the Block IF, ELSE IF, ELSE, and END IF  statements
   as specified by the full FORTRAN-77 standard.




   2.4  DO WHILE And END DO Statements


   The DO WHILE and  END  DO  statements  are  useful  for  writing  well
   structured programs.

   DO WHILE / END DO support involves the following enhancements  to  the
   FORTRAN 77 standard:

        1.  Optional  statement  label  in  the  indexed  (standard)   DO
            statement.

            The syntax of the indexed DO statement is:

                 DO [s[,]] v=e1,e2[,e3]

            where s is the label of the  statement  that  terminates  the
            loop.   If  s is omitted, then the loop must be terminated by
            an END DO statement as discussed below.

        2.  DO WHILE statement

            The DO WHILE statement has the syntax:

                 DO [s[,]] WHILE (e)
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 11


            where s is the label of the  statement  that  terminates  the
            loop.   If  s is omitted, then the loop must be terminated by
            an END DO statement as discussed below.

            e is a logical expression which is tested at the beginning of
            each  execution  of  the  loop,  including the first.  If the
            value of the expression is true, then the statements  in  the
            body  of  the loop are executed;  if the expression is false,
            control transfers to the statement following the loop.

        3.  END DO statement

            The END DO statement has the form:

                 END DO

            An END DO statement terminates the range of a DO or DO  WHILE
            statement.   The END DO statement must be used to terminate a
            DO block if the DO or DO WHILE statement does not  contain  a
            statement  label.   It may also be used as a labeled terminal
            statement if the DO or DO  WHILE  statement  does  contain  a
            terminal statement label.




   2.5  Expressions On Output Lists


   An output list item can be any of the following:  A variable name,  an
   array  element  name,  a  character substring name, an array name, any
   other expression.

   (Note:  FORTRAN-10  supports  output  list  expressions  that  include
   concatenation  of  operands  of length *.  This is an extension of the
   ANSI standard that is also supported by VAX FORTRAN.)



   2.6  Intrinsic And Generic Functions


   FORTRAN  version  7  supports  all  intrinsic  and  generic  functions
   described in section 15.10 of the FORTRAN-77 standard.

   The following intrinsic functions are new in version 7:

        1.  Truncation for double precision - DINT

        2.  Nearest whole number - ANINT, DNINT

        3.  Nearest integer - NINT,IDNINT
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 12


        4.  Positive difference for double precision - DDIM

        5.  Double precision product (of real arguments) - DPROD

        6.  Character functions:

            1.  Conversion from character to integer - ICHAR

            2.  Conversion from integer to character - CHAR

            3.  Length of character entity - LEN

            4.  Location of substring - INDEX

            5.  Character comparisons - LGE, LGT, LLE, LLT


   The following generic function names have been added:
   ACOS, AINT, ANINT, ASIN, COSH, CMPLX, DBLE, DIM, LOG, LOG10, MAX, MIN,
   NINT, REAL, SINH, TAN, TANH.

   The second arument to CMPLX is now optional.

   The generic function name INT has been extended to  support  arguments
   that  are  COMPLEX  and INTEGER (in V6 it only handled REAL and DOUBLE
   PRECISION).




   2.7  Multi-record Internal Files


   Internal files provide a means of  transferring  and  converting  data
   from  internal  storage  to  internal storage.  The functionality that
   they provide  is  similar  to  that  provided  by  ENCODE/DECODE.   An
   internal  file  is  a  character  variable,  character  array element,
   character array, or character substring.   If  a  character  array  is
   used, each array element is a record in the file.  Reading and writing
   records is accomplished by sequential  access  formatted  input/output
   statements.




   2.8  FORTRAN-77 DO Loop Semantics


   The behavior of DO loops in the FORTRAN-77  standard  is  incompatible
   with  that of the earlier FORTRAN-66 standard.  Version 6 (and earlier
   versions) handled DO  loops  in  accordance  with  the  old  standard.
   Version 7 supports the new standard.

   There are two differences between FORTRAN-77 DO loops  and  FORTRAN-66
   DO loops:
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 13


        1.  In FORTRAN-77, zero trip loops are possible;  previously  all
            loops executed at least once

        2.  In FORTRAN-77, the loop index is always available after  loop
            exit;  previously it was not


   Implied DO loops in I/O statements also follow the FORTRAN-77 DO  loop
   rules.   Therefore,  the implied DO loop index will be available after
   loop exit.  The only exception to this is when an error or end-of-file
   condition occurs during execution of the I/O statement.  In that case,
   the value of the implied DO variable is indeterminate.

   FORTRAN version 7 also provides  support  of  the  old-style  DO  loop
   semantics.   The  compiletime  switch  /F66 (or /NOF77) may be used to
   specify this.  Specification of /F66 results in the following:

        1.  All DO  loops  execute  at  least  once.   (If  /F66  is  not
            specified, zero-trip semantics are used.)

        2.  There is no guarantee that the loop index will  be  available
            after  loop  exit.  (If /F66 is not specified, the loop index
            will always be available after loop exit.)


   (Note that the /F66 switch also affects the behavior of  the  EXTERNAL
   statement.)



   2.9  Assumed-Size Array Declarators


   In an array declarator for a dummy array, the upper bound of the  last
   dimension  may  be specified by an *.  Note that an assumed-size array
   cannot be used as an I/O list element, or in any other  context  where
   the length of the array must be known.  This is in accordance with the
   FORTRAN-77 standard.



   2.10  ASSIGN Of FORMAT Statement Numbers


   Scalar variables that have been ASSIGNed FORMAT statement numbers  can
   be used as format specifiers in I/O statements.

   FORTRAN version 7 does not allow the assignment  of  FORMAT  statement
   numbers  to  subscripted  variables;   nor  does it allow the use of a
   subscripted variable as a format specifier.  This  restriction  is  in
   the FORTRAN-77 standard.

   FORTRA.DOC - FORTRAN-10 Version 7                              Page 14


   2.11  INTRINSIC And EXTERNAL Statements


   The INTRINSIC statement  is  used  to  identify  a  symbolic  name  as
   representing an intrinsic function.  It permits the name to be used as
   an actual argument.

   In version 7, if the name of  an  intrinsic  function  appears  in  an
   EXTERNAL statement, that name is subsequently treated as the name of a
   user  defined  function.   This  is  accordance  with  the  FORTRAN-77
   standard.   (See  section  8.7  of the standard.) This is incompatible
   with previous versions of FORTRAN-10

   If the /F66 switch is specified at compiletime, then if  an  intrinsic
   function name appears in an EXTERNAL statement (and is not preceded by
   * or &) that name will still refer to the intrinsic function.



   2.12  SAVE Statement


   A SAVE statement is used to retain the definition of  a  variable,  an
   array,  or a named common block after the execution of a RETURN or END
   statement.

   In fact, FORTRAN-10 usually retains the definitions of all  variables,
   arrays,  and common blocks.  The only exception to this is in the case
   of overlays.

   In version 7, if a FORTRAN overlay contains any local  variables  that
   are SAVEd, all writable storage in that overlay will be preserved.  If
   a named COMMON block is SAVEd, the overlay that contains  that  common
   block will be preserved.  Blank COMMON is always preserved.

   LINK support of writable overlays is  required  for  support  of  this
   feature.  This is provided by LINK version 5.1.



   2.13  Support Of Null Argument Lists For Functions


   In version 6 it was possible to define an  external  function  with  a
   null argument list, but there was no way to reference such a function.
   Furthermore, the form of the declaration  was  incompatible  with  the
   FORTRAN-77  standard.   In  version  6  there  was no way to declare a
   statement function that had a null argument list.

   In version 7 we support the following:

        1.  The form:

                 fun()
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 15


            may be used to reference a  function  with  a  null  argument
            list.


        2.  Statement functions with null argument lists may be declared.
            A   null,   parenthesized   argument   list  appears  in  the
            declaration.

        3.  Parentheses may optionally be used for null argument lists in
            FUNCTION statements.

            The standard requires the parentheses.   Version  6  supports
            FUNCTION  statements  with  null argument lists, but does not
            allow parentheses.  Version 7 supports both forms.




   2.14  FORTRAN-77 Statement Ordering Rules


   Version 7 has relaxed some of the statement ordering restrictions that
   were  imposed  by previous versions.  Version 7 supports the statement
   ordering  rules  specified  by  section  3.6  of  the  full   language
   FORTRAN-77 standard.

   In  addition,  DATA  statements,  PARAMETER   statements,   and   type
   declarations  may  appear  in  any  order  as  long  as  there  are no
   interdependencies.  This extension to the standard is  also  supported
   by VAX FORTRAN.



   2.15  Minor Syntax Extensions


   Version 7 includes the following minor  extensions  for  compatibility
   with the FORTRAN-77 standard:

        1.  The comma is optional in  the  following:   DATA  statements,
            COMMON  statements,  assigned GOTO, after statement number in
            DO statements.

        2.  Parentheses may optionally be used for null argument lists in
            SUBROUTINE and CALL statements.

            Null subroutine argument lists were supported in  version  6,
            but parentheses were not allowed.

        3.  Statement numbers are  legal  on  non-executable  statements.
            These  statement numbers are ignored and are not available at
            execution time.
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 16


        4.  Exponentiation  to  an  integer  power  is  allowed  in   the
            subscript expressions in data statements.





   2.16  Constant Expressions


   FORTRAN Version 7  supports  constant  expressions  in  the  following
   constructs:  Array declarators, PARAMETER statements, implied-DO lists
   in DATA statements.




   2.17  FORTRAN-77 PARAMETER Statements


   FORTRAN version 7 supports PARAMETER statements in accordance with the
   FORTRAN-77  standard,  with  the  exception  that  we  do  NOT support
   compiletime expressions  that  involve  multiplication,  division,  or
   exponentiation of COMPLEX data.

   FORTRAN version 7 PARAMETER statement  support  differs  from  FORTRAN
   Version 6 in the following ways:

        1.  In FORTRAN-77, the data type of a PARAMETER is determined  by
            its   symbolic   name.    This   is   incompatible  with  the
            implementation of PARAMETER that was supported under  version
            6.   Under  version  6 the type was determined by the type of
            the constant.

        2.  In FORTRAN-77, the list of parameters  must  be  enclosed  in
            parentheses.   Under  version  6,  the  list of parameters is
            never enclosed in parenthees.

        3.  In FORTRAN-77,  the  parameter  may  be  set  to  a  constant
            expression.  FORTRAN version 6 only support simple constants.


   If the list of parameters is not enclosed in parentheses, the compiler
   assumes  that  it  is  not  a FORTRAN-77 PARAMETER statement.  In this
   case, it handles it compatibly with FORTRAN version 6,  by  using  the
   data  type  of  the  constant  rather  than that of the symbolic name.
   (Note:  If the list of parameters is not enclosed in parentheses,  and
   if  the  data  type  of the constant and the symbolic name differ, the
   compiler will issue  a  warning  message.   This  warning  message  is
   suppressed when the user compiles with the /F66 switch.)

   In version 7 (as in FORTRAN-77), PARAMETER statements may precede type
   declaration  statements  except  for those statements that specify the
   type of the parameter.
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 17


   FORTRAN-77  PARAMETER  statements  are  implemented  as  specified  by
   section  8.6  of  the FORTRAN-77 standard, with the exception that the
   compiletime expression cannot  contain  multiplication,  division,  or
   exponentiation of COMPLEX values.



   2.18  Expressions As Specifier Values In OPEN And I/O Statements


   Version 7 supports expressions as the values  of  specifiers  in  OPEN
   statements and control information lists.

   Integer expressions are supported as external unit identifiers, record
   numbers, and the values of all numeric OPEN statement specifiers.

   Character expressions are supported as format identifiers and  as  the
   values of all character OPEN statement specifiers.




   2.19  Type Checking For Function And Subroutine Arguments


   LINK version 5.1 provides a limited type checking capability.  FORTRAN
   version  7  will  generate  REL  file blocks to take advantage of this
   capability.

   The primary reason for implementing type checking in FORTRAN version 7
   and  LINK  version  5.1  is to provide support for character constants
   which are passed as actual arguments that correspond to numeric  dummy
   arguments.   This  feature  worked  in  FORTRAN  version 6 because the
   argument passing mechanism for quoted strings was by the word  address
   of the string.  This argument passing mechanism was changed in FORTRAN
   version 7 in order to support FORTRAN  77  character  data;   the  new
   argument   passing   mechanism  involves  passing  the  address  of  a
   descriptor for the string.  If the formal is numeric, then the pointer
   to  the  descriptor  will  be  changed  to  a pointer to the string at
   LINKtime.  Note that this feature only  works  when  both  caller  and
   callee have been compiled with FORTRAN version 7.  If a subprogram was
   compiled with an earlier version of FORTRAN, it will not  contain  the
   REL  file  blocks  that  LINK  uses to recognize that a fix-up must be
   performed on the character argument.

   FORTRAN version 7 will also support a new option to the DEBUG  switch.
   This  option  will  have the form /DEBUG:ARGUMENTS.  If this option is
   specified, FORTRAN will generate REL file  blocks  that  specify  that
   illegal  argument  type  mismatches  should  result in non-fatal error
   messages at load time.

   With FORTRAN version 7  and  LINK  version  5.1,  the  following  type
   checking will be performed:
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 18


        1.  If either the  caller  or  the  callee  does  not  have  LINK
            argument   descriptor   blocks,  no  type  checking  will  be
            performed.  Therefore, no type checking will be performed  on
            calls the involve old REL files.

        2.  If an actual argument  is  "passed  by  descriptor"  and  the
            corresponding  formal  is  "passed by address" then LINK will
            transform the actual argument  into  a  "passed  by  address"
            argument  in some cases.  This argument fixup was implemented
            in LINK in order to  provide  FORTRAN  support  of  character
            constants passed as actuals to numeric dummies.  Before doing
            the fixup, LINK checks that all of the  following  conditions
            are  true;  if any is not, it gives a non-fatal error message
            and does not do the fixup:
             -  The argument must be a constant.
             -  The byte pointer word in the  descriptor  in  the  user's
                image must be word aligned.
             -  The string must be in the same section  as  the  argument
                block.

            If all of the above are true, LINK puts the word  address  of
            the string into the argument block in place of the address of
            the  descriptor  for  the  string.   LINK  also  changes  the
            argument  type  code  in  the  argument block from 15 (string
            descriptor) to 17 (ASCIZ string).

            The fixup of character constants passed as actuals to numeric
            formals  will  be  done  whether  or  not  the user specified
            /DEBUG:ARGUMENTS when compiling his FORTRAN program.

        3.  If the user specified  /DEBUG:ARGUMENTS  when  compiling  his
            FORTRAN  program,  non-fatal error messages will be issued at
            LINK time for the following cases:

            1.  If the argument counts in the caller and callee disagree.

            2.  If a subroutine is called as a function or vice versa

            3.  If an actual argument is a constant and the value of  the
                corresponding  dummy  argument is potentially modified by
                the subprogram.  (Note that  if  the  dummy  argument  is
                passed   as  an  actual  to  another  subprogram,  it  is
                potentially modified.)

            4.  If the length of a character actual is less than that  of
                the  corresponding character dummy.  This is only checked
                if the length of the actual is known at compile time.

            5.  If the following associations  of  actual  argument  data
                types with dummy argument data types occur:
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 19



                Actual                     Associated Dummy
                Argument Type              Argument Type
                ------------               -------------

                Alt return label           Logical
                Alt return label           Integer
                Alt return label           Real            
                Alt return label           Double Precision
                Alt return label           G-floating      
                Alt return label           Complex         
                Alt return label           Character       

                Logical                    Alt return label
                Logical                    Integer
                Logical                    Real            
                Logical                    Double Precision
                Logical                    G-floating      
                Logical                    Complex         
                Logical                    Character       

                Integer                    Alt return label
                Integer                    Logical
                Integer                    Real            
                Integer                    Double Precision
                Integer                    G-floating      
                Integer                    Complex         
                Integer                    Character       

                Real                       Alt return label
                Real                       Logical
                Real                       Integer         
                Real                       Double precision
                Real                       G-floating      
                Real                       Complex
                Real                       Character       

                Double Precision           Alt return label
                Double Precision           Logical
                Double Precision           Integer         
                Double Precision           Real
                Double Precision           G-floating      
                Double Precision           Complex         
                Double Precision           Character       

                G-Floating                 Alt return label
                G-Floating                 Logical
                G-Floating                 Integer         
                G-Floating                 Real            
                G-Floating                 Double Precision
                G-Floating                 Complex         
                G-Floating                 Character       

                Complex                    Alt return label
                Complex                    Logical
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 20


                Complex                    Integer         
                Complex                    Real
                Complex                    Double Precision
                Complex                    G-floating      
                Complex                    Character       

                Character                  Alt return label
                Character                  Logical
                Character                  Integer         
                Character                  Real            
                Character                  Double Precision
                Character                  G-floating
                Character                  Complex         

                Octal                      Alt return label
                Octal                      Double Precision
                Octal                      G-floating
                Octal                      Complex
                Octal                      Character

                Hollerith                  Character

                Double Octal               Alt return label
                Double Octal               Logical
                Double Octal               Integer         
                Double Octal               Real            
                Double Octal               Character

                Note that in FORTRAN programs, all  arguments  that  have
                data type "character" will be "pass by descriptor", while
                all other argument  types  will  be  "pass  by  address".
                Therefore  if the actual argument is a character constant
                and the dummy is any other type, the FORTRAN special case
                action described in item 2 above will be performed.

                All combinations of data type (e.g.  octal, double octal)
                not listed in the above table are ignored.






   2.20  New Functionality In ERRSET


   The functionality of ERRSET has been enhanced in version 7.  Version 7
   provides  ERRSET trapping for additional classes of errors in addition
   to those trapping in version 6.  Also, in  version  7,  the  user  can
   write his own fixup routines for arithmetic exceptions.

   The calling sequence for ERRSET is:

   Call:
           CALL ERRSET (N)
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 21


   or      CALL ERRSET (N, I)
   or      CALL ERRSET (N, I, SUBR)

   where   N = max number of error messages to type

           I = which error this call applies to.  One of:
                  -1 any of the following
                   0 integer overflow
                   1 integer divide check
                   2 input integer overflow
                   3 input floating overflow
                   4 floating overflow
                   5 floating divide check
                   6 floating underflow
                   7 input floating underflow
                   8 library routine error 
                   9 output field width too small
                   21 FORLIB warnings
                   22 non-standard usage warnings
                      ( These warnings are described in
                           section 2.22 below.)
                   23 Array and substring bounds violations

               If I is not specified, -1 is assumed

           SUBR = routine to call on the trap

                  The effect is as if

                      CALL SUBR (I, IPC, N2, ITYPE, UNFIXED, FIXED)

                  were placed in the program just after the instruction causing
                  the trap.
                           I = error number of trap, same as above
                           IPC = PC of trap instruction for
                                   error numbers 0, 1, 4, 5, and 6
                                   ( Note: Error 0 - integer overflow - can 
                                   occur in a jump instruction such as AOJA;
                                   in that case, the value of IPC will
                                   be incorrect. This is due to a permanent
                                   restriction in the hardware. )
                                Otherwise,  PC of FOROTS call
                           N2 = 2nd error number (reserved for DEC)
                           ITYPE = data type of value
                           UNFIXED = value returned by the processor
                           FIXED =  value after fixup
                                   SUBR can change this value.

                  If SUBR is not specified, no routine is called on the APR trap.
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 22


   2.21  Utility Subroutine To Get A Free Unit Number


   FORTRAN V7 provides an additional  FORTRAN-supplied  subroutine  which
   can  be used to get an unused unit number.  The routine FFUNIT ("First
   free unit") is called by:

        CALL FFUNIT(IUNIT)

   where IUNIT is an integer variable which will be set by FFUNIT to  the
   first available unit number.

   If there are no available unit numbers, IUNIT is set to -1.



   2.22  Additional Runtime Warnings


   FOROTS version 7 issues warning messages for a number of  non-standard
   usages for which the results may be unexpected.  These warnings may be
   disabled by using the ERRSET function with error number 22.

   FOROTS version 7 issues warnings for the following:

        1.  Data  type   mismatches   between   format   specifiers   and
            corresponding  I/O  list elements.  ( Bad data will be stored
            in the I/O list elements.  )

        2.  Writing beyond the end of a fixed length record.   (The  data
            is truncated.)

        3.  Input to Hollerith fields of FORMAT statements.  (This  works
            in V7, but we may de-support it in the future.)




   3.0  RESTRICTIONS

   3.1  FORTRAN-77 Features Not Supported


   FORTRAN-10/20 version 7 supports the subset level FORTRAN-77 standard.
   It also supports most of the features in the the full level FORTRAN-77
   standard.

   The following features from the full level standard are not  supported
   by FORTRAN version 7:

        1.  The INQUIRE statement is not supported by version 7.

        2.  In version 7, comment lines and blank lines  may  not  appear
            between  an initial line and its first continuation line, nor
            may they appear between two continuation lines.
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 23


        3.  In version 7,  the  compiletime  expression  in  a  PARAMETER
            statement   cannot   contain   multiplication,  division,  or
            exponentiation of COMPLEX data.




   3.2  Other Restrictions


   Version 7 will not support global  optimization  of  subprograms  that
   contain  character  data.   If the user specifies the /OPTIMIZE switch
   for such a subprogram the warning diagnostic "/OPT  ignored"  will  be
   issued.



   4.0  KNOWN BUGS AND DEFICIENCIES

   4.1  Execute-Only


   FORTRAN and FOROTS do not  work  when  protected  EXECUTE-ONLY.   This
   problem will be fixed in the first autopatch of version 7.

         o  Patch to make the compiler execute-only

            If you want to protect the compiler execute-only, you can  do
            so if you install the following DDT patch to FORTRA.EXE:

            443/ JSP 10,400031     JSP 10,143

            454/ JRST 400062       JRST 174

            455/ JSP 10,400031     JSP 10,143

            463/ JRST 400062       JRST 174

            If you prefer to make a source patch  to  the  compiler,  the
            source  patch  is  as follows.  Note that you should save the
            original source for autopatch.
            File 1)        V7AC:MAIN.BLI[4,504]    created: 1849 12-Jan-1983
            File 2)        DSK:MAIN.BLI[4,714]     created: 1141 03-Feb-1983

            1)1    GLOBAL BIND MAINV = 7^24 + 0^18 + #1710;         ! Version Date: 5-Jan-83
            1)     
            ****
            2)1    GLOBAL BIND MAINV = 7^24 + 0^18 + #1725;         ! Version Date: 3-Feb-83
            2)     
            **************
            1)1    ***** End Revision History *****
            ****
            2)1    ***** End V7 Development *****
            2)     
            2)     1725    TFV     3-Feb-83
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 24


            2)             Add FORLINK linkage to  statistics routines PHASBEGIN,  PHASEND,
            2)             and RNTIME.  This cures the execute only problem on the -10.
            2)     
            2)     ***** End Revision History *****
            **************
            1)2    ROUTINE PHASBEGIN=
            1)     BEGIN
            ****
            2)2    ROUTINE FORLINK PHASBEGIN=              ![1725] Use FORLINK linkage
            2)     BEGIN
            **************
            1)3    ROUTINE PHASEND=
            1)     BEGIN
            ****
            2)3    ROUTINE FORLINK PHASEND=                ![1725] Use FORLINK linkage
            2)     BEGIN
            **************
            1)4    ROUTINE RNTIME=
            1)     BEGIN
            ****
            2)4    ROUTINE FORLINK RNTIME=         ![1725] Use FORLINK linkage
            2)     BEGIN
            **************

         o  Patch to make FOROTS execute-only

            If you want to  protect  FOROT7.EXE  execute-only,  you  must
            install  edit  3266 to FORFMT.MAC.  Note that you should save
            the original source for autopatch.
            File 1)        V7AO:FORFMT.MAC[4,707]  created: 1817 13-Jan-1983
            File 2)        DSK:FORFMT.MAC[4,704]   created: 1030 11-Feb-1983

            1)1            TV      FORFMT  FORMAT PROCESSOR,7(3250)
            1)     
            ****
            2)1            TV      FORFMT  FORMAT PROCESSOR,7(3266)
            2)     
            **************
            1)1    ***** End Revision History *****
            ****
            2)1    ***** End V7 Development *****
            2)     
            2)     3266    JLC     11-Feb-83
            2)             Allows FOROTS to be protected execute-only on TOPS-10.
            2)     
            2)     ***** End Revision History *****
            **************
            1)8    %IFSET: SKIPA   T1,[JRST DATIN]         ;SETUP FOR INPUT
            1)     %OFSET: MOVE    T1,[JRST DATOUT]        ;SETUP FOR OUTPUT
            1)             MOVEM   T1,DATENT
            1)             MOVEM   P,OTHERP                ;SAVE THE CURRENT PDP
            ****
            2)8    %IFSET: XMOVEI  T1,DATIN                ;[3266] SETUP FOR INPUT
            2)             JRST    COMSET                  ;[3266]
            2)     %OFSET: XMOVEI  T1,DATOUT               ;[3266] SETUP FOR OUTPUT
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 25


            2)     COMSET: MOVEM   T1,DATENT               ;[3266]
            2)             MOVEM   P,OTHERP                ;SAVE THE CURRENT PDP
            **************
            1)21           PUSHJ   P,DATENT                ;READ OR WRITE A RECORD
            1)             MOVE    T1,ENC.AD               ;GET ENCODED BLOCK ADDR
            ****
            ;**;[3266] @ EXELP + 6L, change 1 line, JLC, 11-Feb-83
            2)21           PUSHJ   P,@DATENT               ;[3266] READ OR WRITE A RECORD
            2)             MOVE    T1,ENC.AD               ;GET ENCODED BLOCK ADDR
            **************
            1)23   DATLP1: PUSHJ   P,DATENT                ;GO DO INPUT OR OUTPUT
            1)             SKIPN   T1,IO.INC               ;ADD OFFSET TO I/O ADDR
            ****
            2)23   DATLP1: PUSHJ   P,@DATENT               ;[3266] GO DO INPUT OR OUTPUT
            2)             SKIPN   T1,IO.INC               ;ADD OFFSET TO I/O ADDR
            **************
            1)23   NODATA: PUSHJ   P,DATENT                ;DO INPUT OR OUTPUT
            1)             MOVEI   T1,2                    ;ON TO NEXT FORMAT
            ****
            2)23   NODATA: PUSHJ   P,@DATENT               ;[3266] DO INPUT OR OUTPUT
            2)             MOVEI   T1,2                    ;ON TO NEXT FORMAT
            **************




   4.2  Mandatory Patches For Related Products


   None



   4.3  Known Deficiencies In Related Products



        1.  Do NOT install DBMS edit 10500.

            This is an edit to the module DBGATE in DBSFOR.REL.   It  was
            required  in  order  to build DBMS with FORTRAN Version 6 and
            was described in the FORTRAN Version  6  Installation  Guide.
            This  patch  to  DBGATE is also done by the FORTRAN version 6
            autopatch tape 5;  therefore you should be careful to  use  a
            version  of  DBGATE  that  has not been autopatched with this
            tape.

        2.  FOROTS version 7 cannot handle magtapes with blocksize larger
            than  4096  words per block because of a bug in versions 7.01
            and 7.01A of the TOPS-10 operating system.  TOPS-10 MCO 10563
            fixes  this  problem.   This  will  be  included  in the next
            autopatch of the TOPS-10 operating system.

   FORTRA.DOC - FORTRAN-10 Version 7                              Page 26


   5.0  COMPATIBILITY WITH PREVIOUS VERSIONS

   5.1  Incompatibilities Between Versions 6 And 7



         o  Changes in the behavior of OPEN statements

            1.  OPEN statements with no FORM  or  MODE  specifier  behave
                differently  in  version  7  than  they did in version 6.
                This  change  only  affects   programs   that   do   file
                positioning operations (BACKSPACE or SKIPRECORD) of files
                opened with no FORM or MODE specifier.

                If an OPEN statement  does  not  specify  FORM  or  MODE,
                version  6 allows the FORM= attribute to be determined by
                the  first  IO  statement  executed.   Version  7  always
                determines  whether  a  file  is FORMATTED or UNFORMATTED
                when  an  OPEN  statement  is  executed.   If  the   OPEN
                statement  does not include a FORM= or a MODE= specifier,
                it defaults in accordance with the  FORTRAN-77  standard.
                The default is:

                 o  If the OPEN statement  specifies  ACCESS='DIRECT'  or
                    ACCESS='RANDOM'  or ACCESS='RANDIN', then UNFORMATTED
                    (BINARY)

                 o  Otherwise, FORMATTED (ASCII)


                In order to minimize the impact of this  incompatibility,
                FORTRAN   version   7   will  support  formatted  I/O  to
                unformatted files and unformatted I/O to formatted files.
                After  such an I/O operation has occurred to a file, that
                file will be considered to be a "mixed form" file and all
                file  positioning operations ( BACKSPACE and SKIPRECORD )
                will be illegal.

                For example, version  7  will  issue  a  fatal  error  at
                runtime for the following:

                   OPEN(UNIT=1, FILE='FOO') ! Formatted OPEN
                   READ (UNIT=1) X         ! Unformattted READ; this makes the
                                           !  the file have "mixed form"
                   SKIPRECORD (UNIT=1)     ! It is illegal to do SKIPRECORD
                                           ! to a mixed form file



                The user can  fix  his  program  by  modifying  the  OPEN
                statement to include the FORM specifier.

                This functionality is NOT affected by the /F66 switch.
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 27


            2.  The behavior of OPEN on a connected unit has been changed
                to satisfy the requirements of the FORTRAN-77 standard.

                If the OPEN statement contains a "STATUS=OLD"  specifier,
                then  its  behavior depends on whether the file specified
                by the OPEN is the same file that is currently  connected
                to  the  unit.   If it is a different file, the connected
                file is closed and the new file is opened.  If it is  the
                same  file,  the file is not closed, and the file pointer
                is not moved.  This is a requirement  of  the  FORTRAN-77
                standard.   This  behavior  is  not  affected by the /F66
                switch.

                Version 6 did not check for the  case  where  the  second
                OPEN  refers  to  the  same  file  as the first OPEN.  It
                always closes the file and reopens it.

            3.  In FORTRAN version 6, if the RECORDSIZE specification  in
                an  OPEN  statement for a BINARY file conflicted with the
                record size actually found in  the  file,  no  error  was
                indicated.   In  version  7  this  is  a fatal error.  In
                addition, if a type 2, or continuation-type LSCW (logical
                segment  control  word)  is  found  in a file for which a
                RECORDSIZE specification has been given,  this  too  will
                yield  a  fatal error, as files written with a RECORDSIZE
                specification should not have type 2 LSCWs.   This  error
                was also not detected by version 6.


         o  Changes in the behavior of I/O statements

            1.  Changes in formatted I/O

                The treatment of special characters  in  formatted  files
                has  been  changed  in  order to enable users to read and
                write character variables that contain these  characters,
                and to improve the performance of formatted I/O.

                 o  Formatted input for files OPENed  with  fixed  length
                    records

                    In version 7, when formatted input  is  done  from  a
                    file  with  fixed  length records, all characters are
                    read exactly as they appear in the file.  The  number
                    of  characters read is always equal to the RECORDSIZE
                    (RECL) specified in the  OPEN  statement.   Thus,  in
                    version  7, A-format input from a fixed length record
                    will read NUL, CR, LF, FF, or VT if those  characters
                    are  within  the  record length specified in the OPEN
                    statement.

                    This differs from version 6 in two ways:
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 28


                    1.  Version 6 always terminates record input when  it
                        encounters  CR,  LF, FF, or VT, regardless of the
                        RECORDSIZE.

                    2.  Version 6 ignores NULs.


                 o  Formatted input for files OPENed with variable length
                    records

                    In version 7, A-format input from a  variable  length
                    record  reads  all  NULs  that  are  interior  to the
                    record.  Version 6 ignores them.  (Note:  Since  line
                    terminators  terminate the record, version 7 does not
                    read them.  )

                    As in version 6,  leading  NULs  in  variable  length
                    records  are  still  ignored.   This  is necessary in
                    order to support variable length input  from  a  file
                    that  was  written with fixed length output.  This is
                    because fixed length  records  are  word-aligned  and
                    inter-record gaps contain NULs.

                 o  A-format output (for both fixed and  variable  length
                    records)

                    In  version  7,  A-format  output  writes   out   all
                    characters    exactly   as   they   appear   in   the
                    corresponding I/O  list  variables.   In  version  6,
                    blanks  were substituted for NULs.  This is no longer
                    done.

                 o  Padding of fixed length records

                    In version 7, fixed length records in formatted files
                    are  padded  with blanks.  In previous versions, they
                    were padded with NULs.  (The user can specify the pad
                    character  desired  by  using  PADCHAR=  in  his OPEN
                    statement.  Space is the default.)


            2.  Change in multi-record ENCODE/DECODE

                In previous versions of FORTRAN, the character  count  in
                ENCODE  and  DECODE statements was interpreted as a total
                string count, and a  "/"  format  or  indefinite  repeat,
                which  for normal files causes a new record to be read or
                written, aligned the record  pointer  to  the  next  word
                boundary.   In  V7, the count specified is interpreted as
                an internal record size in characters, and "/" format  or
                indefinite repeat cause the record pointer to be advanced
                to the next internal record.

   FORTRA.DOC - FORTRAN-10 Version 7                              Page 29


         o  New Runtime Warning Messages

            1.  In FORTRAN V6 and all previous  versions,  Hollerith  and
                quoted  string input to FORMAT statements was allowed and
                not flagged with any warning.  FORTRAN  V7  will  give  a
                warning  message,  as it is illegal according to the ANSI
                Standard, and some future version  of  the  compiler  may
                compile  or  pool FORMATs, thus disallowing Hollerith and
                quoted string input altogether.

                This warning may be disabled with the ERRSET function.

            2.  In  FORTRAN  V6,  data  type  mismatches  between  format
                specifiers  and  I/O  list  items  were  ignored.  FOROTS
                Version 7 issues a warning for this.  This warning may be
                disabled with the ERRSET function.


         o  Changes that affect assembly language subprograms


            1.  In FORTRAN V6, if a quoted string is an  actual  argument
                to a MACRO subprogram, the argument block that is pointed
                to by AC 16 contains the address of the ASCIZ string.  In
                FORTRAN  V7, the argument block contains the address of a
                two-word descriptor block, in which the first word  is  a
                byte  pointer  to  the string (which will in fact be word
                aligned and ASCIZ) and the second word is the  length  of
                the string.

            2.  In FORTRAN V6 and previous  versions,  calls  to  ALCHN.,
                DECHN.,  FUNCT.,  ALCOR.,  and DECOR.  could have indexed
                arguments  and   ACs   specified   as   arguments.    For
                performance  reasons,  this  capability has been removed.
                Users were warned about this upcoming change  in  the  V6
                manual.

            3.  In versions 6 and before (all the way back to LIB40),  an
                instruction  followed  by  JFCL works as follows:  If the
                instruction is  "JFCL  0,addr",  do  not  type  an  error
                message,  fix  up the result of the instruction, and jump
                to addr.  If the instruction is "JOV addr",  do  type  an
                error  message,  do  fix up the result, and jump to addr.
                The behavior of JOV is different under version 7:  do NOT
                type an error message, do NOT fix up the result, and jump
                to addr.  This makes JOV behave the same under  the  trap
                handler  as  it  does under the hardware.  "JFCL 0," will
                not change.


         o  Changes in the behavior of declarations

            1.  In version 7, if the name of  an  intrinsic  function  is
                specified  in  an EXTERNAL statement that name is treated
                as the name of a user-defined function.   In  version  6,
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 30


                the  function name is treated as the name of an intrinsic
                function.  (In version 6, this kind of EXTERNAL statement
                was  used  to  allow  the  intrinsic  function name to be
                passed as a subprogram argument.)

                If the /F66 switch is specified, EXTERNAL statements  are
                processed compatibly with version 6.

            2.  FORTRAN version 7  supports  the  FORTRAN-77  syntax  and
                semantics  for  PARAMETER  statements.  This is different
                from the version  6  implementation;   however,  the  old
                syntax/semantics also works under version 7 except that a
                warning is issued when it  is  used.   (This  message  is
                suppressed  in the /F66 compilation switch is specified.)
                In particular:
                 o  In version 7, the list of parameters must be enclosed
                    in   parentheses.    If   it   is   not  enclosed  in
                    parentheses, a warning message is issued.
                 o  In version 7, the  data  type  of  the  PARAMETER  is
                    determined   by   its   symbolic   name,  unless  the
                    parentheses  around  the  parameter  list  have  been
                    omitted.   If the parentheses have been omitted, then
                    the data type is determined in the same way as it was
                    in version 6, which is by the type of the constant.


            3.  In Version 7, a type declaration of a generic function is
                ignored.   This  is  in  accordance  with  the FORTRAN-77
                standard.  This functionality is not affected by the /F66
                switch.

                The  interpretation  of  type  declarations  of   generic
                functions  by  FORTRAN Version 6 was not consistent.  For
                example, if SIN was declared to be  double  precision  it
                was  subsequently  treated  as a user function name.  The
                compiler did no type checking on its arguments and a call
                to "SIN" (not "SIN.") was generated.  However, if SIN was
                declared to be real  it  was  treated  as  a  non-generic
                library  function  name.   The  compiler checked that its
                argument in all subsequent calls was real, and a call  to
                "SIN." was generated.


         o  DO loops

            Under FORTRAN version 7, the iteration count for  a  DO  loop
            may  be  zero.   Under  version 6, all loops were executed at
            least once.  The /F66 switch may be specified at  compiletime
            to cause DO loops to be executed compatibly with version 6.

         o  FORDDT

            1.  In version 7 of FORDDT, /C is used  for  CHARACTER  mode.
                In  version  6, /C was used for COMPLEX mode.  In version
                7, /X is used for COMPLEX mode.
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 31


         o  Old  version  5A  constructs  that  generate  warnings  under
            version 6

            FORTRAN-10/20 version 6 issues warning messages for a  number
            of constructs that are fatal in version 7.

            1.  In FORTRAN version 5A the character  '/'  could  be  used
                instead  of ':' to separate the upper and lower bounds in
                a dimension declarator.  In version 6, use of '/'  causes
                a  non-fatal  warning  message  to  be issued.  Version 7
                supports constant expressions in array declarations,  and
                therefore  in  version  7  the  '/'  will be treated as a
                division operator.

            2.  In version 5A the character '#' could be used to separate
                the unit and record numbers in random I/O statements.  In
                version 6, this use of '#'  causes  a  non-fatal  warning
                message  to be issued.  In version 7 the '#' is parsed as
                a .NE.  operator in the expression for the  unit  number;
                this   then   results  in  the  fatal  error  "Relational
                expression illegal as UNIT specifier".

            3.  In version 5A, a subscripted reference could be  used  in
                an  assigned  GOTO  statement.   This  feature  was never
                documented.  In version 6, use of this feature  causes  a
                non-fatal  warning  message  to  be issued.  In version 7
                this will be illegal.  (This is because in FORTRAN-77 the
                comma  in  an  assigned  GOTO  is  optional.  Without the
                comma, use of a subscripted reference in an assigned GOTO
                is ambiguous.)


         o  Other

            1.  The error numbers associated with certain  fatal  runtime
                errors   have   changed,   and  some  errors  which  were
                previously warnings are now fatal.   In  particular,  all
                errors  whose first error number was 799 in version 6 now
                have 97 as the first  error  number;   all  errors  whose
                first  number  was  899 now have 98.  All errors in these
                two error classes are now fatal.

            2.  In  FORTRAN  V6,  quoted  literals  could  be  passed  as
                arguments  to  numeric  formals.   In  FORTRAN  V7, those
                quoted literals are treated as character  constants,  and
                are  passed  by  descriptor.   In  most  cases,  V7  will
                continue to support passing these  constants  to  numeric
                formals.   A LINKtime fixup will be done to support this.
                Note that this feature only works when  both  caller  and
                callee  have  been compiled with FORTRAN version 7.  If a
                version 7 program calls a subprogram  that  was  compiled
                with  an  earlier version of FORTRAN, the subprogram will
                not contain  the  REL  file  blocks  that  LINK  uses  to
                recognize   that  a  fix-up  must  be  performed  on  the
                character argument.
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 32


                If the name of the  function  being  called  is  a  dummy
                argument, then the LINKtime fixup cannot be done.





   5.2  Compiler "FORTRAN-77" Switch


   There will be a compiletime switch which will specify whether  certain
   constructs  should  be  interpreted  compatibly  with  the  FORTRAN-77
   standard or compatibly with previous versions  of  FORTRAN.   The  two
   values of this switch are:

        /F77 - FORTRAN-77 compatible

        /F66 (or /NOF77) - Version 6 compatible

   The default value of this switch is /F77.

   The following constructs will  behave  differently  depending  on  the
   value of this switch:

        1.  DO loops

            When /F77 is specified, 0-trip loops are possible.  When /F66
            is specified, all DO loops execute at least once.

            When /F77  is  specified,  the  loop  index  will  always  be
            available  after loop exit.  When /F66 is specified, there is
            no guarantee that the loop index will be available after loop
            exit.

        2.  Use of intrinsic function names in EXTERNAL statements

            If the name of an instrinsic function appears in an  EXTERNAL
            statement, but is not preceded by * or &:

            1.  When /F77 is specified, the name is subsequently  treated
                as the name of a user defined function.

            2.  When /F66 is specified, the  name  still  refers  to  the
                intrinsic function.


        3.  PARAMETER statements

            The   warning   message   for   non-parenthesized   PARAMETER
            statements is suppressed when /F66 is specified.

   FORTRA.DOC - FORTRAN-10 Version 7                              Page 33


   5.3  FOROTS Interface


   Programs that are compiled with FORTRAN version  7  must  be  executed
   with FOROTS version 7 and FORLIB version 7.  If you inadvertantly load
   version 6 FORLIB/FOROTS with a .REL file that  was  generated  by  the
   version 7 compiler the you may get the runtime error:

        ?Data in IO list but not in format

   Other errors may also occur.

   In most cases, programs that were compiled with FORTRAN version 6 will
   work  with FORLIB/FOROTS version 7;  however, we cannot guarantee that
   this is always true.  In you encounter a problem  running  a  V6  .REL
   file with the new FORLIIB/FOROTS, you must recompile.

   MACRO programs that search FORPRM.UNV should be reassmebled  with  the
   version 7 FORPRM in order to use version 7 FORLIB and FOROTS.



   5.4  Subprogram Calling Conventions


   In most cases subprograms compiled under version 6 can  be  called  by
   subprograms  compiled  under version 7 and vice-versa.  The exceptions
   to this are:

        1.  If a subprogram is compiled with version 7,  it  cannot  pass
            character or quoted string arguments to a subprogram compiled
            with an earlier version of FORTRAN.

            The LINKtime  fixup  of  actual  arguments  that  are  quoted
            strings  only  works  when  both  caller and callee have been
            compiled  with  FORTRAN  version  7.   If  a  subprogram  was
            compiled  with  an  earlier  version  of FORTRAN, it will not
            contain the REL file blocks that LINK uses to recognize  that
            a fix-up must be performed on the character argument.

        2.  If a  version  7  subprogram  has  dummy  arguments  of  type
            character,  it cannot be called by a subprogram compiled with
            an earlier version of FORTRAN.

        3.  Subprograms that do  I/O  must  be  compiled  with  the  same
            version  of FORTRAN.  We cannot guarantee that FOROTS version
            7 will always work when called by subprograms  compiled  with
            the version 6 compiler.


   FORTRA.DOC - FORTRAN-10 Version 7                              Page 34


   5.5  Using DBMS With FORTRAN V7


   The FORTRAN/DBMS interface has been thoroughly  reworked  for  FORTRAN
   V7.   Instead  of  the  DBMS  files being merged into FORLIB, they are
   placed in a separate file called SYS:DBMSF.REL, which is  searched  by
   LINK  after  FORLIB.REL  if  the  program  contains DBMS calls.  Under
   normal circumstances, a  FORTRAN/DBMS  program  will  use  a  combined
   FOROTS/DBMS  file called FDBOT7.EXE for its sharable high segment.  If
   the user desires to use /OTS:NONSHARE to load FOROTS with the program,
   DBMS  will  also be loaded with the program.  Additionally, there is a
   new switch provided - %DBSNS - which, if it is defined  before  FORLIB
   is  searched,  will  load  DBMS  with the user's program regardless of
   whether the sharable FOROTS is used.

   Examples:

   1.  Using sharable FOROTS/DBMS (the default action):

           .LOAD program

   causes the user program to be loaded and uses the sharable  FDBOT7.EXE
   for calls to FOROTS and DBMS.

   2.  Using sharable FOROTS with DBMS loaded with the user's program:

           .R LINK
           *program/DEFINE:%DBSNS/G

   causes the user program to be loaded with DBMS  to  use  the  sharable
   FOROT7.EXE for calls to FOROTS.

   3.  Using nonsharable FOROTS and DBMS:

           .R LINK
           *program/OTS:NONSHARE/G

   causes the user program to be loaded with FOROTS and DBMS.



   5.6  Incompatibilities Between Versions 5A And 6


   There were a number of changes introduced between versions 5A and 6 of
   FORTRAN.   If  your  site  is  converting  directly from version 5A to
   version 7, you should also be aware of the following:

        1.  The constructs '' and 0H which were legal in version  5A  are
            illegal in versions 6 and 7.

            In version 5A, '' produced a string of 5 spaces.  In versions
            6  and 7, a string of one space (' ') should be used for this
            purpose.
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 35


            In version 5A, 0H produced a word of nulls.   In  versions  6
            and  7,  a numeric 0 should be used to initialize a Hollerith
            string with nulls.  In version 7,  CHAR(0)  can  be  used  to
            represent the character NUL.

        2.  Numeric differences

            There were a number of changes made between versions 5A and 6
            to  improve  the  numeric accuracy of results.  These changes
            can  propagate  through  a  calculation  to  produce   larger
            differences in final results.

             o  The mathematical functions in FORLIB were  rewritten  for
                increased accuracy.

             o  The floating point input and output  routines  of  FOROTS
                were made more accurate, so that the numbers they produce
                (both internally and externally) are more accurate  (and,
                therefore different) than those produced by version 5A.

             o  The maximum number of  digits  encoded  by  the  floating
                point output routine was increased in version 6 over that
                encoded by version 5A.  Thus printing with  format,  say,
                E30.20 will produce different results with version 6 than
                with version 5A:  for  both  real  and  double  precision
                numbers  the  number  of non-zero digits has increased to
                20.

             o  Integer division by 0 now returns  the  largest  possible
                integer  value  having  the  sign  of  the numerator.  In
                version 5A, the value returned was the numerator.


        3.  In FORTRAN versions 6 and 7  the  default  interpretation  of
            blanks  in  formatted  files  is  BLANK=NULL,  unless no OPEN
            statement has been executed.  This is a  requirement  of  the
            FORTRAN-77  standard.   It is incompatible with version 5A in
            which blanks are always treated as 0's.

        4.  A string of consecutive linefeeds is treated as one  linefeed
            by 5A;  version 6 treats them as multiple records.

        5.  The functions DFIX  and  IDFIX  have  been  replaced  by  the
            equivalent IDINT.

        6.  DIALOG input may be terminated by a carriage return.  Altmode
            invokes  command recognition and so does not terminate dialog
            input.  If it is necessary  to  type  extremely  long  dialog
            responses, either type over the line boundary without hitting
            carriage return, or use - (hyphen) at the end of the line  as
            a continuation character.

        7.  In versions 6 and 7, when a READ takes the ERR=  branch,  the
            file  is  positioned after the erroneous record.  A BACKSPACE
            may be used to position the file before the erroneous record;
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 36


            otherwise  the  next  READ  will get the record after the one
            with the error.  This is different  than  version  5A,  which
            leaves the file positioned before the erroneous record.

            If it is desired to reread the erroneous record  and  specify
            an ERR= branch, you can now use REREAD with an ERR= branch.

        8.  The BLOCKSIZE parameter of the OPEN statement specifies  tape
            block  size  in  bytes.   In  version  5A,  the block size is
            specified in words.

        9.  If RECORDSIZE is specified when opening a file, and the  file
            contains records that are not of the specified size, behavior
            will differ between version 5A and version 6.   In  formatted
            mode  5A  reads  until  it  finds  a  CRLF, 6 reads until the
            specified  number  of  characters   have   been   read.    In
            unformatted  mode  5A  reads  until the I/O list is satisfied
            (and no farther), 6 reads until the specified number of words
            have  been  read.   Reading  BINARY-mode files with the wrong
            record size is fatal with both versions.

       10.  When reading list-directed I/O (* format), 5A reads '4* 5' as
            '5,5,5,5'.  6 reads it as ',,,,5' (4 null items followed by a
            5).  Files written with 5A can contain repeat counts followed
            by  spaces,  and  so  will  be  interpreted incorrectly by 6.
            Files written by 6 can be read by 5A.

       11.  FOROTS V6 does not  ignore  nulls  encountered  in  a  DECODE
            statement,  whereas V5A did.  Null is an illegal character in
            many of the conversion routines.

       12.  The action of the CLOSE statement has changed in  version  6,
            such  that specification of any file parameters (e.g.  FILE=)
            will cause a rename to be performed.  Version 5A only did the
            rename if it detected an actual change.

       13.  With version 6, recordsize is enforced for input files.   The
            actual  record size used is the record size specified, plus 2
            for the carriage return, line feed sequence, plus the padding
            necessary  to  bring the record to a word boundary.  Thus the
            formula is ((RECSIZ+6)/5)*5.  Records read using a RECORDSIZE
            specification  in the OPEN statement must have precisely this
            calculated number of characters.  FOROTS no longer stops upon
            reading  an  end-of-line  character,  nor  scans for them, in
            advancing  to  the  next  record.    However,   a   premature
            end-of-line  character  within  a  record  will terminate the
            characters read into the FOROTS internal record buffer.

       14.  CALL ERRSET (n) now tells FOROTS to print out n  warnings  of
            each  type.   ERRSET extensions...  CALL ERRSET(n,i) to set a
            limit for  a  specific  error,  CALL  ERRSET(n,i,x)  to  call
            subroutine  x  when  the  error  occurs,  after  FOROTS error
            actions have occurred.
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 37


       15.  Sequential files written with version 6 without a record size
            specified  are  not  padded  with  nulls  to a word boundary,
            whereas version 5A padded to a word boundary to be compatible
            with FORSE files.  This means that files written sequentially
            without a record size specified in the OPEN  statement  will,
            in general, not be readable as random-access files.

       16.  With Version 5A, BLOCKSIZE for  magtape  files  always  meant
            words,  and  the  default  was  128 words for TOPS-10 and 512
            words for TOPS-20.  With version 6, BLOCKSIZE  is  in  bytes,
            36-bit bytes for binary and image mode files, and 7-bit bytes
            for formatted (ASCII) files.  The default is still 128  words
            for  TOPS-10  (640  bytes  for  formatted files), but is 1000
            bytes for TOPS-20 (i.e., different blocksizes  for  formatted
            and unformatted files).

       17.  The definitions of X and T formats have changed from 66 to 77
            for  output  statements.   With  -77, T and X do not actually
            write blanks, they merely position the record pointer.   Only
            the  actual  data  sets  the  record  size, so that (A5,100X)
            writes a 5-character record whereas  (A5,100X,' ')  writes  a
            106 character record.

       18.  With list-directed and namelist I/O, logical  input  data  is
            strictly defined as an optional period, followed by a T or F,
            followed by any set of non-terminator characters.  There will
            no  longer  be  any diagnostic messages given for such trashy
            input.

       19.  The default field width for F (with no field width  supplied)
            for  output  is  dependent  on  the  type  of the variable in
            version 6, and expands for extremely  large  numbers,  rather
            than  producing  asterisks.  In version 5A, the default field
            width was invariant for data type.

       20.  As an extension to the  ANSI  standard,  list-directed  input
            will  accept  any data type for any variable type, and do the
            kind of conversion done by the compiler.  This is  also  true
            for  data preceded with a repetition count (e.g.  2*5.6 input
            to a real variable and an integer variable will  provide  5.6
            to  the  real  variable  and 5 to the integer variable).  The
            exception is that if complex data is specified for  a  double
            precision  variable,  the  DOUBLE PRECISION value of the real
            part is transmitted to the  double  precision  variable  (the
            compiler  truncates  it  to a single precision value and sets
            the 2nd word of the double precision variable to 0).

       21.  With list-directed and NAMELIST I/O, certain  types  of  data
            with no delimiters are interpreted differently by versions 5A
            and  6.   For  instance,  with  version  5A,  -1-1  are  read
            differently  depending  on  whether  the target variables are
            integer or real:  it reads two values of minus 1 for integer,
            and  -1E-1 for real.  Version 6 always reads -1-1 as a single
            value (-1E-1) and converts it appropriately.
   FORTRA.DOC - FORTRAN-10 Version 7                              Page 38


       22.  The ANSI standard specifies that random-access files have  no
            end.   Version  6  obeys  this  rule,  which is a change from
            version 5A.  Thus the END= branch will never  be  taken,  and
            should   not   be   used,  for  random-access  data  transfer
            statements.

       23.  For formatted data and  binary  unformatted  data,  the  ERR=
            branch will be taken for any unwritten record, whether in the
            middle or at the end of the file.  Since there is no  way  to
            know whether data has been written in an image mode file, the
            ERR= branch cannot be used for this purpose  for  image  mode
            files.

       24.  In version 6, dollar format is  defined  as  suppressing  the
            carriage  return  and  one  line  feed  (if  any)  that would
            normally appear if  the  next  data  transfer  were  a  WRITE
            statement,  or  the  automatic  <carriage return - line feed>
            sequence that would normally be inserted  by  FOROTS  if  the
            next data transfer were a READ statement.  Version 5A did not
            suppress the line feed for the succeeding WRITE.

       25.  There  is  no  support  in  version  6  for  KA10s   or   for
            F40-generated  code.   Also, support for the FOROTS version 1
            calling sequence has been removed.




   6.0  INTERNAL CHANGES


   Both FOROTS and the  compiler  have  been  substantially  modified  to
   support  the new features that are in this release.  Complete revision
   histories are contained in REVHST.MAC (for the  compiler),  FORHST.MAC
   (for   FOROTS),  MTHHST.MAC  (for  the  math  library  routines),  and
   FORDDT.MAC (for FORDDT).

   [End of FORTRA.DOC]
