

















                      TOPS-10 STOPCODES SPECIFICATION








                                 April 1986



                  This document  describes  stopcodes  for
                  the   TOPS-10   monitor,   GALAXY,   and
                  DECnet-10 software.
|  
|  
|  
|  OPERATING SYSTEM:                  TOPS-10 Version 7.03
|                                     GALAXY Version 5.1
|  
|  SOFTWARE:                          DECnet-10 Version 4.0
















                                     1










                                            First Printing, December 1980
                                                      Revised, April 1986



   The information in this document is subject to change  without  notice
   and  should  not  be  construed  as  a commitment by Digital Equipment
   Corporation.  Digital Equipment Corporation assumes no  responsibility
   for any errors that may appear in this document.

   The software described in this document is furnished under  a  license
   and  may  only  be used or copied in accordance with the terms of such
   license.

   No responsibility is assumed for the use or reliability of software on
   equipment that is not supplied by DIGITAL or its affiliated companies.





         Copyright  C , 1980, 1986  Digital Equipment Corporation.
                            All Rights Reserved.





   The postage-prepaid READER'S COMMENTS form on the last  page  of  this
   document  requests  the  user's  critical  evaluation  to assist us in
   preparing future documentation.

   The following are trademarks of Digital Equipment Corporation:

        DEC                 MASSBUS             UNIBUS
        DECmate             PDP                 VAX
        DECsystem-10        P/OS                VMS
        DECSYSTEM-20        Professional        VT
        DECUS               Rainbow             Work Processor
        DECwriter           RSTS
        DIBOL               RSX






                                     2










                                  CONTENTS

           1.0     MONITOR STOPCODE DEFINITION  . . . . . . . . . . . . 4
           2.0     TYPES OF STOPCODES . . . . . . . . . . . . . . . . . 5
           2.1       DEBUG Stopcodes  . . . . . . . . . . . . . . . . . 6
           2.2       JOB Stopcodes  . . . . . . . . . . . . . . . . . . 6
           2.3       STOP Stopcodes . . . . . . . . . . . . . . . . . . 7
           2.4       CPU Stopcodes  . . . . . . . . . . . . . . . . . . 8
           2.5       HALT Stopcodes . . . . . . . . . . . . . . . . . . 9
           2.6       INFO Stopcodes . . . . . . . . . . . . . . . . . . 9
           3.0     CONTINUABLE STOPCODES  . . . . . . . . . . . . . . . 9
           4.0     LIST OF MONITOR STOPCODES  . . . . . . . . . . . .  11
           5.0     LIST OF DECNET-10 STOPCODES  . . . . . . . . . . . 112
           6.0     LIST OF GALAXY-10 STOPCODES  . . . . . . . . . . . 134

































                                     3



                                  PREFACE                                  PREFACE



   This document briefly  describes  the  TOPS-10  monitor,  GALAXY,  and
   DECnet-10  stopcodes.   This  specification was designed to assist the
   user in analyzing stopcode  messages,  to  investigate  and  undertake
   corrective  action  when  the  TOPS-10  monitor,  GALAXY, or DECnet-10
   software unexpectedly fails.



   Audience Requirements   Audience Requirements


   The following manuals provide additional information for analyzing and
   regenerating a TOPS-10 monitor, GALAXY, and DECnet-10 software.

         o  TOPS-10 Software Installation Guide describes procedures  for            _______ ________ ____________ _____
            generating and installing TOPS-10 and GALAXY software.

         o  DECnet-10  Network  Generation  and  Installation  Procedures            _________  _______  __________  ___  ____________  __________
            describes   the  procedures  for  generating  and  installing
            DECnet-10    software     on     DECsystems-1090/1091     and
            DECSYSTEM-2020.

         o  DECnet-10 System Manager's and Operator's Guide describes the            _________ ______ _________ ___ __________ _____
            operational, control, and monitoring facilities of DECnet-10.

         o  TOPS-10  Operator's  Guide  describes   the   procedure   for            _______  __________  _____
            reloading a TOPS-10 system.

         o  TOPS-10 Crash Analysis  Guide  describes  how  to  analyze  a            _______ _____ ________  _____
            crash, and how to prevent future monitor errors.

         o  TOPS-10/TOPS-20  Batch  Reference   Manual   describes   user            _______________  _____  _________   ______
            procedures for the TOPS-10 and TOPS-20 batch systems.

         o  TOPS-10/TOPS-20 SPEAR Manual  describes  the  SPEAR  program,            _______________ _____ ______
            which provides a dump to help analyze a hardware errors.

|  
|  
|  
|  1.0  MONITOR STOPCODE DEFINITION        MONITOR STOPCODE DEFINITION
|  
|  This section describes the  TOPS-10  monitor  stopcodes.   A  stopcode
|  message  is  generated when the monitor detects a serious error in its
|  database.  This section describes the types of monitor stopcodes, then
|  briefly explains and illustrates continuable stopcodes.
|  
|  When the TOPS-10 monitor encounters an internal error it issues a one-


                                     4



|  to  six-character  name  called  a  stopcode  name.   The  stopcode is
|  displayed on the console terminal (CTY) and  alerts  you  of  possible
|  system  failure, depending on the severity of the error.  The stopcode
|  message is generated by a stopcode macro when the monitor  detects  an
|  error in the database.  This macro prints the following message on the
|  CTY:
|  
|       ?Stopcode xxxyyy, Type=type, on CPUn at <date/time>
|  
|  Where:
|  
|       xxxyyy    is the stopcode name.        xxxyyy
|  
|       type      is the type of stopcode.   Stopcode  types  are  listed        type
|                 below.
|  
|       n         is the CPU number.        n
|  
|       date/time is the time of day and date when the stopcode occurred.
|  



   2.0  TYPES OF STOPCODES        TYPES OF STOPCODES

   The stopcodes are divided into categories, depending on  the  severity
   of  the  error that cause the stopcode, and the portions of the system
   that might be affected by the error.  The types of  monitor  stopcodes
   are:

        1.  DEBUG stopcodes indicate internal  errors  only.   These  are
            continuable stopcodes.

        2.  JOB stopcodes indicate that the error  may  endanger  a  user
            job.  These are continuable stopcodes.  Only the job that was
            running when the stopcode occurred will be stopped.

        3.  STOP stopcodes indicate errors  that  might  endanger  system
            operation.  These are not continuable stopcodes.

        4.  CPU  stopcodes  indicate  errors   that   prevent   continued
            operation of a CPU.  In a single-CPU configuration, or if the
            CPU that encountered the stopcode was the only CPU running at
            the  time, the CPU stopcode is equivalent to a STOP stopcode.
            If there are other CPUs running in an  SMP  configuration  at
            the  time  of  the stopcode, a dump is taken and the affected
            CPU halts.  Any job that was running on the affected  CPU  at
            the time of the stopcode is stopped.

        5.  HALT stopcodes indicate fatal errors that  halt  the  system,
            and, by definition, are not continuable.



                                     5



        6.  INFO stopcodes are continuable stopcodes that  are  generated
            to inform the system operator of a system event.

   The monitor generates a stopcode using the STOPCD  macro.   There  are
   several  modules  in the monitor, however, that use the BUG.  macro to
   generate a stopcode.  These modules are common  to  both  TOPS-10  and
   TOPS-20.   They  generate  three  types  of BUG.  stopcodes, which are
   equivalent to the following types of stopcodes:

        BUG. Type      STOPCD Type        ____ ____      ______ ____

        HLT            STOP
        CHK            DEBUG
        INF            INFO




   2.1  DEBUG Stopcodes        DEBUG Stopcodes

   A DEBUG stopcode is a stopcode that is not immediately harmful to  any
   job  or  to the system.  When the monitor encounters an internal error
   at the interrupt level, a dump is performed and processing  continues.
   The  following  message  is  printed  on  the  CTY  after the stopcode
   notification:
|  
        [Continuing system]



   2.2  JOB Stopcodes        JOB Stopcodes

   A  JOB  stopcode  indicates  that  an  internal  error  endangers  the
   integrity  of  the  job that is currently running.  The monitor aborts
   the current job and continues processing.

   The following message  is  printed  on  the  CTY  after  the  stopcode
   notification:
|  
        [Aborting job]

   On the user's terminal, the following message is displayed:

        ?Monitor error at {user/exec} PC nnnnnn;  UUO at  {user/exec}  PC
        mmmmmm

   Where:

        nnnnnn and  mmmmmm  are  one  of  the  following  virtual  memory        nnnnnn      mmmmmm
        locations:




                                     6



         o  User location nnnnnn;

         o  Exec location nnnnnn;  Exec called from exec location mmmmmm

         o  Exec location nnnnnn;  Exec called from user location mmmmmm




        2.3  STOP Stopcodes             STOP Stopcodes

        A STOP stopcode indicates an internal error  that  endangers  the
        integrity  of  the  entire  system.  All jobs are aborted and the
        system begins to dump and reload the monitor automatically.   The
        monitor  prints  the  following  message  on  the  CTY  after the
        stopcode notification:
|  
             Reload monitor

        If the monitor obtains the necessary  information,  it  prints  a
        supplementary message on the CTY of the form:

             JOB jobn on TTYnnn running name                 jobn       nnn         name
             UUO is octal representation at user PC address                    octal representation            address
             File filespec                  filespec

        Where:

        jobn                is the number of the job causing the error.        jobn

        nnn                 is the number  of  the  job  controlling  the        nnn
                            terminal.

        name                is the name of the program running  for  that        name
                            job.

        octal               is the octal representation of the monitor        octal
        representation      call failing for that job.        representation

        address             is the value of the program counter for  that        address
                            job.

        filespec            is the file specification for the file  being        filespec
                            accessed.










                                     7



   2.4  CPU Stopcodes        CPU Stopcodes

   A CPU stopcode is handled differently, depending on the number of CPUs
   in  the  configuration  running  at  the  time  of  the  crash.  For a
   single-CPU system, a CPU stopcode  has  the  same  effect  as  a  STOP
   stopcode.  When a CPU stopcode occurs on the only processor running in
   a multiprocessor (SMP) system, the  effect  is  the  same  as  a  STOP
   stopcode.  All user jobs are aborted and the system begins to dump and
   reload the monitor automatically.  The following message is printed on
   the  CTY  of  the CPU that experienced the failure, after the stopcode
   notification:

        Reload monitor

   However, in a SMP system where more than one CPU  is  running  at  the
   time  of  the  stopcode,  the  CPU  stopcode  aborts the job currently
   running, a dump is taken, and the CPU that  encountered  the  stopcode
   halts.

   For SMP systems in which more that one CPU is running,  the  following
   message  is  displayed  on  the  CTY  for the CPU that encountered the
   stopcode:

        [Stopping CPU]

   If  the  monitor  obtains  the  necessary  information,  it  prints  a
   supplementary message on the CTY of the form:

        Job jobn on TTYnnn Running name            jobn       nnn         name
        UUO is octal representation at user PC address               octal representation            address
        File filespec             filespec

   Where:

        jobn                is the number of the job causing the error.        jobn

        nnn                 is the number  of  the  job  controlling  the        nnn
                            terminal.

        name                is the name of the program running  for  that        name
                            job.

        octal               is the octal representation of the monitor        octal
        representation      call failing for that job.        representation

        address             is the value of the program counter for  that        address
                            job.

        filespec            is the file specification for the file  being        filespec
                            accessed.




                                     8



   2.5  HALT Stopcodes        HALT Stopcodes

   A HALT stopcode indicates a fatal error and affects the entire system.
   The  monitor  cannot  automatically reload.  The system halts, and you
   must manually dump and reload the  monitor.   (Refer  to  the  TOPS-10                                                                  _______
   Operator's Guide.)   __________ _____

   HALT stopcodes generate the following message:

        KL HALTED.
|  
|  
|  
|  2.6  INFO Stopcodes        INFO Stopcodes
|  
|  An INFO stopcode is a report on a system event that may be of interest
|  in  debugging crashes.  These stopcodes are for informational purposes
|  only, and do not interrupt system or job execution.



   3.0  CONTINUABLE STOPCODES        CONTINUABLE STOPCODES

   Continuable stopcodes occur when the monitor executes a STOPCD  macro,
   dumps  the memory image, and continues the system automatically.  HALT
   and STOP stopcodes are not continuable.  A CPU stopcode is continuable
   on SMP systems where more than one CPU is running (see Section 2.4).

   The following examples illustrate three  continuable  DEBUG  stopcodes
   and a JOB stopcode, as displayed on the CTY:


   Example 1:   Example 1:

        ?CPU0 monitor error. Stopcode name is ICN


        CPU Status Block on 30-May-86 19:29:21

        CONI APR, = 001060,,004102
        CONI PI, = 000000,,000777
        CONI PAG, = 000000,,020000
        DATAI PAG, = 500100,,000002
        [Dumping on DSK:CRASH.EXE[1,4]]
        [Continuing system]

   Example 2:   Example 2:

        ?CPU1 monitor error. Stopcode name is EUE
        Job 5 on TTY1 running DDT User [1,2]
        UUO is 0 at user PC 002472



                                     9



        CPU Status Block at 4-Oct-86 8:16:36

        APRID = 000231,,342002
        ERA = 600000,,040513
        CONI APR, = 007760,,000003
        CONI PI, = 000000,,000377
        CONI PAG, = 000000,,620001
        DATAI PAG, = 700100,,002255
        AR ARX Data Word = 000000,,057000
        IO Page Fail Word = 000000,,000000

        SBUS Diags:

        CNTRLR FNC 0          FNC 1
        000004 007040,,040610 000200,,000000

        [Dumping on DSK:CRASH.EXE[1,4]]
        [Continuing system]


   Example 3:   Example 3:

        ?CPU1 monitor error. Stopcode name is IEZ
        File DSKE0:OPSER.LOG[1,2]
        Job 1 on CTY running OPSER User [1,2]
        [Dumping on DSK:CRASH.EXE[1,4]]
        [Continuing system]


   The following example illustrates  a  JOB  stopcode  message  that  is
   displayed on the CTY:

        %DECsystem-10 not running


        ?CPU0 monitor error.  Stopcode name is IME
        Job 1 on TTY5 running FH702 User [1,2]
        UUO is 47240040770 at user PC 006477



        CPU Status Block on 24-Jan-86 15:06:00

        APRID = 640336,364654
        ERA = 024000,,006451
        CONI APR, = 007760,000001
        CONI PI, = 000000,,000377
        CONI PAG, = 000000,,660001
        DATAI PAG, = 700100,,001340
        AR ARX Data Word = 000000,,000000
        IO Page Fail Word = 000000,,000000



                                     10



        SBUS Diags: 

        CNTRLR FNC 0           FNC 1
        000004 001740,,017321 000200,,000000
        000010 006160,,006603 000500,,001000

        [Dumping on BLUI:CRASH.EXE[1,4]]
        [Aborting Job]

        [DECsystem-10 Continued]

   The same JOB stopcode message would also appear on the job's terminal,
   in addition to the following message:

        ?Monitor error at user PC 006476



   4.0  LIST OF MONITOR STOPCODES        LIST OF MONITOR STOPCODES

   A list of stopcodes for all systems that run the  TOPS-10  monitor  is
   presented  on  the  following  pages  in alphabetical order.  The list
   shows the name of each stopcode,  the  calling  module,  the  type  of
   stopcode,  a  phrase  message  (for which the name is a symbol), and a
   brief explanation of the containing routine, the error that caused the
   stopcode, and any data items that can be helpful in analyzing dumps.

   Several stopcodes are generated  by  both  the  KSSER  and  the  KLSER
   modules.   For  these  types  of stopcode, the following list uses the
   module name KxSER, to indicate that the stopcode is generated by KLSER
   on a KL processor and KSSER on a KS processor.



   Name    Module   Type    Message and Explanation   ____    ______   ____    _______ ___ ___________


   AAD     FILFND   DEBUG   Access Table Already Dormant

                            ATNLNK unlinks an access table  from  a  name
                            block  (NMB) ring.  This stopcode occurs when
                            an attempt is made to make  an  access  table
                            dormant, but the table is already dormant.

               Data Items:  T1 = location of access table
                            T2 = location of predecessor
                            T3 = location of next in ring


   AAO     KxSER    JOB     Access Allowed Is Off

                            After paging  a  job,  the  monitor  converts


                                     11



                            virtual  IOWDs  into  absolute  IOWDs.   This
                            stopcode occurs  while  checking  the  access
                            bits  for  a page pointed to by the IOWD, and
                            access to that page is not allowed.

               Data Items:  T1 = total number of words accumulated so far
                            T2 = number of words for current page
                            T3 = current page number within this segment
                            T4 = next page number within this segment (T4
                            is the page that was not allowed access)


   ADn     COMMON   CPU     Address Parity Error for CPU n

                            This stopcode occurs when Bit 29 is on in the
                            CONI  APR.  This is a serious hardware error.
                            Call your Field Service representative.


   AES     FILFND   JOB     Abnormal End of Search List

                            SLXAES  is  called  from  several  places  in
                            FILFND.    This   stopcode  occurs  for  many
                            reasons, such  as  unexpectedly  encountering
                            the end of a search list.


   AHS     ONCMOD   STOP    Already Have Structure

                            DMKSTR sets up structures according to tables
                            in  ONCMOD  for  the  DESTROY  option.   This
                            stopcode occurs when  a  duplicate  structure
                            name is found in the table.

               Data Items:  T1 = duplicate structure name
                            P2 = address of structure data block
                            P3 = address of previous structure data block
                            or DIFSTR if this is the only structure
                            P4  =  system  structure   number   of   this
                            structure
|  
|  
|  ALW     FILUUO   JOB     ACCESS TABLE LINKED WRONG.
|  
|  
|  ANFAIB  NETSER   STOP    No buffer set up when advancing input
|  
|                           When  attempting  to  finish  processing  the
|                           filling  of  the current user's input buffer,
|                           no input buffer (DEVAXI) is found to  be  set
|                           up.



                                     12



|              Data Items:  F = address of DDB
|  
|  
|  ANFAOB  NETSER   STOP    No buffer set up when calling NTDAOB
|  
|                           When  attempting  to  finish  processing  the
|                           emptying of the current user's output buffer,
|                           no output buffer (DEVAXO) is found to be  set
|                           up.
|  
|              Data Items:  F = address of DDB
|  
|  
|  ANFBLW  NETSER   STOP    Buffer Length Wrong
|  
|                           On a call to MKNPCB/MKUPCB to allocate an ANF
|                           Protocol  Control  Block,  the  length of the
|                           data buffer associated with the PCB  did  not
|                           match  the  calculated length.  (The PCBs are
|                           stored in free lists sorted by the  PCB  data
|                           buffer size.)
|  
|              Data Items:  U = address of PCB
|                           T1 = length of PCB data buffer, in words
|                           T2 = length PCB data buffer should be
|  
|  
|  ANFCGM  NETSER   STOP    Can't Get Message
|  
|                           After   a    call    to    PCBECK    returned
|                           "guaranteeing"  the  availablity  of  an  ANF
|                           network Protocol Control Block, a  subsequent
|                           call to PCBEGT to get a free PCB failed.
|  
|  
|  ANFCIL  NETSER   STOP    Connect Initiate message too Long
|  
|                           An  attempt  was  made  to  send  a   Connect
|                           Initiate  (or  possibly  a  Connect  Confirm)
|                           message    that    exceeded    the    maximum
|                           "reasonable" size of a connect message.
|  
|              Data Items:  F = address of DDB
|                           W = address of NDB
|                           P3 = byte count for proposed connect message
|  
|  
|  ANFCLA  NETSER   STOP    LAT still assigned in CLNNDB
|  
|                           CLNNET  was  called  to  "clean  up"  an  ANF
|                           network Device Data Block, but the DDB claims
|                           to still  be  connected  to  a  remote  node.


                                     13



|                           (CLNNET  should  be  called  only  after  the
|                           device has been disconnected.)
|  
|              Data Items:  F = address of network DDB
|  
|  
|  ANFCND  NETSER   STOP    CLNNDB has no DDB
|  
|                           CLNNET  was  called  to  "clean  up"  an  ANF
|                           network  Device  Data  Block,  but register F
|                           contained zero.
|  
|  
|  ANFDDQ  NETSER   STOP    Data Request count went negative
|  
|                           The  count  of  outstanding   data   requests
|                           available for a network device went negative.
|  
|              Data Items:  F = address of DDB
|  
|  
|  ANFDLA  NETSER   STOP    No DLA on disconnect
|  
|                           When disconnecting an ANF network  device,  a
|                           call  to  NCSDSC  discovered  that  the DDB's
|                           Destination Link Address was zero.
|  
|              Data Items:  F = address of DDB
|  
|  
|  ANFDMU  NETSER   STOP    Data buffer Messed Up
|  
|                           On a call to MKNPCB/MKUPCB to allocate an ANF
|                           Protocol  Control  Block,  a  free PCB's data
|                           buffer check words were found  to  have  been
|                           corrupted.    The   memory  word  immediately
|                           preceding  the  data  buffer  should  contain
|                           SIXBIT/NET/  in its left half, and the memory
|                           word immediately following  the  data  buffer
|                           should contain SIXBIT/NETMEM/.
|  
|              Data Items:  U = address of free PCB
|                           T1 = contents of bottom-end check word
|                           T2 = contents of top-end check word
|  
|  
|  ANFDRQ  NETSER   STOP    Data Request count negative
|  
|                           When processing a Data Request message for  a
|                           device  from  a remote node, the current data
|                           request count was negative.



                                     14



|              Data Items:  F = address of DDB
|  
|  
|  ANFDRZ  NETSER   STOP    Sending Data Requests to device 'zero'
|  
|                           A call to NCSDRQ to send data requests  to  a
|                           remote   node  discovered  that  the  network
|                           device's Destination Link Address  field  was
|                           zero.
|  
|              Data Items:  F = address of DDB
|  
|  
|  ANFDS1  NETSER   STOP    Can't send Disconnect message (no PCB?)
|  
|                           After   a    call    to    PCBECK    returned
|                           "guaranteeing"  the  availability  of  an ANF
|                           network Protocol Control Block, a  subsequent
|                           call to PCBEGT to get a free PCB failed.
|  
|  
|  ANFFCW  NETSER   STOP    Free PCB Count Wrong
|  
|                           The PCBSEC routine encountered a  discrepancy
|                           in  a  PCB  free list:  the free list counter
|                           claimed  there  are  no  free  PCBs  in  this
|                           particular  list,  yet  the  free  list chain
|                           contains at least one free PCB.
|  
|              Data Items:  T2 = index into NTFREC/NTFREF tables
|  
|  
|  ANFFEK  NETSER   STOP    FEK bad, FEKOAD and FEKOCT in conflict
|  
|                           On a call to NETWRT/FRCWRT to queue an output
|                           network  Protocol  Control  Block  to  an ANF
|                           network Front End Kontroller, the FEK  output
|                           queue  was  found  to  be  inconsistent:  the
|                           count of output PCBs as specified  by  FEKOCT
|                           did  not  match  the  actual  output queue in
|                           FEKOAD.
|  
|              Data Items:  U = address of PCB
|                           J = address of FEK
|                           T3 = actual count of PCBs in FEKOAD queue
|  
|  
|  ANFGFK  NETSER   STOP    Garbage FEK pointer
|  
|                           Some routine  attempted  to  convert  an  ANF
|                           network  Front  End  Kontroller  (data block)
|                           address into a logical line number,  but  the


                                     15



|                           FEK address in not in the FEK chain (that is,
|                           the FEK does not exist).
|  
|              Data Items:  J = address for non-existant FEK
|  
|  
|  ANFIFC  NETSER   STOP    Illegal FEKINT function code
|  
|                           An ANF network Front  End  Kontroller  called
|                           NETSER's  FEK interrupt service (FEKINT) with
|                           an illegal function code in T1.
|  
|              Data Items:  J = address of FEK
|                           T1 = FEK interrupt function code
|  
|  
|  ANFINP  NETSER   STOP    Input done interrupt with no input buffer
|  
|                           An ANF network Front  End  Kontroller  called
|                           NETSER's  FEK  interrupt  service (FEKINT) to
|                           process an "input done" interrupt yet had  no
|                           ANF  network Protocol Control Block specified
|                           in either FEKIDN or FEKIAD (depending on  the
|                           interrupt function code).
|  
|              Data Items:  J = address of FEK
|  
|  
|  ANFLAA  NETSER   STOP    LAT Already Assigned
|  
|                           When attempting to establish a connection  to
|                           a remote device's node, the Device Data Block
|                           was found to  already  have  a  Link  Address
|                           Table entry.
|  
|              Data Items:  F = address of DDB
|                           T1 = LAT address
|  
|  
|  ANFLAT  NETSER   STOP    DDB and LAT don't agree
|  
|                           When freeing up an ANF  network  Device  Data
|                           Block,  a  call to GIVSLA discovered that the
|                           DDB's link address did not match the  network
|                           Link  Address  Table.  (The LAT entry did not
|                           point back to the DDB which points to the LAT
|                           entry.)
|  
|              Data Items:  F = address of DDB
|                           P2 = DDB's link address (index into LAT)




                                     16



|  ANFLCC  NETSER   STOP    Not in confirm wait -- LAT table messed up
|  
|                           While waiting for a Connect Initiate  message
|                           to  be answered, the Link Address Table state
|                           for the  device  transited  into  an  illegal
|                           state  (a state that was neither success, nor
|                           failure, nor still-waiting).
|  
|              Data Items:  F = address of DDB
|                           T1 = LAT state
|  
|  
|  ANFLDD  NETSER   STOP    LAT and DDB disagree
|  
|                           When disconnecting an ANF network  device,  a
|                           call to NCSDSC discovered that the DDB's link
|                           address  did  not  match  the  network   Link
|                           Address  Table.  (The LAT entry did not point
|                           back to the  DDB  which  points  to  the  LAT
|                           entry.)
|  
|              Data Items:  F = address of DDB
|  
|  
|  ANFMBL  NETSER   STOP    Buffer length wrong
|  
|                           On a call to RMVPCB to free up an ANF network
|                           Protocol  Control  Block, the PCB data buffer
|                           length was found to be too large (larger than
|                           the maximum allowable data buffer size).
|  
|              Data Items:  U = address of PCB
|                           T2 = PCB data buffer length, modulo MSGAGW
|  
|  
|  ANFMDL  NETSER   STOP    Must have a DLA assigned
|  
|                           While trying to format an ANF network  output
|                           message header, a device was found to have no
|                           Destination Link Address set.
|  
|              Data Items:  F = address of DDB
|                           U = address of PCB
|  
|  
|  ANFMRL  NETSER   STOP    Message Request too Large
|  
|                           A  call  was  made   to   the   MKNPCB/MKUPCB
|                           routine(s)   to   allocate   an  ANF  network
|                           Protocol Control Block  (data  buffer)  which
|                           exceeded the maximum configured message size.



                                     17



|              Data Items:  T1 = requested PCB size, in words
|  
|  
|  ANFMSQ  NETSER   STOP    Message queues are screwed up
|  
|  
|  ANFNCT  NETSER   STOP    NCT processors shouldn't skip
|  
|                           An  internal-to-NETSER   message   processing
|                           routine  took  a  "skip" return, which should
|                           never happen.
|  
|              Data Items:  U = probably an address of a PCB
|  
|  
|  ANFNFI  NETSER   STOP    Sending Node ID to the null FEK
|  
|                           An attempt was made to send an  ANF  Node  ID
|                           message  to  the  null  Front End Kontroller.
|                           The null  FEK  never  goes  offline,  and  so
|                           should never come online, and so should never
|                           need to be greeted with a Node ID message.
|  
|              Data Items:  J = address of FEK
|  
|  
|  ANFNFK  NETSER   STOP    This is the null FEK
|  
|                           The monitor received and processed a Node  ID
|                           message  from  the null Front End Kontroller.
|                           Since NETSER never sends a Node ID  over  the
|                           null FEK, it should never receive one.
|  
|  
|  ANFNFP  NETSER   STOP    No free PCBs or no free messages
|  
|                           After   a    call    to    PCBECK    returned
|                           "guaranteeing"  the  availability  of  an ANF
|                           network Protocol Control Block, a  subsequent
|                           call to PCBEGT to get a free PCB failed.
|  
|  
|  ANFNIL  NETSER   STOP    Not at Interrupt Level
|  
|                           The main ANF network service loop NETSCN  was
|                           called at a level other than interrupt level.
|  
|  
|  ANFNNT  NETSER   STOP    No NDB for Terminal
|  
|                           In the process  of  disconnecting  a  network
|                           terminal,  no Node Data Block can be found to


                                     18



|                           match the remote node number as specified  in
|                           the terminal's LDB (LDPRNN pointer).
|  
|              Data Items:  U = address of terminal LDB
|  
|  
|  ANFNPL  NETSER   STOP    No PCBs on List
|  
|                           A call was made to CLNFEK to "clean  up"  and
|                           reinitialize   an   ANF   network  Front  End
|                           Kontroller (data block).  The count of queued
|                           transmit  Protocol  Control Blocks (contained
|                           in FEKOCT) did not match  the  actual  output
|                           PCB chain (starting with FEKOAD).
|  
|              Data Items:  J = address of FEK
|  
|  
|  ANFNUL  NETSER   STOP    Null FEK being "cleaned"
|  
|                           A call was made to CLNFEK to "clean  up"  and
|                           reinitialize   an   ANF   network  Front  End
|                           Kontroller (data block),  but  the  specified
|                           FEK  was the so-called null FEK, which should
|                           never go offline.
|  
|              Data Items:  J = address of FEK
|  
|  
|  ANFNWA  NETSER   STOP    Node Went Away
|  
|                           When disconnecting an ANF network  device,  a
|                           call  to  NCSDSC discovered that the device's
|                           remote node  "went  away"  (the  node  is  no
|                           longer in communication with the local host).
|                           In this  case,  the  device  service  routine
|                           should  have simply destroyed the DDB, rather
|                           than  trying  to  disconnect  it  first  (for
|                           example, just call ZAPNET).
|  
|              Data Items:  F = address of DDB
|  
|  
|  ANFOBS  NETSER   STOP    Obsolete feature
|  
|                           On a call to ZAPPCB to deallocate (and return
|                           to  the  monitor's general purpose free pool)
|                           an ANF network Protocol Control Block, a  PCB
|                           was  found  to  own a "secondary" data buffer
|                           (in addition to the primary data  buffer),  a
|                           feature no longer in use.



                                     19



|              Data Items:  U = address of PCB
|  
|  
|  ANFOUT  NETSER   STOP    Output done interrupt with no PCB
|  
|                           An ANF network Front  End  Kontroller  called
|                           NETSER's  FEK  interrupt  service (FEKINT) to
|                           process an "output done" interrupt,  yet  had
|                           no ANF network Protocol Control Block address
|                           in FEKODN.
|  
|              Data Items:  J = address of FEK
|  
|  
|  ANFPCC  NETSER   STOP    Count of PCBs on list is wrong
|  
|                           A call was made to CLNFEK to "clean  up"  and
|                           reinitialize   an   ANF   network  Front  End
|                           Kontroller (data block).  The count of queued
|                           transmit  Protocol  Control Blocks (contained
|                           in FEKOCT) did not match  the  actual  output
|                           PCB chain (starting with FEKOAD).
|  
|              Data Items:  J = address of FEK
|  
|  
|  ANFPCL  NETSER   STOP    PCB lists screwed up
|  
|                           On a call to MKNPCB/MKUPCB to allocate an ANF
|                           Protocol   Control   Block,  the  PCB  "free"
|                           list(s) were found to be  inconsistent.   The
|                           PCB   free  pool  consists  of  linked  lists
|                           (sorted by PCB size) of unused (and therefore
|                           available  to  be  re-used)  free  PCBs.  The
|                           count of free PCBs disagrees with the  length
|                           of the linked list of free PCBs.
|  
|              Data Items:  U = address of (alleged) free PCB
|                           T2 = index  into  NTFREC/NTFREF  linked  list
|                           table
|  
|  
|  ANFPCM  NETSER   STOP    PCB data buffer check words trashed
|  
|                           On a call to RMVPCB to free up an ANF network
|                           Protocol  Control  Block, the PCB data buffer
|                           check words were found to be corrupted.   The
|                           memory  word  immediately  preceding the data
|                           buffer should contain SIXBIT/NET/ in its left
|                           half,   and   the   memory  word  immediately
|                           following  the  data  buffer  should  contain
|                           SIXBIT/NETMEM/.


                                     20



|              Data Items:  U = address of PCB
|                           T1 = contents of bottom-end check word
|                           T2 = contents of top-end check word
|  
|  
|  ANFPCR  NETSER   STOP    PCB tag word trashed
|  
|                           On a call to RMVPCB to free up an ANF network
|                           Protocol  Control Block, the PCB was found to
|                           be corrupted, either the PCBTAG word did  not
|                           contain   SIXBIT/PCBTAG/,  or  the  PCB  data
|                           buffer length  was  not  a  proper  size  (in
|                           particular,  was not a multiple of the MSGAGW
|                           allocation "granularity").
|  
|              Data Items:  U = address of PCB
|                           T1 = contents of PCBTAG word
|                           T2 = length of PCB data buffer
|  
|  
|  ANFPCT  NETSER   STOP    PCB trashed
|  
|                           On a call to MKNPCB/MKUPCB to allocate an ANF
|                           Protocol Control Block, an unused PCB removed
|                           from the PCB free lists was found to  contain
|                           junk  in  the PCBTAG check word (which should
|                           contain SIXBIT/PCBTAG/).
|  
|              Data Items:  U = address of unused PCB
|                           T1 = contents of PCBTAG word
|  
|  
|  ANFPCV  NETSER   STOP    PCB not valid
|  
|                           On a call to NETWRT/FRCWRT to queue an output
|                           network  Protocol  Control  Block  to  an ANF
|                           network Front End Kontroller, the  PCB  check
|                           word  was  found to be corrupted.  The PCBTAG
|                           word    of    the    PCB    should    contain
|                           SIXBIT/PCBTAG/.
|  
|              Data Items:  U = address of PCB
|                           J = address of FEK
|  
|  
|  ANFRDN  NETSER   STOP    Routing header has bad Destination Node
|  
|                           When processing a just-received  ANF  network
|                           message,  the  destination  node  number  (as
|                           specified in the message) did not  match  the
|                           local host node number.



                                     21



|              Data Items:  U = address of PCB
|                           W = address of NDB which sent the message
|                           P1 =  current  byte  pointer  into  PCB  data
|                           buffer
|  
|  
|  ANFRDT  NETSER   STOP    Releasing DDB twice
|  
|                           ZAPNET was called to release an  ANF  network
|                           Device  Data  Block,  but  the DDB is already
|                           marked as having been cleared (and  has  been
|                           returned to the monitor free pool).
|  
|              Data Items:  F = address of network DDB
|  
|  
|  ANFRSN  NETSER   STOP    Routing header has bad Source Node
|  
|                           When processing a just-received  ANF  network
|                           message, the source node number (as specified
|                           in the message) did not match the remote node
|                           number  from  the ANF network Node Data Block
|                           from which this message was de-queued.
|  
|              Data Items:  U = address of PCB
|                           W = address of NDB which sent the message
|                           P1 =  current  byte  pointer  into  PCB  data
|                           buffer
|  
|  
|  ANFSBA  NETSER   STOP    Secondary Buffer Allocated ("old feature")
|  
|                           On a call to RMVPCB to free up an ANF network
|                           Protocol  Control  Block,  a PCB was found to
|                           own a "secondary" data buffer (in addition to
|                           the primary data buffer), a feature no longer
|                           in use.
|  
|              Data Items:  U = address of PCB
|  
|  
|  ANFSLA  NETSER   STOP    SLA on a connect
|  
|                           On  a  call  to  NCSCNT  to  send  a  Connect
|                           Initiate  message (or possibly from NCSCNC to
|                           send a Connect Confirm message) to  a  remote
|                           node  for  a  device, the network Device Data
|                           Block had no Source Link Address.
|  
|              Data Items:  F = address of DDB
|                           W = address of NDB



                                     22



|  ANFTLK  NETSER   STOP    W points at NETNDB (talking to itself)
|  
|                           An illegal operation was detected directed at
|                           the  Node Data Block for the local host.  For
|                           example, an attempt was made (in  CLNNDB)  to
|                           delete  the NDB as no longer reachable on the
|                           network.
|  
|              Data Items:  W = address of NDB
|  
|  
|  ANFTMF  NETSER   STOP    Too Many FEKs
|  
|                           When rebuilding  the  neighbor's  table  (for
|                           sending  Neighbors  messages to other nodes),
|                           there  were  more  than  NGHMAX   Front   End
|                           Kontrollers (neighbors).
|  
|              Data Items:  J = address of FEK
|                           T1 = node number of FEK neighbor
|  
|  
|  ANFUBN  NETSER   STOP    Unsent Byte count went Negative
|  
|                           When processing the segmentation  of  a  user
|                           output  buffer,  the count of bytes remaining
|                           to be transmitted (DEVAXO+1) went negative.
|  
|              Data Items:  F = address of DDB
|  
|  
|  ANFUND  NETSER   STOP    Unreasonable Network DDB length
|  
|                           The MAKDDB routine was called  to  create  an
|                           ANF   network   Device  Data  Block  with  an
|                           "unreasonable" DDB size (either smaller  than
|                           the  minimum  DDB  length,  or much (10 octal
|                           words) bigger).
|  
|              Data Items:  T2 = requested DDB size, in words
|  
|  
|  ANFWLA  NETSER   STOP    Wrong LAT Assigned
|  
|                           A call  to  GETSLA  to  assign  a  free  link
|                           address  from the Link Address Table was made
|                           with an ANF network Device Data  Block  or  a
|                           terminal  Line Data Block that was already in
|                           the link address table.
|  
|              Data Items:  T1 = address of DDB or LDB



                                     23



|  ANFWLS  NETSER   STOP    Wrong LAT State
|  
|                           When processing a RELEASe monitor call for an
|                           ANF  network  device, the device was found to
|                           already be disconnected when its Link Address
|                           Table entry state claimed to be "OK".
|  
|              Data Items:  F = address of DDB
|                           S = DEVIOS flags (IOSCON clear)
|                           T2 = LAT state
|  
|  
|  ANFWMB  NETSER   STOP    User Wrote in Memory before Block
|  
|                           On a call to GIVZWD to deallocate a block  of
|                           NETSER  memory and return it to the monitor's
|                           general purpose free pool, the top-end  check
|                           word  was  found  to  be corrupted.  The left
|                           half of the word  immediately  preceding  the
|                           memory block should contain SIXBIT/NET/.
|  
|              Data Items:  T1 = LH contents of top-end check word
|                           T2 = (adjusted) address of memory block
|                           -1(P) = (adjusted) length of memory block
|  
|  
|  ANFWPE  NETSER   STOP    User Wrote Past the End of the block
|  
|                           On a call to GIVZWD to deallocate a block  of
|                           NETSER  memory and return it to the monitor's
|                           general purpose  free  pool,  the  bottom-end
|                           check  word  was  found to be corrupted.  The
|                           word  immediately  after  the  memory   block
|                           should contain SIXBIT/NETMEM/.
|  
|              Data Items:  T1 = LH contents of top-end check word
|                           T2 = contents of bottom-end check word
|                           0(P) = (adjusted) address of memory block
|                           -1(P) = (adjusted) length of memory block
|  
|  
|  ANFXDS  NETSER   STOP    Can't send Disconnect message (no PCB?)
|  
|                           After   a    call    to    PCBECK    returned
|                           "guaranteeing"  the  availability  of  an ANF
|                           network Protocol Control Block, a  subsequent
|                           call to PCBEGT to get a free PCB failed.
|  
|  
|  ANFXMT  NETSER   STOP    No buffer set up when calling NTDXMT
|  
|                           When processing an output buffer from a  user


                                     24



|                           program,   NTDXMT   found  no  output  buffer
|                           pointer (DEVAXO) set up.
|  
|              Data Items:  F = address of DDB
|  
|  
|  ANFZFK  NETSER   STOP    Zero FEK pointer
|  
|                           An ANF network Front  End  Kontroller  called
|                           NETSER's  FEK interrupt service (FEKINT) with
|                           no FEK address in J.


   ANU     FILIO    DEBUG   AU Not Owned By Us

                            UPAU obtains  the  Alter-UFD  (AU)  resource.
                            This  stopcode  occurs  when  there is no UFD
                            data block (UFB) for the given DDB or  a  job
                            returns  an  Alter-UFD  (AU) resource that is
                            already owned by someone else.

               Data Items:  P1 = 0 if no UFB, otherwise the UFB for DDB
                            P2 = not applicable if no UFB, otherwise  job
                            number trying to release the AU resource
                            UFBAUJ(P1) = job owning the AU resource


   AOC     FILFND   DEBUG   Already Own CB

                            GETCB gets  the  core  block  (CB)  resource.
                            This  stopcode occurs when a job requests the
                            CB resource, but already owns it.

               Data Items:  J = job number


   APF     VMSER    DEBUG   Allocated Page Free

                            This stopcode occurs when the  monitor  finds
                            an  unallocated page of memory in the list of
                            pages allocated to a segment.

               Data Items:  P2 = disk address-1
                            P3 = current physical page allocated
                            P4 = number of pages
                            T3 = byte pointer to the map slot


   AR1     ONCMOD   DEBUG   ASKDEC Returned CPOPJ1

                            CHGASL  changes  the  active  swapping  list.
                            This  stopcode  occurs  when  the  routine to


                                     25



                            input a decimal number returns POPJ1.


   ARF     CORE1    STOP    Attempt To Return Free Page

                            GVPAGS returns pages to the  free-core  list.
                            This  stopcode occurs when the monitor checks
                            its table of free pages  before  returning  a
                            page  and  finds  that  the  page  is already
                            marked as being free.

               Data Items:  T1 = first page on free-core list
                            T2 = page being  returned  to  the  free-core
                            list  (this  is  the  page  that  caused  the
                            stopcode)
                            T3 = number of pages returned so far
                            T4 = bit  being  tested  in  the  page  table
                            (400000,,0)  PAGTAB(T2)  =  page-status  bits
                            (status-bit  definitions  can  be  found   in
                            module S.MAC)


   ARM     FILFND   DEBUG   Access Rings Messed Up

                            ATNLNK unlinks an access table  from  a  name
                            block  ring.   This  stopcode  occurs when an
                            access ring  is  not  linked  to  any  access
                            table.


   BAC     CORE1    DEBUG   Bit Already Clear

                            SETZRS sets zeros in a table.  This  stopcode
                            occurs  when  the  SETZRS routine attempts to
                            zero bits that are already zero.

               Data Items:  T2 = still on the stack =  AOBJN  pointer  to
                            tables
                            T1 = number of bits to clear


   BAD     FILFND   JOB     Block Already Dormant

                            ATSFR0 puts an access table in the  free-core
                            list.   This  stopcode occurs when an attempt
                            is made to make the access table dormant, but
                            the table is already dormant.

               Data Items:  T1 = location of access table


   BAO     FILIO    DEBUG   Bit Already One


                                     26



                            TAKBLK allocates blocks from the disk.   This
                            stopcode  occurs when the monitor attempts to
                            allocate a block that is already allocated.

               Data Items:  PDL = cluster address.


   BAZ     FILIO    DEBUG   Bit Already Zero

                            GIVBLK returns disk  blocks.   This  stopcode
                            occurs  when  the  monitor attempts to return
                            blocks that are already free;  this can occur
                            when  a  damaged  file  is  deleted.  If this
                            stopcode occurs with  any  frequency,  it  is
                            suggest  you  run  DSKRAT  on  the  structure
                            indicated in the  stopcode  printout  on  the
                            CTY.


   BBS     D85INT   STOP    Bad Byte Size

                            DLBP makes the  DL10  the  byte  pointer  for
                            data.   This  stopcode occurs when the number
                            of bytes per word supplied is  illegal.   The
                            number of bytes per word must be from 2 to 6.

               Data Items:  T4 = wrong byte size


|  BEC     MSCCOM   DEBUG   Packet with bad end code received


   BFC     D60SER   DEBUG   Bad Function Code

                            The  front  end  controller  received  a  bad
                            function code.  This is a monitor error.


   BFO     TAPUUO   DEBUG   Better Find One

                            INVERT generates a transfer list for  a  read
                            backwards.  This stopcode occurs when the end
                            of the original  transfer  list  for  a  read
                            backwards is not found.

               Data Items:  T2 = head of old transfer list
                            T3 = item number to find


   BIN     FILIO    STOP    Block Number is Negative

                            MONRED reads a block or a series  of  blocks.


                                     27



                            This  stopcode  occurs  when  this routine is
                            called with a negative block number.

               Data Items:  T1 = IOWD for data
                            T2 = block number


   BMR     FILUUO   JOB     Block Missing from RIB

                            ALLP0A is used  to  work  with  a  RIB  whose
                            blocks  are  allocated  but  not  used.  This
                            stopcode occurs when the RIB for a file shows
                            that  the  file has more blocks than actually
                            exist.

               Data Items:  T3 = missing block


   BNR     FILUUO   JOB     Block Not RIB

                            NOTOLD creates a  new  name  in  a  directory
                            block.   This  stopcode occurs when a pointer
                            to a block is not found in the RIB.

               Data Items:  P2 = block that is being looked for


   BNT     FILFND   DEBUG   Block Not There

                            UFORSS gets a UFD or  an  SFD  access  block.
                            This stopcode occurs when a core block (AT or
                            UFB) that is known to exist is not found.


   BNZ     CORE1    DEBUG   Bit Not Zero

                            CSETOS sets bits in a table.   This  stopcode
                            occurs  when  one  of the bits to be set in a
                            table is already set.

               Data Items:  T3 = number of bits to set
                            T4 = address,,position


   BPE     CLOCK1   JOB     Breakpoint PC EXEC Mode

                            The  user  PC  on  a  control-D  to   a   DDT
                            unsolicited  breakpoint trap did not have the
                            USRMOD bit, although the user was supposed to
                            be in user mode.

               Data Items:  T1 = PC  word  that  the  user  is  currently


                                     28



                            running


   BPF     CLOCK1   JOB     Breakpoint PUTWRD failed

                            The  attempt  to  store  the  return  PC  (in
                            processing an unsolicited ^D breakpoint) into
                            the location pointed to by .JBBPT failed even
                            though   the   address  had  been  previously
                            address checked.


   BPT     FILFND   JOB     Bad Search List Pointer

                            SLXBPT is used only for this stopcode and  is
                            called  from  FILUUO.   This  stopcode occurs
                            when an attempt is made to build  the  search
                            list, but no search list can be found.


   BRC     COMCON   DEBUG   Bad Return from CMPBIT

                            SAVEXE saves a  virtual  memory  system  core
                            image.  This stopcode occurs when the routine
                            that computes the flag bits for  a  directory
                            entry gives an error return.


   BSN     SEGCON   STOP    Bad Segment Number

                            COMIT compares the job number with the  right
                            half  of  JBTSGN(T1).   This  stopcode occurs
                            when the right half of J and the  right  half
                            of JBTSGN(T1) are not the same.

               Data Items:  T1 = high-segment number of job
                            J = job number


   BSY     XTCSER   DEBUG   DA28 Busy

                            The BUSY bit was (still)  on  when  the  DA28
                            interrupted.


   BWA     FILIO    JOB     Block Went Away

                            SETLST sets  up  an  I/O  list  block.   This
                            stopcode occurs when NXTBLK, which is used to
                            return the next block address, gives an error
                            or   a   non-skip   return   that   indicates
                            end-of-file, writing in the middle of a file,


                                     29



                            or another similar error.

               Data Items:  J = job number
|  
|  
|  CAM     CPNSER   CPU     CPU accessability mask
|  
|                           A device that can do I/O with only one CPU is
|                           owned by more than one CPU.
|  
|  
|  CAO     FILUUO   DEBUG   Cluster Address Odd
|  
|                           ADJALC allocates the  initial  blocks  for  a
|                           file.   This  stopcode  occurs  when  a block
|                           supercluster address is not an even  multiple
|                           of a block cluster address.
|  
|              Data Items:  T1 = number of blocks in group
|                           P2 = remainder
|  
|  
|  CAS     REFSTR   STOP    Couldn't Allocate Space
|  
|                           This stopcode is always preceded  by  one  of
|                           the  following  messages,  which explains why
|                           space could not be allocated:
|  
|                                Bad block in HOME.SYS space.
|  
|                                File structure  full,  suggest  reducing
|                                swapping space.
|  
|  
|  CBB     COMCON   DEBUG   Command Block Bad
|  
|                           In  copying  the  program-to-run  information
|                           from  a  user  defined  command  block to the
|                           SAVGET  locations,  it  was  found  that  the
|                           command block was too big to fit.
|  
|  
|  CCR     CLOCK1   STOP    Can't continue with resource


   CDn     COMMON   CPU     Cache Directory Parity Error, CPU n

                            This is a serious hardware error.  Call  your
                            Field Service representative.


   CDA     FILIO    DEBUG   In-Core Copy Doesn't Agree


                                     30



                            DD2MN copies pointers from a DDB to a monitor
                            buffer to perform monitor I/O.  This stopcode
                            occurs when  the  cluster  pointer  from  the
                            structure  data block does not agree with the
                            in-core copy.

               Data Items:  T1 = in-core copy
                            T4 = pointer from structure data block

   CDD     MSGSER   DEBUG   Can't Disconnect Device

                            This stopcode occurs when a release  call  on
                            MPX  fails  because  the disconnect format is
                            invalid or the device is not connected.
|  
|  
|  CDRASC  NETDEV   STOP    NTDSIB failed in C.ASCI
|  
|                           After calling  NTDIBA  to  guarantee  a  user
|                           input  buffer  is  available, the ANF network
|                           card reader service routine was unable to set
|                           up  an  input  buffer  to  receive  a network
|                           message.
|  
|              Data Items:  F = address of DDB
|                           U = address of PCB
|  
|  
|  CDRBIN  NETDEV   STOP    NTDSIB failed in C.BIN
|  
|                           After calling  NTDIBA  to  guarantee  a  user
|                           input  buffer  is  available, the ANF network
|                           card reader service routine was unable to set
|                           up  an  input  buffer  to  receive  a network
|                           message.
|  
|              Data Items:  F = address of DDB
|                           U = address of PCB
|  
|  
|  CDRIMG  NETDEV   STOP    NTDSIB failed in C.IMAG
|  
|                           After calling  NTDIBA  to  guarantee  a  user
|                           input  buffer  is  available, the ANF network
|                           card reader service routine was unable to set
|                           up  an  input  buffer  to  receive  a network
|                           message.
|  
|              Data Items:  F = address of DDB
|                           U = address of PCB




                                     31



   CFP     CLOCK1   JOB     Can't Find PDB

                            SETRUN sets the  job-status  run  bit.   This
                            stopcode occurs when there is no process data
                            block (PDB) for this job.

               Data Items:  J = job number


   CGS     ONCMOD   STOP    Couldn't Get Structure Data Block

                            DMKSTR sets up structures according to tables
                            in   ONCMOD  in  the  DESTROY  option.   This
                            stopcode occurs when the  maximum  number  of
                            structures is exceeded.

               Data Items:  .FSMAX = maximum number of structures allowed
                            T1 = structure name
                            P3 = address of last structure data block
                            P4  =  system  structure  number   for   this
                            structure


   CI7     UUOCON   DEBUG   CI7 Continuable Snapshot Dump

                            A user requested  continuable  snapshot  dump
                            was   requested   (CONFIG   program  SNAPSHOT
                            command.  See TOPS-10 Operator's Guide.)                                          _______ __________ ______


   CIB     CLOCK1   CPU     CPU Interlocks Broken

                            APRSUB services common APR interrupts.   This
                            stopcode  occurs  when  the CPU interlock has
                            been  modified.   Typically,   the   stopcode
                            occurs  while  trying  to continue a CPU that
                            has stopped due to a fatal error.

               Data Items:  .CPNBI = CPU interlock that was modified


   CIF     FHXKON   DEBUG   RC10 Isn't Fancy

                            This  stopcode  occurs   when   the   monitor
                            attempts   an   RP04-only   function   on  an
                            RC10-controlled device.


   CIO     REFSTR   DEBUG   CPF Is Odd

                            COMCFP computes a CFP.  This stopcode  occurs
                            when the number of blocks per supercluster is


                                     32



                            not a multiple of the number  of  blocks  per
                            cluster.


   CL0     SCNSER   STOP    Chunk Links to 0

                            DELCHR deletes  characters  from  the  user's
                            input  buffers  when he presses the RUBOUT or
                            DELETE key.  This stopcode occurs when a  TTY
                            chunk has a backward link to 0.

               Data Items:  T2 = current chunk


   CME     FILFND   DEBUG   CFP Modulo Error

                            SETCFP computes a CFP.  This stopcode  occurs
                            when   CFP   does   not   start  at  an  even
                            supercluster boundary.

               Data Items:  T2 = supercluster address relative to block 0
                            of unit
                            T3 = remainder


   CMP     LOKCON   STOP    Can't Move Page

                            In attempting to move pages out of a block of
                            memory  that  is  being set off-line, routine
                            PAGFRE discovered that  the  free  page  into
                            which  we  were trying to move a page was not
                            really free.

               Data Items:  P2 = target (free) page


   CMS     VMSER    DEBUG   CORE1 Must Skip

                            SEGCON   returns   core   allocated   to    a
                            nonsharable   high  segment.   This  stopcode
                            occurs when CORE1 gives a nonskip return when
                            asked for core in use.


   CMU     SEGCON   DEBUG   Core Messed Up

                            CHKTAL compares CORTAL with a value  obtained
                            from   various  job  tables.   This  stopcode
                            occurs  when  the  core  usage   tables   are
                            inconsistent.

               Data Items:  U = free+idle+dormant


                                     33



                            CORTAL = bit table


   CNA     SCHED1   STOP    Core Not Available

                            SWAPI swaps in a job or high  segment.   This
                            stopcode occurs when an error return is given
                            by  the  core-allocation  routine   (CORGET),
                            which  indicates  that  no core is available,
                            although it has already  been  verified  that
                            enough core is available.

               Data Items:  J = job number


   CNE     FILUUO   DEBUG   Cluster Not Even

                            ADJALC allocates the  initial  blocks  for  a
                            file.   This  stopcode  occurs when the block
                            computed as the start of a supercluster  does
                            not begin at an even supercluster address.

               Data Items:  T2 = starting block number
|  
|  
|  CQO     CLOCK1   STOP    Clock queue overflowed at some time.


   CRH     REFSTR   DEBUG   Cannot Read Home Blocks

                            REFSTR  refreshes  a  file  structure.   This
                            stopcode occurs when the routine used to read
                            home blocks (GTHOM) gives an error return.
|  
|  
|  CRM     RAXKON   DEBUG   Command reference number missing
|  
|  
|  CRU     MSCCOM   DEBUG   Command reference number unknown


   CSA     COMCON   DEBUG   Couldn't Set Access Allowed

                            SETAA sets the access-allowed bit for a page.
                            This  stopcode  occurs  when the PAGE monitor
                            call function to set access allowed fails.
|  
|  
|  CSB     ONCMOD   STOP    Crosses section boundary


   CSE     FILIO    STOP    Checksum Error


                                     34



                            CHKSUM computes a folded  checksum  from  the
                            first  data  word.  This stopcode occurs when
                            the pointer for checksumming points to a word
                            that is not in the user's address space.

               Data Items:  RH(M) = address that caused the error;   J  =
                            job number
|  
|  
|  CSF     RAXKON   DEBUG   Connect to MSCP server failed


   CSP     SEGCON   JOB     Cannot Store Path

                            STONAM is used during SAVE, GET, R,  and  RUN
                            commands  to  search  a  path.  This stopcode
                            occurs when there is not enough free core  to
                            store the full path specification.

               Data Items:  T2 = number of words available
|  
|  
|  CTHBCM  NRTSER   INFO    Bad configuration message
|  
|  
|  CTHIBO  NRTSER   STOP    CTERM host input buffer overflow
|  
|  
|  CTHOCE  NRTSER   STOP    Output count exceeded
|  
|  
|  CTHPED  NRTSER   INFO    Protocol error detected
|  
|                           CTERM protocol is not followed by process  at
|                           source node.
|  
|  
|  CTHPER  NRTSER   INFO    Protocol error reported
|  
|                           CTERM protocol is  not  followed  by  process
|                           running on TOPS-10 node.
|  
|  
|  CTX     CTXSER   JOB     Context skew
|  
|  
|  CTXFWA  CTXSER   STOP    CTXMIG's first context went away
|  
|  
|  CTXMCT  CTXSER   STOP    CTXMIG called twice




                                     35



|  CTXNIP  CTXSER   STOP    Context migration not in progress


   CU0     NETDEV   STOP    Can't Use Zero Dispatch

                            This stopcode occurs when an attempt is  made
                            to use a zero dispatch in the SCNSER dispatch
                            table.  A zero dispatch is illegal.


   CWN     NETSER   DEBUG   Core Allocation Went Negative

                            GIVZWD  returns  monitor  free  core.    This
                            stopcode   occurs  when  GIVZWD  attempts  to
                            return more free core than it has.

               Data Items:  core allocation count
                            -1(P) = number of words returned
|  
|  
|  D78BI   D78INT   JOB     Bad IOWD
|  
|  
|  D78IN0  D78INT   JOB     Input character count non-0
|  
|  
|  D78NC   D78INT   JOB     Not enough free monitor core
|  
|  
|  D78ON   D78INT   JOB     Output character count is not equal to 0.
|  
|  
|  D78PI   D78INT   JOB     Positive IOWD
|  
|  
|  D78VI   D78INT   DEBUG   Version incorrect
|  
|  
|  DA28B   XTCSER   DEBUG   DA28 is broken


   DBZ     FILIO    DEBUG   DEPLPC Bit Zero

                            USETO0 does a USETO.   This  stopcode  occurs
                            when the last group of pointers for a file is
                            not the last group in the RIB;  there  should
                            be more file pointers.

               Data Items:  W = last block allocated
                            T3 = last pointer in core flag




                                     36



|  DC75WE  D85INT   DEBUG   DC75 wrong PDP11 code
|  
|  
|  DC76MS  D76INT   DEBUG   DC76 message is short
|  
|  
|  DC76QF  D76INT   DEBUG   DC76 queue full


   DCR     FILUUO   DEBUG   DELRIB CPOPJ Return

                            CLSDL1 deletes a file.  This stopcode  occurs
                            when  DELRIB  does  not  skip, even though it
                            should always give a skip return.
|  
|  
|  DDN     MSCCOM   DEBUG   Driver dispatch address not setup
|  
|  
|  DDPAHB  NETDEV   DEBUG   Already have receive buffer
|  
|                           An ANF  DDP  "kontroller"  dispatch  function
|                           call  was  made to post a new receive buffer,
|                           but the DDP already had a buffer pending.
|  
|              Data Items:  F = address of DDB
|  
|  
|  DDPALA  NETDEV   STOP    Destination allocated address is zero
|  
|                           When trying to process an input message  from
|                           a   DDP  in  "kontroller"  mode,  the  DECnet
|                           message  block  format  was  invalid.    (The
|                           Message  Segment Descriptor allocated address
|                           was zero.)
|  
|  
|  DDPBAU  NETDEV   STOP    Being awfully uncooperative!
|  
|                           After  making  an  ANF  DDP  device  into   a
|                           "kontroller",  DECnet  subsequently  rejected
|                           the new "kontroller".
|  
|              Data Items:  F = address of DDB
|  
|  
|  DDPBBM  NETDEV   STOP    Bad output message block
|  
|                           When trying to process an output message  for
|                           a   DDP  in  "kontroller"  mode,  the  DECnet
|                           message block format was invalid.  (There was
|                           no first Message Segment Descriptor block.)


                                     37



|              Data Items:  F = address of DDB
|                           P1 = address of DECnet message block
|  
|  
|  DDPBCD  NETDEV   STOP    Byte copy didn't
|  
|                           When trying to process an input message  from
|                           a DDP in "kontroller" mode, the EXTEND/MOVSLJ
|                           instruction to copy the  data  from  the  ANF
|                           Protocol   Control   Block  into  the  DECnet
|                           Message Segment Descriptor block failed.
|  
|  
|  DDPFIX  NETDEV   STOP    This needs to be fixed
|  
|                           When  servicing  an  ANF  DDP  device  output
|                           queue,  no Node Data Block could be found for
|                           the node that owns the DDP device.
|  
|              Data Items:  F = address of DDB
|  
|  
|  DDPFNC  NETDEV   STOP    Illegal kontroller function call
|  
|                           The ANF DDP "kontroller" dispatch routine was
|                           called  with an illegal or unknown kontroller
|                           function code.
|  
|              Data Items:  T1 = kontroller function code
|  
|  
|  DDPIDV  NETDEV   STOP    Illegal driver number
|  
|                           The DDP service routine tried to dispatch  to
|                           a  unknown  or  illegal  higher-level  driver
|                           type.
|  
|  
|  DDPIOT  NETDEV   DEBUG   Illegal Owner Type
|  
|                           The DDP service routine tried to dispatch  to
|                           a unused or illegal higher-level driver type.
|  
|  
|  DDPKON  NETDEV   STOP    Can't make a kontroller out of DDP
|  
|                           The DDPCKN routine was unable to set  an  ANF
|                           DDP   device  into  "kontroller"  mode  on  a
|                           DDP-initiated connect cycle.
|  
|              Data Items:  F = address of DDB



                                     38



|  DDPMTB  NETDEV   STOP    DDP Message Too Big for driver
|  
|                           When running in "kontroller" mode, a  message
|                           was received which was too big to give to the
|                           associated higher-level driver routine.
|  
|  
|  DDPNDA  NETDEV   STOP    No allocated data address
|  
|                           When trying to process an output message  for
|                           a   DDP  in  "kontroller"  mode,  the  DECnet
|                           message block format was invalid.  (A Message
|                           Segment   Descriptor   had   no  data  buffer
|                           address.)
|  
|              Data Items:  F = address of DDB
|                           P1 = address of DECnet MSD
|  
|  
|  DDPNDT  NETDEV   STOP    No NDT entry
|  
|                           The Network Device Table entry in the  system
|                           NDTTAB  table  for  the  DDP-class device was
|                           zero.
|  
|  
|  DDPRBA  NETDEV   DEBUG   Receive Buffer already Allocated
|  
|                           On an ANF DDP "kontroller" dispatch  function
|                           call   to   "OPEN"   (or  initialize)  a  DDP
|                           kontroller or circuit,  the  kontroller  (DDP
|                           device)   already   had   a   receive  buffer
|                           outstanding.
|  
|              Data Items:  F = address of DDB
|  
|  
|  DDPRDQ  NETDEV   STOP    NTDRDQ failed
|  
|  
|  DDPSE0  NETDEV   STOP    Not in Section 1
|  
|                           The DDP service routine was  not  running  in
|                           Section  1,  and  thus  could  not  call  its
|                           higher-level driver routine.
|  
|  
|  DDPSIB  NETDEV   STOP    NTDSIB failed after NTDIBA succeeded
|  
|                           After calling  NTDIBA  to  guarantee  a  user
|                           input  buffer  is  available, the ANF network
|                           DDP service routine was unable to set  up  an


                                     39



|                           input buffer to receive a network message.
|  
|              Data Items:  F = address of DDB
|                           U = address of PCB
|  
|  
|  DDPSLJ  NETDEV   STOP    Couldn't move the sludge
|  
|                           When trying to process an output message  for
|                           a  DDP in "kontroller" mode, an EXTEND/MOVSLJ
|                           instruction failed in copying bytes from  the
|                           DECnet  message  block  into  an  ANF network
|                           Protocol Control Block.
|  
|              Data Items:  F = address of DDB
|  
|  
|  DDPXMT  NETDEV   STOP    NTDXMT failed, not running out of freecore
|  
|                           A call to NTDXMT to output a user  buffer  to
|                           an  ANF  DDP  device  failed  for some reason
|                           other  than  a  lack  of  available   network
|                           Protocol Control Blocks to hold the message.
|  
|              Data Items:  F = address of DDB


   DDS     FILUUO   DEBUG   DELRIB Didn't Skip

                            BADUFD deletes a file.  This stopcode  occurs
                            when  DELRIB  does  not  skip, even though it
                            should always give a skip return.


   DER     FILUUO   DEBUG   DELRIB Error Return

                            CLSFUL is used when there is no  space  on  a
                            structure  or  all  pointer  slots are taken.
                            This stopcode occurs  when  DELRIB  does  not
                            skip,  even  though  it  should always give a
                            skip return.


   DFU     COMNET   DEBUG   Device Unrecognized

                            DSPOBJ dispatches on the object  type.   This
                            stopcode  occurs when the specified device is
                            not on the network.

               Data Items:  T4 = object type
                            DEVCHR(F) = device characteristics



                                     40



   DHA     FILIO    DEBUG   Don't Have AU Resource

                            DWNAU releases the Alter-UFD resource.   This
                            stopcode  occurs  when  this file attempts to
                            return the AU resource when it does  not  own
                            it.

               Data Items:  S = should have had IOSAW(200000) set

   DHD     FILIO    DEBUG   Don't Have DA

                            DWNDA  returns  the  DISK  ALLOCATION  queue.
                            This  stopcode occurs when this file does not
                            own the DA resource.

               Data Items:  PJOBN = job number
|  
|  
|  DIEBAD  ERRCON   STOP    Bad PC in DIE
|  
|  
|  DMO     COMMON   STOP    DECnet core and monitor overlap
|  
|                           On a KS10, the core allocated for DECnet data
|                           base  and  the  monitor  low segment overlap.
|                           Rebuild the monitor, specifying  fewer  jobs,
|                           fewer terminals, or both.
|  
|  
|  DN60DD  D6SINT   DEBUG   PDP11 tried to give us to much
|  
|  
|  DN60DI  D6SINT   DEBUG   Not expecting a To-10 done interrupt
|  
|  
|  DN60ID  D6SINT   DEBUG   PDP11 is trying to give
|  
|  
|  DN60VI  D6SINT   DEBUG   DN60 wrong PDP11 code


   DNF     FILUUO   DEBUG   DDB Not Found

                            CLRDDB clears a disk data block (DDB).   This
                            stopcode  occurs  when  an attempt is made to
                            return a  DDB,  but  no  predecessor  DDB  is
                            found.

               Data Items:  F = location of DDB


   DNR     FILUUO   DEBUG   DELRIB Non-Skip Return


                                     41



                            SETEN5 is used when the  RIB  is  set  up  to
                            insert  constant  values  and write them out.
                            This stopcode occurs  when  DELRIB  does  not
                            skip,  even  though  it  should always give a
                            skip return.


   DNS     FILUUO   DEBUG   DELRIB Non-Skip Return

                            CLOSR2 is called by CLRSTS when a  rename  is
                            in  progress  at  the time of a delete.  This
                            stopcode occurs when DELRIB  does  not  skip,
                            even  though  it  should  always  give a skip
                            return.


   DOC     FILFND   DEBUG   Don't Own CB

                            GVCBJ returns the  CB  resource  for  a  job.
                            This  stopcode occurs if GVCBJ is called, but
                            the job does not own the CB resource.


   DOM     CORE1    STOP    Don't Own MM Resource

                            On a multiprocessor KL,  the  processor  that
                            wishes to manipulate pages in memory must own
                            the memory-management resource before it  can
                            do so.  This stopcode occurs when a processor
                            tries to manipulate memory pages and does not
                            own  the  memory-management  resource.   This
                            resource can also be owned by a job.

               Data Items:  If the CPU owns the MM  resource,  INTLMO  is
                            the  APRID  of  the  CPU.   If a job owns the
                            resource, .CPJOB contains the job number  (in
                            this case, MMUSER is the job that owns the MM
                            resource).


   DPL     COMCON   DEBUG   Directory Page Lost

                            GTSAVP  reads  in  a  page  that  was  output
                            earlier.   This  stopcode  occurs either when
                            the page already exists or when an I/O  error
                            occurs.


   DPN     COMCON   DEBUG   Directory Page Nonexistent

                            RELDIR gets rid of  the  directory  page  and
                            restores  any  pages  that  were  written out


                                     42



                            earlier,  after  it  creates  the  directory.
                            This  stopcode  occurs  when a PAGE.  monitor
                            call with a function of 1 fails.


   DQR     DZINT    DEBUG   Illegal Queue Routine

                            The address of the routine to transfer to  on
                            dataset timeout for a DZ-11 line was zero.
|  
|  
|  DSS     VMSER    DEBUG   DLTSP Skipped
|  
|                           CLRSPG clears spy pages  from  a  user's  map
|                           when  called by GETMIN.  This stopcode occurs
|                           when CLRSPG cannot clear a spy page.
|  
|              Data Items:  T1 = user virtual page number of page
|  
|  
|  DTEAHB  DTESER   DEBUG   Already have receive buffer
|  
|  
|  DTEARD  DTESER   STOP    Runaway driver
|  
|  
|  DTEBAA  DTESER   STOP    Buffer already there
|  
|  
|  DTEBDN  DTESER   STOP    Bad device number
|  
|  
|  DTEBMB  DTESER   DEBUG   Bad message block pointer
|  
|  
|  DTEBTC  DTESER   DEBUG   Bad transfer count(s)
|  
|  
|  DTECDF  DTESER   STOP    Copy data failed
|  
|  
|  DTECOW  DTESER   STOP    Called for output on wrong CPU
|  
|  
|  DTEDNE  DTESER   STOP    Count not even
|  
|  
|  DTEDNH  DTESER   STOP    Driver not hungry
|  
|  
|  DTEDWA  DTESER   DEBUG   DDB went away?



                                     43



|  DTEDWC  DTESER   DEBUG   DTECLR called on wrong CPU
|  
|  
|  DTEEFI  DTESER   STOP    Illegal function code
|  
|  
|  DTEFNG  DTESER   STOP    Illegal function code
|  
|  
|  DTEI1S  DTESER   DEBUG   Illegal To-11 done state for QP2
|  
|  
|  DTEIBA  DTESER   DEBUG   Input buffer already allocated
|  
|  
|  DTEIDS  DTESER   DEBUG   Illegal To-10 done state
|  
|  
|  DTEIDX  DTESER   STOP    Bad index in byte pointer
|  
|  
|  DTEIKF  DTESER   DEBUG   Illegal kontroller function
|  
|  
|  DTEIPA  DTESER   STOP    No post address
|  
|  
|  DTEITM  DTESER   DEBUG   Illegal To-10 transfer mode in QP2
|  
|  
|  DTEITS  DTESER   DEBUG   Illegal To-10 transfer state
|  
|  
|  DTEMDM  DTESER   STOP    No master DTE
|  
|  
|  DTEMDS  DTESER   JOB     MOVSLJ didn't skip
|  
|  
|  DTENFC  DTESER   STOP    No free core
|  
|  
|  DTENFP  DTESER   STOP    No forward pointer in MSD
|  
|  
|  DTENIS  DTESER   STOP    DTE in wrong state
|  
|  
|  DTENOD  DTESER   STOP    No data
|  
|  
|  DTENOM  DTESER   STOP    No message block


                                     44



|  DTEOBA  DTESER   DEBUG   Output buffer already allocated
|  
|  
|  DTEPCI  DTESER   STOP    Function code illegal
|  
|  
|  DTEPTL  DTESER   STOP    Packet too large
|  
|  
|  DTEQEF  DTESER   STOP    Queue entry full
|  
|  
|  DTERWC  DTESER   DEBUG   DTERLD called on wrong CPU
|  
|  
|  DTETNI  DTESER   STOP    DTE not idle
|  
|  
|  DTETQP  DTESER   STOP    Found queue point
|  
|  
|  DTEWCN  DTESER   STOP    Wrong CPU number
|  
|  
|  EMS     VMSER    STOP    Exceeding maximum section
|  
|  
|  ENQATA  QUESER   DEBUG   Bad access table address
|  
|                           Code assumes that the access table  addresses
|                           are under 400,000.  FRECOR access tables must
|                           be  within  400,000,   or   you   must   make
|                           appropriate code changes to QUESER.
|  
|  
|  ENQAVE  QUESER   DEBUG   Already have EQ
|  
|                           AVESTP  is  a  stopcode-only  routine.   This
|                           stopcode   occurs   when   a   job   has  the
|                           Enqueue/Dequeue Wait resource when it  should
|                           not have it.
|  
|              Data Items:  J = job number
|  
|  
|  ENQCWD  QUESER   JOB     Can't wake job/context after DEQ.
|  
|                           DEQ.  process is  completed,  but  WAKE.   to
|                           requesting  program  or  idle context failed,
|                           for some reason.  Make  sure  the  requesting
|                           program or context handle is valid.



                                     45



|  ENQCWJ  QUESER   JOB     Can't wake job/context
|  
|                           DEQ.  process is completed, but  lock  cannot
|                           be  granted.   Check  the waiting process for
|                           invalid requesting job or context handle.
|  
|  
|  ENQDNL  QUESER   DEBUG   DEQ not interlocked
|  
|                           DEQIT dequeues one  Q-entry.   This  stopcode
|                           occurs  when  the  job  does  not  own the DQ
|                           interlock.
|  
|              Data Items:  J = job number
|  
|  
|  ENQIJC  QUESER   JOB     Illegal job/context handle
|  
|                           Code tried to obtain a q-chain header  for  a
|                           particular  context,  but  the attempt failed
|                           because  of   internal   discrepancies.    An
|                           invalid job or context handle was requested.
|  
|  
|  ENQLNF  QUESER   DEBUG   Lock not found
|  
|                           REDTB fills a user table with data  from  the
|                           LOCK-associated  table.  This stopcode occurs
|                           when the system cannot find the LOCK block.
|  
|  
|  ENQQFU  QUESER   JOB     Q-blocks fouled up
|  
|                           TSTAAC tries  to  determine  if  we  need  to
|                           increment  the read count in the access table
|                           to make it stay around.  This stopcode occurs
|                           when a zero entry is found in the link to the
|                           next queue.
|  
|  
|  ENTMPB  ETHUUO   DEBUG   MISSING USER PORTAL BLOCK
|  
|                           Occurs when  attempting  to  release  a  user
|                           portal which doesn't exist in the user portal
|                           table.
|  
|  
|  ENTPCN  ETHUUO   DEBUG   USER PORTAL COUNT NON-ZERO
|  
|                           Occurs when ETHUUO tries to  release  an  EJB
|                           (ethernet  job block) which hasn't closed all
|                           user portals.


                                     46



|  ENTPTF  ETHUUO   DEBUG   USER PORTAL TABLE FULL
|  
|                           Occurs when  the  user  portal  count  claims
|                           there  is  a  free  entry  in the user portal
|                           table, but all the entries are used.
|  
|  
|  ENTUUE  ETHUUO   DEBUG   UNEXPECTED ETHSER ERROR CODE
|  
|                           Shouldn't happen.  Means ETHUUO got an  error
|                           code back from ETHSER that it didn't expect.


   ERB     REFSTR   DEBUG   Error Reading BAT Block

                            REDBAT reads in BAT blocks and returns a  new
                            unit  pointer.   This stopcode occurs when an
                            error is encountered while reading.

               Data Items:  U = address of current unit


   ERD     ONCMOD   DEBUG   Error Refreshing Disk

                            WUNSTR refreshes a structure.  This  stopcode
                            occurs when an I/O error is encountered while
                            refreshing.


   ERF     TAPSER   STOP    Error Recovery Procedure Fouled Up

                            ERPINT is used when an interrupt is  received
                            while  error  recovery  is in progress.  This
                            stopcode occurs when a pointer that should be
                            pointing  at an I/O request block is pointing
                            elsewhere.

               Data Items:  T1 = bad pointer
                            TKBERB(W) = good pointer


   ERH     REFSTR   DEBUG   Error Reading HOME.SYS

                            This  stopcode  occurs  when  the   refresher
                            cannot  read  the home blocks.  (See stopcode
                            CRH.)


   ERM     ONCMOD   DEBUG   Error Reading MFD

                            SPTSSB creates the SPT table and the swapping
                            SAT  table  for  a  disk unit.  This stopcode


                                     47



                            occurs when an I/O error occurs while reading
                            the MFD read-in block.

               Data Items:  P1 = address of first word of MFD RIB (RH)
                            T2 = logical block number to read
                            U = unit data block address
                            F = file data block address
                            S = (RH) standard error bits


   ERP     REFSTR   STOP    Extraneous Retrieval Pointer

                            HOMRBS stores  a  retrieval  pointer  in  the
                            HOME.SYS read-in block.  This stopcode occurs
                            when the byte pointer is confused.

               Data Items:  T1 = current byte pointer


   ERS     ONCMOD   DEBUG   Error Reading SAT

                            FILMAN  finds  and  sets  up   all   of   the
                            structures  on  the  system.   This  stopcode
                            occurs when I/O takes place while reading the
                            SAT.SYS read-in block for a structure.

               Data Items:  S = error bits


   ESS     FILFND   JOB     Empty System Search List

                            SLXESS is  a  stopcode-only  routine  and  is
                            called  throughout FILFND.  Examine the stack
                            for the location.
|  
|  
|  ETHCCC  ETHSER   DEBUG   Can't create channel block
|  
|  
|  ETHCCP  ETHSER   DEBUG   Can't create PORTAL block
|  
|  
|  ETHICN  ETHSER   DEBUG   Invalid Ethernet channel number
|  
|  
|  ETHIFC  ETHSER   DEBUG   Invalid function code
|  
|  
|  ETHIFP  ETHSER   DEBUG   Invalid function for PORTAL
|  
|  
|  ETHIPI  ETHSER   DEBUG   Invalid ethernet PORTAL Id


                                     48



|  ETHIPS  ETHSER   DEBUG   Invalid protocol state
|  
|  
|  ETHUDS  ETHSER   DEBUG   Unexpected disable protocol state
|  
|  
|  ETHUES  ETHSER   DEBUG   Unexpected enable protocol state


   EUE     ERRCON   DEBUG   Executive UUO Error

                            EMUERR is called when a monitor call is  made
                            illegally   at  exec  level.   This  stopcode
                            occurs  when  the  monitor  call  occurs   at
                            non-interrupt level.


   EWB     REFSTR   DEBUG   Error Writing Block

                            BLKWRT writes out  a  block.   This  stopcode
                            occurs  when  the subroutine to do the actual
                            writing of the block, OWNWRT, gives an  error
                            return that indicates an I/O error.

               Data Items:  DEVMBF(F) = IOWD
                            T2 = logical block number
                            U = address of unit


   EWH     REFSTR   DEBUG   Error Writing Home Block

                            HOMUPD  updates  the   home   blocks.    This
                            stopcode  occurs  when the subroutine used to
                            do the physical I/O (WRTRUN) gives  an  error
                            return.

               Data Items:  T2 = list of items to be written
                            S = standard error bits


   EWR     ONCMOD   DEBUG   Error While Refreshing

                            RFRES2  refreshes  a  structure  during   the
                            DESTROY option.  This stopcode occurs when an
                            I/O error is encountered during the refresh.

               Data Items:  S = error bits
|  
|  
|  EXFCHK  SCNSER   STOP    Exhausted free chunks




                                     49



   FAD     FILUUO   DEBUG   File Already Dormant

                            CLRSTG is used during a CLOSE monitor call to
                            do  general  clean-up  tasks.   This stopcode
                            occurs when the access-table entry  for  this
                            file is mistakenly marked dormant.

               Data Items:  ACCDOR(T1) = access-table entry for this file
|  
|  
|  FDL     VMSER    STOP    FRDCR lied
|  
|  
|  FDP     FILIO    DEBUG   Fixed-Head Device Position
|  
|                           FREINT handles unsolicited interrupt  from  a
|                           device.    This   stopcode   occurs   when  a
|                           position-done   interrupt   occurs   for    a
|                           fixed-head   device.   This  may  indicate  a
|                           hardware problem.
|  
|              Data Items:  KONPOS(J) = unit positioning flag
|  
|  
|  FEM     ERRCON   HALT    Fatal Error in Monitor
|  
|                           PARHALT halts a CPU when there is  a  serious
|                           error in the monitor.
|  
|  
|  FFU     NETSER   STOP    F Fouled Up
|  
|                           NETHIB puts a network job in the HIBER state.
|                           This  stopcode  occurs  when NETHIB is called
|                           with F = 0.
|  
|  
|  FLE     SCNSER   STOP    Free List Empty
|  
|                           GETCHK  fetches  chunks   from   the   SCNSER
|                           free-chunk  chain.  This stopcode occurs when
|                           the pointer to the first  chunk  (TTFTAK)  is
|                           zero.
|  
|  
|  FON     VMSER    STOP    Funny Address Overlaps Next
|  
|                           GVFWDS returns words acquired  by  GTFWDC  or
|                           GTFWDU.   This  stopcode occurs when the size
|                           of the current chunk plus the the address  of
|                           the  current chunk overlaps the first word of
|                           the next chunk.


                                     50



|              Data Items:  T1 = words to return
|                           T2 = address
|  
|  
|  FOP     VMSER    STOP    Funny Address Overlaps Previous
|  
|                           GVFWDS returns words acquired  by  GTFWDS  or
|                           GTFWDU.   This stopcode occurs when the first
|                           word of the funny address is in the  previous
|                           chunk.
|  
|              Data Items:  T1 = words to return
|                           T2 = address
|  
|  
|  FPE     VMSER    DEBUG   Funny Page Must Exist
|  
|                           GVFWDS returns words acquired  by  GTFWDS  or
|                           GTFWDU.    This   stopcode  occurs  when  the
|                           monitor tries to get a page map entry, but no
|                           funny  page exists from which to get the page
|                           map entry.
|  
|              Data Items:  T1 = words to return
|                           T2 = address
|  
|  
|  FPI     CORE1    STOP    GTPAGS Free Page In Use
|  
|                           This stopcode occurs when the  monitor  tries
|                           to  get  a  page from the free-core list, but
|                           finds a page marked  "in  use"  on  the  free
|                           list.
|  
|              Data Items:  T1 = first page added to or  taken  from  the
|                           free-core  list;   T2  =  negative  number of
|                           pages to add or take from the free-core list
|  
|  
|  FPN     LOKCON   STOP    SETMFL Free Page Not Found
|  
|                           SETMFL moves monitor pages when  its  current
|                           pages  are being set off line.  This stopcode
|                           occurs when the target page is not  found  on
|                           the free-core list.
|  
|              Data Items:  T1 = current page (being set off line)
|                           P2 = target  page  (this  is  the  page  that
|                           caused the stopcode)
|  
|  
|  GNA     DATMAN   STOP    GETWRD not available


                                     51



|                           GETWRD was called at clock level but the word
|                           requested was not available.
|  
|  
|  HBE     REFSTR   DEBUG   Home Block Read Error
|  
|                           HOMUPD  updates  the   home   blocks.    This
|                           stopcode  occurs  when the subroutine to read
|                           in the current home blocks from disk  (GTHOM)
|                           gives an error return, which indicates an I/O
|                           error.
|  
|              Data Items:  S = standard error bits
|  
|  
|  HIF     FILIO    DEBUG   Hole In File
|  
|                           USETO0 is used to do a USETO.  This  stopcode
|                           occurs  when  the  last  block  of  the  file
|                           exists, but some preceding block does not.
|  
|  
|  HSF     FILIO    JOB     HSC50 not fancy


   HWU     FILIO    JOB     Hardware Wrong Unit

                            POSERC is used during  disk  error  recovery.
                            This stopcode occurs when the wrong unit on a
                            disk  controller  interrupts.   This   is   a
                            hardware problem.

               Data Items:  P2 = error bits
                            T1 = retry count


   IBI     CLOCK1   JOB     Intercept Block Illegal

                            ESTOP stops the user on an error and flags it
                            as  an error stop.  This stopcode occurs when
                            the user-defined intercept block  is  illegal
                            for some reason.


   IBZ     FILIO    JOB     I/O to Block Zero

                            UUOPWR performs CALLIs for  a  disk  channel.
                            This   stopcode   occurs   when  Block  0  is
                            requested, but the file is not  HOME.SYS[1,4]
                            or  the  drive is not an RP04.  An RP04 reads
                            block 0 to check for format errors.



                                     52



               Data Items:  T1 = PPN
                            T2 = file name
|  
|  
|  ICI     MSCCOM   DEBUG   Invalid connect-ID


   ICL     UUOCON   JOB     Illegal Channel Number

                            JDAADR returns the address of  a  channel  in
                            USRJDA  or  the extended channel table in T1.
                            This stopcode occurs when the channel  number
                            is greater than the maximum number allowed.

               Data Items:  T2 = channel number
                            HIGHXC# = maximum


   ICN     SEGCON   DEBUG   In-Core Count Negative

                            DECCNT decrements  the  high-segment  in-core
                            count for a job that has a very high segment,
                            which must be in core.  This stopcode  occurs
                            when  the count of the number of jobs in core
                            sharing a high segment becomes negative.

               Data Items:  J = job number
                            JBTSTS(J) = in-core count,  which  should  be
                            zero now


   IDC     ONCMOD   STOP    Impossible Drum Condition

                            DRMHLT checks for a unit on  line  and  write
                            protected.   This  stopcode  occurs because a
                            drum can never give an on-line condition.


   IEZ     KxSER    DEBUG   IOWD Equals Zero

                            After paging a job, the monitor attempted  to
                            convert  virtual  IOWDs  to  absolute  IOWDs.
                            This stopcode occurs  when  this  routine  is
                            called with an IOWD of zero.

               Data Items:  T2 = IOWD
                            P3 = location of channel data block
                            P4 =  frame  count,,characters/word  if  DX10
                            channel


   IFI     TAPSER   STOP    Illegal Function at Interrupt


                                     53



                            TAPIFI is a general interrupt error halt.  In
                            one  case,  for example, the monitor found an
                            illegal function  in  an  I/O  request  block
                            while  at interrupt level.  Examine the stack
                            for the specific error address.


   IIP     FILIO    STOP    I/O In Progress - Error

                            MONIO reads a block or series of blocks  from
                            the  disk.   This  stopcode  occurs  when the
                            monitor attempts to start I/O for a DDB  that
                            already has I/O active.

               Data Items:  S = status bits
                            T1 = IOWD for data
                            T2 = block number


   IME     KxSER    JOB     Illegal Memory Reference from Executive

                            This stopcode occurs when  there  is  a  page
                            fault  while  in  exec  mode  that  is not an
                            address break.

               Data Items:  .CPAPC = page fault PC
                            .CPPFW = page fault word


   IOP     COMMON   CPU     I/O Page Failure

                            There is usually a serious hardware  failure.
                            Call your Field Service representative.

   IPC     KxSER    CPU     Illegal Page Failure Trap Code

                            SEILM processes  page  failure  traps.   This
                            stopcode  occurs  when the trap code returned
                            by the pager after getting a page  fail  trap
                            is not in the range 0 through 23 or 25.

               Data Items:  T1 = page fail code
                            .CPTCX = page trap context;
                            .CPTPI = PI state
|  
|  
|  IPE     VMSER    DEBUG   In progress queue empty


   IPF     VMSER    DEBUG   In-Use Page Free

                            SCNPT scans the page  table.   This  stopcode


                                     54



                            occurs   when  SCNPT  finds  a  page  on  the
                            free-core list that is  listed  in  the  page
                            table as allocated.


   IPM     VMSER    DEBUG   Illegal Pointer in MEMTAB

                            This stopcode occurs when the  monitor  finds
                            an inconsistency in the swapping database.


   IPN     VMSER    DEBUG   IPCF Page Nonexistent

                            GVIPCP returns IPCF pages  to  the  free-core
                            list.  This stopcode occurs when GVIPCP swaps
                            out IPCF pages that are not in the swap list.


   IPU     LOKCON   STOP    IPCF Page Unowned

                            In attempting  to  swap  out  an  IPCF  page,
                            LOKCON   was   unable  to  find  a  job  that
                            contained the IPCF page in its queue.


   ITS     DTESER   DEBUG   Illegal To-10 Transfer State

                            DTESER  received  a  To-10  interrupt   which
                            specified an illegal state.
|  
|  
|  IUD     DTESER   DEBUG   Illegal user for DTE
|  
|  
|  IUI     FILIO    DEBUG   Illegal use of UPPDC at interrupt level


   IUN     FILUUO   DEBUG   Invalid Unit Number

                            ERRFIN  finishes  a  CLOSE  when   an   error
                            occurred.  This stopcode occurs when the unit
                            number for the UFD is illegal.

               Data Items:  UN1PTR = pointer to number  in  structure  of
                            the unit;  T1 = unit of UFD


   JAC     UUOCON   DEBUG   Job Data Area Clobbered

                            IOALL does I/O for all devices assigned to  a
                            job.   This  stopcode occurs when the highest
                            channel number in use is greater than 17.


                                     55



               Data Items:  T2 = highest channel in use


   JDJ     ONCMOD   DEBUG   JFFO Didn't Jump

                            CMPLOG  computes  the  SIXBIT  logical   unit
                            number  within  a  structure.   This stopcode
                            occurs after a  call  to  subroutine  MSKUNI,
                            which  sets up a search mask for a unit name,
                            and it returns no  mask  for  the  unit  name
                            given.

               Data Items:  P2 = unit number
                            STRNAM(P2) = unit name
                            T2 = should have been the complement  of  the
                            search mask


   JIT     SYSINI   HALT    Job In Transit

                            LOKINI initializes  LOKCON  on  location  140
                            restarts,  unlocks all jobs, and frees up the
                            core they occupy.  This stopcode occurs  when
                            a job is locked and is being moved.

               Data Items:  J = job number


   JNC     FILIO    DEBUG   Job Not in Core

                            ADRINT checks that a job is in core, possibly
                            at  interrupt  level.   This  stopcode occurs
                            when the job is not in core.

               Data Items:  T1 = job number


   JNE     CLOCK1   STOP    JBTADR not equal to CORTAL

                            In  cross-checking  JBTADR   and   CORTAL   a
                            mismatch was found.

               Data Items:  P3 = amount of free-core specified by the sum
                            of JBTADR entries


   KAF     COMMON   CPU     Keep-Alive Failure

                            This routine/stopcode is executed because the
                            console  front  end  detected that the KL did
                            not  update  the  keep-alive  counter.   This
                            stopcode occurs when the front end executes a


                                     56



                            XCT 71.


   KCP     RNXKON   DEBUG   KDB Command in Progress

                            CMDWAT waits for a command  to  complete  and
                            calls  RNXINR to process it before starting a
                            new command.


   KDS     DPXKON   DEBUG   KONEC2 Didn't Skip

                            POSINT handles positioning interrupts.   This
                            stopcode  occurs  when  the subroutine KONEC2
                            does not skip, even though it  should  always
                            give a skip return.


   KID     SYSINI   HALT    Kontroller Is Down

                            DSKINI, which is called on location  140  and
                            143  starts  and  restarts,  initializes  the
                            disk.  This stopcode occurs when a controller
                            goes off-line during disk initialization.

               Data Items:  J = kontroller
|  
|  
|  KIM     RAXKON   DEBUG   Kontroller id mismatch
|  
|  
|  KLPBRC  KLPSER   INF     Bad Read-Counters packet
|  
|  
|  KLPCGN  KLPSER   CHK     Can't get CI node number
|  
|  
|  KLPCKE  KLPSER   CHK     SET-CIRCUIT command error
|  
|  
|  KLPCLB  KLPSER   INF     Close buffer function failed
|  
|  
|  KLPCPE  KLPSER   INF     KLIPA CRAM parity error
|  
|                           A parity error occurred on  the  CI20,  which
|                           may indicate a hardware condition.
|  
|  
|  KLPCRR  KLPSER   CHK     READ-REGISTER command failed




                                     57



|  KLPDED  KLPSER   INF     CI-20 is dead
|  
|  
|  KLPDFQ  KLPSER   INF     Datagram free queue empty
|  
|  
|  KLPEPB  KLPSER   CHK     Received bad error logging packet
|  
|  
|  KLPERQ  KLPSER   CHK     Empty response queue
|  
|  
|  KLPERR  KLPSER   INF     Received packet with error
|  
|  
|  KLPHLT  KLPSER   INF     KLIPA microprocessor halted
|  
|                           The  CI20  microprocessor  halted  for   some
|                           reason.
|  
|  
|  KLPHNG  KLPSER   INF     CI-20 is hung
|  
|  
|  KLPILP  KLPSER   INF     Software     response      terminated      in
|                           locally-generated packet
|  
|  
|  KLPIPA  KLPSER   INF     Invalid packet arrived
|  
|  
|  KLPIRD  KLPSER   INF     Invalid remotely-generated data request
|  
|  
|  KLPIRP  KLPSER   INF     Software     response     bit      on      in
|                           remotely-generated packet
|  
|  
|  KLPKAF  KLPSER   INF     KLIPA Keep Alive Failed
|  
|                           The KLIPA will reload automatically.
|  
|  
|  KLPKRW  KLPSER   HLT     CI-20 read the wrong register
|  
|  
|  KLPLBF  KLPSER   INF     Loopback failed
|  
|  
|  KLPMBE  KLPSER   INF     MBUS error




                                     58



|  KLPMCE  KLPSER   INF     Received an MCNF or an MDATREC with an error
|  
|  
|  KLPMCR  KLPSER   CHK     Received an unexpected MCNF or MDATREC
|  
|  
|  KLPMFQ  KLPSER   INF     Message free queue empty
|  
|  
|  KLPNBD  KLPSER   HLT     No buffer descriptor table
|  
|  
|  KLPNDB  KLPSER   INF     No datagram buffer
|  
|  
|  KLPNDE  KLPSER   INF     Packet with bad node number
|  
|  
|  KLPNEN  KLPSER   CHK     CI-20 not enabled
|  
|  
|  KLPNMG  KLPSER   INF     No message buffer
|  
|  
|  KLPNOD  KLPSER   HLT     Can't    get    datagram    buffers    during
|                           initialization
|  
|  
|  KLPNOR  KLPSER   INF     Remote port is sick
|  
|  
|  KLPNPB  KLPSER   HLT     No path block at PPDOVC
|  
|  
|  KLPOHF  KLPSER   HLT     Internal software inconsistency
|  
|  
|  KLPONC  KLPSER   HLT     Trying to open a virtual circuit which  isn't
|                           closed
|  
|  
|  KLPOPC  KLPSER   INF     Packet with bad opcode
|  
|  
|  KLPPIA  KLPSER   INF     CI-20 has lost its PI assignment
|  
|  
|  KLPPIC  KLPSER   HLT     PCB is Corrupted
|  
|  
|  KLPPPD  KLPSER   INF     Packet with bad PPD byte



                                     59



|  KLPPTQ  KLPSER   INF     Queue interlock timeout
|  
|  
|  KLPRCE  KLPSER   CHK     READ-COUNTERS command failed
|  
|  
|  KLPRLF  KLPSER   INF     CI-20 microcode reload failed
|  
|  
|  KLPRMQ  KLPSER   INF     Queue interlock timeout
|  
|  
|  KLPRSF  KLPSER   INF     CI-20 restart failed
|  
|  
|  KLPRSH  KLPSER   INF     Received shutdown message
|  
|  
|  KLPSCR  KLPSER   CHK     SET-CIRCUIT command received
|  
|  
|  KLPSTR  KLPSER   INF     CI-20 started
|  
|  
|  KLPSWO  KLPSER   INF     Received a START when VC was open
|  
|  
|  KLPVIR  KLPSER   CHK     Virtual address in packet is wrong
|  
|  
|  KLPWAB  KLPSER   INF     CI wire A has gone from good to bad
|  
|  
|  KLPWAG  KLPSER   INF     CI wire A has gone from bad to good
|  
|  
|  KLPWBB  KLPSER   INF     CI wire B has gone from good to bad
|  
|  
|  KLPWBG  KLPSER   INF     CI wire A has gone from bad to good
|  
|  
|  KN5     RAXKON   INF     Kontroller not in 576-byte sector mode
|  
|  
|  KNF     XTCSER   STOP    Kontroller Not Free
|  
|                           XTCSER received a remote  interrupt  request,
|                           the the kontroller was not free.
|  
|  
|  KNIARD  KNISER   INF     KLNI auto-reload disabled


                                     60



|  KNICAC  KNISER   DEBUG   Can't allocate counters data buffer
|  
|  
|  KNICAM  KNISER   DEBUG   Can't allocate MCAT table
|  
|  
|  KNICAP  KNISER   DEBUG   Can't allocate PTT table
|  
|  
|  KNICCC  KNISER   DEBUG   Cannot create CONSO skip chain entry
|  
|  
|  KNICCK  KNISER   DEBUG   Can't create Ethernet kontroller block
|  
|  
|  KNICCP  KNISER   DEBUG   Cannot create port control block
|  
|  
|  KNICPE  KNISER   INF     KLNI CRAM parity error
|  
|                           A parity error occurred on the  NIA20,  which
|                           may indicate a hardware condition.
|  
|  
|  KNICWS  KNISER   DEBUG   KLNI counters buffer is wrong size
|  
|  
|  KNIDPE  KNISER   INF     KLNI data path error
|  
|  
|  KNIEPE  KNISER   INF     KLNI EBUS parity error
|  
|  
|  KNIHLT  KNISER   INF     KLINI microprocessor halted
|  
|                           The  NIA20  microprocessor  halted  for  some
|                           reason.
|  
|  
|  KNIICO  KNISER   DEBUG   Invalid command opcode
|  
|  
|  KNIIFC  KNISER   DEBUG   Illegal function code
|  
|  
|  KNIKAF  KNISER   INF     KLNI Keep Alive failed
|  
|  
|  KNIMBE  KLNISER  INF     KLNI MBUS error
|  
|  
|  KNIMWS  KNISER   DEBUG   KLNI MCAT table is wrong size


                                     61



|  KNIPIT  KNISER   INF     PUTQUE interlock timeout
|  
|  
|  KNIPWS  KNISER   DEBUG   KLNI PTT table is wrong size
|  
|  
|  KNIRIT  KNISER   INF     REMQUE interlock timeout
|  
|  
|  KNIWUV  KNISER   DEBUG   Wrong microcode version


   KNM     TX1KON   DEBUG   Kontroller Not Mapped

                            In attempt to uncache a DX10 KDB we found the
                            KDB was not in the EPMP.


   KSW     TAPSER   DEBUG   Kontroller Status Wrong

                            TAPSIO is used when the upper level wants  to
                            start  I/O.   This  stopcode  occurs when the
                            tape-controller status is wrong.

               Data Items:  TKBSTS(W) = status
|  
|  
|  LATICB  LATSRV   CHK     LATCBR  called  from   NISRV   with   illegal
|                           callback function code
|  
|                           NISRV has called the LATSRV callback  routine
|                           with an invalid function code.
|  
|  
|  LATIMT  LATSRV   INF     LAT Illegal Message Type
|  
|                           LAT virtual  circuit  message  received  with
|                           message type out of range.
|  
|  
|  LATINE  LATSRV   CHK     LATINI failed to initialize
|  
|  
|  LATMEM  LATSRV   CHK     LAT buffer overwritten
|  
|                           While  trying  to  return  a  buffer,  LATSRV
|                           discovered it had been overwritten.
|  
|  
|  LATNSC  LATSRV   INF     LAT Host node stopped circuit
|  
|                           LAT Host node stopped the circuit.


                                     62



|                           Look at the Reason Code in T1 and the  PC  in
|                           T2.   This error, if relatively infrequent is
|                           nothing to be concerned about.  If it  occurs
|                           frequently,  use the CODE and PC to determine
|                           further action.
|  
|  
|  LDBNIU  SCNSER   DEBUG   LDB Not In Use
|  
|                           A call to the FRELDB routine was made, though
|                           the  terminal's  LDB does not have the LTLUSE
|                           bit set in the LDBTTW word.   Normally,  this
|                           bit  would  be set on a return from GETLDB to
|                           indicate that that LDB is in use.
|  
|  
|  LLMCIF  LLMOP    CHK     Read Channel Info Failed
|  
|                           Attempt to read the Ethernet  channel  status
|                           failed when the Data Link Layer was called.
|  
|              Data items:  T1 contains the error code returned from  the
|                           DLL
|  
|  
|  LLMIL1  LLMOP    INF     Received Invalid Loopback Message
|  
|                           Received a  Loopback  message  that  was  too
|                           short or was improperly formatted.  This is a
|                           MOP protocol violation by a remote node.
|  
|              Data items:  T1 contains the received message length.
|                           T2-T3 contains the Ethernet  address  of  the
|                           transmitting node.
|  
|  
|  LLMILF  LLMOP    INF     Invalid Loopback Function Code
|  
|                           Received a Loopback message that was  neither
|                           a  Loopback  reply  message or a forward data
|                           message.  This is a MOP protocol violation by
|                           a remote node.
|  
|              Data items:  T1 contains the function code.
|                           T2-T3 contains the Ethernet  address  of  the
|                           transmitting node.
|  
|  
|  LLMIR1  LLMOP    INF     LLMOP Received Invalid Remote Console Message
|  
|                           Received a Remote Console  message  that  was
|                           too   short,   too  long  or  was  improperly


                                     63



|                           formatted.  This is a MOP protocol  violation
|                           by a remote node.
|  
|  
|  LLMLXF  LLMOP    INF     Loopback Transmit Failed
|  
|                           LLMOP was unable to transmit a  forward  data
|                           message.
|  
|              Data items:  T1 contains the error code returned from  the
|                           DLL
|                           T2 contains the channel status returned  from
|                           the DLL
|                           T3 contains the channel on which the  failure
|                           occurred
|  
|  
|              LLMMCF       LLMOP CHK Declare Multicast Address Failed
|  
|                           Attempt to declare the  Assistant  Multi-Cast
|                           Address  failed  when the Data Link Layer was
|                           called.
|  
|              Data items:  T1 contains the error code returned from  the
|                           DLL
|  
|  
|  LLMOPF  LLMOP    CHK     Open Portal Failed
|  
|                           Failed to open an NI  portal  with  the  Data
|                           Link Layer.
|  
|              Data items:  T1 contains the error code returned from  the
|                           DLL.
|  
|  
|  LLMRQC  LLMOP    CHK     RB Queue Corrupted
|  
|                           Attempted to remove an RB queue entry from an
|                           empty queue or the RB was not on the queue.
|  
|  
|  LLMRRF  LLMOP    INF     Response Transmit Failed
|  
|                           LLMOP was unable to transmit  a  MOP  request
|                           message.
|  
|              Data items:  T1 contains the error code returned from  the
|                           DLL.
|                           T3 contains the channel on which the  failure
|                           occurred.



                                     64



|  LLMRXF  LLMOP    CHK     Resource Failure
|  
|                           LLMOP was not able to obtain  resources  from
|                           the memory manager.
|  
|  
|  LLMSB2  LLMOP    CHK     Specify Receive Buffer Failure
|  
|                           LLMOP could not post a receive buffer to  the
|                           Data Link Layer.
|  
|              Data items:  T1 contains the error code returned from  the
|                           DLL.
|  
|  
|  LLMSCA  LLMOP    INF     Ethernet Channel Address Change
|  
|                           LLMOP was called by NIDDL on change of state.
|  
|  
|  LLMSTC  LLMOP    INF     Data Link State Change
|  
|                           LLMOP was called by NIDDL on change of state.
|                           This  is for information only.  No corrective
|                           action required.


   LN1     ERRCON   STOP    Line Not Found

                            EXCALP prints a monitor call PC message for a
                            job.   This stopcode occurs when no terminals
                            a log line can be found for the job  that  is
                            causing the error.


   LND     FILUUO   DEBUG   Logical Name Not Found

                            LNMSTP consists of only the stopcode and  its
                            recovery.   LNMSTP is called when the monitor
                            could not set up the definition of  LIB  that
                            was  present  before  an ENTER UUO that could
                            not find a file.


   LNP     FILIO    DEBUG   Last Pointer Not a Pointer

                            OUTGRP allocates more  space  for  an  output
                            file.    This   stopcode   occurs   when   an
                            allocation is made, but a RIB error occurred;
                            or  when  the monitor tried to deallocate the
                            space, but the RIB pointer was invalid.



                                     65



               Data Items:  T2 = pointer


   LNS     SCNSER   STOP    Line Not Set Up

                            TSETBI clears the input  and  output  buffers
                            for  a  line.  This stopcode occurs when this
                            routine is called before the line is set up.


   LNT     ERRCON   STOP    Line Not There

                            HALTI prints the "Halt at  ..."  message  and
                            stops  the  job.   This  stopcode occurs when
                            there  is  no   controlling   terminal   line
                            associated with the job.


   LPU     FILUUO   JOB     Last Pointer Unit-Change

                            ALLP0B writes the redundant RIB in  the  last
                            block  of the RIB.  This stopcode occurs when
                            the RIB pointer is decoded as  a  unit-change
                            pointer.

               Data Items:  T2 = pointer
|  
|  
|  LPRIXC  LLMOP    HLT     Invalid Xmit Complete
|  
|                           NIDLL called back to LLMOP  with  a  transmit
|                           complete  event  for  an  RB  which is not in
|                           Transmit Initiated state.  This is a software
|                           bug.  Call your DIGITAL Software Specialist.
|  
|              Data items:  T1 contains the current RB state.
|                           T3 contains the status in the UN block.
|  
|  
|  LPRLXF  LLMOP    INF     Loop Request Transmit Failed
|  
|                           LLMOP was unable to transmit a  forward  data
|                           message.
|  
|              Data items:  T1 contains the error code returned from  the
|                           DLL.
|                           T3 contains the channel on which the  failure
|                           occurred.
|  
|  
|  LPSIFC  LLMOP    CHK     LPSCBR called with invalid function code



                                     66



|                           The LLMOP Loopback Protocol Server Call  Back
|                           Routine  was  called  by  the Data Link Layer
|                           with an invalid callback function code.  This
|                           is   a   software  bug.   Call  your  DIGITAL
|                           Software Specialist.
|  
|  
|  MCCWNE  SCNSER   STOP    Meta character called when not expected
|  
|  
|  MCI     MSCCOM   DEBUG   Missing connect id

   MCM     METCON   DEBUG   Meter Channel Data Block Missing

                            RELCHN releases  a  channel.   This  stopcode
                            occurs  when  an attempt is made to release a
                            meter channel data block (MCDB) that  is  not
                            there.

               Data Items:  T2 = predecessor MCDB (if any)


   MCN     FILFND   DEBUG   Mount Count Negative

                            SLSR6 documents  the  mount  count  when  the
                            search   list  is  modified.   This  stopcode
                            occurs when the mount count for  a  structure
                            becomes negative.

               Data Items:  STRMNT(T3) = mount count
|  
|  
|  MCRBRN  NETDEV   STOP    Bad remote node number
|  
|                           When processing an ANF  network  "node  down"
|                           condition, NETMCR (MCRNWD) was called to deal
|                           with   a   terminal    belonging    to    the
|                           no-longer-accessible  node,  but the terminal
|                           claimed to belong to a different node.
|  
|              Data Items:  U = address of LDB
|                           T1 = node number from LDB
|                           P1 = node number that "went down"
|  
|  
|  MCRDSF  NETDEV   STOP    Disconnect failed
|  
|                           When  processing  an  ANF  network   terminal
|                           Disconnect message, a call to PCBECK returned
|                           "guaranteeing" the  availability  of  an  ANF
|                           network   Protocol   Control  Block,  then  a
|                           subsequent call to PCBEGT to get a  free  PCB


                                     67



|                           failed.
|  
|              Data Items:  U = address of LDB
|  
|  
|  MCRILS  NETDEV   STOP    Illegal state
|  
|                           While waiting for  an  ANF  network  terminal
|                           request  to  be  honored, the terminal's Link
|                           Address Table state transited into an illegal
|                           state  (neither  accepted,  nor rejected, nor
|                           still waiting).
|  
|              Data Items:  U = address of LDB
|                           T2 = illegal LAT state
|  
|  
|  MCRJIZ  NETDEV   STOP    Job number Is Zero
|  
|                           On       a       program-initiated,        or
|                           user-command-initiated  connect request for a
|                           remote ANF network terminal, .CPJOB was zero.
|  
|              Data Items:  U = address of LDB
|                           W = address of NDB
|  
|  
|  MCRNCO  NETDEV   DEBUG   No character for output
|  
|                           On a call to MCXDAT to build a  Data  Message
|                           for  an ANF network terminal, the LRLTTO flag
|                           (valid character in LDPCHR) was  not  set  in
|                           the  terminal's  Line  Data Block.  MCXDAT is
|                           only called when there is at least one  valid
|                           data  character  to  be  transmitted, and the
|                           first data character is always in LDPCHR.
|  
|              Data Items:  U = address of LDB
|  
|  
|  MCRNSN  NETDEV   STOP    No source node for terminal
|  
|                           When processing a "Disconnect with reconnect"
|                           for  an  ANF  network  terminal, no Node Data
|                           Block can be found for the connected terminal
|                           (SRCNDB failed).
|  
|              Data Items:  U = address of LDB
|  
|  
|  MCRNWA  NETDEV   STOP    MCRNWD should have disconnected us



                                     68



|                           When processing a Disconnect request  for  an
|                           ANF  network terminal, no Node Data Block can
|                           be found for the connected  terminal  (SRCNDB
|                           failed).
|  
|              Data Items:  U = address of LDB
|  
|  
|  MCRSLZ  NETDEV   STOP    SLA is zero
|  
|                           On  a  call  to  MCRXCN  to  send  a  Connect
|                           Initiate   message  (or  possibly  a  Connect
|                           Confirm message) to a remote ANF network node
|                           for  a  network  terminal,  the terminal Line
|                           Data Block had no Source Link Address.
|  
|              Data Items:  U = address of LDB
|                           W = address of NDB
|  
|  
|  MIF     MSCCOM   STOP    MSCP driver initialization failed
|  
|  
|  MIN     VMSER    DEBUG   Monitor page in working set


   MIW     ONCE     STOP    Memory Interleaving is Wrong

                            BYPSYM finds the top of core  and  moves  the
                            symbol  table  up.  This stopcode occurs when
                            there is a memory interleaving error in  that
                            some  words  within  a page exist and some do
                            not.  The operator must correct the problem.


   MIZ     VMSER    DEBUG   MEMTAB Is Zero

                            This stopcode occurs when the  monitor  finds
                            an inconsistency in the swapping database.


   MMR     LOKCON   STOP    Moving Monitor Page Not Required

                            SETMFL sets  memory  pages  off  line.   This
                            stopcode  occurs  when  the  memory  location
                            labeled MOFLPG indicates that  monitor  pages
                            must  be moved, but none of the page's PAGTAB
                            entries has the monitor code bit set.

               Data Items:  MOFLPG = number of monitor pages that were to
                            be moved
                            LOKREL = number of pages, first  page  number


                                     69



                            to set off line

   MNA     FILIO    JOB     Monitor Buffer Not Available

                            GTMNBF gets a monitor buffer.  This  stopcode
                            occurs   when   there   is  no  buffer  space
                            available.

               Data Items:  T2 = number of words requested

   MNM     SYSINI   STOP    Monitor in Nonexistent Memory

                            KIINI initializes  a  KI10,  KL10,  or  KS10.
                            This  stopcode occurs when a page is found to
                            be nonexistent and  the  page  is  not  free.
                            Therefore,  the  monitor already has the page
                            in question.

               Data Items:  T3 = page number


   MNR     ERRCON   HALT    Master -11 Not Running

                            DIE recovers/reloads after an internal system
                            error.   This  stopcode  occurs  when the -11
                            with a DTE in privilege mode is not running.
|  
|  
|  MOPIFC  LLMOP    INF     LLMOP Received an invalid MOP message
|  
|                           The  LLMOP  Remote  Console  Protocol  Server
|                           received   a  MOP  message  with  an  invalid
|                           function  code.   This  is  a  MOP   protocol
|                           violation by a remote node.
|  
|  
|  MPF     MSCCOM   DEBUG   MSCCOM packet send failed


   MPN     LOKCON   STOP    Monitor Page Not Found

                            SETMFL sets monitor  pages  off  line.   This
                            stopcode  occurs  when the source page cannot
                            be found in the monitor.

               Data Items:  P3 = monitor source page


   MXM     MSGSER   DEBUG   MPX DDB Missing

                            This stopcode occurs when a  pointer  in  the
                            DDB chain does not point to a multiplexd DDB.


                                     70



   N4C     CPNSER   JOB     Not 4 Cached Pages

                            FIXOTB fixes up OUCHTB when turning  off  the
                            cache  for some page so that OUCHE references
                            through four  cached  pages.   This  stopcode
                            occurs  when  four  cached  pages  cannot  be
                            found.

               Data Items:  P3 = page for which cache is being turned off


   NAP     FILUUO   JOB     Not Address Pointer

                            UFDNXT initializes the  next  block  for  the
                            directory.  This stopcode occurs when the new
                            pointer is decoded as other than  an  address
                            pointer.

               Data Items:  P1 = location is monitor buffer
                            T2 = bad pointer

   NCA     CLOCK1   STOP    No Core Assigned

                            NULADR restores the software state  and  then
                            the  hardware state of the new job to be run.
                            This stopcode occurs when the job to  be  run
                            has no core assigned to it.

               Data Items:  J = job number

   NCC     LOKCON   STOP    Not Enough Contiguous Free Core

                            Certain types of monitor pages must  be  kept
                            contiguous.  This stopcode occurs when LOKCON
                            does not have enough contiguous space to lock
                            jobs after memory has been set off-line.


   NCE     UUOCON   DEBUG   No Command Slot Available

                            This  stopcode  occurs  when  attempting   to
                            insert a user-defined command.  The condition
                            should have been caught earlier.


   NCM     IPCSER   JOB     No Core For Message

                            SETQSR  sets  up  IPCF  packets  to  send  to
                            QUASAR.  This stopcode occurs when no core is
                            available to build the message.




                                     71



   NDJ     SCNSER   DEBUG   No DDB For Job

                            TTYFND finds a terminal number for the job in
                            AC  J.   This  stopcode occurs when no device
                            data  block  can  be  found  for  this  job's
                            terminal.

               Data Items:  J = job number


   NDL     COMNET   STOP    No DECnet Loaded

                            This  stopcode  occurs  if  any   DECnet-only
                            routines   are  called,  but  DECnet  is  not
                            assembled into the monitor.


   NDP     CLOCK1   JOB     Not DDB Pointer

                            WSYNC waits until the current buffer activity
                            is  complete.  This stopcode occurs when this
                            routine is  called  with  other  than  a  DDB
                            pointer in F.

               Data Items:  F = the supposed DDB pointer


   NDS     CLOCK1   STOP    Null Job Did SAVGET

                            MONSTR sets up ACs for  a  monitor  job  that
                            starts  at monitor call level.  This stopcode
                            occurs when the job number is 0.


   NEM     LP2SER   JOB     No Exec Virtual Memory

                            DVLRAM loads the RAM or VFU  with  data  from
                            the  user.   This stopcode occurs when DVLRAM
                            tries to map the user  virtual  address  into
                            exec virtual memory, but there is none.

               Data Items:  F = DDB
                            T1 = function


   NER     FILUUO   DEBUG   No Extended RIB

                            CLSO2A looks for the last  written  block  in
                            the  next RIB.  This stopcode occurs when the
                            pointer for the last block of a file  is  not
                            in  the  RIB,  and  there is no extended RIB;
                            the pointer is lost.


                                     72



   NEV     UUOCON   STOP    No Executive Virtual Memory

                            NEWBUF sets up a byte pointer and item  count
                            for  I/O.   This stopcode occurs when the DDB
                            does not have executive virtual memory.

               Data Items:  T1 = input buffer header address


   NFB     FEDSER   STOP    No Front-End Device Block

                            FDIGET  gets  the  front-end   device   (FED)
                            address  in  F.  This stopcode occurs when no
                            device data block is  found  for  this  front
                            end.

               Data Items:  T1 = FED unit number (also on this stack)


   NFD     RPXKON   DEBUG   No Front-End Drive

                            DAVIN1 starts an operation on a drive that is
                            busy on the other port.  This stopcode occurs
                            when DAVIN1 cannot find the drive number.


   NFS     VMSER    DEBUG   No First Slot

                            This stopcode occurs when, at the start of  a
                            fragment,  the  first  physical  page  of the
                            fragment is not found in the page map.


   NIF     RNXKON   DEBUG   RNXKON Isn't Fancy

                            This stopcode occurs if the monitor tried  to
                            unload    an   RP20   or   read/write   10/11
                            compatability mode on an RP20.
|  
|  
|  NIJ     IPCSER   STOP    No IPCF database for job/context


   NIV     TAPUUO   STOP    Null Interrupt Vector

                            TPMDON  is  called  by  TAPSER  when  I/O  is
                            complete  to  dispatch to the correct routine
                            for processing.  This  stopcode  occurs  when
                            the  routine  address  for  this  function is
                            null.

               Data Items:  P1 = function


                                     73



                            (T1) = should be dispatch address


   NJT     ERRCON   STOP    Null Job Has TTY

                            EXCALP prints the PC of a monitor  call  that
                            caused  an  error.  This stopcode occurs when
                            NULJOB has control of the terminal.


   NLB     FILUUO   JOB     No Last Block

                            This stopcode occurs during  UFD  compression
                            if  we  cannot  find the pointer for the last
                            block of the UFD.


   NMC     ONCMOD   STOP    No More Core

                            OK22B  sets  up  controllers  during   system
                            startup.    This  stopcode  occurs  when  the
                            routine used to create a  device  data  block
                            for  ONCE-only  I/O  (SETDDO)  gives an error
                            return,  which  indicates  that  no  core  is
                            available.

               Data Items:  T2 = size of chunk needed
|  
|  
|  NMCPUM  UUOCON   DEBUG   Need missing CPU mask
|  
|  
|  NMU     REFSTR   DEBUG   No More Units
|  
|                           HOMZR2  writes  zeros  in  unused  blocks  in
|                           HOME.SYS.   This  stopcode  occurs  when  the
|                           count of units is  greater  than  the  number
|                           that can be accessed.
|  
|              Data Items:  T1 = cluster count
|                           T2 = next retrieval pointer
|  
|  
|  NNF     FILUUO   DEBUG   NMB Not Found
|  
|                           GETNMB gets the location of  the  name  block
|                           (NMB)  from  the  DDB.   This stopcode occurs
|                           when there is no access table entry  for  the
|                           user channel.
|  
|  
|  NNR     FILUUO   JOB     No Next RIB


                                     74



|                           DELGRP returns blocks  on  an  update  ENTER.
|                           This  stopcode  occurs  when  the  last block
|                           pointer cannot be found in the  current  RIB,
|                           so  an  attempt is made to scan the next RIB,
|                           but there is no other RIB.
|  
|  
|  NNS     CORE1    DEBUG   Not in Non-Zero Section
|  
|                           In attempting to  clear/set  bits  in  a  bit
|                           table,  SETR  was called requesting the usage
|                           of a relative AOBJN pointer.   This  is  only
|                           relevant  for bit tables in non-zero sections
|                           and the code was not executing in a  non-zero
|                           section.
|  
|  
|  NNU     ONCMOD   DEBUG   Not a New Unit
|  
|                           FILMAN finds and sets up  all  structures  on
|                           the  system.   This  stopcode occurs when the
|                           monitor expects to find a new unit pointer as
|                           the next item read, but does not.
|  
|              Data Items:  T1 = AOBJN  pointer  for  scanning  retrieval
|                           information
|                           T2 = supposed new unit pointer (Bit  18  must
|                           be set to be a new unit pointer)
|                           T3 = logical unit number in this structure
|                           P2 = address of structure
|  
|  
|  NOB     COMNET   DEBUG   "Nobody" Got Obsolete Buffer
|  
|                           This stopcode occurs if someone tries to pass
|                           a  message  to a Front End which is not owned
|                           by anyone.  This is probably  caused  by  the
|                           line  driver trying to return stale data to a
|                           previous line user and getting confused.
|  
|  
|  NOR     MSCCOM   STOP    Notification code out of range
|  
|  
|  NOT     SCNSER   DEBUG   No Operator TTY
|  
|                           TTYERP finds a terminal device data block for
|                           a   monitor  error  message.   This  stopcode
|                           occurs when the monitor cannot find a DDB for
|                           a  job,  so  it  tries to find the operator's
|                           line number from ONCE and still  cannot  find
|                           it.


                                     75



|  NOW     FILIO    DEBUG   No opr wait (obsolete)


   NPD     FILIO    DEBUG   No Pointers in DDB

                            EXTRIB  creates  an   extended   RIB.    This
                            stopcode  occurs  when  an  extended  RIB  is
                            needed, but no pointers exist in the DDB.

               Data Items:  DEVMBF(F) = IOWD to monitor buffer


   NPF     LOKCON   STOP    Next Page Free

                            PAGFND  finds  the  target   page   in   this
                            segment's  map  because  it  was  not  on the
                            free-core list.  This stopcode occurs when  a
                            page in this segment is marked as free.

               Data Items:  T1 = current page
                            T2 = PAGTAB entry for the next page (this  is
                            the page that caused the error)


   NPI     KxSER    HALT    Not Parity Instruction

                            SWPTRP sweeps  a  memory  for  parity.   This
                            stopcode  occurs when a page fail trap occurs
                            that is not caused by the sweep routine  and,
                            in  fact,  is  caused  by  the instruction at
                            label CPLMPI.

               Data Items:  T1 = PC of the instruction  that  caused  the
                            trap (also in .UPMP + .LMPFP)
                            .UPMP + .LMPFW = page fail word


   NPJ     DATMAN   DEBUG   No PDB for Job

                            This stopcode occurs  when  no  process  data
                            block can be found for this job.

               Data Items:  J = job number


   NPN     ERRCON   STOP    Nonexistent Page Not Free

                            CPINXF fixes up  the  core-allocation  tables
                            after  pages  have  been marked out in NXMTAB
                            because  of  parity  errors  or  NXMs.   This
                            stopcode  occurs  when  the page being marked
                            off line is in use not free).


                                     76



               Data Items:  PAGTAB(T1) = page entry of page  causing  the
                            stopcode


   NPU     ERRCON   STOP    Null Pushdown List Underflow

                            This stopcode occurs when there are more POPs
                            on  the  null  pushdown  list  than  matching
                            PUSHs.


   NRF     VMSER    DEBUG   SWPLST Not Really Fragmented

                            This stopcode occurs when there is a  pointer
                            to  a  fragmented SWPLST entry, but the entry
                            is not really fragmented.


   NRM     FILUUO   JOB     Next RIB Missing

                            RENRIB   is   used   when    allocation    or
                            deallocation  is  done  and  set up to do the
                            close.  This stopcode occurs  when  the  last
                            block pointer is not found in the current RIB
                            and there are no other RIBs.


   NRS     ONCMOD   DEBUG   No RIB in SAT

                            FILMAN finds and sets up  all  structures  on
                            the  system.   This  stopcode occurs when the
                            monitor expects to see a read-in  block,  but
                            does not.

               Data Items:  T1 = the supposed RIB
|  
|  
|  NSA     ONCMOD   STOP    No section allocated


   NSE     VMSER    DEBUG   No SWPLST Entry

                            This  stopcode  occurs   when   the   monitor
                            attempts   to  compute  the  unit  and  block
                            numbers corresponding to a SWPLST entry,  but
                            the pointer to SWPLST points to a zero word.


   NSR     REFSTR   STOP    No Second RIB

                            FILSET creates  a  file  of  contiguous  disk
                            space  and  write zeros in data blocks.  This


                                     77



                            stopcode occurs when the subroutine  used  to
                            scan  a  block  of retrieval pointers to find
                            the group pointer,  SCNPTR,  gives  an  error
                            return because it cannot find it.

               Data Items:  P1 = pointer to cluster count
                            T2 = number of clusters in this pointer


   NSS     REFSTR   DEBUG   No Space for SAT

                            ENDSAT allocates blocks in the HOME.SYS  file
                            for  SATs.   This  stopcode occurs when there
                            are no free clusters left.


   NSU     FILIO    DEBUG   No Such Unit

                            USTRIB reads in the RIB and scans it from the
                            beginning  if  the  pointers do not encompass
                            the desired block.  This stopcode occurs when
                            the  subroutine  that  finds  a  unit (NEWUN)
                            gives an error  return  indicating  that  the
                            desired unit is greater than the last unit in
                            the structure.

               Data Items:  S = error bits
                            IOBKTL SET


   NTE     SCHED1   STOP    Not Processor Queue Error

                            QLNKZ is used in  the  requeuing  of  a  job.
                            This  stopcode  occurs  when  this routine is
                            called for a job that is not in  a  processor
                            queue.

               Data Items:  J = job number


   NUB     FILFND   JOB     No UFB Block

                            STRDN4 creates an access table  entry.   This
                            stopcode  occurs  when  there is no UFD for a
                            file even though the file exists.

               Data Items:  P2 = Structure data block (LH)

   NUE     FILUUO   JOB     No UFB Error

                            SETUFR sets the RIBUFD word in the RIB.  This
                            stopcode occurs when an error return is given


                                     78



                            by the subroutine used to compute  the  RIBUF
                            word, but actually there is no UFD or SFD, so
                            there can be no UFB error.

               Data Items:  DEVUFB(F) = pointer to UFD
                            DEVSFD(F) = pointer to SFD, if any


   NUI     XTCSER   DEBUG   Non-existent Unit Interrupting

                            XTCSER could not find the UDB for a  unit  it
                            received an interrupt request from.
|  
|  
|  NUL     VMSER    DEBUG   Not at UUO level
|  
|  
|  NULCCR  NULFEK   STOP    Conversion code out of range
|  
|  
|  NULFNC  NULFEK   STOP    Function code out of range


   NUN     FILUUO   DEBUG   NMB Use-count Negative

                            The name-block use count was  decremented  to
                            -1.


   NUP     FILUUO   DEBUG   No Unit-Change Pointer

                            LSTUNI finds the last unit-change pointer  in
                            a  RIB.   This stopcode occurs when no change
                            pointer is found or when the pointer is not a
                            unit-change pointer.

               Data Items:  T2 = pointer
|  
|  
|  NUT     FILIO    CPU     No unit for transfer


   NWA     NETDEV   STOP    No-one Wrote Anything

                            At the end of building an ANF network message
                            for  a network terminal, TWRPCB was called to
                            send the accumulated message,  but  the  byte
                            count was zero (or negative).

               Data Items:  U = address of LDB
                            P3 = byte count for NCL message



                                     79



   NXS     VMSER    DEBUG   Non-existent Section

                            DNZSPG is called to return a non-zero section
                            page  to  free core.  This stopcode occurs if
                            the section of the specified  page  does  not
                            exist.


   NXU     FILIO    DEBUG   Non-existent Unit

                            WRTRIB writes a RIB.   This  stopcode  occurs
                            when  a  unit-change pointer points to a unit
                            that does not exist in the structure.

               Data Items:  S = error bits
                            U = 0 if not in any F/S


   O1F     VMSER    DEBUG   Only 1 Fragment

                            This stopcode occurs when swapping  space  is
                            fragmented,  but  there  is only one entry in
                            the fragment table.


   OMR     KSSER    JOB     Out of Mapping Registers

                            MAPIO sets  up  the  UNIBUS  adapter  mapping
                            registers  for  a  given  IOWD  following the
                            paging of a job.  This stopcode  occurs  when
                            an  attempt  is  made  to  point  to the next
                            mapping register, but there is none.

               Data Items:  P1 = address of next paging  register  to  be
                            used
                            P2 = address of first paging register used


   ONC     FILUUO   DEBUG   Odd-Numbered Cluster

                            UPDGIV deallocates or truncates blocks from a
                            file.   This  stopcode occurs when the number
                            of blocks allocated to a file is not an  even
                            multiple of the number of clusters allocated.

               Data Items:  T1 = number of clusters
                            T2 = remainder
|  
|  
|  ONCPUX  CPNSER   JOB     X out of range in ONCPU<X>
|  
|                           Caused by a call to ONCPUn, with  a  bad  CPU


                                     80



|                           number.   Correct  the CPU number supplied by
|                           the calling routine.
|  
|  
|  OOC     VMSER    STOP    Out of core blocks
|  
|                           MAPBAK called SAVCTS to set up for running at
|                           UUO   level,   but  SAVCTS  returned  at  the
|                           non-skip return.  This could occur  if  there
|                           was  insufficient  low core to save the job's
|                           current UUO-level context.


   OVA     ONCE     STOP    Out of Virtual Address Space

                            ONCMAP  selects  the  physical  and   virtual
                            address  for space in the high segment.  This
                            stopcode occurs when the  number  of  virtual
                            pages is greater than 256K.

               Data Items:  R1 = virtual page number


   P2L     VMSER    STOP    Page Too Low

                            This stopcode occurs when an address  in  the
                            user  page  map  is  too  low;   that is, the
                            address is in the monitor space.


   PAO     COMCON   STOPE   Page Already Out

                            PAGRE  creates  a   directory   page.    This
                            stopcode  occurs  when  an attempt is made to
                            page out a page that  is  already  out.   The
                            page  is  being  paged  out because the job's
                            physical limit has been exceeded.

               Data Items:  J = job number
|  
|  
|  PBO     NETSER   STOP    PCB Buffer Overflow
|  
|                           An ANF network Front End Kontroller interrupt
|                           service  routine  called  NETSER  (FEKINT) to
|                           process  an  "input  done"  interrupt.    The
|                           network  Protocol  Control  Block returned by
|                           the FEK contained a data byte count  (PCBCTR)
|                           that was greater than the allocated length of
|                           the PCB data buffer (PCBALN), indicating that
|                           the  FEK  wrote  past  the  end  of  the data
|                           buffer.


                                     81



|              Data Items:  J = address of FEK
|                           U = address of PCB


   PCN     IPCSER   DEBUG   Packet Count Negative

                            UIPCFR is used  on  an  IPC  receive  monitor
                            call.  This stopcode occurs when the count of
                            unreceived IPCF packets goes negative.

               Data Items:  P1 = PID


   PDA     FILIO    DEBUG   Pointers With Different Addresses

                            DD2MN copies pointers from  the  DDB  to  the
                            monitor buffer during monitor mode I/O.  This
                            stopcode occurs when  the  RIB  pointers  and
                            those now in the monitor buffer differ.

               Data Items:  T3 = XORed RIB and monitor buffer pointers
                            T4 = cluster pointer
|  
|  
|  PDLOVF  ERRCON   JOB     Exec PDL overflow


   PEW     VMSER    DEBUG   PAGTAB Entry Wrong

                            PHYCRZ   allocates   physical   core.    This
                            stopcode  occurs  when  a page that is in the
                            free-core list is found  while  scanning  the
                            pages allocated to a segment.

               Data Items:  T1 = number of pages
                            T2 = starting virtual page number


   PEZ     CORE1    STOP    PAGPTR Equals Zero

                            GTPAGS  adds  to  or  takes  pages  from  the
                            free-core  list.   This  stopcode occurs when
                            the location  PAGPTR,  which  points  to  the
                            first free page, is zero.


   PFC     VMSER    STOP    Page on Free Core List

                            SETHMT prepared for high-segment swap.   This
                            stopcode occurs when the monitor finds a page
                            that is in the free-core list while  scanning
                            pages allocated to a segment.


                                     82



               Data Items:  T1 = first disk address
                            T2 = first page number
                            T3 = number of pages
|  
|  
|  PFHASA  MONPFH   JOB     JS.ASA lit in PFH
|  
|  
|  PFHGDF  MONPFH   JOB     GETWDU didn't fault
|  
|  
|  PFHJOB  MONPFH   JOB     Wrong job owns device
|  
|  
|  PFHUUO  MONPFH   JOB     PAGE UUO failed
|  
|              Data items:  T1 = error code
|                           Arglst stored at .JDAT+JOBUAL
|  
|  
|  PFHZER  MONPFH   JOB     Page fault on Page zero
|  
|  
|  PFL     VMSER    DEBUG   Piece on Free List
|  
|                           GVFWDS returns words acquired  by  GTFWDC  or
|                           GTFWDU.  This stopcode occurs when an attempt
|                           is made to return a chunk of funny space that
|                           is already on the free list.
|  
|  
|  PFN     KxSER    CPU     Page Fault in Null Job
|  
|                           A page fault occured while the null  job  was
|                           running.
|  
|  
|  PFNOIO  MONPFH   JOB     PFH has no IO to do (I'm stuck!)


   PFR     VMSER    DEBUG   Piece Out of Free Range

                            GVFWDS returns words acquired  by  GTFWDC  or
                            GTFWDU.   This stopcode occurs when GVFWDS is
                            called with an address that is not  in  funny
                            space.


   PGL     COMCON   STOP    Pages Got Lost

                            PAGFRE  creates  a  directory   page.    This
                            stopcode occurs when the page cannot be paged


                                     83



                            out.
|  
|  
|  PGTPAR  KLSER    CPU     Page table parity


   PIE     ERRCON   CPU     Priority Interrupt Error

                            This stopcode occurs when a device interrupts
                            to the wrong location.  A jump occurred to an
                            even address between 42 and 66 (octal).


   PIF     VMSER    DEBUG   Page Is Free

                            This stopcode occurs when the monitor finds a
                            page  that  is in the free-core list while it
                            is scanning pages allocated to a segment.


   PIN     VMSER    DEBUG   Page In Working Set

                            WSBIT  gets  bit  and  index  for  WSBTB  and
                            AABTAB.    This   stopcode  occurs  when  the
                            monitor finds a page in the working set  that
                            has been verified as not in the working set.


   PIW     VMSER    DEBUG   Page Isn't in Working Set

                            PAGOMT sets up MEMTAB for paging  out.   This
                            stopcode occurs when the monitor decides that
                            a page must be in the working set, but it  is
                            not.


   PLP     FILIO    DEBUG   Past Last Pointer

                            USETO1  is  used  to  do  a  USETO  when  the
                            requested  block  is  higher than the highest
                            allocated block.  This stopcode  occurs  when
                            the  SCNPTR  routine,  which  scans pointers,
                            cannot find a block that  should  be  in  the
                            file.

               Data Items:  P1 = top block to allocate
                            P2 = first block to allocate
                            DEVLPC(F) = RIB pointer


   PMU     CORE1    STOP    PAGTAB Messed Up



                                     84



                            This  stopcode  occurs   when   a   zero   is
                            encountered  as  the link to the next page in
                            the  segment  while  setting  up  the  user's
                            page-map  page to reflect the location of the
                            pages in physical memory.

               Data Items:  T1 = byte pointer to the map
                            T2 = page attributes
                            T4 = number of pages -1 left in this segment
|  
|  
|  PNA     DATMAN   STOP    PUTWRD not available
|  
|                           PUTWRD was called  at  clock  level  but  the
|                           requested word was not available.


   PNE     FILIO    DEBUG   Pointers Not Equal

                            PTRTST reads the pointers into core, compares
                            the  old  pointers  in  the  RIB with the new
                            pointers in the DDB, and rewrites the RIB  if
                            they  differ.   This  stopcode occurs when an
                            error is found in the cluster  pointer  after
                            the pointers in the RIB have been updated.

               Data Items:  (T1) = pointer in the monitor buffer
                            T3 = XORed RIB and monitor buffer pointers
                            T4 = cluster pointer


   PNM     FILFND   DEBUG   Physical Name Mismatch

                            DSKCHK  checks  to  see   whether   C(T1)   =
                            'DSK,''DS' or 'D'.  This stopcode occurs when
                            the physical name of the device is lost after
                            it  has been determined that a name refers to
                            a disk unit.


   PNP     LOKCON   STOP    Page Not Present

                            PAGMOV finds the target page on the free-core
                            list   or  within  the  current  segment  and
                            exchanges it  with  the  source  page.   This
                            stopcode  occurs  when the source page cannot
                            be found in the current segment.

               Data Items:  T2 = successor to current page


   PNW     VMSER    DEBUG   Page not in Working Set


                                     85



                            DLTMPG returns a funny page to the  free-core
                            list.


   POR     SEGCON   STOP    Process Out of Range

                            COMIT  is  used  to  right  half  of  J  with
                            JBTSGN(T1).   This  stopcode  occurs when the
                            job number is out of range.

               Data Items:  J = job number
|  
|  
|  PPQ     VMSER    DEBUG   Page on in progress queue


   PQE     FILIO    DEBUG   Positioning Queue Empty

                            UNIPOS picks a file  on  a  unit  and  starts
                            positioning  for  that  file.   This stopcode
                            occurs  when  a  disk   unit   was   in   the
                            position-wait  state,  but there are no files
                            in its queue to be positioned.

               Data Items:  U = location of unit data block
|  
|  
|  PQW     VMSER    DEBUG   Paging queue wrong
|  
|                           A page that was supposed to be on one of  the
|                           in-core   queues  cannot  be  found,  because
|                           either the  count  for  the  queue  indicates
|                           there  are  no pages in the queue, and/or the
|                           first page pointer for the queue  lists  zero
|                           for the first page.
|  
|              Data Items:  T3 points to queue header
|                           first word  of  header  contains  count,  and
|                           second word contains first page on queue
|                           T2 contains page   of page that should be  on
|                           queue.
|  
|  
|  PRF     KLSER    CPU     Page Refill Failure
|  
|                           This stopcode occurs when a page-fail code of
|                           22 is returned by the pager.
|  
|              Data Items:  T1 = page-fail code
|                           .CPTPI = PI state
|                           .CPTCX = trap context



                                     86



|  PSF     CORE1    STOP    Page in Segment Free
|  
|                           This stopcode occurs when  a  page  is  found
|                           that  is marked in PAGTAB as being free while
|                           scanning a job's pages looking for page n  or
|                           the last page.
|  
|              Data Items:  T1 = current page within this segment
|                           T2 = number of pages left to scan
|                           T3 = PAGTAB entry for next page  in  segment,
|                           that is, PAGTAB(T1)
|  
|  
|  PTP     KxSER    HALT    Page Table Parity
|  
|                           A page fail code of 25 was received from  the
|                           pager.   The operation that failed is retried
|                           10 times before halting.
|  
|              Data Items:  .CPPTP = count of page table parity errors
|                           ** = ACs saved in CPU status block
|  
|  
|  PTT     CORE1    DEBUG   Past Top of Table
|  
|                           SETZRS sets zeros in a table.  This  stopcode
|                           occurs  when  the  SETZRS routine attempts to
|                           zero more bits than exist.
|  
|              Data Items:  (T2) = top of table
|                           T4 = final address to clear bits
|  
|  
|  PUF     SEGCON   JOB     PATH UUO failed
|  
|                           PTHFIL looks up a file and returns  the  path
|                           for   it.   This  stopcode  occurs  when  the
|                           PATH. monitor call fails.
|  
|  
|  PUN     FILUUO   DEBUG   PPB Use-count Negative
|  
|                           The PPB use-count was decremented to -1.
|  
|  
|  RAX     RAXKON   STOP    RAXKON is miserable


   RBQ     SCHED1   STOP    Requeueing to Beginning of Queue

                            QFIX is used in the requeuing of jobs.   This
                            stopcode  occurs  when  an attempt is made to


                                     87



                            requeue a job to the beginning  of  the  same
                            queue.


   RCC     SCNSER   STOP    Range-Checked Chunk

                            This stopcode is called  by  several  places,
                            each  doing  a  range  check  on  a character
                            address.   This  stopcode  occurs  when   the
                            character  address  is  not  within  the  TTY
                            buffer pool.

               Data Items:  T2 = character address character address  (in
                            T2)  that  was  not  in  the TTY buffer pool.
                            This can be caused by attempting  TTY  output
                            without  first  setting  up  U to point to an
                            LDB.


   RCD     SCNSER   DEBUG   Random Chunk Discrepancy

                            This stopcode is  called  from  a  number  of
                            places in SCNSER where it is noted that chunk
                            pointers and counts are inconsistent.
|  
|  
|  RCS3XF  LLMOP    INF     LLMOP Transmit Failed
|  
|                           LLMOP was unable to transmit a  forward  data
|                           message.
|  
|              Data items:  T1 contains the error code returned from  the
|                           DLL
|                           T2 contains the channel on which the  failure
|                           occurred
|  
|  
|  RCSIFC  LLMOP    CHK     RCSCBR called with invalid function code
|  
|                           The LLMOP Remote Console Protocol Server Call
|                           Back  Routine  was  called  by  the Data Link
|                           Layer with an invalid callback function code.
|                           This  is  a  software bug.  Call your DIGITAL
|                           Software Specialist.
|  
|  
|  RCSPIS  LLMOP    INF     Ethernet Periodic Identify-Self
|  
|                           This is a temporary debugging BUGINF.  It  is
|                           here   to  provide  an  indication  that  the
|                           periodic Identify-Self transmission is  being
|                           performed.


                                     88



   RDN     TAPUUO   DEBUG   Regular DDB Not Found

                            SETODN sets the density  in  the  other  DDB.
                            This stopcode occurs when there is no regular
                            DDB.

               Data Items:  R3 = UDB


   RDP     FSXKON   DEBUG   RS04 Doesn't Position

                            FSXPOS is a  stopcode-only  routine  that  is
                            used  when the FILIO module tries to position
                            an RS04.


   RDS     SEGCON   STOP    REMAP Didn't Skip

                            GETFIN remaps the save file after it has been
                            read  in  its entirety.  This stopcode occurs
                            when the remap fails  because  the  arguments
                            are wrong, pages do not all exist in the page
                            specified, or moving the pages to the virtual
                            address  specified  would  cause the high and
                            low segments to overlap.
|  
|  
|  RDXDAT  NETDEV   STOP    NTDSIB failed in R.DATA
|  
|                           After calling  NTDIBA  to  guarantee  a  user
|                           input  buffer  is  available, the ANF network
|                           remote data entry device service routine  was
|                           unable to set up an input buffer to receive a
|                           network message.
|  
|              Data Items:  F = address of DDB
|                           U = address of PCB


   REH     ERRCON   HALT    Recursion in Error Handler

                            DIE recovers/reloads after an internal system
                            error.   This  stopcode  occurs  when another
                            stopcode occurs before the  previous  one  is
                            done.


   RFU     TAPSER   STOP    Recovery Fouled Up

                            ERPINT   handles   interrupts   while   error
                            recovery   is  in  progress.   This  stopcode
                            occurs when the function code for dispatching


                                     89



                            is greater than 6.

               Data Items:  T2 = function code
                            T1 = pointer


   RJ0     CLOCK1   DEBUG   Requeue Job 0

                            REQUE requeues a job to run.   This  stopcode
                            occurs when an attempt is made to requeue job
                            0 (the null job) or a job number greater than
                            JOBMAX, to run.


   RHN     FILIO    DEBUG   Reread Home Block-Count Negative

                            SETMDL sets the file to idle when monitor I/O
                            is  done.  This stopcode occurs when the flag
                            DEVRHB(F) indicates that the HOME blocks  are
                            being  reread,  but  the  flag that tells the
                            number  of  units  that  are  rereading  HOME
                            blocks (HOMFG) is negative.


   RIE     XTCSER   DEBUG   Remote Interrupt Error

                            This stopcode occurs if there  is  any  error
                            bits  are  lit  on an interrupt from a remote
                            system on the DA28.


   RIF     DPXKON   DEBUG   RP10 Isn't Fancy

                            These  are  stopcode-only   routines.    This
                            stopcode  occurs when the monitor attempts an
                            RP04-only function, such as an UNLOAD, on  an
                            RP10-controlled device.


   RJZ     SCHED1   STOP    Requeue Job Zero

                            QXFER is used in  the  requeuing  of  a  job.
                            This  stopcode  occurs when a call is made to
                            this routine with a job number less  than  or
                            equal to zero or greater than JOBMAX.

               Data Items:  J = job number


   RLD     STOP     UUOCON  Reload Monitor

                            This is a result of the RECON.  UUO  function


                                     90



                            .RCRLD,  which  is  callable  by a privileged
                            user or the CONFIG command SHUTDOWN.   (Refer
                            to  the  TOPS-10  Operator's  Guide  for more                                     _______  __________  _____
                            information.


   RNP     VMSER    DEBUG   Returning Non-existent Page

                            DNZSPG returns non-zero section pages to free
                            core.   This stopcode occurs if an attempt is
                            made to return a page that does not exist.
|  
|  
|  ROU     ONCMOD   STOP    Ran Out of Units

                            NXTSAT reads all  the  SATs  on  a  unit  and
                            computes  the number of free clusters left in
                            each SAT.  This stopcode occurs when the  SAT
                            pointers indicate that there is another unit,
                            when in fact there is no other unit.

               Data Items:  P4 = number of units remaining


   RPM     ONCMOD   DEBUG   Retrieval Pointer Mismatch

                            FILMAN finds and sets up all structures on  a
                            system.    This   stopcode  occurs  when  the
                            unit-change pointer in the file  SAT.SYS  did
                            not  point  to  the  next  unit  in  the file
                            structure.

               Data Items:  T2 = expected unit-change pointer
                            T3 = logical unit number expected


   RPZ     VMSER    STOP    Returning Page 0

                            The monitor tried to return  page  0  to  the
                            free page list, but it could not.


   RQD     SCNSER   DEBUG   RECINT Queue Discrepancy

                            This stopcode occurs if we just  emptied  the
                            RECINT   queue   but  the  taker  and  putter
                            pointers do not match.


   RQF     SCNSER   DEBUG   RECINT Queue Full

                            This stopcode  occurs  the  RECINT  character


                                     91



                            queue wraps around.
|  
|  
|  RS04IF  FSXKON   DEBUG   RS04 isn't fancy


   RSJ     CLOCK1   DEBUG   Requeue Same Job

                            REQUE requeues a job to run.   This  stopcode
                            occurs  when  an attempt is made to queue the
                            same job again.

               Data Items:  J = job number


   RTM     NETDEV   STOP    Requested Too Much

                            A call  to  TRQPCB  to  get  an  ANF  network
                            Protocol   Control   Block   (for  a  network
                            terminal) requested a message size which  was
                            either   negative  or  exceeded  the  maximum
                            configured terminal PCB buffer size.

               Data Items:  U = address of LDB
                            T1 = requested PCB size (in bytes)


   RWD     FILIO    DEBUG   Returning Wrong Unit's DA

                            DWNDA gives up  a  disk  allocation  request.
                            This  stopcode occurs when the unit's DA that
                            is being dequeued is  not  correct  for  this
                            job.

               Data Items:  PJOBN = job number


   RWS     VMSER    DEBUG   Returning Space to Wrong Section

                            GVFWDS  returns  funny  space  pages.    This
                            stopcode  occurs  if  the monitor attempts to
                            return funny space from a section from  which
                            it cannot be allocated.
|  
|  
|  RX2     RX2SER   STOP    RX2SER fouled up
|  
|  
|  RXX     RX2SER   DEBUG   Unimplemented error recovery


   SAC     ERRCON   DEBUG   Strange APR Condition


                                     92



                            This stopcode occurs when  an  APR  interrupt
                            occurs with no known error bits set.

               Data Items:  S = APR error condition


   SAU     CPNSER   DEBUG   Scheduler Already Unlocked

                            ULKSCD unlocks the scheduler interlock.  This
                            stopcode occurs when the interlock is already
                            free.

               Data Items:  SCKLOK = Interlock


   SBn     COMMON   CPU     SBUS Error Alone

                            This stopcode occurs when an SBUS error alone
                            came  up  in  CONI  APR.   This  is a serious
                            hardware problem.  Call  your  Field  Service
                            representative.


   SBT     FILUUO   DEBUG   Shouldn't Be Truncating

                            CLSRIB closes a file.  This  stopcode  occurs
                            when an attempt is made to truncate unwritten
                            blocks, but the highest block number  in  the
                            file is too small.

               Data Items:  P2 = current block of RIB
                            P3 = DEVREL


   SBW     VMSER    DEBUG   SWPLST Bits Wrong

                            This stopcode occurs when an entry in  SWPLST
                            shows  both  that I/O is in progress and that
                            I/O is complete.


   SBZ     VMSER    STOP    Swap Block Zero

                            This stopcode occurs if, in picking the  next
                            swap list entry, we find that it specifies an
                            invalid disk address.
|  
|  
|  SCABMT  SCASER   CHK     Bad message type from remote node
|  
|  
|  SCACCI  SCASER   HLT     Cannot complete initialization


                                     93



|  SCACFO  SCASER   HLT     SC.CON received failure from SC.OUT
|  
|  
|  SCACRB  SCASER   CHK     Can't reclaim buffers
|  
|  
|  SCACSC  SCASER   CHK     Can't send credit request
|  
|  
|  SCACVC  SCASER   INF     Virtual circuit closure requested
|  
|  
|  SCAEEE  SCASER   CHK     Block state  is  zero  when  trying  to  send
|                           connection management request
|  
|  
|  SCAFN2  SCASER   HLT     Can't complete deferred call to SC.DIS
|  
|  
|  SCAFN3  SCASER   HLT     Can't complete deferred call to SC.DRQ
|  
|  
|  SCAILC  SCASER   HLT     Illegal lock count in connection block
|  
|  
|  SCALCC  SCASER   HLT     Connection block lock count has changed
|  
|  
|  SCALFO  SCASER   HLT     SC.LIS received failure from SC.OUT
|  
|  
|  SCANBN  SCASER   HLT     No buffer for notification table
|  
|  
|  SCANLF  SCASER   CHK     Notice table full
|  
|  
|  SCANMB  SCASER   CHK     Can't return SCS control message buffer
|  
|  
|  SCANOC  SCASER   CHK     Received packet and connection block  doesn't
|                           exist
|  
|  
|  SCANP1  SCASER   HLT     .CBNPO has gone negative
|  
|  
|  SCANP2  SCASER   HLT     .CBNPO has gone negative
|  
|  
|  SCANP3  SCASER   HLT     .CBNPO has gone negative



                                     94



|  SCANPC  SCASER   HLT     No page for CID table
|  
|  
|  SCANSC  SCASER   CHK     Negative path count
|  
|  
|  SCAOF2  SCASER   CHK     Duplicate offline for a node
|  
|  
|  SCAOHF  SCASER   HLT     Internal software inconsistency
|  
|  
|  SCAPER  SCASER   CHK     Protocol error
|  
|  
|  SCAQQQ  SCASER   CHK     Unexpected credit field in creditrequest
|  
|  
|  SCARBS  SCASER   CHK     Reap bit is set when block state is non-zero
|  
|  
|  SCASBN  SCASER   CHK     Block state already non-zero
|  
|  
|  SCASCQ  SCASER   HLT     SCA credit queue failed
|  
|  
|  SCASSS  SCASER   CHK     Connect block already linked
|  
|  
|  SCATMO  SCASER   INF     SCA timed out remote node
|  
|  
|  SCAUXR  SCASER   CHK     Unexpected response


   SCB     XTCSER   DEBUG   Spurious CONI Bit

                            This stopcode occurs if certain random  error
                            bits  are  lit  on the CONI status read on an
                            XTC interrupt.


   SCR     DEBUG    SEGCON  Segment Couldn't Be Read

                            INPSEG is called to read in a  high  segment.
                            This   stopcode   occurs  if  INPSEG  returns
                            non-skip.


   SDE     FILIO    DEBUG   SAT Doesn't Exist



                                     95



                            GIVBLK returns disk  blocks.   This  stopcode
                            occurs if GIVBLK cannot find the SAT in which
                            the blocks are supposed to exist.


   SDS     UUOCON   DEBUG   SWPADR Didn't Skip

                            SWPADR converts a swapping space address to a
                            unit/disk address.  This stopcode occurs when
                            the  JOBPEK  UUO  determines  it   needs   to
                            read/write   the  swapping  space  and  calls
                            SWPADR  to  convert  a  swap  address  to   a
                            unit/disk  address.   SWPADR  does not have a
                            non-skip return.


   SER     FILUUO   JOB     SETDDO Error Return

                            FAKDDB sets a DDB.  This stopcode occurs when
                            subroutine   SETDDO  gives  an  error  return
                            indicating no core is available  to  build  a
                            device  data  block,  although space had been
                            found just before the call.

               Data Items:  T1 = address in memory found previous to call


   SFU     FILIO    DEBUG   Swapper Fouled Up

                            SWAPIO puts a swap request  into  the  queue.
                            This  stopcode  occurs  when  this routine is
                            called with no request.

               Data Items:  SQREQ = 0, should have been the request


   SHU     SCHED1   DEBUG   Swapper Hung Up

                            NOFORC times out devices that are active to a
                            job waiting to be swapped out.  This stopcode
                            occurs when the device-hung timer  times  out
                            while the job was in FORCEF.
|  
|  
|  SICDNA  SEGCON   STOP    Share and in-core counts do not agree


   SIE     VMSER    DEBUG   SWPLST Is Empty

                            DLTSLE was called to delete a  SWPLST  entry,
                            but there were no entries in SWPLST.



                                     96



   SIN     VMSER    DEBUG   SWPCNT Is Negative

                            This stopcode occurs when the  count  of  the
                            number   of   outstanding  swapping  requests
                            becomes negative while an entry  from  SWPLST
                            is being deleted.
|  
|  
|  SIU     SCASER   CPU     SCA interlock unowned


   SLF     VMSER    DEBUG   SWPLST Full

                            This stopcode occurs when there  is  no  room
                            for an entry in the swap list table.


   SLM     FILUUO   DEBUG   Search List Missing

                            FNDFRA is used when the PPB  and/or  the  UFB
                            are  deleted.   This stopcode occurs when the
                            SETSRC routine cannot set up a  search  list,
                            even  though it seemed possible when the call
                            started.


   SLO     FILFND   JOB     Search List Overflow

                            SLXSLO is a stopcode-only  routine.   Examine
                            the stack for the location of the error.


   SLZ     VMSER    DEBUG   SLECNT Is Zero

                            This stopcode occurs when the  subroutine  to
                            find  an  entry in the SWPLST table is called
                            when there are no entries in the table.


   SMU     SCHED1   DEBUG   SWPCNT Messed Up

                            SWAP is used to swap jobs.

               Data Items:  J = job number
                            SWPCNT  =   count   of   completed   swapping
                            operations
|  
|  
|  SNASHR  SEGCON   STOP    SNA/JBTSHR discrepency


   SNF     LOKCON   STOP    Segment Not Found


                                     97



                            LOCK0 locks a segment in core.  This stopcode
                            occurs when the monitor cannot find a segment
                            that contains a certain page.

               Data Items:  T3 = absolute page address being looked for


   SNI     SWPSER   DEBUG   Swapping Not In Progress

                            SWPINT is used when paging or swapping I/O is
                            done  for  a  monitor  that  includes virtual
                            memory.   This  stopcode  occurs   when   the
                            swap-in progress count goes negative.

               Data Items:  SPRCNT = Swap-in progress count


   SNO     SCHED1   DEBUG   Segment Not Owned By Anyone

                            While attempting to migrate  a  high  segment
                            from  a  unit  that  is  being  taken off the
                            active swapping list, CHKMIG found a  segment
                            that  should have been in use by some job but
                            no job was linked to the high segment.


   SNS     NETDEV   STOP    NTRPCB Not Set Up

                            TWRPCB  writes  back  the  count  field   and
                            updates  the  pointer  in  the  PCB.  It also
                            removes garbage from the stack.

               Data Items:  T1 = minimum number of bytes


   SOD     SCHED1   STOP    Space On Disk

                            SWAPI swaps in either a job or high  segment.
                            This stopcode occurs when the core-allocation
                            routine (CORGET) assigns space on  the  disk,
                            but the assignment is illegal.

               Data Items:  J = job number


   SOR     ERRCON   STOP    Segment Out of Range

                            ERRPNT prints common  error  messages.   This
                            stopcode  occurs  when  the  job  or  segment
                            number is too large.

               Data Items:  J = job number


                                     98



   SPM     FILUUO   JOB     Second Pointer Missing

                            UFDNXT  initializes  the  next  block  for  a
                            directory.   This  stopcode  occurs  when the
                            pointer to the second RIB is missing from the
                            first RIB.

               Data Items:  T3 = Supposed location of second RIB pointer


   SRE     ONCMOD   DEBUG   SAT Read Error

                            NXTSAT reads all SATs on a unit and  computes
                            the number of free clusters left in each SAT.
                            This stopcode occurs when a read error occurs
                            while reading the SAT.


   SRO     SWPSER   STOP    Space Ran Out

                            NXUN is used when we have filled the  current
                            unit  and  we need more swapping space.  This
                            stopcode occurs when there are no more  units
                            for swapping.
|  
|  
|  SSCNEG  SEGCON   DEBUG   Segment share count negative


   SSD     SWPSER   STOP    Swap Space Disappeared

                            FOUND is used when contiguous space has  been
                            found  on a unit for swapping.  This stopcode
                            occurs when an attempt is  made  to  allocate
                            that  space,  which  for  some  reason  is no
                            longer available.

               Data Items:  U = address


   SSO     LOKCON   STOP    Segment Swapped Out

                            LOCK0 locks a segment in core.  This stopcode
                            occurs  when  a  high segment that is neither
                            dormant nor idle has no low segment in core.


   SWN     SWPSER   DEBUG   SQREQ Went Negative

                            SWPINT is used when paging or swapping I/O is
                            done.  This stopcode occurs when the count of
                            paging or swapping requests goes negative.


                                     99



   TC0     XTCSER   DEBUG   XTCSER Stopcode Zero

                            XTCSER has found the controller free and  the
                            unit  unlocked, but there are requests in the
                            queue waiting to be processed.


   TC1     XTCSER   STOP    XTCSER Stopcode One

                            XTCSER should have already set a "Waiting for
                            Input" message, but has not.


   TC2     XTCSER   DEBUG   XTCSER Stopcode Two

                            XTCSER expected the DAS28 to be idle, but  it
                            was not.


   TC3     XTCSER   DEBUG   XTCSER Stopcode Three

                            The number of pseudo active tasks in the  XTC
                            UDB went negative.


   TC4     XTCSER   DEBUG   XTCSER Stopcode Four

                            The number of pseudo active tasks in the  XCT
                            KDB went negative.


   TC5     XTCSER   DEBUG   XTCSER Stopcode Five

                            The number of pseudo active tasks in the  XTC
                            UDB went negative.


   TC6     XTCSER   DEBUG   XTCSER Stopcode Six

                            The number of pseudo active tasks in the  XTC
                            KDB went negative.


   TC7     XTCSER   STOP    XTCSER Stopcode Seven

                            This stopcode occurs when XTCSER expected  to
                            have  the controller interlocked but found it
                            did not.


   TCI     FILUUO   DEBUG   Truncation Check Inconsistent



                                    100



                            RENDEL deallocates or truncates on a  RENAME.
                            This  stopcode occurs when an attempt is made
                            to truncate too many blocks and  a  check  on
                            the same had already succeeded.

               Data Items:  P1 = AOBJN pointer;  P3 = number of blocks
|  
|  
|  TIC     SCNSER   DEBUG   LDBTIC wrong
|  
|  
|  TMDELE  SCNSER   DEBUG   Too many deletions from echo
|  
|  
|  TMDELI  SCNSER   DEBUG   Too many <DEL>s in input


   TMP     FILIO    DEBUG   Too Many Pointers

                            PTRWRT copies RIB  pointers  into  a  monitor
                            buffer  and  writes it.  This stopcode occurs
                            when there are more retrieval  pointers  than
                            can  fit in a RIB.  The counter DEVRSU should
                            prevent this from happening.

               Data Items:  T2 = remaining pointers (IOWD)


   TMR     REFSTR   STOP    Too Many Retrieval Pointers

                            SATRBS  stores  retrieval  pointers  in   the
                            SAT.SYS  read-in block.  This stopcode occurs
                            when the SAT byte pointer is messed up.

               Data Items:  T1 = SAT byte pointer
|  
|  
|  TMU     ONCMOD   STOP    Too Many Units

                            NXTSAT reads all SATs on a unit and  computes
                            the number of free clusters left in each SAT.
                            This stopcode occurs when there are  pointers
                            to   more  units  after  the  last  has  been
                            retrieved.

               Data Items:  U = pointer to more units


|  TSKAND  NETDEV   STOP    Already got an NPD
|  
|                           On a user-program "LOOKUP" to an ANF  network
|                           TSK device, the TSK Device Data Block already


                                    101



|                           had one (or  both)  of  the  Network  Process
|                           Descriptor blocks assigned.  The NPDs contain
|                           the local  and  remote  LOOKUP  and/or  ENTER
|                           "names",  and  as  such should not yet be set
|                           for a TSK DDB entering passive connect wait.
|  
|              Data Items:  F = address of DDB
|  
|  
|  TSKIOS  NETDEV   STOP    IOSCON is on
|  
|                           When attempting to put  an  ANF  network  TSK
|                           device  into  either  "active"  or  "passive"
|                           connect wait, the TSK device was found not to
|                           be  in  the  "idle"  state.   Either the Link
|                           Address Table state was not "idle" or the TSK
|                           Device   Data   Block   IOSCON   (device   is
|                           connected) flag was set.
|  
|              Data Items:  F = address of DDB
|                           S = DEVIOS word
|                           T1 = LAT state
|  
|  
|  TSKLE2  NETDEV   STOP    NPD already assigned in LOOKUP/ENTER
|  
|                           On a user-program "LOOKUP" or "ENTER"  to  an
|                           ANF  network  TSK  device, the TSK device was
|                           found to have one  or  both  Network  Process
|                           Descriptor blocks already assigned.
|  
|              Data Items:  F = address of DDB
|  
|  
|  TSKNIC  NETDEV   STOP    Not in "CI" state
|  
|                           On a user-program "CLOSE" to an  ANF  network
|                           TSK device, the TSK device Link Address Table
|                           state is inconsistent with TSK device.
|  
|              Data Items:  F = address of DDB
|  
|  
|  TSKNID  NETDEV   STOP    Not in disconnect confirm
|  
|                           While waiting for an ANF network  TSK  device
|                           Disconnect  request  to  be  honored, the TSK
|                           device Link  Address  Table  state  transited
|                           into  an  illegal  state (neither waiting for
|                           Disconnect Confirm, nor Disconnected).
|  
|              Data Items:  F = address of DDB


                                    102



|                           T1 = LAT state
|  
|  
|  TSKNIP  NETDEV   STOP    Not in passive state
|  
|                           On a user-program "ENTER" to an  ANF  network
|                           TSK  device, the TSK device state was illegal
|                           (neither "idle", nor  "OK",  nor  in  passive
|                           connect wait).
|  
|              Data Items:  F = address of DDB
|                           T1 = LAT state
|  
|  
|  TSKNPD  NETDEV   STOP    NPD already assigned
|  
|                           On  a   user-program-generated   request   to
|                           implicitly  (with  a  LOOKUP or ENTER monitor
|                           call) or explicitly  (with  a  TSK.   monitor
|                           call)  set  the  Network  Process  Descriptor
|                           information for an ANF  network  TSK  device,
|                           the  TSK  Device Data Block was found to have
|                           one or both of the NPDs already assigned.
|  
|              Data Items:  F = address of DDB
|  
|  
|  TSKSCC  NETDEV   STOP    Send connect confirm failed
|  
|                           After   a    call    to    PCBECK    returned
|                           "guaranteeing"  the  availability  of  an ANF
|                           network Protocol Control Block, a  subsequent
|                           call  to  PCBEGT  failed to get a free PCB to
|                           acknowledge an incoming  TSK  device  Connect
|                           Initiate request.
|  
|              Data Items:  F = address of DDB
|  
|  
|  TSKSIB  NETDEV   STOP    No input buffer
|  
|                           After calling  NTDIBA  to  guarantee  a  user
|                           input  buffer  is  available, the ANF network
|                           TSK device service routine was unable to  set
|                           up  an  input  buffer  to  receive  a network
|                           message.
|  
|              Data Items:  F = address of DDB
|                           U = address of PCB
|  
|  
|  TSKSOR  NETDEV   STOP    LAT State is out of range


                                    103



|                           The ANF network Link Address Table state  for
|                           a TSK device was found to be out of the known
|                           range of LAT states.  The  ANF  Link  Address
|                           Table is very probably corrupted.
|  
|              Data Items:  F = address of DDB
|                           T1 = LAT state


   UAF     KSSER    STOP    UNIBUS Addressing Failure

                            SEILM  processes  page-failure  traps.   This
                            stopcode  occurs  when  what  appears to be a
                            page  fault  turns  out  to   be   a   UNIBUS
                            addressing failure.  (KS10 only)
|  
|  
|  UCR     MSCCOM   DEBUG   Unexpected connect response


   UDE     FILIO    DEBUG   Unit Doesn't Exist

                            RIBCUR reads the current RIB.  This  stopcode
                            occurs  when  a  requested unit is not in any
                            file structure.

               Data Items:  DEYRBU =  current  RIB  logical  unit  number
                            pointer


   UDM     FILUUO   JOB     UFD Data is Missing

                            UFDALB allocates a block  for  a  UFD.   This
                            stopcode  occurs  when  the  core tables show
                            that the UFD is longer than it actually is.

               Data Items:  T3 = supposed number of blocks of this UFD.


   UFI     FILUUO   STOP    Unit Free-Count Inconsistent

                            CLSOU5 is used during a CLOSE after finding a
                            unit  with space on it.  This stopcode occurs
                            when an  attempt  is  made  to  allocate  the
                            space, but no space is available.

               Data Items:  T2 = Number of blocks needed
|  
|  
|  UGA     RAXKON   DEBUG   UDB gone away




                                    104



|  UID     D8SINT   DEBUG   Unexpected Input Done
|  
|                           T10DON handles To-10 Done interrupts from the
|                           -11.   This  stopcode occurs when no input is
|                           expected.
|  
|              Data Items:  T1 = CPU number
|  
|  
|  UIF     ONCMOD   STOP    Unit Already In File Structure
|  
|                           DMKSTR sets up structures according to tables
|                           in  ONCMOD.  This stopcode occurs when a unit
|                           appears in more than one structure.
|  
|  
|  UIL     ERRCON   STOP    UUO at Interrupt Level
|  
|                           EMUERR is called when an illegal monitor call
|                           occurs  at  exec level.  This stopcode occurs
|                           when the monitor  call  occurs  at  interrupt
|                           level.
|  
|  
|  UIP     XTCSER   DEBUG   Not a Unique Interrupt
|  
|                           XTCSER decided to call  routine  DDBINT  (for
|                           DDB  doing  data  I/O) instead of UNIINT, but
|                           XKBIUN (pointer to UDB requesting  interrupt)
|                           was  non-zero,  implying  XTCSER  should have
|                           called UNIINT.  Only one of DDBINT or  UNIINT
|                           should be called.
|  
|  
|  ULE     LP2SER   JOB     Unexpected LP20 Error
|  
|                           LPTERR   handles   VFU   errors   for    LP20
|                           controllers.
|  
|              Data Items:  F = DDB
|                           T1 = function
|  
|  
|  ULP     KSSER    DEBUG   UBA Lost its PI Assignment
|  
|                           KSSEC performs once-a-ssecond tasks  for  the
|                           KS10.
|  
|  
|  UN5     RAXKON   INF     Unit not in 576-byte sector mode




                                    105



   UNF     FILUUO   DEBUG   UFB Not Found

                            NAMNW updates RIBNAM, RIBEXT, and RIBPPN when
                            there  is  a CLOSE for RENAME.  This stopcode
                            occurs when a RENAME is done across UFDs  and
                            the UFB is not found.

               Data Items:  T1 = Structure number
                            T2 = Start of UFB chain


   UNJ     COMMON   STOP    UUO from Null Job

                            This  stopcode  occurs  when  the  null   job
                            executes   a  monitor  call  other  than  the
                            doorbell call.


   UNL     VMSER    DEBUG   UPMP Not Last

                            This stopcode occurs when the UPMP is not the
                            last page swapped out.


   UNR     UUOCON   DEBUG   UPMP not right

                            GETUVP is called by the JOBPEK UUO to read  a
                            page  from the swapping space.  This stopcode
                            occurs if the job's UPMP is in core,  but  is
                            not mapped as the current UPMP.
|  
|  
|  UOF     RAXKON   DEBUG   Unit online failed


   UPC     FILUUO   JOB     Unit-Change Pointer Clobbered

                            SETENC enters a file.  This  stopcode  occurs
                            when  the  pointer to a unit of a RIB is lost
                            during RIB definition.

               Data Items:  S = status bits
                            T3 = location of the access table


   UPF     KxSER    HALT    Unexpected Page Fail

                            This stopcode occurs when  there  is  a  page
                            fail  trap  during  a  recovery attempt of an
                            AR/ARX trap, which is not caused  by  a  test
                            reference.



                                    106



               Data Items:  .UPMP+.LMPFW = page fail code
                            .UPMP+.LMPFP = page fail PC


   UPI     FILIO    DEBUG   Unit Pointer Illegal

                            EXTRIB  creates  an   extended   RIB.    This
                            stopcode  occurs  when  an attempt is made to
                            create an extended RIB on a nonexistent unit.

               Data Items:  T2 = change unit pointer (should have been  a
                            real unit pointer)


   USW     TAPSER   DEBUG   Unit Status Wrong

                            TAPSIO is used when the swapper  level  wants
                            to start I/O on a unit.  This stopcode occurs
                            when the unit status is not as expected.  For
                            example,  the  unit  was started (possibly on
                            another controller) when it should have  been
                            stopped.

               Data Items:  RUBSTS(U) = unit number
|  
|  
|  UWA     RAXKON   DEBUG   UDB went away?!
|  
|  
|  VTMECC  NETDEV   STOP    Echo counts messed up
|  
|                           Preparatory to sending characters for an  ANF
|                           VTM  terminal to a remote MCR/host, the count
|                           of characters about to be  sent  was  greater
|                           than   the   terminal's   count   of   echoed
|                           characters available.
|  
|              Data Items:  U = address of LDB
|  
|  
|  VTMILS  NETDEV   STOP    Illegal state
|  
|                           An ANF network Disconnect was received for  a
|                           VTM  terminal  that was neither connected to,
|                           in connect wait, or in disconnect wait  state
|                           for   the  node  which  sent  the  disconnect
|                           message.
|  
|              Data Items:  U = address of LDB
|                           T2 = LAT state




                                    107



|  VTMLAL  NETDEV   STOP    LDB and LAT do not agree
|  
|                           On  a  call  to  VTMCLR  to  "clean  up"  and
|                           reinitialize an ANF network VTM terminal Line
|                           Data Block,  the  LDB's  Link  Address  Table
|                           entry does not point back to the LDB.
|  
|              Data Items:  U = address of LDB
|                           T1 = LAT address (from LDB)
|  
|  
|  VTMLAT  NETDEV   STOP    LAT address not set up
|  
|                           On  a  call  to  VTMXCN  to  send  a  Connect
|                           Initiate   message  (or  possibly  a  Connect
|                           Confirm message) to a remote ANF network node
|                           for  a  VTM  terminal, the terminal Line Data
|                           Block had no Source Link Address.
|  
|              Data Items:  U = address of LDB
|                           W = address of NDB
|  
|  
|  VTMLDB  NETDEV   STOP    No LDB in VTMENQ
|  
|                           VTMENQ was called to "queue" an  ANF  network
|                           VTM  terminal  Line  Data  Block  for  VTMSCN
|                           processing, but U contained 0.
|  
|  
|  VTMNDA  NETDEV   STOP    Node number doesn't agree
|  
|                           When processing an ANF  network  "node  down"
|                           condition, NETVTM (VTMNWD) was called to deal
|                           with  a  VTM  terminal   connected   to   the
|                           no-longer-accessible  node,  but the terminal
|                           claimed to be connected to a different node.
|  
|              Data Items:  U = address of LDB
|                           T1 = node number from LDB
|                           P1 = node number that "went down"
|  
|  
|  VTMNDB  NETDEV   STOP    No NDB for LDB's node.
|  
|                           In  the  once-a-jiffy  processing   loop   in
|                           NETVTM,  a  connected ANF VTM terminal's Node
|                           Data  Block  could  not  be   found   (SRCNDB
|                           failed).
|  
|              Data Items:  U = address of LDB



                                    108



|  VTMNLA  NETDEV   STOP    No LAT address for virtual terminal?
|  
|                           In  the  once-a-jiffy  processing   loop   in
|                           NETVTM, a connected ANF VTM terminal's Source
|                           Link Address was zero.
|  
|              Data Items:  U = address of LDB
|  
|  
|  VTMNNN  NETDEV   STOP    But VTMNWD should have caught this
|  
|                           In  the  once-a-jiffy  processing   loop   in
|                           NETVTM,  a  connected ANF VTM terminal's Node
|                           Data  Block  could  not  be   found   (SRCNDB
|                           failed).
|  
|              Data Items:  U = address of LDB
|  
|  
|  VTMQED  NETDEV   STOP    Line not queued though LRLQED is set
|  
|                           VTMDEQ was called to "dequeue" an ANF network
|                           VTM  terminal, but the VTM terminal Line Data
|                           Block was not queued  (even  though  the  LDB
|                           LRLQED  (VTM  terminal is queued) flag is set
|                           for the terminal).
|  
|              Data Items:  U = address of LDB
|  
|  
|  VTMSDF  NETDEV   STOP    Send disconnect failed
|  
|                           After   a    call    to    PCBECK    returned
|                           "guaranteeing"  the  availability  of  an ANF
|                           network Protocol Control Block, a  subsequent
|                           call  to  PCBEGT  failed to get a free PCB to
|                           send a Disconnect Confirm message for an  ANF
|                           VTM terminal.
|  
|              Data Items:  U = address of LDB


   WAD     VMSER    DEBUG   WSBTBL and AABTBL Discrepancy

                            This stopcode occurs when there is an  access
                            page  fault  for  a page that should have the
                            access allowed bit on in the page map.
|  
|  
|  WCT     ONCE     HALT    Wrong CPU type
|  
|                           This stopcode occurs when ONCE is running  on


                                    109



|                           a   different  type  of  processor  than  the
|                           monitor was built for.
|  
|                           Use  the  correct  monitor  or  rebuild   the
|                           monitor.
|  
|  
|  WEM     NETSER   STOP    Generic ANF network crash
|  
|                           This is a  catch-all  stopcode  for  the  ANF
|                           network  service.   Examine the stack for the
|                           location of the error.
|  
|  
|  WFC     D6SINT   DEBUG   Bad function code to FEK
|  
|  
|  WNGUCV  COMMON   HALT    Wrong Ucode version
|  
|  
|  WNS     D85INT   DEBUG   Window was not setup?
|  
|  
|  WPT     KxSER    HALT    Wrong Parity Trap
|  
|                           This stopcode occurs when  there  is  a  page
|                           fail  while  trying to recover from an AR/ARX
|                           trap,  which  occurred  because  of  a   test
|                           reference, but the page fail code is not 36.
|  
|              Data Items:  T1 = page fail code
|                           .UPMP + .LMPFW = page fail code
|                           .UPMP + .LMPFP = page fail PC
|  
|  
|  WRF     COMMON   CPU     Warm Restart Failed
|  
|                           A condition such as a DEX has occured and the
|                           monitor  has  attempted  to warm restart, but
|                           cannot due to  various  conditions  being  in
|                           effect at the time of the original failure.
|  
|  
|  WRJ     COMMON   JOB     Warm Restart Got Job
|  
|                           A condition such as a DEX has occured and the
|                           monitor  has  attempted  a warm restart.  The
|                           condition occured while some job  other  than
|                           the null job was running in user mode.
|  
|  
|  WSM     FILIO    STOP    Wrong Size Moved


                                    110



|                           Routine CSSETL is called to set the size of a
|                           BLT  to/from  the  disk cache.  This stopcode
|                           occurs if the size is greater than one  block
|                           worth of data.
|  
|  
|  WTP     CLOCK1   JOB     Wrong Type of PDL
|  
|                           WSCHED is entered at monitor call level  when
|                           a  job  goes into I/O wait or sharable-device
|                           wait.  This stopcode occurs when the  address
|                           of  the  pushdown  list  is  too  low to be a
|                           monitor call pushdown list.
|  
|              Data Items:  P = pushdown list
|  
|  
|  XIF     RAXKON   STOP    RAXKON isn't fancy


   XPW     LOKCON   STOP    Exchanged Page Went Away

                            FIXMAP finds a page with  which  a  page  was
                            exchanged and fix the map slot for that page.
                            This stopcode occurs when the monitor  cannot
                            find the page that was exchanged.


   XTH     SCHED1   DEBUG   XJOB Too High

                            FNDXPN  finds  the   expanding   job.    This
                            stopcode  occurs when the count of the number
                            of jobs that must be swapped out and back  in
                            to   satisfy  a  core  expansion  request  is
                            positive, but no expanding job is found.


   ZBC     REFSTR   DEBUG   Zero Blocks Per Cluster

                            REFSTR refreshes a structure.  This  stopcode
                            occurs where the number of blocks per cluster
                            equals zero.

               Data Items:  T1 = IOWD for home block
                            P2 = address of structure data block
|  
|  
|  ZPS     VMSER    Zero Page Swap
|  
|                           A request for swapping  specified  0  as  the
|                           number of pages to transfer.



                                    111



   5.0  LIST OF DECNET-10 STOPCODES        LIST OF DECNET-10 STOPCODES

   Name    Module   Type    Message and Explanation   ____    ______   ____    _______ ___ ___________


   COM911  D36COM   HLT     The date is past 9 November 2021

                            The two-byte  Julian  half-day  field  in  an
                            event  message is limited to 9 November 2021.
                            The  routine  above  calculated  the   Julian
                            half-day,  and  found that it overflowed.  It
                            is unlikely that the date itself really  went
                            past  2021.  An AC was probably destroyed, or
                            the routine to get the time from the  monitor
                            is returning invalid information.


   COMAFB  D36COM   CHK     A free block pointer is bad

                            There is a block on a free list, most  likely
                            just  added to the list, whose address is not
                            in the expected range.  The offending pointer
                            is  in  P1.  A subroutine whose address is on
                            the stack is probably returning  a  block  to
                            the  wrong  free  list,  or  is  returning an
                            invalid pointer.
|  
|  
|  COMATB  D36COM   CHK     A-Block request too big
|  
|                           For the time  being,  until  we  get  a  real
|                           memory-manager    for    non-   message-block
|                           requests, we only support requests for memory
|                           up  to  the  size  of a VBL block, see DEFBLK
|                           macro.
|  
|                           Wait for the real memory manager or make  the
|                           size of VBLs bigger than they are now.
|  
|  
|  COMBNN  D36COM   CHK     Bad local node number
|  
|                           The node number that was set  with  the  NODE
|                           command  in  the  CONFIG file was higher than
|                           the DECNET MAXIMUM-ADDRESS value set  in  the
|                           same  file.   As  a consequence DECnet cannot
|                           initialize.
|  
|                           Change the startup file to be consistent.


   COMCHA  D36COM   CHK     Number of available FB blocks to large


                                    112



                            When checking the CH begstr  for  a  type  of
                            block,  the  code determined that more blocks
                            were available than  there  were  originally.
                            DNCHFB  is  supposed  to defend against this.
                            CHNUM was probably trashed.


   COMCHB  D36COM   CHK     CH pointer off by a few

                            A pointer internal  to  the  core  management
                            routines  is  off  by  a few words.  You have
                            probably trashed an AC by  adding  to  it  or
                            XORing some bits.


   COMCHO  D36COM   CHK     CH pointer out of range

                            In the  core  block  checking  routines,  the
                            internal pointer to the CH begstr applying to
                            this type of block is bad.   Your  executable
                            code was probably trashed.


   COMCID  D36COM   CHK     Couldn't initialize DECNET

                            SCTINI found some reason  to  object  to  the
                            DECnet  environment.   See SCTINI for reasons
                            why it takes a non-skip return.


   COMDNP  D36COM   CHK     DNGPOS called with bad MS

                            In range checking the  ac  MS,  its  contents
                            were  outside the range of addresses used for
                            the MS block.  Trace back to the  caller  and
                            find out why it has a junk pointer.


   COMFBA  D36COM   CHK     FB available count is wrong

                            DNCHFB walked through a free list and found a
                            different  number  of blocks on the list than
                            the header indicated.  A forward pointer  was
                            probably  destroyed  in a previously returned
                            block.


   COMFBB  D36COM   CHK     FB in database is off by a few

                            DNCHFB found a block on  a  free  list,  most
                            likely just returned, whose address is not on
                            a block boundary  for  blocks  on  this  free


                                    113



                            list.   The  offending  pointer  is in P1.  A
                            caller on the stack is probably  returning  a
                            junk  pointer,  either  a  real  pointer to a
                            block   that   has   been   incremented    or
                            decremented, or a completely junk pointer.


   COMFBF  D36COM   CHK     FB is already on free list

                            The block that P1 points to is already on the
                            free  list  and  is  being returned again.  A
                            caller on the stack is returning a block that
                            is already free.


   COMFBO  D36COM   CHK     FB pointer is out of range

                            When checking a free block pointer, the  code
                            found that the pointer is not pointing to the
                            free core allocated for this type  of  block.
                            Identify   the  routine  that  supplied  this
                            pointer.


   COMFBT  D36COM   CHK     FB pointer is off by a few

                            A free block pointer is off by a  few  words.
                            The  user  of  this  pointer probably added a
                            constant,  and  forgot  to  restore  it  when
                            returning  the block.  Trace the user of this
                            pointer, and make sure the pointer  is  valid
                            when given to the memory manager.


   COMFWZ  D36COM   CHK     Tried to free words at zero

                            DNFWDS was called with a pointer of zero.


   COMIEL  D36COM   CHK     Illegal end of list pointer

                            CHAVL, the available count, said there was at
                            least  one  block  on  the free list, but the
                            first pointer was zero.   A  forward  pointer
                            was   probably   destroyed  in  a  previously
                            returned block.


   COMMMI  D36COM   CHK     Memory manager must be initialized

                            The field CHBOT, which indicates where a free
                            core  pool  starts, is zero.  This field gets


                                    114



                            set when the core manager is initialized.  If
                            DNINIM has already been called, check to make
                            sure it is initializing all CH blocks.


   COMMMS  D36COM   CHK     Bad pointer passed to memory manager

                            When DNGWDS gives out a  block  of  core,  it
                            leaves  a  check  word immediately before the
                            first word of core given to the  user.   This
                            word  contains the length of the block, and a
                            "check" quantity to verify  that  this  block
                            contains  what  is  expected.  This bug means
                            that the check word has been trashed, or  the
                            pointer that was passed to the memory manager
                            is bad.


   COMMPR  D36COM   CHK     Message pointer check

                            DNFMSG caller tried  to  return  a  piece  of
                            memory  that  is  not in the range of message
                            blocks.  See stack for caller and find why it
                            is trying to return a bad message block.


   COMMS1  D36COM   CHK     Bad pointer passed to memory manager

                            Header word trashed or bad pointer.


   COMMS2  D36COM   CHK     Bad pointer passed to memory manager

                            Header word trashed or bad pointer.


   COMMS3  D36COM   CHK     Bad pointer passed to memory manager

                            Header word trashed or bad pointer.


   COMMTS  D36COM   CHK     New message block too short


   COMMZP  D36COM   CHK     DNMINI was passed a zero pointer

                            A caller probably meant to ask for zero bytes
                            of  user  data  in  T2 and mistakenly put the
                            count in T1.  T1 is supposed to  contain  the
                            pointer to the message block being refreshed.
                            Find caller on the stack and fix it.



                                    115



   COMODP  D36COM   CHK     DNGOPS called with bad MS

                            In range checking the  ac  MS,  its  contents
                            were   found  to  be  outside  the  range  of
                            addresses used for the MS block.  Trace  back
                            to  the  caller  and  find  out why he has an
                            invalid pointer.


   COMSCO  D36COM   HLT     Section 1 assertion failed

                            This  code  is  supposed  to  be  running  in
                            section  one or greater, yet the TESTS1 macro
                            found code running in section zero.  Look  on
                            the stack for the address of the TESTS1 macro
                            that detected the fault.  Find the code  that
                            fell into section zero and fix it.

   COMSTB  D36COM   CHK     Smear request too big

                            The caller requested that a very large  block
                            be  smeared.  Find out what the caller really
                            wanted to smear and fix the call.
|  
|  
|  DNBBP   D36COM   CHK     Bad byte-pointer
|  
|                           CIDLL is copying a DECnet message  to  a  SCA
|                           buffer,  and  came  across a bytepointer in a
|                           MSD where the first three bits are 5,6 or 7
|  
|  
|  DNBNP   D36COM   CHK     Bad number of padding
|  
|                           DNCMSD has a software bug in the  logic  that
|                           calculates number of pad bytes
|  
|  
|  DNDDGE  DNADLL   CHK     Didn't get reserved emergency msg blk
|  
|                           We should never run out of emergency  blocks,
|                           ROUTER  should  sign up for enough blocks and
|                           then use no more than signed up for.
|  
|                           Either ROUTER hasn't  signed  up  for  enough
|                           emergency  blocks  or  has used too many.  If
|                           too many, they are  probably  in  some  input
|                           queue.   Find  all calls to DNGEMS and DNMINP
|                           and find who used too many.
|  
|  
|  DNDEBI  DNADLL   CHK     Emergency circuit buffer already in use


                                    116



|                           This BUG is not documented yet.
|  
|  
|  DNDIFK  DNADLL   CHK     Illegal function code from DDP kontroller
|  
|                           This BUG is not documented yet.
|  
|  
|  DNDIKF  DNADLL   CHK     Illegal function code from DLL kontroller
|  
|                           This BUG is not documented yet.
|  
|  
|  DNDINF  DNADLL   CHK     Illegal function code from NTMAN
|  
|                           DNADLL was called  with  a  bad  function  by
|                           NTMAN
|  
|  
|  DNDIUF  DNADLL   CHK     Illegal function code from DNADLL user
|  
|                           DNADLL was called  with  a  bad  function  by
|                           ROUTER
|  
|  
|  DNSLJ   D36COM   CHK     MOVSLJ failed
|  
|                           The MOVSLJ instruction did not skip
|  
|  
|  DTIIFK  DNADLL   CHK     Illegal function code from DTE kontroller
|  
|                           This BUG is not documented yet.


   LLIAAL  LLINKS   CHK     Arg blk to NSPACC wrong length


   LLIAK2  LLINKS   CHK     Duplicate msg put on ACK queue
|  
|  
|  LLIBWK  LLINKS   CHK     SCTNSF call from sched w/o lock
|  
|                           The DECnet entry point SCTNSF has been called
|                           from schedular level when the Session Control
|                           interlock was locked.
|  
|                           All  schedular  level  routines  which   call
|                           SCTNSF  should first check SCTLOK.  If SCTLOK
|                           is not -1, then the caller  should  wait  for
|                           the   next  schedular  cycle  before  calling
|                           SCTNSF.


                                    117



   LLICGT  LLINKS   CHK     Can't DNMINI a msg blk

                            DNMINI refused to initialize a message block.
                            This  should  never happen when the number of
                            bytes requested is zero.  There  is  probably
                            something  wrong  with the message block, its
                            pointer, or DNMINI.


   LLICLS  LLINKS   CHK     Tried to close in non-pre-close state


   LLIDDP  LLINKS   CHK     Tried to destroy non-DP port


   LLIDIR  LLINKS   CHK     Duplicate Interrupt Message Received

                            The code found a duplicate interrupt  message
                            on  the unacked interrupt receive queue.  One
                            should never get  this  message  because  the
                            code  is not allowed out of the NSP interlock
                            with  anything   in   this   receive   queue.
                            Identify  the  problem.  Either the interrupt
                            flow control malfunctioned and sent more than
                            one  data request, or the remote node sent an
                            interrupt message without a data request.
|  
|  
|  LLIELZ  LLINKS   CHK     MB back pointer to EL zero
|  
|                           This BUG is not yet documented


   LLIFNS  LLINKS   CHK     SCTL passed bad NSP PID


   LLIFZM  LLINKS   CHK     Tried to free zero msg
|  
|  
|  LLIGEC  LLINKS   CHK     Could not get EC block
|  
|                           There  isn't  any   memory   for   an   event
|                           communication block, although there should be
|                           since  this  routine  is   only   called   at
|                           initialization.
|  
|                           Verify that the  memory  manager  initialized
|                           correctly.


   LLIHTG  LLINKS   HLT     INIHSH can't get a hash table



                                    118



   LLIHTS  LLINKS   HLT     NSPHTS not set up


   LLIIFC  LLINKS   CHK     Illegal flow control type


   LLIILI  LLINKS   CHK     Interrupt message must not be segmented


   LLIIVO  LLINKS   CHK     Illegal call vector offset


   LLILMA  LLINKS   CHK     RETBUF left LAR # LMA


   LLINNI  LLINKS   CHK     NSP not yet initialized

                            NSP  (LLINKS)  will   reject   all   messages
                            received   from  either  Session  Control  or
                            Router   until   DECnet   initialization   is
                            complete.


   LLINNP  LLINKS   CHK     No memory for reserved NDB


   LLINRP  LLINKS   CHK     No memory for reserved ports


   LLIOAL  LLINKS   CHK     OPEN arg blk wrong length


   LLIODN  LLINKS   CHK     NSIODN got message with NMACK=0


   LLIORC  LLINKS   CHK     ORC should never be negative
|  
|  
|  LLIORQ  LLINKS   CHK     ORQ is non-empty at port close
|  
|                           This BUG is not yet documented


   LLIPIM  LLINKS   CHK     PROCXQ found illegal message type


   LLIQIN  LLINKS   CHK     Queued interrupt message illegal


   LLIRFN  LLINKS   CHK     NSP called RESPRC with bad fcn code

                            LLINKS's reserved  port  handler  was  called


                                    119



                            with an unknown Session Control function code
                            in T3.  If there is  a  new  Session  Control
                            function  code  and this routine doesn't know
                            about it, the function code  must  be  added.
                            Otherwise,  look  on  the stack to find which
                            LLINKS routine called Session Control with an
                            invalid function code.  An occurrence of this
                            stopcode indicates that the version of  LLINK
                            and Session Control are skewed.


   LLIRMG  LLINKS   CHK     NSP called RESPRC without msg blk

                            LLINKS's reserved  port  handler  was  called
                            with  no  message block pointer;  T4 is zero.
                            Look  on  the  stack  to  find  which  LLINKS
                            routine   called   Session  Control  with  T4
                            containing zero.


   LLIRMH  LLINKS   CHK     RMVHSH didn't find port


   LLIRQ2  LLINKS   CHK     Duplicate msg requeued


   LLIS2S  LLINKS   CHK     Illegal flow control at PRCRQS


   LLISCM  LLINKS   CHK     ELSCM should not have been set


   LLISIF  LLINKS   CHK     SENDC0's DNMINI failed


   LLITNE  LLINKS   CHK     Unknown Event Type at NSPEVT

                            T1 contains an illegal NSP event type.   Note
                            that  NSPEVT  is  called by SCLINK as well as
                            LLINKS.  Caller address is on the stack.


   LLIWNE  LLINKS   CHK     Can't get event arg blk

                            There isn't any  free  memory  for  an  event
                            argument  block.   Presumably  it  really ran
                            out, but some may  have  been  lost.   Either
                            allocate more free memory or accept that some
                            events will be lost.


   LLIXM2  LLINKS   CHK     Duplicate msg queued for xmit


                                    120



   LLIXNN  LLINKS   CHK     NSP not yet initialized


   LLIXR2  LLINKS   CHK     Duplicate msg requeued for xmit


   LLIXVO  LLINKS   CHK     Illegal Router call


   LLIXZM  LLINKS   CHK     NSP called with no message block
|  
|  
|  NMXTBG  D36COM   HLT     NMXTIM TABLE OUT
|  
|                           Create a new table.
|  
|                           I really doubt that  this  table  has  become
|                           obsolete.  Look for a different bug.


   NRTBPM  NRTSER   CHK     Bad pointer passed to memory manager


   NRTFW0  NRTSER   CHK     Tried to free words at zero


   NRTHBC  NRTSER   CHK     NRTHBR should never be called


   NRTILS  NRTSER   CHK     NRT link in unexpected state


   NRTINP  NRTSER   CHK     NRT Input to DECnet failed


   NRTOUD  NRTSER   CHK     NRT output to DECnet failed


   NRTPCL  NRTSER   CHK     Partial Configuration Msg Loss


   NRTSAB  NRTSER   HLT     No memory for NRT's SAB


   NRTSET  NRTSER   CHK     SCTPSQ returned wrong channel info


   NRTSJB  NRTSER   HLT     No memory for NRT's SJB


   NRTSJM  NRTSER   HLT     No memory for NRT's SJB



                                    121



|  NTBSUP  D36COM   CHK     Buffer supplied
|  
|                           The routine NTPARM was  called  to  handle  a
|                           network  management  parameter.   The routine
|                           can only handle returns of  a  single  value,
|                           but NTMAN had supplied a multi-word buffer.
|  
|  
|  NTBTSM  D36COM   CHK     Buffer too small
|  
|                           NTMAN requested a show counter operation, but
|                           did not supply a buffer large enough to store
|                           all the counters.


   NTMBCF  NTMAN    CHK     Bad coded field on output

                            While  formatting  output  for  a  SHOW,  the
                            program  was  requested  to  generate a Coded
                            field of more than one byte.  The program  is
                            not  coded  for  this  function.  Look at the
                            descriptor block pointed to by NT.  Check  to
                            see if this item is supposed to be a multiple
                            byte Coded.  If not, fix  the  item's  entry.
                            If  it  is  correct, write the code to handle
                            multiple-byte Coded fields.


   NTMBCX  NTMAN    CHK     Bad call to NMXXND

                            A "layer" (any routine described  in  NMXDSP)
                            that  handles information in Router's routing
                            vector was called.  All  the  information  in
                            this  vector is supposed to be read only, but
                            it was called for a set  or  clear  function.
                            Look  at  the  descriptor block pointed to by
                            the AC NT, and determine  which  item  caused
                            this layer to be called.  Then fix the item's
                            entry to indicate that this  is  a  read-only
                            parameter.


   NTMBDL  NTMAN    CHK     Bad multiple byte length

                            The  code  generates  output  for  a  numeric
                            field,  and  was asked to generate an illegal
                            number of bytes.


   NTMBFP  NTMAN    CHK     Bad format type encountered

                            While the  program  was  in  the  process  of


                                    122



                            reading  a  value  from  the user string, the
                            descriptor tables returned an invalid  format
                            for  this  item.   The  AC  NT  points to the
                            descriptor for this  item,  and  field  NTSEQ
                            should  tell  which item is being referenced.
                            Fix the entry for this item so it contains  a
                            valid format type.


   NTMBLI  NTMAN    CHK     Bad Line id

                            Router gave an error return  when  asked  for
                            the state of a circuit.  The only valid error
                            return  from  this  routine  is  due   to   a
                            nonexistent circuit.


   NTMBSS  NTMAN    CHK     Bad string size in NMXNI4

                            When attempting  to  copy  an  identification
                            string from NMXVAR into a freecore block, the
                            string claimed to  be  too  long  to  fit  in
                            either   block.    Find  out  how  this  byte
                            (containing the length) got trashed.


   NTMCNO  NTMAN    HLT     Circuit name overrun

                            More than 16 bytes of data were returned to a
                            16  byte  field.   The data beyond the buffer
                            was trashed.  Examine the algorithm at NMXC2N
                            to determine why the code returned more bytes
                            than were expected.  To avoid this halt,  fix
                            the  above code to check for overrun while it
                            is producing the bytes.


   NTMDVI  NTMAN    CHK     NMXDSP value illegal

                            The code called a layer to obtain a value  or
                            set  a  value for an item.  The routine value
                            in the descriptor block pointed to by NT  was
                            illegal.   Examine the data structure pointed
                            to by NT.  Probably  this  was  caused  by  a
                            trashed   NT,   since  the  descriptor  block
                            generation macros are supposed to range check
                            this value.
|  
|  
|  NTMEFO  NTMAN    CHK     Event function out of range
|  
|                           The event function supplied by a DECnet layer


                                    123



|                           to NMXEVT was out of range.
|  
|                           Make callers of  NMXEVT  supply  the  correct
|                           function code


   NTMEOR  NTMAN    CHK     Entity type out of range

                            While double-checking the entity  ID,  before
                            dispatching  on  it,  the code found the type
                            value was illegal.  Since the value  supplied
                            by  the user is checked at GETBLK, this means
                            that field NXENT was trashed.


   NTMESL  NTMAN    CHK     Event string too long

                            The code received  an  event  from  a  DECnet
                            layer,  and the length of the data string was
                            too long to fit in the storage block.  Either
                            increase  the  size  of  .NQMXS  or cause the
                            DECnet layer to return a smaller string.


   NTMFOR  NTMAN    CHK     Format out of range

                            In formatting output for a SHOW,  the  format
                            block  for  this  item  had an illegal format
                            type.  See NTMBFP.


   NTMFUR  NTMAN    CHK     Function code out of range

                            The code is going  to  dispatch  by  function
                            code, and found that the function code is out
                            of range.  Since the function  code  supplied
                            by  the user is checked in GETBLK, this means
                            that field NXFNC was trashed.


   NTMILI  NTMAN    CHK     Invalid Line ID

                            NMXDLL was called to perform a function for a
                            line, and the previously validated line ID is
                            bad.  The probable cause is that something is
                            trashing NXNUM.


   NTMILN  NTMAN    CHK     Illegal number size

                            The code is going to  read  a  numeric  value
                            from   the   user's   string.    The   format


                                    124



                            descriptor block for this item specified read
                            of an illegal number of bytes.


   NTMINT  NTMAN    CHK     Invalid numeric type

                            The code is generating output for  a  numeric
                            field,  and  was  asked to generate something
                            other than decimal, hexadecimal or octal.


   NTMKOR  NTMAN    CHK     Kontroller out of range in Circuit-id

                            The Kontroller field in a line-id is  out  of
                            range.   The  value LD.MAX defines the number
                            of Kontrollers known by D36PAR, and  thus  by
                            NTMAN.   The  most likely cause of this error
                            is a trashed AC.


                                                NOTE

                                A Kontroller  is  any  device  driver
                                with which Router will interface.  It
                                is used  to  define  the  name  of  a
                                circuit/line,  under  the  assumption
                                that  each  Kontroller  will  control
                                only a single line type.


   NTMNEC  NTMAN    CHK     No error code, with error return

                            Some routine took the  non-skip  return,  but
                            did not give an error code by calling NTExxx.
                            This means that the program returned  to  top
                            level  and  field  NXERR was zero.  Determine
                            which routine is failing, and make the  error
                            return give an error code.


   NTMNTR  NTMAN    CHK     Node type is out of range

                            The code  was  going  to  select  entries  to
                            return  (for  function  .NTSHO)  and needs to
                            know the  node  type  (executor,  remote,  or
                            loop)  in  order  to  choose the correct one.
                            For  other  entities  (circuit,  lines)  this
                            field should contain zero.  This field is set
                            by ENTCVT.
|  
|  
|  NTMORE  NTMAN    CHK     Unrecognized entity type


                                    125



|                           An event was received from  a  DECnet  layer,
|                           and the entity type is not legal.
|  
|                           Find the routine that logged the  event,  and
|                           convince it to supply a legal entity type.
|  
|  
|  NTMSAN  NTMAN    HLT     Event sanity check failed
|  
|                           The event logger runs a sanity check  on  the
|                           supplied   argument   block,  and  the  check
|                           failed.
|  
|                           Fix the software.


   NTMSOR  NTMAN    CHK     Selection criteria is out of range

                            The code is going to select items  to  return
                            (for   .NTSHO)  depending  on  the  selection
                            criteria, and found the criteria to be out of
                            range.   Fix  the check in GETBLK or find out
                            why field NXSEL is being trashed.
|  
|  
|  NTMSQF  NTMAN    CHK     Signal queue full
|  
|                           The signal queue was full when a  new  signal
|                           was  logged.   This  might  be  caused  by  a
|                           malfunctioning NMLT20 that does not read  the
|                           signals  from  the signal queue, or it may be
|                           caused by a DECnet device driver going rogue.
|                           A signal is used to tell NMLT20 that a device
|                           needs attention/reload.
|  
|                           Restart NMLT20, or  turn  off  malfunctioning
|                           DECnet  device.   If  necessary,  reload  any
|                           devices by hand.


   NTMSRF  NTMAN    CHK     Skipness of return fouled up

                            The code  returns  from  NTMAN  with  a  skip
                            return,  but there is an error code stored in
                            field NXERR.  Identify  the  caller  that  is
                            giving the error code (or trashing NXERR) and
                            make it give a non-skip return.


   NTMSSB  NTMAN    CHK     Setting a circuit substate

                            Setting a substate is  illegal.   This  entry


                                    126



                            should  be read-only in the descriptor block,
                            and the code should have caught this  before.
                            Make  the  entry  in  the descriptor block be
                            read-only.


   NTMXNL  NTMAN    CHK     ROUTER doesn't know about a line

                            The code asked router  for  the  state  of  a
                            circuit,  and  router  gave  an error return.
                            The only valid failure is for a  non-existent
                            circuit.   The  code  should  have previously
                            checked  the  circuit  ID  for  existence  at
                            ENTCVT.
|  
|  
|  NTNBUF  D36COM   CHK     No buffer supplied
|  
|                           NTMAN requested a show counter operation, but
|                           did not supply a buffer to store the counters
|                           in.
|  
|  
|  ROUAWS  ROUTER   CHK     Adjacency block in queue when state is unused
|  
|                           An adjacency block has been left in the queue
|                           of   active  adjacencies  but  its  state  is
|                           unused.


   ROUBCD  ROUTER   CHK     Bad Checksum detected when  building  routing
                            msg

                            This stopcode indicates  that  something  got
                            trashed.   Look  at P1;  it points to the end
                            of     the     normal     routing      vector
                            [RTRNRV]+[RTRMXN].   Check  the vector itself
                            (pointed  to  by  RTRNRV)  and  see  if   the
                            topology   appears   reasonable.   Make  sure
                            RTRCKS is less than 16 bits.


   ROUBMB  ROUTER   CHK     Bad message block pointer

                            A Kontroller called RTRDSP  with  a  function
                            requiring  a  message  block, and the pointer
                            supplied (in T3) is either 0 or out of range.
                            Determine  why the Kontroller gave an invalid
                            pointer.  The pointer should originally  have
                            been obtained from this module.




                                    127



   ROUBSN  ROUTER   CHK     Bad source node in message from NSP
|  
|  
|  ROUBSZ  ROUTER   CHK     Router circuit  block  size  was  zero  on  a
|                           running circuit
|  
|                           This BUG is not documented yet.


   ROUBTF  ROUTER   INF     Bad Test message format


   ROUBTM  ROUTER   INF     Bad Hello or Test message


   ROUCGE  ROUTER   CHK     Couldn't get emergency buffer for circuit

                            ROUTER requires that the memory manager  save
                            at  least  2  buffers per circuit for ROUTER,
                            one for the routing message ROUTER keeps  for
                            each  circuit and one to guarantee some level
                            of route-through ability.  ROUTER  was  asked
                            to  open  a  circuit,  but the memory manager
                            could not guarantee  the  buffers.   Allocate
                            more memory or settle for fewer circuits.


   ROUCGV  ROUTER   CHK     Couldn't get memory for event arg block


   ROUCNL  ROUTER   CHK     Trying to call non-existent NSP


   ROUEHB  ROUTER   CHK     No Message Block for Event data


   ROUEHM  ROUTER   CHK     No Message Block for Event data
|  
|  
|  ROUHCE  ROUTER   INF     Bad NI router list message format
|  
|  
|  ROUIFK  ROUTER   CHK     Illegal function code from Kontroller
|  
|                           This BUG is not documented yet.
|  
|  
|  ROUIFS  ROUTER   CHK     Router  got  through  the   forward   routine
|                           without picking a route
|  
|                           For  some  reason  RTRFWD  got  through   its
|                           Forward  process and either did not pick up a


                                    128



|                           router or failed to flag a message which  was
|                           for  the local node as such or an unreachable
|                           message as such.


   ROUIKF  ROUTER   CHK     Illegal Kontroller function

                            CALKON was called with  an  illegal  function
                            code.   The  only  allowed values are KF.QOB,
                            KF.INI, and KF.HLT.


   ROUILS  ROUTER   CHK     Illegal Circuit Specified in NSP msg


   ROUIVL  ROUTER   CHK     Invalid circuit state


   ROUNLN  ROUTER   CHK     Trying to return msg to non-local NSP


   ROUNMR  ROUTER   CHK     NMX out of range


   ROUNOR  ROUTER   CHK     Node number out of range


   ROUNSD  ROUTER   CHK     Tried to call non-existent device driver


   ROUNSO  ROUTER   CHK     NSP sent out-of-range packet


   ROURML  ROUTER   CHK     Stored routing message format error in RTRRCR


   ROUSOR  ROUTER   CHK     Setting state out of range


   ROUUER  ROUTER   CHK     Unexpected end of routing message


   ROUUET  ROUTER   CHK     Unknown event type in RTNEVT
|  
|  
|  ROUUOC  ROUTER   CHK     Unable to obtain count of nodes in  Phase  IV
|                           message
|  
|  
|  ROUUOS  ROUTER   CHK     Unable to obtain  starting  ID  in  Phase  IV
|                           routing message



                                    129



   ROUXNZ  ROUTER   CHK     R2NCAL called with MB=0


   ROUZXT  ROUTER   CHK     Tried to free msg with MB=0
|  
|  
|  SCLA2N  SCLINK   CHK     Node database inconsistent
|  
|                           The node database SCLA2N failed  an  internal
|                           consistency check


   SCLBFS  SCLINK   CHK     Bad format type not caught


   SCLCIM  SCLINK   CHK     NSP called SCTLCI without a msg blk


   SCLFCT  SCLINK   CHK     Illegal function in call from NSP


   SCLFMZ  SCLINK   CHK     Tried to free message with MB zero


   SCLGTN  SCLINK   CHK     Global connect timer count went negative


   SCLICR  SCLINK   CHK     Negative buffers reserved, from input

                            LLINKS  sent  a  buffer  to  SCLINK's   NSFDR
                            routine.  This routine decremented the number
                            of  buffers  reserved  for  the   appropriate
                            logical  link  and  the  count went negative.
                            Either LLINKS offered too many buffers or the
                            count   DCNRSB   was  decremented  or  zeroed
                            prematurely.


   SCLISU  SCLINK   CHK     Illegal SL at SCTINU

                            After  a   Session   Control   function   was
                            complete,  register SL no longer held a value
                            for the SLB pointer.  Find out which  routine
                            in SCLINK smashed SL.


   SCLJTN  SCLINK   CHK     Job connect timer count went negative


   SCLMF1  SCLINK   CHK     SNDDRM failed to send DRQs

                            The code  should  never  fail  to  send  data


                                    130



                            requests when a message block already exists.


   SCLMF2  SCLINK   CHK     SNDDRM failed to send DRQs


   SCLMI1  SCLINK   CHK     DNMINI failed to re-init an MB


   SCLMIF  SCLINK   CHK     DNMINI failed to init msg blk


   SCLNCP  SCLINK   CHK     No CBLOCK pointer in SJB


   SCLNMB  SCLINK   CHK     NSP called SCTL without a msg blk


   SCLNRD  SCLINK   CHK     No resources to send DRQs in SCCCR


   SCLNZE  SCLINK   CHK     Passing zero error code to SCMUUO

                            The  code  arrived  at  a  routine  that   is
                            supposed to store an error code for the user,
                            but found that the error code is zero.   This
                            is  an  illegal  value.   Find  which routine
                            called SCTNIE with  T1  containing  zero  and
                            correct the caller's behavior.


   SCLOCR  SCLINK   CHK     Negative buffers reserved, from output

                            LLINKS sent a buffer to SCLINK's Output  Done
                            routine.   This  decremented  the  number  of
                            buffers reserved for the appropriate  logical
                            link  and  the  count  went negative.  Either
                            LLINKS returned too many buffers or the count
                            DCNRSB was decremented or zeroed prematurely.
|  
|  
|  SCLRIB  SCLINK   CHK     Bad SCTRIB call from LLINKS
|  
|                           LLINKS has called SCTRIB  for  permission  to
|                           send  a  message  to SCLINK and has passed an
|                           invalid SLB address in T1.
|  
|                           Find out what is in LLINK's ELSCB and why  it
|                           is not an SLB pointer.


   SCLSBJ  SCLINK   CHK     Bad Job Block Pointer Passed to SCTNSF


                                    131



   SCLSIM  SCLINK   CHK     Got a segmented interrupt message from NSP


   SCLSJR  SCLINK   CHK     SCMUUO called NSFJR in SCLINK


   SCLSLB  SCLINKS  CHK     SLB bad at FRESLB

                            There is no Session Control Job  Block  (SJB)
                            for  this  Session  Control Link Block (SLB).
                            This error could have happened  at  any  time
                            during   the  life  of  the  link,  after  it
                            actively transferred data.


   SCLSMS  SCLINK   CHK     STRMAT messed up the stack pointer


   SCLSNM  SCLINK   CHK     No Message Block supplied to SCTNSF


   SCLSNS  SCLINK   CHK     Sblock not supplied to NSFIS


   SCLSPF  SCLINK   CHK     SLB self pointers messed up in FNDSLB


   SCLSPM  SCLINK   CHK     Self pointers messed up in SLB


   SCLSPS  SCLINK   CHK     SLB Self pointers messed up in SLBMAT


   SCLSTM  SCLINK   CHK     Trying to start a  CI  timer  that's  already
                            going


   SCLTFJ  SCLINK   CHK     Freeing SJB with SLB entries existing


   SCLTFS  SCLINK   CHK     Tried to free wrong SLB
|  
|  
|  SCLVAS  SCLINK   CHK     Couldn't get memory
|  
|                           SCLINK  called  ASGVAS  to   assign   virtual
|                           address   space  for  the  node  name/address
|                           database.   Since  the  requested  memory  is
|                           non-resident,  this  should  always  succeed.
|                           However, ASGVAS gave a fail return.




                                    132



   SCLWVS  SCLINK   CHK     Incoming connect with wrong  Session  Control
                            version


   SCLZST  SCLINK   CHK     Illegal state value at SCTNIU

                            The SCLINK error handler found that the state
                            code in this link's SLB was illegal.  This is
                            just a gateway check to see if  something  in
                            SCLINK  is  wrong.  Find the function code in
                            the SAB and trace the probable flow from that
                            function code.


   SCMAAE  SCLINK   CHK     Address Check after Function Call


   SCMBCN  SCLINK   CHK     Bad channel number

                            The channel  number  obtained  from  the  SLB
                            field SLCHN does not match the channel number
                            expected by the code.   This  probably  means
                            that   the   interlocks   are  not  correctly
                            arranged, and the SLB has changed.


   SCMNP2  SCLINK   CHK     No SJB for SCTPSI


   SCMNPD  SCLINK   CHK     No PDB for Job
|  
|  
|  SCTBWK  SCLINK   CHK     SCTNSF call from sched w/o lock
|  
|                           The DECnet entry point SCTNSF has been called
|                           from scheduler level when the Session Control
|                           interlock was locked.
|  
|                           All  scheduler  level  routines  which   call
|                           SCTNSF  should first check SCTLOK.  If SCTLOK
|                           is not -1, then the caller  should  wait  for
|                           the   next  schedular  cycle  before  calling
|                           SCTNSF.











                                    133



   6.0  LIST OF GALAXY-10 STOPCODES        LIST OF GALAXY-10 STOPCODES

   An alphabetical list of the GALAXY-10 stopcodes is  presented  on  the
   following pages.  The list shows the name of each stopcode, the module
   in which it is found, the stopcode message (for which the  name  is  a
   mnemonic), and an explanation.

   Each GALAXY component is made up  of  one  or  more  modules,  thus  a
   stopcode  can  be generated by a module with a name other than that of
   the component producing the stopcode.  See example on page B-2.

   When GALAXY encounters an internal error, a stopcode is generated.   A
   message  of  the  following  form  appears  in  the operator log file,
   followed by the contents of the ACs and the last 9 stack locations.

        ?Stopcode - XXXYYY - in module module on date on time                    XXXYYY             module    date    time
        Reason:  message                 message
        Program is program name version n(nnnn) using GLXLIB version                   program name         n(nnnn)
        n(nnnn)        n(nnnn)
        Crash block starts at location address                                       address
        Last GLXLIB error:  ## (message)                            ##  message

   Where:

        XXXYYY              is the name of the stopcode, identifying  the        XXXYYY
                            error.

        module              is the module in which the stopcode occurred.        module

        date                is the date on which the stopcode occurred.        date

        time                is the time at which the stopcode occurred.        time

        message             is the stopcode message.        message
        program name        is the program running for that job.        program name

        n(nnnn)             is the version number.        n(nnnn)

        address             is the location of the crash block.        address

        ##                  is the number of the last GLXLIB  error  that        ##
                            occurred.












                                    134



   Example:

        ?Stopcode - PQI - in module QSRT10 on 23-Feb-84 on 18:43:17
        Reason:  Prime Queue is Interlocked
        Program is QUASAR version 4(1173) using GLXLIB version 1(1161)
        Crash block starts at location 674000
        Last GLXLIB error:  23 (End of list reached)

        Contents of the ACs:

        0/ 777777777777 3 61353 1

        4/ 63377 0 0 10000000

        10/ 16 637163000000 0 140421

        14/ 0 141577 140 777501063716

        Last 9 stack locations:

        -1(P)/ 312000630517 -2(P)/ 312 -3(P)/ 312000061244

        -4(P)/ 312000017227 -5(P)/ 312000630517 -6(P)/ 312

        -7(P)/ 312000017226 -8(P)/ 312000064261 -9(P)/ 0





























                                    135



   Name    Module   Message and Explanation   ____    ______   _______ ___ ___________


   ABS     GLXSCN   Atom buffer too small

                    The command from OPR is too long to fit in  the  Atom
                    buffer for parsing.


   AIE     QSRSCH   Attempt to add invalid event queue entry

                    S$EVENT detected that the entry to be added to  EVENT
                    QUEUE is not the correct size.


   AMT     QSRMDA   Allocated is more then total (VOL .VLVSL BLOCKS)

                    SCNVOL detected that the number  of  words  allocated
                    for  VOL  block  pointer  is  greater  than the total
                    number of VOL blocks.


   APT     GLXINT   Unknown APR trap at PC <pc> APR CONI  =  <octal  CONI
                    word>


   ASE     GLXMEM   Addressing space exhausted


   AZA     GLXCOM   Attempt to zero the ACs

                    Bad argument(s) passed to routine .ZCHNK.


   BBF     PLRLBP   Bad backspace file

                    Incorrect TCB status detected backspacing a  file  on
                    tape.


   BBR     PLRLBP   Bad backspace record

                    Incorrect TCB status detected backspacing a record on
                    tape.


   BCN     PLRLBP   Bad call to nxtfil

                    Routine NXTFIL was called to skip to the next  file's
                    HDR1  label,  but  the  TCB status indicates that the
                    tape is not positioned in user data.



                                    136



   BCP     PLRLBP   Bad Call to POSTAP


   BDS     GLXSCN   Bad Default String

                    The first character in the default string  ($DEFAULT)
                    is a null.


   BFC     GLXSCN   Bad function code

                    An  invalid  parse  function  code  was  detected  in
                    routine S%CMND.


   BLI     QSRMDA   <text>

                    The BLISS routines called by QUASAR detected an error
                    that  warranted  a  stopcode;   "text"  is the reason
                    returned by the BLISS routine.


   BME     QSRMDA   'B' Matrix Entry is Missing

                    RETBMA called D$BMTX to  find  a  user's  'B'  matrix
                    entry,  but  there  is  no  corresponding  'B' matrix
                    entry.


   BPN     GLXMEM   Bad page number <page number>

                    VALPAG determined that a page  is  not  part  of  the
                    initial core image or is not marked in use.


   BRS     QSRFSS   BAD REQUEST SIZE

                    The argument passed to routine GETDPA is not  in  the
                    range 1 to 1000 (octal).


   BTA     GLXTXT   Bad $TEXT argument given at address <address>


   BTF     GLXSCN   Bad table format

                    TABLK detected two  identical  entries  in  a  table.
                    Table entries must be unique.


   BTT     GLXKBD   Backing up terminal twice



                                    137



                    GLXKBD  only  stores  the  current  character.    The
                    previous character cannot be retrieved.


   CAC     GLXMEM   Count of Available Pages Confused

                    M%ACQP detected that PAGSTA points at or past the top
                    of memory.


   CAD     CDRIVE   CANNOT ADD/DELETE READER TO/FROM INTERRUPT SYSTEM

                    The PISYS.  UUO failed in routine INTCNL.


   CAS     PLRDSK   Can't Append to SPT list


   CCD     PLRT10   Can't Change Density

                    The call to I$SDEN for setting the density of a  tape
                    drive took the error return in I$NDEN.


   CCE     ORION    Can't create list entry

                    The call to L%CENT in ADDNOD failed to create a  list
                    entry.
|  
|  
|  CCE     QSRQUE   Can't create list entry

                    C$SEND was unable to  create  a  list  entry  in  the
                    RESEND queue list of IPCF messages to be re-sent.


   CCI     SPRINT   Can't clear UFD Interlock

                    The SETUUO UUO failed to clear  the  UFD  (User  File
                    Directory) interlock in routine CLRUFL.


   CCP     GLXMEM   Cannot create page

                    The PAGE.  UUO failed in routine CREPAG.


   CCR     PLRTAP   Can't Check Ring status

                    The TAPOP.  UUO in T$WRCK failed  when  checking  for
                    write ring status.



                                    138



   CCS     CDRIVE   CANNOT CLOSE SPOOL FILE

                    F%REL failed to close  the  spooled  reader  file  in
                    CREATE.


   CCT     PLRTAP   Can't connect tape to PSI system

                    In T$OPEN, the call to I$PICD failed to  connect  the
                    tape  drive  to  the PSI interrupt system in order to
                    trap off-line, resulting in hung device conditions.


   CCW     PLRT10   Can't Clear Watch bits

                    The SETUUO UUO  took  the  error  return  in  routine
                    I$INIT.


   CDC     PLRT10   Can't Determine Density capabilities

                    The  TAPOP.   UUO  took  the   error   return   while
                    performing the .TFPDN function in routine I$PDEN.


   CDC     QSRT10   Can't get Disk Characteristics for Unit <unit name>

                    The DSKCHR UUO failed in routine I$GATR.


   CDD     QSRT10   Can't Determine Tape Densities

                    The TAPOP.  UUO failed while  performing  the  .TFPDN
                    function in routine I$GATR.


   CDM     GALGEN   Cannot Determine Monitor Type

                    The GETTAB UUO failed  trying  to  determine  monitor
                    type.


   CDT     QSRT10   Can't Determine Tape Track Status

                    The TAPOP.   UUO  failed  while  performing  function
                    .TFTRK in routine I$GATR.


   CEI     BATCON   Can't enable interrupts

                    The PISYS.  UUO failed in routine SYSINI.



                                    139



|  CEM     QUASAR   Catalog entry is missing


   CFC     GLXMEM   Count of Free Pages Confused

                    GLXMEM's database is corrupt.


   CFF     SPRINT   CAN'T FIND FILES TO LOAD

                    In EXECUTE, SPRINT could not position to the head  of
                    the  list of files necessary to generate an "execute"
                    command.


   CFO     ORION    Cannot GETTAB operator PPN


   CFU     QSRT10   Can't Find UCB for Unit <unit name>

                    In I$ISTR, QUASAR was unable to find  the  UCB  (Unit
                    Control  Block) corresponding to the system structure
                    identified.


   CFV     QSRMDA   Can't Find VSL Address in VOL Entry

                    In DELBSL, there is no link from a VOL (volume) block
                    back  to  the  VSL  (Volume Set List).  A link should
                    have existed because the VOL block was using  a  link
                    in the VSL pointing to the VOL block.


   CGC     CDRIVE   Cannot Get Reader Hardware Characteristics

                    DEVOP.  UUO failed in INPGET while trying  to  obtain
                    reader characteristics.


   CGC     QSRT10   Can't Get Controller Type for Tape Drive <tape drive>

                    TAPOP.  UUO failed while performing  function  .TFKTP
                    in routine I$GATR.


   CGD     PLRT10   Can't Get Density

                    TAPOP.  UUO took the error  return  while  performing
                    the .TFDEN function in I$GDEN.


   CGD     QSRT10   Can't get Disk Physical Unit


                                    140



                    SYSPHY UUO failed in routine I$INIT.


   CGF     ORION    Cannot GETTAB FRCLIN line number


   CGP     GLXIPC   Can't Get a PID

                    C%INIT callled C%CPID to create a  PID  (Process  ID)
                    and C%PID was unsuccessful.


   CGS     CDRIVE   Cannot Get Spool File PPN

                    GETTAB UUO failed in routine RDINIT.


   CGS     PLRT10   Can't GETTAB States word

                    The GETTAB UUO  took  the  error  return  in  routine
                    I%OPRP  while  trying to get the %CNSTS word from the
                    monitor.


   CGS     QSRT10   Can't Get Status of Tape Drive <tape drive>

                    The TAPOP.   UUO  failed  while  performing  function
                    .TFSTS in routine I$GATR.


   CIF     GALGEN   Command Initialization Failed

                    The call to SCMND returned FALSE in GETANS.


   CLS     GLXKBD   Can't lookup status of terminal JFN

                    The  FILOP.   UUO  in  routine  K%OPEN  failed  while
                    performing   the  .FOGET  function  for  a  terminal.
                    Location CHNJFN contains the channel number.


   CME     QSRMDA   'C' Matrix Entry is Missing

                    D$DLCK called D$CMTX to  find  a  user's  'C'  matrix
                    entry but the entry does not exist.


   CMU     PLROPR   Can't Make TCB

                    The call to G$MTCB returned FALSE in I$CREC.



                                    141



   CMV     PLROPR   Can't Make TCB

                    The call to G$MTCB returned FALSE in I$CUNL.


   CNE     ORION    Central site node not present

                    The call to FNDNOD in W$NODE returned a failure while
                    using G$HOST as an argument.


   COP     QSRT10   Cannot Open Prime Queue

                    The FILOP.  UUO failed  in  I$OQUE  when  QUASAR  was
                    trying to open the master queue file.


   COR     QSRT10   Cannot Open Redundant Queue

                    FILOP.  UUO failed in I$OQUE when QUASAR  was  trying
                    to open the secondary queue file.


   COS     CDRIVE   CANNOT OPEN SPOOL FILE

                    F%OOPN returned an error that was not  'file  already
                    exists' in GETFIL.


   CPF     PLRT10   Clear label Parameters Failed

                    TAPOP.  UUO took the error  return  in  I$CLLP  while
                    performing the .TFLPR+.TFSET function.


   CRB     PLRT10   Can't Read Buffer size

                    TAPOP.   UUO  took  the  error   return   in   I$RDLP
                    performing the .TFBSZ function.


   CRD     QSRQUE   CREATE REJECTED DEFER DATA

                    In routine Q$DEFER, the  call  to  Q$CREATE  detected
                    errors.


   CRL     GLXFIL   Can't read last byte of file


   CRL     QSRQUE   CREATE REJECTED LOGOUT DATA



                                    142



                    The call to Q$CREATE in Q$LOGOUT detected errors.


   CRM     PLRT10   Can't Read user's Mode

                    The TAPOP.  UUO took  the  error  return  in  routine
                    I$RDLP while performing the .TFMOD function.


   CRM     QSRQUE   CREATE REJECTED MODIFY

                    The call to Q$CREATE in Q$MODIFY detected errors.


   CRS     QSRQUE   CREATE REJECTED SPOOLING DATA

                    The call to Q$CREATE in Q$SPOOL detected errors.


   CRS     SPRINT   Can't read searchlist

                    This  stopcode  indicates  one  of  two   conditions.
                    Either  the  JOBSTR UUO failed in GETSRC while trying
                    to read SPRINT's current search list,  or  the  PATH.
                    UUO  failed  in  GETSRC while trying to read SPRINT's
                    current path.

   CSB     PLRTAP   Can't Set Blocksize


   CSD     PLRTAP   Can't Set Density


   CSI     GLXINT   Cannot set up interrupt system

                    The PIINI.  UUO failed in routine SETINT.


   CSI     PLRTAP   Can't Set Industry compatible mode


   CSM     PLRTAP   Can't Set DIGITAL compatible Mode


   CSS     QSRT10   Can't get System Structure List

                    The SYSSTR UUO failed in routine I$ISTR.


   CSS     SPRINT   Cant set searchlist

                    This  stopcode  indicates  one  of  two   conditions.


                                    143



                    Either  the STRUUO UUO failed in SETSRC trying to set
                    SPRINT's search list, or the  PATH.   UUO  failed  in
                    SETSRC trying to set SPRINT's path.


   CST     OPR      Can't set timer for parsing

                    The call to I%TIMR returned FALSE in SETIME.


   CSU     PLRTAP   Can't Switch Units

                    The TAPOP.  UUO  failed  in  T$NUNI  when  trying  to
                    switch tape drive units.


   CTL     GLXFIL   Cannot trim LSN in buffered mode

                    F%IBUF does not handle Line Sequenced Numbered files.
                    F%IBYT must be used.


   CUD     QSRFSS   CLEARING UNUSED DPA

                    QUASAR tried to release unused space in the  failsoft
                    file.


   CUF     PLRT10   CHKACC UUO Failed

                    The CHKACC UUO failed in routine I$CKAC.


   CUT     OPR      Can't unset timer after parsing

                    The call to I%TIMR returned FALSE in CLTIME.


   CWT     PLRTAP   Can't Write Tape-mark


   DBC     ORION    Debug Crash - Keep this crash

                    Execution  continued  at  the  location  following  a
                    $DEBRK macro in an interrupt service routine.


   DDF     ORION    Delete DN60 node failed

                    A call to L%DENT returned FALSE in DELNOD.




                                    144



   DSP     ORION    Delete send Failure pid table entry inconsistency

                    The call to CHKFSL in DELSPL failed to find an  entry
                    in the "send failure PID table."


   DTL     QSRFSS   DPA TOO LARGE

                    VALDPA detected a Disk Page Address for the  failsoft
                    file that is too large.


   DTS     QSRFSS   DPA TOO SMALL

                    VALDPA detected a Disk Page Address for the  failsoft
                    file that is too small.


   DTU     GLXINT   Date/Time unavailable

                    The GETTAB UUO to get Universal Date/Time  failed  in
                    routine I%NOW.


   DUF     GLXINT   DEBRK UUO failed


   EEP     QSRT10   ERROR EXPANDING PRIME QUEUE

                    The FILOP.  UUO failed in routine I$WRIT.


   EER     QSRT10   ERROR EXPANDING REDUNDANT QUEUE

                    The FILOP.  UUO failed in routine I$WRIT.


   EWS     CDRIVE   ERROR WRITING SPOOL FILE

                    The call to F%OBUF took the error return in OUTCRD.


   FCE     GLXMEM   Free count exceeds FREINI

                    The current count of free pages exceeds  the  initial
                    count of free pages.


   FCN     GLXMEM   Free count negative

                    Routine REDUCE detected that the count of free  pages
                    went negative.


                                    145



   FFT     GLXKBD   Action FILOP.  failed to terminal

                    The FILOP.  UUO failed  in  K%OPEN  while  trying  to
                    perform either the .FOSET or the .FOWRT function.


   FIT     GLXFIL   FD location requested with illegal type.

                    Routine F%FD was called with illegal arguments.


   FSE     GLXKBD   File System Error

                    TXTINP detected an error returned  from  F%IBYT  that
                    was not an EOF error.


   FUD     QSRFSS   FOUND UNUSED DPA

                    An unused DPA (Disk Page Address) indicates that  the
                    failsoft file system database is corrupt.


   GNF     PLRT10   GETTAB for user's Name Failed


   GOF     GLXIPC   SYSTEM GOPHER IS NOT AROUND

                    In C%INIT, GETTAB to get [SYSTEM]GOPHER's PID failed.


   GSF     PLRT10   GETTAB for Serial number Failed


   IAC     OPR      Argument count <count> not valid in display message

                    An argument block of zero was found in a message from
                    ORION.


   IAM     QSRT10   Invalid Account Validation Message Returned

                    In I$VACT, the call to A$OB2Q was unable to find  the
                    queue  header  for  the  object  type  passed  in the
                    account validation ACK (acknowledgement) message.


   IBN     GLXSCN   Illegal base for number

                    The base for a number to be parsed  was  not  in  the
                    range 2-10 (decimal).



                                    146



   IBP     GLXKBD   Illegal byte pointer in K%TXTI

                    The byte pointer that CONVBP was going to convert  is
                    zero.    This  invalid  byte  pointer  was  found  at
                    RD+.RDDBP.


   IBS     GLXFIL   Illegal byte size given

                    An  invalid  byte  size,  out  of  the   range   1-36
                    (decimal), was given in a call to open a file.


   IBU     BATCON   Illegal BATCON UUO

                    In BATCON's  LUUO  handler,  UUOCON,  an  opcode  was
                    detected that was out of range.


   IDM     OPR      Message argument type <argument type> not  valid  for
                    display message

                    The  argument  type  was  something  other  than  the
                    argument type constant, .CMTXT.


   IDM     OPRLOG   Invalid Display Message Type <msg type>


   IDM     PLRLBP   Invalid Date from Monitor
|  
|  
|  IDR     QUASAR   Invalid DECtape resource number returned


   IEC     OPR      Invalid error code for failure

                    An OPR  failure  error  code  is  not  in  the  range
                    expected in routine SETFAL.


   IFC     OPRPAR   INVALID FUNCTION CODE FROM COMMAND


   IFM     GLXFIL   Illegal file mode in subroutine call

                    An operation was attempted on a file,  but  the  file
                    was  opened  in  a  mode  that prevents the requested
                    operation from succeeding.


   IFN     GLXFIL   Illegal IFN provided in call


                                    147



                    The IFN passed to CHKIFN was not in IFNTAB.


   IIF     GLXIPC   IPCF to interrupt system connect failed

                    In CPIDI, the PISYS.   UUO  failed  while  trying  to
                    connect a job to the interrupt system.


   IIP     GLXKBD   Illegal Input Pointer

                    CONVBP detected a byte pointer of zero at RD+.RDIOJ.


   IJM     QSRADM   Interlocked Job Missing

                    Inconsistency in QUASAR's queue database was detected
                    in KILPSB.


   IJW     QSRADM   Interlocked Job Wrong

                    Inconsistency in QUASAR's queue database was detected
                    in KILPSB.


   ILM     GLXINT   Illegal memory reference at PC <pc>


   IMV     QSRMDA   Invalid MDR/VSL Forward/Backchain Pointers

                    NSTUSR detected that a VSL does not contain a pointer
                    to an MDR.  Every VSL should point to an MDR.


   IOS     QSRMDA   Invalid Owner Specified in Reassign Message

                    DEASSIGN detected that the job number in the DEASSIGN
                    message  does  not  match  the  job number in the MDR
                    pointed to by the UCB of the device being deassigned.


   IPE     PLEASE   Internal parser error


   IPF     PLRTAP   Illegal Positioning Function


   IPH     OPRNET   INVALID PROCESS HANDLE TO KILL


   IPP     OPRPAR   Invalid PDB Header in Parse Block


                                    148



   IQN     GLXTXT   Illegal qualifier number <number> at <address>

                    An illegal argument qualifier was  used  in  a  $TEXT
                    macro.


   IRF     GLXIPC   IPCF Reception failure

                    In RCVMSG, the IPCFR.   UUO  took  the  error  return
                    while trying to receive an IPCF message.


   ITD     QSRMDA   Invalid Tape Density Specified for <tape drive name>

                    The density for a tape drive returned in  the  .STSTS
                    does  not  match any of the legal densities contained
                    in the UCB for that tape drive.


   ITR     QSRMDA   Invalid Tape Resource Number Returned

                    VSLRSN  detected  that  the  tape   resource   number
                    contained in a VSL is zero.


   IVU     QSRMDA   Invalid VOL/UCB Forward/Backchain Pointers

                    DSMACK detected that there is not a pointer to a  UCB
                    in  a  VOL block of a volume that is being dismounted
                    from a device.   When  a  volume  is  mounted,  there
                    should  be  a  pointer in the VOL block to the UCB of
                    the device, and a pointer in the UCB to the VOL block
                    of the volume mounted.


   IVV     QSRMDA   Invalid VSL/VOL Forward/Backchain Pointers

                    D$FOWN did not detect a pointer in a VOL  block  back
                    to a VSL when the VOL block was found by a pointer in
                    a VSL.  VSL and VOL blocks must be doubly linked.


   LDF     LPTSPL   Line Printer Device Status DEVOP.  Failed


   LEM     CDRIVE   Lousy error message from D60SIN

                    An unidentified error code was  returned  by  D60SIN.
                    S1 = error code.


   LGF     PLRTAP   Label Get Failed


                                    149



   LNA     QSRMDA   Logical Name Assignment Failed

                    The DEVLNM UUO  failed  in  REASSI  while  trying  to
                    assign a logical name to a device.


   LNI     SPRINT   LOG not initialized

                    LOGTXT was called to put  a  character  in  the  log,
                    there is not a LOG page set up for usage.


   LRF     PLRTAP   Label Release Failed


   MCF     PLRT10   MTAID.  UUO Failed


   MDS     QSRMEM   MOVING DIFFERENT SIZES

                    QUASAR's queue database is corrupt.


   MQE     QSRMDA   Missing QE for a pseudo process

                    D$CHKB detected that there was no QE page address  in
                    the MDR for a batch job in the input queue.


   MST     OPR      Missing syntax table


   MSZ     SPROUT   Message size too large
|  
|  
|  MVD     QUASAR   Attempt to generate multi-volume DECtape volume set.


   NAM     QSRMDA   Negative 'A' Matrix Entry Computed

                    The  count  of  an  entry  in  the  'A'  matrix  went
                    negative.   There  cannot be a negative number of any
                    physical resource.


   NBM     QSRMDA   Negative 'B' Matrix Entry Computed

                    The  count  of  an  entry  in  the  'B'  matrix  went
                    negative.   There  cannot  be  a  negative  number of
                    allocations (claims) for a resource.




                                    150



   NBR     QSRSCH   Next-job'ing bad request

                    In preparing a "next  job"  message  for  an  object,
                    NEXTJB  called  F$RDRQ  to find the address of the EQ
                    (external  queue)  page  on  disk  and  the   address
                    returned was zero.


   NCM     QSRMDA   Negative 'C' Matrix Entry Computed

                    The count in  a  'C'  matrix  went  negative.   There
                    cannot  be a negative number of owners (sharers) of a
                    device.


   NCS     OPRNET   NO CURRENT SERVER DATABASE IN SKEW


   NDE     ORION    Node database empty

                    In DELNOD,  it  was  discovered  that  the  OPR  node
                    database  is empty.  There must be at least a central
                    host node.


   NEB     PLRTAP   No Error Bit

                    Routine RETERR was called, but no error bits were lit
                    in P1.


   NFB     CDRIVE   FIRST BLOCK IN MESSAGE NOT THE OBJECT BLOCK


   NFP     GLXMEM   No free pages

                    M%IPRM was unable to get a  free  page  for  an  IPCF
                    receive.


   NFV     PLRT10   No free PS vectors

                    I$PICD detected that  there  are  no  free  interrupt
                    vectors available.


   NGF     QSRT10   NECESSARY GETTAB FAILED

                    The GETTAB UUO in DOGTAB failed.


   NIP     GLXINT   No interrupt is in progress


                                    151



                    The DEBRK.  UUO took the skip return.


   NMF     QSRFSS   NO MORE FILESPACE

                    The failsoft file is full.


   NUE     QSRMDA   Null UCB chain encountered

                    In D$INIT, the call to L%FIRST failed to  return  the
                    first UCB block in the UCB chain.


   NUV     QSRDSP   No UCB ptr and No VSL ptr from VOL

                    MDA's database is corrupt.


   NVD     PLRT10   No valid density

                    I$PDEN was unable to determine a  valid  density  for
                    reading a tape drive.


   NXM     GLXINT   Non-existant memory at PC <pc>


   OBR     GLXOTS   Obsolete routine executed


   ODE     ORION    OPR delete entry error

                    DELOPR detected  that  the  list  of  "operators"  is
                    empty.


   ODI     ORION    OPR database inconsistent

                    The call to VALOPR in SPDOPR failed.


   ONV     QSRMDA   Offset of New Volume is Invalid

                    In D$VSR, the calculated offset into the block of VOL
                    block pointers in the VSL is negative.


   OOR     GLXOTS   OTS only routine executed


   OSF     OPR      ORION send failed


                                    152



   OTS     GLXFIL   File Open Block is too small


   PAF     GLXMEM   Page access check failed

                    While performing  function  .PAGCA,  the  PAGE.   UUO
                    failed in routine M%IPRC.


   PDL     GLXINT   Pushdown list overflow at PC <pc>


   PEF     GLXMEM   Page existence check failed

                    The  PAGE.   UUO  failed  while  performing  function
                    .PAGCA in PAGFRE.


   PIR     GLXIPC   PID Index out of range

                    The system PID index passed to SPID is invalid.


   PKF     GLXMEM   Page kill failed

                    The PAGE.  UUO failed in KILPAG.


   PLM     PULSAR   Previous List TCB has been meddled


   PNR     PULSAR   PULSAR Not Restartable


   PQI     QSRT10   Prime Queue is Interlocked

                    In I$OQUE, the FILOP.   UUO  error  return  indicates
                    that the master queue is being modified.


   PRF     PLRTAP   Positioning Request Failed


   PWE     QSRT10   PRIME WRITE ERROR

                    The OUT UUO in I$WRIT took the error return.   IO.BKT
                    was  not  one  of  the  error bits returned using the
                    GETSTS UUO.


   QBI     QSRMDA   QUASAR blew it



                                    153



                    The caller of SNDREC failed to provide a device  name
                    for the RECOGNIZE message being sent to PULSAR.


   QNR     QUASAR   QUASAR Not restartable


   QSF     CDRIVE   Send to QUASAR FAILED


   QSF     LPTSPL   Send to QUASAR FAILED


   QSF     SPRINT   QUASAR send failed


   QSF     SPROUT   Send to QUASAR FAILED


   RAR     GLXIPC   Releasing already released IPCF message

                    In C%REL, RCVMDB+MDB.MS contains zero.


   RAT     PULSAR   Requesting work for active TCB


   RCN     ORION    G$RSDC is negative database confused

                    RSDMSG detected that  the  resend  "retry  count"  is
                    negative.


   RCN     QSRFSS   REQUEST COUNT NEGATIVE


   RCO     ORION    G$RSDC off ..  does not match list data

                    In RSDMSG, the resend "retry  count"  indicates  that
                    there  are  more  messages to resend, but the list is
                    empty.


   RCW     QSRFSS   REBUILD COUNT WRONG

                    This stopcode indicates problems rebuilding  part  of
                    the  in-core  queues  from the current section of the
                    failsoft file.


   REF     QSRT10   READING END OF FILE



                                    154



                    A second EOF error return was generated because there
                    is no more data to be read.


   REI     ORION    Remembered entry <entry #> in list <list #> invalid

                    NXTMSG  detected  an  error  in  its   IPCF   message
                    database.


   RIE     QSRT10   READ I/O ERROR

                    In I$READ, the IN UUO took the error return, and  the
                    error was not EOF.


   RJM     QSRADM   Requeue job missing

                    QUASAR's object database is corrupt.


   RKD     PLRDSK   Running a killed disk TDB


   RKM     PLRTAP   Running a killed magtape TDB


   RLT     PLRTAP   Failed Reading Label Type


   RMB     QSRMDA   Resource Number Missing in 'B' Matrix

                    The unique resource identifier is missing  in  a  'B'
                    matrix entry.


   RMC     QSRMDA   Resource Number Missing in 'C' Matrix

                    The unique resource identifier is missing  in  a  'C'
                    matrix entry.


   RNF     GLXMEM   Received non-existent page

                    M%IPRC detected that a page created by IPCF does  not
                    exist.


   RNW     GLXMEM   Ridiculous number of words requested

                    The number of words requested is greater than  number
                    of words available in M%GMEM.


                                    155



   RPF     PLRT10   Read label Parameters Failed

                    The TAPOP.  UUO failed in I$RDLP.


   RRF     QSRFSS   Rebuild Routine Failed

                    One of the queue rebuild routines in REBTBL failed.


   RSE     PULSAR   Reschedule from exec level


   RSF     PLRT10   TAPOP.  to Read Statistics Failed


   RTS     GLXFIL   Rename block too small


   RTT     PLRTAP   Releasing Tape Twice


   RUJ     QSRSCH   Releasing Uninterlocked Job

                    In JOBDUN, the ITN of the job and object do not match
                    when trying to release the job-object interlock.


   RWE     QSRT10   REDUNDANT WRITE ERROR

                    In I$WRIT, the OUT UUO took the error return.  IO.BKT
                    is not the error when writing redundant queue.


   RZP     GLXMEM   Request for zero pages


   SCE     QSRMDA   Structure Catalog Entry is Missing

                    A known structure in the 'A' matrix was not found  in
                    the structure catalog.


   SDF     OPR      Setup dialog failed


   SFI     ORION    Send failure table inconsistent


   SFO     OPR      Setup failure by OPR




                                    156



   SFP     GLXSCN   Scanning floating point not implemented

                    XCMFLT was called.


   SIO     PLRTAP   Switch units with OPEN Label DDB


   SLT     PLRT10   Set Label Type failed


   SND     PLRTAP   Switch units with non-existent device <device>


   SPF     PLRT10   Set label Params Failed


   SSR     PLRLBP   Strange Skip Record


   STS     OPRPAR   SHARED SWITCH TABLE SIZE OF <table  size>  TOO  SMALL
                    FOR TABLE OF SIZE <table size>


   TBI     PLEASE   S%TXTI block incorrect


   TDE     OPRPAR   TABLE DELETE ERROR


   TFF     GLXKBD   FILOP.  OUT failed to terminal


   TML     GLXTXT   Too many levels of call

                    SAVLVL detected that it was called more than once  to
                    save T%TEXT context.


   TML     LPTSPL   TOO MANY LOG BUFFERS REQUIRED

                    LOGBUF detected that more than ten  pages  are  being
                    used to build LPTSPL's RUN LOG.


   TMS     CDRIVE   Too many setups

                    CDRIVE was told to start more  readers  than  it  can
                    handle.


   TMS     LPTSPL   Too many setups


                                    157



                    LPTSPL was told to start more printers  than  it  can
                    handle.


   TMS     QSRFSS   TOO MANY SECTIONS

                    Corrupt failsoft queue.


   TMS     SPROUT   Too many setups

                    SPROUT was told to start more plotters  than  it  can
                    handle.


   TMT     GLXSCN   Too much text

                    The buffer for the command being parsed  cannot  hold
                    any more text.


   TNO     GLXKBD   Terminal never opened


   TUF     PLRT10   TAPOP.  UUO failed

                    The TAPOP.  UUO failed while trying to get REELID  in
                    I$RDEV.


   UDR     PLRT10   Unknown drive type  DSKCHR  bits  =  <characteristics
                    bits>


   UFI     GLXFIL   Unknown File Information Descriptor

                    F%INFO was called with an invalid argument.


   UIR     GLXIPC   Unexpected IPCF interrupt received

                    C%INTR was called on an IPCF interrupt but PSIFLG  is
                    zero.


   ULS     PLRDSK   Unit parameter list is short


   UMS     SPRINT   Unsupported Recording Mode Specified <mode>


   UMT     GALGEN   Unrecognized Monitor Type


                                    158



   UNR     GLXOTS   Unimplemented routine executed


   URM     SPRINT   Unknown  Recording  Mode  <mode>  Error  in   NEXTJOB
                    Message


   USM     QSRT10   Unique stream missing

                    Calls to either L%FIRST or L%NEXT in UNIFST  returned
                    FALSE.


   VPF     QSRMDA   Volume Pointer Not Found

                    SCNVOL detected that VSL's  VOL  block(s)  links  are
                    inconsistent.


   VSA     QRSMDA   VSL Address is Missing in a VOL

                    There is no pointer to a VSL in a VOL block found  by
                    a  pointer  from a VSL.  VSL and VOL blocks should be
                    doubly linked.


   WBL     QSRT10   WRITING BAD LENGTH

                    The block length to be written in I$WRIT  is  greater
                    than one page (512 words).


   WFO     GLXINT   WTO Function  <function>  Out  of  range  at  address
                    <address>


   WLT     OPR      Wrong length table entry block


   WNF     PULSAR   Waiting TCB not found


   WQV     QSRFSS   Wrong version of master queue file


   ZTE     OPR      Zero entry in syntax table entry block


   ZTS     OPR      Zero tables setup for OPR


   ZWR     GLXMEM   Zero words of memory returned


                                    159
