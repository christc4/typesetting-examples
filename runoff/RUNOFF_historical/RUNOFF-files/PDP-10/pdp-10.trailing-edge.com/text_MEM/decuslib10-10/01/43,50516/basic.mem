University of Pennsylvania Medical School BASIC                           Page 1
Introduction


                                  Introduction




     The University of Pennsylvania Medical School BASIC is a segmented program
derived from DECSYSTEM-10 BASIC, version 17E.  There are currently five
segments.


               BASIC - COMMAND/EDIT (6K/11P)
               BASCOM - COMPILE/LOAD (6K/12P)
               BASXCT - EXECUTE (8K/15P)
               BASDDT - BASIC DEBUGGER (12K/24P)
               BASCRF - BASIC CREF (5K/10P)
               BASERR - ERROR (1K/2P)


     The design goals of this program are to  approach  compatibility  with  the
BASIC-PLUS  language  on  the  PDP-ll,  under  the restriction that all existing
BASIC-10 programs should run unchanged, to add more  computing  power  and  user
convenience  to  BASIC,  and  to  fix  all  known  bugs in version l7E.  Certain
features of PDP-11 BASIC-PLUS, such as those  assuming  a  16-bit  two-character
word, and system functions, were considered too machine-dependent for inclusion,
and record I/O was not implemented due to conflicts with BASIC-10 I/O.  In  most
other  respects  the  functionality of PDP-11 BASIC-PLUS, with some minor syntax
changes to retain compatibility with BASIC-10, has been reproduced.  No existing
BASIC-10 programs are known to have been affected.


     This document describes the enhancements made to BASIC-10, and is  intended
to  be  used  in  conjunction  with and as an appendix to the DECSYSTEM-10 BASIC
Conversational Language Manual, DEC order code DEC-10-LBCMA-A-D.
University of Pennsylvania Medical School BASIC                           Page 2
Syntax Changes


                                 Syntax Changes



A)  Multiple Statements on a Single Line


     More than one statement can be written on a single line  as  long  as  each
statement  (except  the  last)  is  terminated  with  a backslash, \ (SHIFT-L on
teletypes).  Thus only the first statement on a line can (and must) have a  line
number.  For example:

          10 INPUT A,B,C

is a single statement line, while

          20 LET X=X+1 \ PRINT X,Y,Z \ IF Y=2 GOTO 10

is a multiple-statement line containing three statements: a LET, a PRINT, and an
IF-GOTO statement.

     The following restrictions apply to this construction:

           1)  DATA statements and Image statements must be the  only  statement
               in lines in which they appear.

           2)  DEF FN?  statements must be the first statement in lines in which
               they appear.

           3)  REM statements and comments indicated by a single quote  must  be
               the  last  element  in  lines  in  which  they appear.  (i.e. the
               remainder of the line is treated as text for the comment)

           4)  END and FNEND statements must be the last statement in  lines  in
               which they appear.


B)  A Single Statement on Multiple Lines.


     A single statement can be continued on successive lines of the program.  To
indicate  that  a  statement is to be continued, the line is terminated with the
LINE FEED key instead of the RETURN  key.   The  LINE  FEED  causes  a  carriage
return/line feed operation on the terminal and the line to be continued does not
contain a line number.  For example:

          10 LET W7=(W-X4*3)*(Z-A/
          (A-B)-17)

where the first line was terminated with the LINE FEED key is equivalent to:

          10 LET W7=(W-X4*3)*(Z-A/(A-B)-17)

Note that the LINE FEED key does not cause a printed character to appear on  the
University of Pennsylvania Medical School BASIC                           Page 3
Syntax Changes


page.   Programs  using this construction may not be edited by the line editors,
LINED or SOS.


C)  Line Length


     The maximum length of a  BASIC  program  line  has  been  expanded  to  255
characters.  The maximum length of a string used or generated by a BASIC program
remains 132 characters.
University of Pennsylvania Medical School BASIC                           Page 4
BASIC Statements


                                BASIC Statements



A)  OPEN


     The OPEN statement associates a file on disk with an  I/O  channel  number.
BASIC  permits  up  to  nine  files  to be open at a given time, and, therefore,
permits internal file designators to be integers  between  one  and  nine.   The
general form of the open statement is as follows:

          <ln> OPEN <string> (FOR INPUT) AS FILE <type> <expression> (TO PLOT)
                            (FOR OUTPUT)

The string field is a character string constant,  variable  or  expression  that
contains  the external file specification of the file to be opened.  The type is
either # for sequential access or : for random access, and must be present.  The
expression must have an integer value between one and nine, corresponding to the
internal channel number on which the file is being opened.

     There are three distinct forms for the OPEN statement:

               OPEN <string> FOR OUTPUT
               OPEN <string> FOR INPUT
               OPEN <string>

           A)  An OPEN FOR INPUT statement will cause an automatic RESTORE to be
               done  on  the  file.  If the file does not exist at this time, an
               error message will be given.
           B)  An OPEN FOR OUTPUT statement will cause an automatic  SCRATCH  to
               be done on the file.  If the file exists at this time, it will be
               deleted.
           C)  An OPEN statement without an INPUT  or  OUTPUT  designation  will
               perform  no  other function except to associate the file with the
               specified I/O channel number.


     The OPEN statement does not control whether the program attempts to perform
input  or  output on the file or whether read and/or write access to the file is
granted; these privileges are controlled by the file protection code.


     For an explanation  of  the  OPEN  statement  argument  TO  PLOT,  see  the
description of the BASIC Plotting Package below.


     In the OPEN statement, as well as in the FILE and FILES statements, and any
edit-level  commands  where it is appropriate, project-programmer numbers can be
specified for files in the usual format - [project no.,programmer no.].
University of Pennsylvania Medical School BASIC                           Page 5
BASIC Statements


B)  CLOSE


     The CLOSE statement is used to terminate I/O between the BASIC program  and
the  disk  file.  Once a file has been closed, it can be reopened for reading or
writing on any internal file designator.  All files will automatically be closed
at  the  end of program execution or upon execution of the CHAIN statement.  The
format of the CLOSE statement is as follows:

          <ln> CLOSE <expression> (,<expression>,...)

The expression indicated has the same meaning as  the  expression  in  the  OPEN
statement  and  indicates the internal channel number of the file to close.  Any
number of files can be closed with a single CLOSE statement; if  more  than  one
file is to be closed, the expressions are separated by commas.


C)  ON-GOSUB


     The ON-GOSUB statement is used to transfer control conditionally to one  of
several  subroutines  or  to  one  of  several  entry  points  in  one (or more)
subroutines.  The statement has the following form:

          <ln> ON <expression> GOSUB <list of line numbers>

Depending on the integer value  (truncated  if  necessary)  of  the  expression,
control is transferred to the subroutine which begins at one of the line numbers
listed.  Encountering the RETURN statement after control is transferred in  this
way  allows  the  program to resume execution at the line following the ON-GOSUB
line.


D)  INPUT


     Messages to be printed at execution time can now  be  inserted  within  the
INPUT statement itself.  This message is set off by double quotes from the other
arguments of the INPUT statement and must be the first element,  if  used.   For
example:

          10 INPUT "YOUR AGE IS";A

is equivalent to:

          10 PRINT "YOUR AGE IS";
          20 INPUT A

     The use of the comma or semicolon character (or no character) to separate a
character string to be printed from the input variable names is analogous to the
PRINT statement.

University of Pennsylvania Medical School BASIC                           Page 6
BASIC Statements


     Strings may appear anywhere in INPUT statements, however each time a string
appears the data elements following it must be entered at the beginning of a new
line.  The character left-arrow or underline, _, may optionally follow a  string
and  its  format  character, if present, and has the effect of suppressing the ?
normally output by BASIC.  For example:

          10 INPUT "TYPE X AND Y : "_X,Y


     The INPUT LINE statement followed by a single string argument can  be  used
to  put  a  complete line of input, including blanks, tabs, and commas, into the
string argument of the statement:

          10 INPUT LINE A$


E)  User-Defined String Functions


     Character string functions can be  written  in  the  same  way  as  numeric
functions.   The  function  is  indicated  as  being  a string function by the $
character after the function name.


     User-defined string functions return character string values, although both
numeric  and  string  values  can  be  used  as  arguments to the function.  For
example, the following multiple-line function returns  the  string  which  comes
first in alphabetical order:

          10 DEF FNF$(A$,B$)
          20 FNF$=A$
          30 IF A$>B$ THEN FNF$=B$
          40 FNEND


     Numbers cannot be used  as  arguments  in  a  function  where  strings  are
expected or vice versa.


F)  Statement Modifiers


     To increase the flexibility and  ease  of  expression  within  BASIC,  five
statement  modifiers  are  available (IF, UNLESS, FOR, WHILE, and UNTIL).  These
modifiers are appended to program statements to indicate  conditional  execution
of the statements or the creation of implied FOR loops.
University of Pennsylvania Medical School BASIC                           Page 7
BASIC Statements


1)  The IF Statement Modifier

The form:

          <ln> <statement> IF <condition>

is analogous to the form:

          <ln> IF <condition> THEN <statement>

For example:

          10 PRINT X IF X <>0

is the same as:

          10 IF X <> 0 THEN PRINT X

When a statement modifier appears to the right  of  an  IF-THEN  statement,  the
modifier  operates  only on the THEN clause or the ELSE clause, depending on its
placement to the left or right of ELSE.  It is not possible to include  an  ELSE
clause when using the modifier form of IF.  Several modifiers may be used within
the same statements.  For example:

          70 PRINT X(I,J) IF I=J IF X(I,J) <> 0

which will print the value of X(I,J) only if the value X(I,J) is non-zero and if
I  equals  J.  Whenever there is more than one modifier on a line, the modifiers
are executed in a right-to-left order.  That is, the rightmost one  is  executed
first, and the leftmost one is executed last.


2)  The UNLESS Statement Modifier

The form:

          <ln> <statement> UNLESS <condition>

causes the statement to be  executed  only  if  the  condition  is  false.   For
example, the following statements are all equivalent:

          10 PRINT A UNLESS A = 0
          20 PRINT A IF NOT A=0
          30 IF NOT A=0 THEN PRINT A
          40 IF A <> 0 THEN PRINT A

This particular form simplifies the negation of a logical condition.
University of Pennsylvania Medical School BASIC                           Page 8
BASIC Statements


3)  The FOR Statement Modifier

The form:

          <ln> <statement> FOR <variable>=<expr.>TO<expr.>(STEP<expr.>)

or the form:

          <ln> <statement> FOR <variable>=<expr.>(STEP<expr.>)(WHILE<expr.>)
                                                              (UNTIL<expr.>)

can be used to imply a FOR loop on a single line.  For example  (using  none  of
the optional elements):

          10 PRINT I, SQR(I) FOR I = 1 TO 10

This statement is equivalent to the following FOR-NEXT loop:

          10 FOR I = 1 TO 10
          20 PRINT I,SQR(I)
          30 NEXT I

In cases where the FOR-NEXT loop is extremely simple, the necessity for separate
FOR  and  NEXT statements is eliminated.  Notice that this implied FOR loop will
only modify (and hence execute iteratively) one statement in the  program.   Any
number of implied FOR loops can be used in a single program.

As is the case with all modifiers, a FOR modifier in an  IF  statement  operates
only  on  the  THEN or ELSE clause with which it is associated, and never on the
the conditional expression to the left of the THEN.  Thus, if it was desired  to
print  all  non-zero  values in a vector X(100), the following program would not
operate properly:

          10 DIM X(100)
          20 READ X(I) FOR I = 1 TO 100
          30 IF X(I)<>0 THEN PRINT I,X(I) FOR I = 1 TO 100

since the implied FOR loop at line 30 applies only to the THEN PRINT . . .  part
of  the statement, and not to the IF . . . part.  The first value of X tested is
X(100), since I remained at 100 from  statement  20.   To  achieve  the  desired
effect, it is only necessary to code line 30, not as an IF statement, but rather
as a PRINT statement with nested modifiers; for example:

          30 PRINT I,X(I) IF X(I)<> 0 FOR I = 1 TO 100

When expressed in the latter form, the nested modifier rule  takes  effect,  all
the values of X(I) are tested and printed as appropriate.
University of Pennsylvania Medical School BASIC                           Page 9
BASIC Statements


4)  The WHILE Statement Modifier

The form:

          <ln> <statement> WHILE <condition>

is used to repeatedly execute the statement while  the  specified  condition  is
true.  For example:

          10 LET X=X*X WHILE X<1E6

is equivalent to:

          10 IF X>=1E6 GO TO 30
          20 LET X=X*X

The WHILE modifier operates usefully only in iterative loops where  the  logical
loop  structure modifies the values which determine loop termination.  This is a
significant  departure  from  FOR  loops,  in  which  the  control  variable  is
automatically  iterated;  a  WHILE  statement  need  not  have  a formal control
variable.  The following statements never terminate properly:

          10 X=X+1 WHILE I<1000
          20 PRINT I,A(I) WHILE A(I)<>0

In both cases, the program fails to alter the values which are used to determine
when  the loop is done.  A successful application of the WHILE modifier is shown
below:

          10' TEST OF SQUARE ROOT ROUTINE
          20 X=X+1 WHILE X=SQR(X*X) AND X<1.E6
          30 PRINT X


5)  The UNTIL Statement Modifier

The form:

          <ln> <statement> UNTIL <condition>

is used to execute the statement repeatedly until the  condition  becomes  true;
which is to say, while the condition is false.  For example:

          10 X=X+1 UNTIL X<>SQR(X*X) OR X>=1.E6

is the same as

          10 X=X+1
          20 IF X=SQR(X*X) AND X<1.E6 THEN 10
University of Pennsylvania Medical School BASIC                          Page 10
BASIC Statements


6)  Multiple Statement Modifiers


     More than one modifier  can  be  used  in  a  single  statement.   Multiple
modifiers are processed form right to left.  For example:

          10 LET A=B IF A>0 IF B>0

which is equivalent to:

          10 IF B>0 THEN IF A>0 THEN A=B

or

          10 IF B>0 AND A>0 THEN LET A=B

A matrix (M by N) can be read one row at a time as follows:

          50 READ A(I,J) FOR J=1 TO M FOR I = 1 TO N


G)  Relational and Logical Expressions

     Variables and  constants  may  be  combined  with  relational  and  logical
operators  in  addition  to  arithmetic  operators  to form expressions.  Unless
otherwise stated in the documentation, logical and relational expressions may be
substituted  wherever  an  arithmetic  expression  is  legal.  In the absence of
parentheses, the following precedence of operators will be followed:
          1)  exponentiation
          2)  unary minus
          3)  multiplication and division
          4)  addition and subtraction
          5)  relational operators 
              <,<=,>,>=,=,<>
          6)  NOT
          7)  AND,OR(IOR),XOR,IMP,EQV


The logical operators are as follows:

University of Pennsylvania Medical School BASIC                          Page 11
BASIC Statements


     Operator  Example   Meaning

     NOT       NOT A     The logical negative of A.
                         If A is true, NOT A is false.
     AND       A AND B   The logical product of A and B.
                         A AND B is true only if both
                         A and B are true, otherwise, false.
     OR        A OR B    The logical sum of A and B.
     or IOR              A OR B has the value true if either
                         A or B is true, otherwise, false.
     XOR       A XOR B   The logical exclusive or of A and B.
                         A XOR B is true if either A or B is
                         true but not both, otherwise, false.
     IMP       A IMP B   The logical implication of A and B.
                         A IMP B is false if and only if
                         A is true and B is false.
     EQV       A EQV B   A is logically equivalent to B.
                         A EQV B has the value true if
                         A and B are both true or both false.


     There is one special restriction on  the  use  of  logical  expressions:  a
construct  of the form F OR <expression> may not appear in a context, e.g. as an
element of a PRINT list, where a FOR modifier would be  valid.   Furthermore  it
should  be  noted  that  the  ambiguous  expression  PI OR X  is  given the more
reasonable interpretation P IOR X.


H)  Two-dimensional String Arrays


     Two-dimensional string arrays are now permitted in BASIC.  They are handled
in  the  same manner as one-dimensional string arrays.  All string functions and
operations are legal.


I)  Virtual Data Storage


     Some applications may require more core memory for  data  storage  than  is
economically  feasible.   BASIC  addresses this need with a simple random-access
file system called virtual core.

     The BASIC virtual core system provides a mechanism for  the  programmer  to
specify  that  a  particular data array is not to be stored in the computer core
memory, but within the PDP-10 disk file system instead.   Data  stored  in  disk
files  external  to  the  user  program  remain,  even after the user leaves his
terminal, and can be retrieved by name at a later  session.   Items  within  the
file are individually addressable, as are items within core arrays.  In fact, it
is  the  similar  way  in  which  data  are  treated  in  both  core  and  these
random-access files which leads to the name virtual core.
University of Pennsylvania Medical School BASIC                          Page 12
BASIC Statements


     With virtual data storage, the user can reference any  element  of  one  or
more  arrays  within the file, no matter where in the file that element resides.
This random access of data allows the user  non-sequential  referencing  of  the
data  for  use  in  any  BASIC statement.  The virtual core arrays are read into
memory automatically by the system.

1)  Virtual Core DIM Statement

     In order for an array of data to exist in virtual core, it must be declared
in  a  special  form  of  the  DIM  statement.  This special DIM statement is as
follows:

          <ln> DIM#<integer constant>,<list>

where the integer constant is between 1 and 9 and corresponds  to  the  internal
file  designator on which the program has opened a disk file.  The variable list
appears as it would in a DIM statement for a core-resident array.  Thus,  a  100
by 100 matrix could be defined as:

          10 DIM #1, A(100,100)

Numbers and strings can be stored in virtual core arrays.  More than  one  array
can be specified in one virtual core field.  For example:

          25 DIM #1,A(1000), B(100,100), C$(2500)

allocates space for 1001 numbers for A, 10201 numbers for B, and 2501  character
strings  (each  16  characters  long)  for  C$.   However, if a virtual array is
defined in this fashion, future references should always dimension the arrays to
the same size.

2)  Virtual Core String Storage

     One of the few differences in data handling between core  and  disk  arrays
occurs  in the storage of strings within string arrays in virtual core.  Strings
in the computer memory are of variable  length  from  0  to  a  maximum  of  132
characters.   Strings  in  virtual  core  arrays  are  of  fixed  length  from 0
characters to a maximum of 128 characters.  This fixed length can be defined  by
the  program.  The system forces the maximum length to be a power of 2; i.e. one
of the following lengths:

          2,4,8,16,32,64,128

Each element in the  virtual  core  string  need  not  use  the  maximum  length
available,  even  though  space  is  reserved for each element to be the maximum
size.  If the user indicates other than one of the values above, he receives the
next higher size.  thus:

          10 DIM #1,X$(10)=65

is equivalent to:

          10 DIM #1,X$(10)=128
University of Pennsylvania Medical School BASIC                          Page 13
BASIC Statements


If no length is specified, a default length of 16 characters  is  assumed.   The
maximum  length of virtual core strings is specified as an expression in the DIM
statement, using the form:

<ln> DIM #<integer const.>,<string(dim(s))>=<integer const.>

For example:

          15 DIM #1,A$(100)=32,B$(100)=4,C$(100)

where A$ consists of 101 strings of 32 characters each, maximum, B$ consists  of
101  strings of 4 characters each, maximum, and C$ consists of 101 strings of 16
characters each, maximum.

     If a length attribute is given in a DIM statement  for  an  in-core  string
array, an error will be given.


3)  Opening a Virtual Core File


     In order for the user to reference his virtual core  file,  he  must  first
associate  a disk file (by name) with an internal channel designator from 1 to 9
(which is then used in the virtual DIM declaration).  This is done with an OPEN,
OPEN FOR INPUT, or OPEN FOR OUTPUT statement:

     <ln> OPEN <string> (FOR INPUT ) AS FILE @<expression>
                        (FOR OUTPUT)

where the string is the name of a disk file  and  the  expression  specifies  an
internal file designator.  The @ sign specifies the type for a virtual core disk
file.


4)  Virtual Core Programming Convention


     Recoverable errors occur when using virtual core if the user  program  does
any of the following:

          1)  References a virtual core array without first
              opening the file.
          2)  Exceeds virtual core, that is defines an array
              that is greater than the disk storage quota
              allocated to them.
          3)  Attempts to read or write to the virtual array
              disk file.
University of Pennsylvania Medical School BASIC                          Page 14
BASIC Statements


5)  Using the Virtual Array Facility


     The BASIC virtual array facility provides the means for a BASIC program  to
operate  on data structures that are too large to be accommodated in core at one
time.  To accomplish this, BASIC uses the disk file system for storage  of  data
arrays, and only maintains portions of these files in core at any given time.

     All references to virtual arrays are ultimately located via file  addresses
relative  to  the  start  of the file.  No symbolic information concerning array
names, dimensions, or data types is stored within  the  file.   Thus,  different
programs  may  use different array names to refer to the data contained within a
single virtual array file.  The user must be cautious in such operations,  since
it  is  his  (or  her)  responsibility to ensure that all programs referencing a
given set of virtual arrays are referencing the same data.

     Within a single BASIC program, it is possible to open the same virtual core
array  file  twice  on the same channel for the purpose of reallocating the data
within the file.  For example:

          145 OPEN "DATA" FOR INPUT AS FILE @1
          150 DIM#1, A$(10)=4
          155 DIM#1, B$(4)=16

The program now has access to the file DATA through both the array  A$  and  the
array  B$.  Each element of B$ contains four elements of A$ (B$(0) is equivalent
to the elements A$(0) through A$(3), etc.).  Note that  the  file  is  open  for
input  only  and  that  the  two DIM# statements reference that file on a single
channel number (#1 in this case).

          Note also that the two statements

               75 DIM#1,A(10)
               80 DIM#1,B(10)

          are not equivalent to the statement;

               90 DIM#1,A(10),B(10)

In the first case the arrays A and B are equivalent to each other and constitute
the  first array in the file open on channel 1.  In the second case the arrays A
and B are defined as both existing sequentially in the file open on channel 1.

     User programs may define two-dimensional virtual arrays as well  as  singly
dimensioned  ones.   Two-dimensional  arrays  are  stored  on disk (and in core)
linearly, row-by-row.  Thus, in the case of a matrix X(1,2), the  array  appears
physically as:
                              X(0,0)  lowest address
                              X(0,1)
                              X(0,2)
                              X(1,0)
                              X(1,1)
                              X(1,2)  highest address
University of Pennsylvania Medical School BASIC                          Page 15
BASIC Statements


The user should keep in mind that in BASIC, as in most BASICs, array  subscripts
begin with 0, not 1.  An array with dimension n, or (n,m) actually contains n+1,
or [(n+1)*(m+1)] elements.

     If a virtual  array  is  to  be  referenced  sequentially,  it  is  usually
preferable  to  reference  the  rows, rather than the columns, in sequence since
there will be fewer disk accesses.

     Virtual core arrays are stored on disk in blocks, each of which may contain
maximally  128  pieces  of numeric data or 512 characters of string information.
It is permissible to have two (or more) arrays sharing the same file.  That  is,
the following DIM# statement is perfectly legal:

          100 DIM#1,Z(1000),B(999),C(1000)

The array B begins immediately after the 1001st element of Z and C(0) is  placed
immediately  after  B(999).  There is, however, an exception to this rule.  When
the type of the array changes (from numeric to string or string  to  numeric)  a
new  block  will  be  started.  Also, if one string array follows another, a new
block will be started if an element of it would  otherwise  be  split  across  a
block boundary.  Consider the following case:

          10 DIM#1, A$(24)=16,B$(100)=64

The first 400 characters (25*16) are allocated to A$.  If the array B$  were  to
begin  immediately  after  A$,  one  of the elements of B$ (B$(1)) would cross a
block boundary (i.e. after B$(0) is stored, there are only 48 characters left in
the  block).   Hence,  B$  begins  at  the start of the second block in the file
rather than immediately after A$.

     The dimensions indicated in a DIM# statement set maximum  allowable  values
for subscripts, but do not define the size of the file set up.  Instead the file
is expanded as elements of the arrays are used or  changed.   Thus  a  user  may
specify dimensions as great as may ever be needed without inefficiency.

     NOTE - No matrix functions (ZER, INV, etc.)  are  implemented  for  virtual
arrays as of this version.  They may, however, be implemented at a later date.

J)  ON ERROR GOTO Statement


     Certain errors can be detected by BASIC while  executing  a  user  program.
These  errors  fall into two broad areas: computational errors (such as division
by 0) and I/O errors (such as attempting to read a non-existent file).  Normally
the  occurrence  of  any  of these errors causes termination of the user program
execution and the printing of a diagnostic message.

     Some applications may require the continued execution  of  a  user  program
after  an  error  occurs.  In these situations, the user can execute an ON ERROR
GOTO statement within his program.  This  statement  tells  BASIC  that  a  user
subroutine  exists,  beginning  at the specified line number, which will analyze
any I/O or computational error encountered in the program and  possibly  attempt
to recover from that error.
University of Pennsylvania Medical School BASIC                          Page 16
BASIC Statements


     The format of the ON ERROR GOTO statement is as follows:

     <ln> ON ERROR GOTO  (<line number>)

This statement is placed in the program prior to any executable statements  with
which  the  error  handling routine deals.  If an error does occur, user program
execution is interrupted and the user-written error subroutine is started at the
line  number indicated.  The variable ERR, available to the program, assumes one
of the values listed below.


                            User Recoverable Errors


     (*) indicates that program execution continues, following printing  of  the
error  message,  if  an  ON  ERROR  GOTO  statement  is not present.  Otherwise,
execution terminates and the system prints the READY message.


1       internal error within BASIC or monitor error
2       illegal filename format
3       file opened on more than one channel
4       cannot enter file for output
5       cannot lookup file for input
6       out of static list space for string manipulations
7       string record or formula length < 1 or > 132
8       end-of-file
9       attempt to reference a file that was never established
10      broad class of input/output errors
18      SET argument is out of bounds
27      subroutine or function calls itself
28      line number is out of bounds
31      RETURN before GOSUB
32      mixed random access and sequential
35      output item too long for list
36      cannot erase file on specified channel
37      file not found by RESTORE command
38      input line too long
41      mixed strings and numbers
42      no fields in image
46      illegal channel number
*50     input data not in correct form
*53     attempt to take log of zero or negative number
*54     attempt to take square root of negative number
*56     singular matrix inverted
57      out of data
58      ON evaluated out of range
60      no more core available
*61     division by zero
70      attempt to output a number to a string field or vice versa
71      output line more than 132 characters
72      no character in image
73      more than 132 characters in image
74      exponent requested for * or $ field
University of Pennsylvania Medical School BASIC                          Page 17
BASIC Statements


75      attempt to output negative number to an * or $ field
76      MARGIN is too small
77      MARGIN is out of bounds
78      PAGE length is out of bounds
79      I/O to file opened as a plot file
80      attempt to write a line number > 99999
81      impossible vector length
82      illegal character seen on input
83      string size exceeded for virtual array
84      DIMENSION error
85      CHR$ argument out of bounds
86      INSTR argument out of bounds
87      LEFT$ argument out of bounds
88      MID$ argument out of bounds
89      RIGHT$ argument out of bounds
90      SPACE$ argument out of bounds
91      VAL argument not in correct form
*92     arithmetic overflow
*93     arithmetic underflow
*94     too many elements in MAT INPUT
*95     over or underflow occurred during MAT INV
*96     magnitude of SIN or COS arg too large to be significant
*97     TAN of PI/2 or COTAN or zero
*98     underflow in integer exp.
*99     overflow in integer exp.
*100    underflow in floating exp.
*101    overflow in floating exp.
*102    zero to a negative power
*103    negative value raised to fractional power

     When an error is encountered in a user program, BASIC checks to see if  the
program has executed the ON ERROR GOTO statement.  If this is not the case, then
a message is printed at the user's terminal and the programs  proceeds  (if  the
error  does  not  cause execution to terminate).  If the ON ERROR GOTO statement
was executed previously, then execution continues at the specified  line  number
where  the program can test the variables ERR and ERL to discover precisely what
error occurred and decide what action is to be taken.

     There is one error condition that causes program termination regardless  of
the execution of ON ERROR GOTO with the message: Too many FN's, GOSUB's or error
traps.  This is most often caused by incorrect use  or  absence  of  the  RESUME
statement.


K)  RESUME Statement


     After the problem is corrected (if this is both possible and desired by the
programmer),  execution  of  the  user program can be resumed through use of the
RESUME statement (which is placed at the end of the error handling routine, much
like  a  return  statement in a normal subroutine).  The RESUME statement causes
the program statement that originally caused the error  to  be  reexecuted.   If
execution is to be restarted at some other point within the program (as might be
the case for a non-correctable problem), the new line number can be specified in
University of Pennsylvania Medical School BASIC                          Page 18
BASIC Statements


the RESUME statement at the end of the error handling routine.

     The format of the RESUME statement is as follows:

          <ln> RESUME (<line number>)

For example:

          2000 RESUME
          2001 RESUME 100

The line 2000 restarts the user program at the  line  in  which  the  error  was
detected, and is equivalent to the statement:

          2000 RESUME 0

     A RESUME or RESUME 0 statement in an error handling routine passes  control
to  the  line containing the statement which caused the error.  If the statement
which caused the error is on a multiple statement line, control is passed to the
first  statement  on  the  line.   Therefore,  the first statement on a multiple
statement line with error handling should be the statement which  generates  the
trappable error.  Such placement of the statement prevents logic errors.

     Line 2001 above restarts the user program at line 100 (which can be used to
print some terminal message for the particular operation).  The RESUME statement
with a line number argument should otherwise be used  sparingly,  since  it  can
lead to a variety of subtle error conditions.

     A RESUME statement will dismiss the error condition and  should  always  be
included  in  the error handling routine.  A GOTO statement should never be used
to exit from the error routine.


L)  Disabling The User Error Handling Routine


     If there are portions of the user program in which any errors detected  are
to  be processed by the system and not by the user program, the error subroutine
can be disabled by executing the following statement:

          <ln> ON ERROR GOTO 0

which returns control of error handling to the system.  An equivalent form is:

          <ln> ON ERROR GOTO 

in which case line 0 is assumed.  Executing this statement causes the system  to
treat errors as it would if no ON ERROR GOTO <ln> had ever been executed.

     Generally, the error handling subroutine should detect and properly  handle
only  a few different errors; it is useful to have the BASIC system handle other
errors, if they occur.  For this reason,  BASIC  allows  the  ON  ERROR  GOTO  0
statement  to be executed within the error subroutine itself.  Special treatment
is accorded this case, in that the disabling  occurs  retroactively;  the  error
University of Pennsylvania Medical School BASIC                          Page 19
BASIC Statements


which  caused  entry  to  the  error  subroutine  is then reported and a message
printed as though no ON ERROR GOTO <ln> statement had been in effect.

     As an example of this feature, suppose a user wished  only  to  handle  the
case where a file is expected to be on disk and is not found for input.

     The program below requests the file name and attempts to read from it.

          10 INPUT F$
          20 ON ERROR GOTO 100 \ OPEN F$ FOR INPUT AS FILE #1
          30 READ #1,I,J
          40 .
          50 .
             .
             .
          100 'THIS IS THE ERROR HANDLING ROUTINE
          110 IF ERR <> 37 THEN ON ERROR GOTO 0      'FILE NOT FOUND ERROR ONLY
          120 PRINT F$;" WAS NOT FOUND, IS THERE ANOTHER";
          130 INPUT A$
          140 IF A$ = "N" THEN STOP
          150 INPUT "NEW FILE NAME";F$
          160 RESUME
          170 END

     In this example, if the call to the error subroutine  was  caused  by  some
error  other  than  the  file not found error, the program would exit via the ON
ERROR GOTO 0 in line 110.  This permits  an  appropriate  error  message  to  be
printed on the user's terminal.


M)  The ERL Variable


     It is sometimes useful to be able to recognize the line number at which  an
error occurred.  Following an error detection, the integer variable ERL contains
the line number of the error.

     ERL would be  used,  for  example,  to  indicate  which  of  several  INPUT
statements caused an error.

     The ERL variable should not be tested  against  a  constant  for  equality,
since  resequencing  the program could change the number of the line causing the
error.  Instead the LL function (see below) should be used.


N)  The PAUSE and PLOT Statements


     The PAUSE and PLOT statements  are  used  exclusively  in  connection  with
graphical output, see below under BASIC Plotting Package.
University of Pennsylvania Medical School BASIC                          Page 20
BASIC Statements


O)  The FOR Statement


     The FOR  statement  may  be  terminated  by  WHILE  <expression>  or  UNTIL
<expression> instead of TO <expression>.


P)  The WHILE and UNTIL Statements


     Loops may be initiated  by  the  statements  WHILE  <expression>  or  UNTIL
<expression>.   Such loops operate exactly as FOR loops, except that there is no
variable incremented for each execution of the loop.  They are terminated by the
NEXT statement with no argument.
University of Pennsylvania Medical School BASIC                          Page 21
New Functions


                                 New Functions




     The following new functions have been added to the list  of  BASIC  Library
routines.


A)  TIME$

          Returns an eight character string representing the 24-hour time of day
     as HH:MM:SS.

B)  DATE$

          Returns a nine character  string  representing  the  current  date  as
     DD-MON-YY.

C)  ASCII(S$)

          Generates the ASCII value of the  first  character  contained  in  the
     string S$.  i.e. ASCII("XAB")=88.

D)  FIX(N)

          Returns  the  truncated  value   of   X   (SGN(X)*INT(ABS(X)).    i.e.
     FIX(-.5)=0.

E)  LINE

          Returns the current line number of the statement being executed or the
     line number of the statement last executed when ^C (control-C) interruption
     occurred.  (useful in BASDDT)

F)  LL(<constant>)

          Returns the value of its argument, which must be an ambiguous constant
     equal  to  a  line number in the program.  This argument is recognised as a
     line number by the RESEQUENCE command.

G)  NUM$(N)

          Indicates a string of numeric characters representing the value  of  N
     as  it would be output by a PRINT statement.  NUM$(N)=(SPACE)N(SPACE) FOR N
     >= 0 NUM$(N)=-N(SPACE) FOR N < 0
University of Pennsylvania Medical School BASIC                          Page 22
New Functions


H)  PI

          Constant value of PI (3.1415927)

I)  POS(N)

          Returns current position on the output line.  N  is  the  I/O  channel
     number.  POS(0) returns the value for the user's teletype.

J)  CRT(I%)

          If I% is non-zero, the ASCII characters with decimal values 10-13  are
     legal  within  strings, if it is zero, they are not.  The value returned by
     the CRT function is the argument with which it was last called, or zero  if
     it has not been called before.  Note that a CRT(1%) must be executed before
     using  the  BASIC  plotting  package  (see  below)  to  allow  the  control
     characters required for screen functions on the Tektronix-4010 to be sent.

K)  DAY$

          Returns a string containing the day of the week, spelled out in full.

L)  ECHO(I%)

          If I% is non-zero, the teletype echo is turned off, if it is zero, the
     echo  is turned on again.  The value returned is either 1% or 0%, according
     to whether the echo had been turned off or on respectively by the  previous
     call.   The  echo is always turned on again when the program ends execution
     or is aborted.

M)  SLEEP(I%)

          Causes the program to suspend execution for I%  seconds,  or  until  a
     line is typed on the terminal.  If the suspension is ended by a time-out, a
     value of 0% is returned, if by  terminal  input,  -1%  is  returned.   This
     function can be used to check if anything has been typed, using an argument
     of 0%, or, for example, to prompt students using an educational program.
University of Pennsylvania Medical School BASIC                          Page 23
Edit Level Commands


                              Edit Level Commands



A)  SAVFIL(NL)


     These commands, followed by an optional  file  name,  create  compact  core
images  of  BASIC  programs  on the disk.  The source code is deleted from these
files, so for large programs, they occupy substantially  less  memory  than  the
code  produced  by  the RUN or RUNNH commands.  Since they are already compiled,
their execution does not carry the overhead of compilation for  each  run.   The
SAVFILNL  command differs from the SAVFIL command in that the line number tables
are also deleted.  This results in a further saving of memory at the expense  of
deleting  line numbers from any execution-time error message.  The files created
by these commands are given the name specified, if any, or else the name of  the
current program.  They are always given the extension .SAV, thus eliminating any
conflict with .BAS files.  Their extension must be given  explicitly  to  delete
them with the UNSAVE command.

     Since line number information is deleted from .SAV  files  created  by  the
SAVFILNL  command  the statements RESUME and ON ERROR GOTO without arguments and
CHAIN with a line number argument are illegal in them.


B)  RUNSAV


     This command, followed by a file name, runs the  .SAV  file  of  that  name
created  by  the SAVFIL(NL) command.  It is not possible to start the program at
other than the first line.  The CHAIN statement with a line number  argument  is
regarded  as  a  syntax  error  in  creating  a  .SAV file.  The CHAIN statement
executed from a .SAV file requires a .SAV file to be chained.  It  is  therefore
unnecessary  to  specify  the  file extension.  Since the source code is deleted
from .SAV files, a new session is begun after the  execution  of  any  of  these
commands.   The  .SAV files produced are normal .SAV files which can be run from
the Monitor by use of the RUN command.  However, return is to the Monitor  level
instead  of BASIC Edit level.  With new versions of BASIC, .SAV files may become
obsolete.  If this is the case, a warning message to resave soon will  be  given
when the .SAV file is run.  Please heed the warning.


C)  RUNFSAV


     This command is similar to the RUNSAV command except that the .SAV file  is
assumed  to  be  created  by the Monitor SAVE command.  Exit from the program is
always to Monitor level.
University of Pennsylvania Medical School BASIC                          Page 24
Edit Level Commands


D)  DDT(NH)


     This command calls for the BASIC debugger to be included  as  part  of  the
execution routine along with your BASIC program.  Refer to the section on BASDDT
for use of the debugger.


E)  GENERATE (NN)(,(MM))(,(LL))


     This command will  generate  line  sequence  numbers  for  input  from  the
teletype.   NN  is  the  starting value, MM is the maximum number, and LL is the
increment.  If NN or LL is omitted, they will default to 10.  If MM is  omitted,
99999  will  be the maximum.  Therefore, if no arguments are given, they will be
10,99999,10.  If NN is greater than LL, only one line sequence  number  will  be
generated.   To  prematurely  end  the  generation of line sequence numbers, the
ALTmode or ESCape character (echoed as $) is typed on the  line  followed  by  a
RETURN.   Normally  the  GENERATE  command  automatically inserts a blank at the
beginning of each line.  To suppress this feature the GENERATE NO BLANK  or  GEN
NOB command can be substituted.  For example:

          READY
          GEN 10,,40
          10 LET A=1
          20 LET B=23
          30 LET C=PI/2
          40 FOR J = 1 TO 10
          READY
          GEN 60
          60 D=SIN(J*C)
          70 PRINT D
          80 NEXT J
          90$
          READY


F)  SYNTAX


     This command will cause each line  of  input  to  be  automatically  syntax
checked  upon  being  entered.   It  will not check for logic errors, but merely
guarantee that the statement entered is grammatically correct.   SYNTAX  is  the
default  state  upon  entering  BASIC.   The  statement will be entered into the
source text regardless of the outcome  of  the  syntax  check.   SYNTAX  may  be
combined  with  GENERATE,  however,  a  new  line sequence number will always be
generated.  For example:

University of Pennsylvania Medical School BASIC                          Page 25
Edit Level Commands


          READY
          10 LET K=1
          20 FOR J = 1 TO 1O
          ? ILLEGAL "FOR" USE       (An O was typed instead of a 0)
          20 FOR J=1 TO 10          (User corrects the syntax error)
          30 LET K=K+J^2
          40 NEXT K                 (Notice that this is a logical
                                    error and cannot be detected)
          50 PRINT K
          60 END
          RUNNH

          ? NEXT WITHOUT FOR IN LINE 40

          ? FOR WITHOUT NEXT IN LINE 20

          READY
          40 NEST J                 (NEXT was misspelled)
          ? ILLEGAL STATEMENT KEYWORD
          40 NEXT J
          RUNNH


           386


          READY


G)  NOSYNTAX


     This command turns off the automatic syntax checking of the input line.  It
must be used when creating a BASIC data file from Edit level.


H)  CATALOG


     Two switches have been added to the CATALOG command, /FAST and /PROTECTION.
/FAST will give the directory with four filename.ext per line.  /PROTECTION will
print the protection code following the file to which it applies.  The  switches
may be abbreviated to as few as one character.  For example:

University of Pennsylvania Medical School BASIC                          Page 26
Edit Level Commands


          READY
          CATALOG/FAS


          TEST  .BAS      TEST1 .BAS      STAR  .TRK      DATA  .BAS
          SWITCH.INI

          READY
          CAT/PROTECTION


          TEST  .BAS<155>
          TEST1 .BAS<155>
          STAR  .TRK<157>
          DATA  .BAS<055>
          SWITCH.INI<055>


          READY


I)  CREF


     The CREF command gives a cross reference listing on the line printer.   The
file will be queued to the printer after the CREF command is given.


     There is one switch implemented for the CREF command.  /TTY will cause  the
cross reference listing to come out on the user's terminal.


J) PPN Specification


     In  all  commands  and  statements   referencing   files,   except   QUEUE,
project-programmer  numbers  can  be specified in the usual format following the
file name - [project no.,programmer no.].
University of Pennsylvania Medical School BASIC                          Page 27
BASIC Debugger


                                 BASIC Debugger




     This is a new release of the  BASIC  debugging  technique  (BASDDT).   Most
BASIC  statements  are now included.  BASDDT occupies its own high segment (11k)
and in no way affects running programs when not used.

A)  BASDDT Control Commands


     There are six BASDDT control commands.  These commands may  be  abbreviated
to  the first three characters.  As the name implies, they control the action of
BASDDT.  The BASDDT control commands may  not  be  used  in  multiple  statement
lines,  nor  may  they  be  used in conjunction with BASDDT statements, they are
intended only for single, immediate action.

          1)  START N      (Where N is an optional line number)

          This command initializes BASDDT and must be used to begin execution of
          the program.  Prior to the START command, only BASDDT control commands
          (with the exception of CONTINUE) are legal.  When  BASDDT  is  invoked
          with the edit command DDT(NH), BASDDT will respond with:

          [BASDDT EXECUTION]

          >

          after compilation of the program.  At  this  point,  it  is  ready  to
          receive  and  process  commands.   Whenever  the  right  angle bracket
          appears, BASDDT is waiting for input of a command or statement.   When
          the  user  is  ready  to  begin  execution  of the program (i.e. after
          setting stops), he should issue the START command.  The  program  will
          optionally begin 1) at the line number specified in the start command,
          if one was included, 2) at the line number specified  in  the  DDT(NH)
          command or 3) at the first executable statement.

          2)  STOP N(,M,L...)       (where N,M,L...  are line numbers)


               Execution of the BASIC program may be suspended at  various  line
          numbers  throughout the program through use of the STOP command.  STOP
          takes as its argument a list of line numbers separated by commas.  The
          line numbers must exist in the user program.  There is no limit to the
          number of stops a user may  have.   Setting  stops  at  non-executable
          statements will cause a stop at the next executable statement.  When a
          stop is reached, BASDDT will inform the user at which  line  the  stop
          occurred.  The stop will occur prior to execution of that line number.
          Example:

University of Pennsylvania Medical School BASIC                          Page 28
BASIC Debugger


          >STOP 90
          >START
          <STOP># 90
          >


          3)  CONTINUE N      (where N is an optional line number)


               CONTINUE is used to proceed from a  stop.   If  N  is  specified,
          control  will go to that line number.  However, unlike the BASDDT GOTO
          statement, CONTINUE is an unconditional transfer.  As  such,  CONTINUE
          with an argument should be used sparingly and with care.  Example:

          >STOP 90,50,150
          >START
          <STOP># 50
          >CONT
          <STOP># 90


          4)  LIST


               LIST (takes no arguments) will print on  the  user's  teletype  a
          list of all program stops.  Example:

          >LIST
          STOPS:    50 90 150
          >

          5)  REMOVE N(,M,L,...)      (where N,M,L,..  are line numbers)


               REMOVE is used to remove a previously placed stop in  the  user's
          program.   If  no  argument  is  specified,  all  stops  are  removed.
          Removing a non-existent stop is considered a no-op.  Example:

          >LIST
          STOPS:    50 90 150
          >REMOVE 90
          >LIST
          STOPS:    50 150

          6)  DECLARE V1(,V2,V3,V4,V5)      (where V1-V5 are variable names)


               For your convenience, five scalar locations have been reserved to
          use  as an aid to debugging.  Before they can be referenced, they must
          be assigned a legal BASIC scalar  name  through  use  of  the  DECLARE
          command.   Once  a  variable  name  has  been  declared,  it cannot be
          removed.  Example:

University of Pennsylvania Medical School BASIC                          Page 29
BASIC Debugger


          >DECLARE T1,T4
          >LET T1=5 \ T4=1
          >PRINT T1;T4
           5 1
          >


B)  BASDDT Statements


               The following  statements  cause  a  specific  action  to  occur.
          Except  where  noted,  they  are exactly alike in nature to the normal
          BASIC statement except that they are executed  immediately.   Multiple
          statement lines and multiple line statements are also legal in BASDDT.
          Two backslashes in BASDDT are used to end control  of  an  IF-THEN  or
          IF-THEN-ELSE.  Example:

          >IF A = B THEN C=1 \ B=2 \ D=4

          In this case, if A does not equal B, no statements will  be  executed.
          However, in the following example:

          >IF A = B THEN C=1 \\ B=2 \ D = 4

          B=2 and D=4 will be executed regardless of the outcome of IF A = B.


Statement        Available       BASIC-BASDDT difference

DATA             no
READ             yes             none
PRINT            yes             none
LET              yes             none
GOTO             yes             none
IF-THEN          yes             use of two backslashes
IF-THEN-ELSE     yes             use of two backslashes
FOR-NEXT         yes             none
ON-ERROR         no
ON-GOTO          yes             none
ON-GOSUB         yes             none
DIM              no
END              yes             exits to edit mode with runtime message
GOSUB            yes             none
INPUT            yes             none
STOP             no              BASDDT control command
REM              no              BASDDT control command for REMOVE
RESUME           yes             none
RESTORE          yes             none
CHANGE           yes             none
CHAIN            yes             chained program will also have BASDDT
MARGIN           yes             none
PAGE             yes             none
NOPAGE           yes             none
QUOTE            yes             none
University of Pennsylvania Medical School BASIC                          Page 30
BASIC Debugger


NOQUOTE          yes             none
PRINT USING      yes             none
FILES            no
FILE             no              use OPEN instead
OPEN             yes             none
CLOSE            yes             none
SCRATCH          yes             none
WRITE            yes             none
IF END           yes             none
SET              yes             none
PAUSE            no               
PLOT             no               

All matrix instructions and functions are implemented.

All statement modifiers are implemented.

In addition, the BASDDT statement, BASDDT, has been  added.   It  will  transfer
control to BASDDT input level.  Example:

          >FOR I = 1 TO 10 \ IF X2 > 30 THEN BASDDT \ X2=X2+X1^2 \ NEXT I
          >PRINT X2,I
          31         8
          >


C)  Control-C


     The control-C (^C) has different actions depending upon where it is  given.
At the input level (i.e. when the right angle bracket is displayed), a control-C
causes an immediate return to edit level with no runtime message printed.   When
the  control-C  is  given  during  the execution of the user's program or BASDDT
statments, control will return to BASDDT input level.  The LINE function can  be
used to determine where control was interrupted.  Example

>CONT
^C
^C
>PRINT LINE
 50

Warning- - -the statement being executed may be  interrupted  before  completion
and  partial  answers  may occur.  The continue command without a line number is
illegal after a control-C.
University of Pennsylvania Medical School BASIC                          Page 31
BASIC Debugger


D)  Execution Errors

Any program execution errors result in a return to BASDDT input level after  the
printing  of the message.  Thereafter the continue command without a line number
is illegal.
University of Pennsylvania Medical School BASIC                          Page 32
BASIC Plotting Package


                             BASIC Plotting Package




     Graphical output on the Tektronix-4010-1 can now be  done  in  BASIC.   The
Tektronix-4010-1  has  a  grid  size  of 780 vertical points and 1024 horizontal
points.  All coordinates greater than the  above  will  be  truncated  to  these
values.

     There  are  two  types  of  positioning  on  the   Tektronix-4010-1.    The
alphanumeric cursor which represents the point at which alphanumeric output will
begin and the "pen" position which represents the point at which  graphing  will
begin.   BASIC  PRINT  statements  modify  the  alphanumeric cursor but will not
affect the "pen" position.  Using the BASIC PLOT functions will modify the "pen"
postion  and  also  move  the  position  of the alphanumeric cursor to the "pen"
position at the end of the graphing movement.  An alphanumeric character  is  14
vertical positions by 10 horizontal positions.

     All  coordinate  arguments  in  the  following   definitions   are   screen
coordinates relative to users origin.  All scaling must be done by the user.


The form:

          <ln> PLOT F1 (,F2,F3,....)

where Fn represents one of the following eight functions.

     1)  INIT

               This call initializes internal plotting parameters.  It also sets
          the  "pen" to the lower left hand corner and defines this point as the
          origin (0,0).  INIT should be the first  PLOT  call  in  the  program,
          unexpected results may occur otherwise.

     2)  PAGE

               This call erases the screen and moves the alphanumeric cursor  to
          the  upper  left  hand corner.  It does not affect the position of the
          "pen".

     3)  LINE(X,Y,I)

               This call will move the "pen" position to the coordinates  (X,Y).
          If I is greater than 0 (I>0), the movement will be made with the "pen"
          down (that is to say a line will be drawn).  If  I  is  less  than  or
          equal to 0 (I<=0), the movement will be made with the "pen" up.
University of Pennsylvania Medical School BASIC                          Page 33
BASIC Plotting Package


     4)  ORIGIN(X,Y)

               This call will move the "pen" position to (X,Y) and define it  as
          (0,0).

     5)  STRING(X,Y,<string expression>)

               This call will output the <string expression> with the lower left
          hand  corner  of  the  first  character beginning at (X,Y).  The "pen"
          position will be left at the lower  right  hand  corner  of  the  last
          character typed.

     6)  WHERE(X,Y)

               This call will return the coordinates of the  "pen"  position  in
          (X,Y)  relative  to  the users origin.  For example, if the origin was
          defined  at  absolute  screen  coordinates  (500,500)  and  the  "pen"
          position  was  at  absolute  screen  coordinates (600,50), coordinates
          (100,-450) would be returned.

     7)  CURSOR(X,Y,Z)

               This call causes the cross-hairs to be displayed on  the  screen.
          After  typing  any alphanumeric character, the cross-hair coordinates,
          relative to the users origin, are returned in (X,Y), and  the  decimal
          representation of the typed character is returned in Z.

     8)  SAVE(N)

               This call causes the graphical output saved on disk in a file  on
          channel number N to be plotted.


     In order to suspend program execution so that a hard copy may  be  made  of
the screen, the PAUSE statement (with no arguments) has been added.  Its purpose
is merely to pause until any printing keyboard character is typed.

     Below is a sample program which will plot a sine and cosine curve.


  100 PRINT "STEP IN FRACTION OF PI"      'ASK FOR STEPPING FACTOR
  110 INPUT J2                            'GET THE STEP
  120 LET J1=200/J2                       'CONVERT TO SCREEN COORDINATES
  130 PLOT INIT,PAGE                      'INITIALIZE FOR PLOTTING
  135                                     'AND CLEAR THE SCREEN
  140 PLOT STRING(0,700,"COSINE ")        'PRINT LABEL FOR COSINE CURVE
  150 PLOT WHERE(X,Y)                     'SAVE POSITION OF LINE FOR SINE CURVE
  160 PLOT LINE (250,700,1)               'DRAW SOLID LINE FOR COSINE CURVE
  170 PLOT STRING(0,675,"SINE ")          'PRINT LABEL FOR SINE CURVE
  180 PLOT LINE (X,675,0)                 'MOVE PEN BELOW COSINE LINE
  190 REM DRAW DASHED LINE TO LABEL SINE CURVE USING
  200 REM STEPPING FACTOR
  210 N=1                                 'BEGIN WITH PEN DOWN
  220 FOR R2=X+J1 TO 250 STEP J1          'ARGUMENTS FOR DASHED LINE
University of Pennsylvania Medical School BASIC                          Page 34
BASIC Plotting Package


  230 PLOT LINE (R2,675,N)                'DRAW OR MOVE THE PEN POSITION
  240 N=N+1 \ IF N>1 THEN N=0             'IF PEN WAS UP, MAKE IT DOWN
  250                                     'AND VICE VERSA
  260 NEXT R2                             'LOOP THROUGH POINTS
  270 PLOT ORIGIN (0,400)                 'DECLARE ORIGIN
  280 REM
  290 REM DRAW THE AXIS
  300 REM
  310 PLOT LINE (0,-200,0),LINE(0,200,1)  'Y-AXIS  400 POINTS
  320 PLOT LINE (1000,0,0),LINE (0,0,1)   'X-AXIS  1000 POINTS
  330 PLOT LINE (0,COS(0)*100,0)          'MOVE WITH PEN UP TO FIRST POINT
  340 FOR R2=J1 TO 1000 STEP J1           'DRAW COSSINE CURVE
  350 Y=COS(PI/200*R2)*100                'CALCULATE Y POSTION
  360 PLOT LINE (R2,Y,1)                  'DRAW THE LINE
  370 NEXT R2                             'DO ALL THE POINTS
  380 PLOT LINE (0,SIN(0)*100,0)          'POINT TO FIRST SINE POSITION
  390 N=1                                 'UP-DOWN DASH LINE INDICATOR,
  395                                     'START AT DOWN
  400 FOR R2=J1 TO 1000 STEP J1           'DRAW DASHED SINE CURVE
  410 Y=SIN(PI/200*R2)*100                'CALCULATE Y POSITION
  420 PLOT LINE (R2,Y,N)                  'DRAW OR MOVE THE PEN
  430 N=N+1 \ IF N>1 THEN N=0             'IF PEN UP, MAKE DOWN
  440 NEXT R2                             'DO ALL POINTS
  450 PLOT ORIGIN (0,-250)                'NEW ORIGIN FOR LABELLING
  460 FOR J=0 TO 4                        'OUTPUT FIVE "PI" LABELS
  465 X=J*200                             'CONVERT TO SCREEN COORDINATES
  470 IF X=0 THEN PLOT STRING(X,0,"0")    '0 PI
  480 IF X <>0 THEN PLOT STRING (X,0,STR$(J)+"*PI") 'LABEL PI(S)
  490 PLOT LINE (X,240,0),LINE (X,260,1)  'DRAW HASH MARK ON AXIS
  500 NEXT J                              'GO THRU LOOP
  505 PAUSE                               'LET HIM MAKE A HARD COPY IF HE WANTS
  510 END


       Plotting output may be saved on disk and recalled at a  later  date.   To
  save plotting output, the OPEN statement of the following form is used:

            <ln> OPEN <file spec> FOR OUTPUT AS FILE #N TO PLOT

  The file must be opened as a sequential access file.  N must be a legal  BASIC
  channel number.  All graphical output (except cursor and string plotting) will
  be saved in the file specified until a CLOSE statement is  executed  or  until
  the  end  of the program (whichever comes first).  Only one file may be opened
  for output plotting at a time.  If another file is opened on  channel  N,  the
  previous file will be closed.

       To recall the file to be plotted on the screen, the OPEN statement of the
  following form is used:

            <ln> OPEN <file spec> FOR INPUT AS FILE #N TO PLOT

  As above, the file must be opened as a sequential access file and N must be  a
  legal  BASIC  channel  number.  This OPEN statement merely associates the file
  with a channel for plotting.  As many files as there are channel  numbers  may
University of Pennsylvania Medical School BASIC                          Page 35
BASIC Plotting Package


  be  opened at any time.  To have the file displayed on the screen, the SAVE(N)
  PLOT function is used (where N is a channel number corresponding to  the  file
  opened  to  plot).  The contents of the file will then be displayed.  Assuming
  the user has already created a plot file, the following example would be  used
  to display it.

          10 OPEN "PLOT.BAS" FOR INPUT AS FILE #1 TO PLOT
          20 PLOT INIT,PAGE,SAVE(1)
          30 END
University of Pennsylvania Medical School BASIC                          Page 36
Integer Usage


                                 Integer Usage



     Numbers on the system can be represented and manipulated in either  integer
or floating point format.  The implications of representing numbers in a certain
format and the resultant benefits are described  in  the  following  discussion.
Certain  operations  involving  integer  numbers are more efficient if performed
using a forced integer format.


A)  Integer Constants and Variables


     Normally, all numeric values (variables and constants) specified in a BASIC
program  are stored internally as floating-point numbers.  Integer constants can
assume values in the range -99999999 to +99999999.

     A constant, variable  or  function  can  be  specified  as  an  integer  by
terminating its name with the % character.  For example:

          100% A%   FNX%(Y)
          -4%  A1%  FNL%(N%,L%)

The user is expected to indicate where an integer constant is to be generated by
using the % character.  Otherwise a floating-point value is normally produced.

     When a floating-point  value  is  assigned  to  an  integer  variable,  the
fractional  portion  of  that  number is lost.  The number is not rounded to the
nearest value (a FIX function is performed rather than an  INT  function).   For
example:

          A%=-1.1

causes A% to be assigned the value -1.


B)  Integer Arithmetic


     Arithmetic performed with integer variables is performed modulo 2^35.   The
number  range  -34359738368  to  +34359738367 is treated as continuous, with the
number after +34359738367 equal to -34359738368.

     Integer division forces truncation of any remainder, for  example  5%/7%=0%
and  199%/100%=1%.   Operations  can  be  performed  in  which  both integer and
floating-point data are freely mixed.   The  result  is  stored  in  the  format
indicated as the resulting variable, for example:

          25 LET X% = N%+FNA(R)+2

The result of the expression on the right is truncated  to  provide  an  integer
value for X%.  The result of mixing integer and floating-point data is explained
in section G below.
University of Pennsylvania Medical School BASIC                          Page 37
Integer Usage


C)  Integer I/O


     Input and output of integer variables is  performed  in  exactly  the  same
manner as operations on floating-point variables.  (Remember that in cases where
a floating-point variable has an integer value it is automatically printed as an
integer  but  is  still  stored  internally  as a floating-point number).  It is
illegal to provide a floating-point value for an integer variable through either
a READ or INPUT statement.  For example:

          LISTNH
          10 READ A,B%,C,D%,E
          20 PRINT A,B%,C,D%,E
          30 DATA 2.7,3,4,5.7,6.8
          40 END

          READY
          RUNNH


          ? BAD DATA IN LINE 10

          READY

          when line 30 is changed to

          30 DATA 2.7,3,4,5,6.8

          the following is printed:

          RUNNH

          2.7      3       4       5       6.8

          READY


D)  User-defined Integer Functions


     Functions  can  be  written  to  handle  integer  variables  as   well   as
floating-point  variables.   A  function  is  defined  to  be of integer type by
following the function name with the % character.

     A function to return the remainder when one integer is divided  by  another
is shown below:

          10 DEF FNR%(I%,J%) = I% - J%*(I%/J%)

and could be called later in a program as follows:

          100 PRINT FNR%(A%,11%)
University of Pennsylvania Medical School BASIC                          Page 38
Integer Usage


     Integer arguments can  not  be  used  where  floating-point  arguments  are
expected  and  vice versa, if they are an error message will be given at compile
time.


E)  Use of Integers as Logical Variables


     Integer variables or integer valued expressions can be used  in  any  place
that a logical expression can appear.  An integer value of 0% corresponds to the
logical value FALSE, and any non-zero value is defined to be TRUE.  The  logical
operators  (AND,  OR(IOR),  NOT,  XOR, IMP, EQV) operate on logical (or integer)
data in a bitwise manner.  The integer -1% (which is represented  internally  as
thirty-six  binary  ones)  is  normally  used by the system when a TRUE value is
required.

     Logical values generated by BASIC always have the values -1% (TRUE) and  0%
(FALSE).   The  following  statements  illustrate the use of integers in logical
applications.

          10 IF -1% THEN PRINT "TRUE" ELSE PRINT "FALSE"
          20 J%=-1% \ I%=0%
          30 PRINT J% AND I%,J% OR I%
          40 IF 1<0 XOR -1% THEN PRINT "TRUE" ELSE PRINT "FALSE"
          50 A$="ABCDE" \  B$="FGHIJ"
          60 K%= A$ <> B$ EQV I% EQV J%
          70 PRINT K%
          80 END
          RUNNH


          TRUE
          0       -1
          TRUE
          -1


          READY


F)  Logical Operation on Integer Data


     BASIC permits a user program to combine integer variables or integer valued
expressions   using   a  logical  operator  to  give  bit-wise  integer  results
(operations on floating-points numbers are also permitted,  but  logical  string
operations are not).

     In the following truth tables, A represents the condition of one bit in one
integer  value,  and  B represents the condition of the bit in the corresponding
bit position of another integer value.  The truth tables are as follows.

University of Pennsylvania Medical School BASIC                          Page 39
Integer Usage


A   B  A AND B      A   B  A OR B

1   1  1            1   1  1
1   0  0            1   0  1
0   1  0            0   1  1
0   0  0            0   0  0


A   B  A XOR B      A   B  A EQV B

1   1  0            1   1  1
1   0  1            1   0  0
0   1  1            0   1  0
0   0  0            0   0  1


A   B  A IMP B      A   NOT A

1   1  1            1   0
1   0  0            0   1
0   1  1
0   0  1


     The result of  a  logical  operation  is  an  integer  value  generated  by
combining the corresponding bits of two integer values according to the rules as
shown in the truth tables above.  For example, the following command prints  the
logical product of the integers 85 and 28.

          PRINT 85% AND 28%

          20

Each  bit  in  the  internal  representation  of  85%  is  combined  with   each
corresponding  bit  in the internal representation of 28% according to the rules
in the AND truth tables.  By consulting the AND (logical product)  truth  table,
it can be seen that a bit is generated in the bit position of the result only if
both bits are 1 in the corresponding bit position of the integer values 85%  and
28%.   The  resultant  value  of 20 printed by BASIC is the integer value of the
bits set in the internal representation of the logical product.


G)  Mixed-mode Arithmetic


     The user can perform arithmetic operations  using  a  mix  of  integer  and
floating-point  numbers.  To force a floating point representation of an integer
constant, terminate it with a decimal point.  Use the % character  as  described
above  to  force  an  integer representation of a constant.  Constants without a
decimal point or % character  are  termed  ambiguous.   The  remainder  of  this
section describes the results of arithmetic operations using a mix of numbers.
University of Pennsylvania Medical School BASIC                          Page 40
Integer Usage


     If both operands of an arithmetic operation are either  explicitly  integer
or floating-point, the system generates, respectively, integer or floating-point
results.  If one operand of an arithmetic operation is an integer and another is
floating-point,   the   system   converts   the   integer  to  a  floating-point
representation and generates a floating-point result.  For example:

          PRINT 1%/2%;1./2.;1%/2.;1./2%
          0 .5 .5 .5

In the first two operations, the system generates the explicit results;  in  the
second  two,  the  system  converts  the explicit integer and generates floating
point results.

     When an  ambiguous  constant  appears  in  an  arithmetic  expression  (for
example,  10  as  opposed  to  10%  or 10.), the system represents it in integer
format if an integer variable (for example, I%)  or  an  integer  constant  (for
example  3%)  occurs  anywhere  to  the  left of the constant in the expression.
Otherwise, the system treats the ambiguous constant as a floating point number.
University of Pennsylvania Medical School BASIC                          Page 41
Index


                                     Index

                                     INDEX




BASDDT . . . . . . . . . . . . . . . . . 27
BASIC Debugger . . . . . . . . . . . . . 27
BASIC Plotting Package . . . . . . . . . 32

CATALOG  . . . . . . . . . . . . . . . . 25
CLOSE  . . . . . . . . . . . . . . . . . 5
CREF . . . . . . . . . . . . . . . . . . 26

DDT(NH)  . . . . . . . . . . . . . . . . 24
Debugging  . . . . . . . . . . . . . . . 27
Disabling User Error Handling  . . . . . 18

Edit Level Commands  . . . . . . . . . . 23
ERL Variable . . . . . . . . . . . . . . 19
ERR Variable . . . . . . . . . . . . . . 16

FOR Statement  . . . . . . . . . . . . . 20

GENERATE . . . . . . . . . . . . . . . . 24

Index  . . . . . . . . . . . . . . . . . 41
INPUT  . . . . . . . . . . . . . . . . . 5
Integer Usage  . . . . . . . . . . . . . 36

Logical and Relational Expressions . . . 10

New Functions  . . . . . . . . . . . . . 21
NOSYNTAX . . . . . . . . . . . . . . . . 25

ON ERROR GOTO  . . . . . . . . . . . . . 15
ON-GOSUB . . . . . . . . . . . . . . . . 5
OPEN . . . . . . . . . . . . . . . . . . 4, 34

Plotting . . . . . . . . . . . . . . . . 22, 32
PPN Specification  . . . . . . . . . . . 26

Relational and Logical Expressions . . . 10
RESUME . . . . . . . . . . . . . . . . . 17
RUNFSAV  . . . . . . . . . . . . . . . . 23
RUNSAV . . . . . . . . . . . . . . . . . 23

SAVFIL(NL) . . . . . . . . . . . . . . . 23
Statement Modifiers  . . . . . . . . . . 6
SYNTAX . . . . . . . . . . . . . . . . . 24
Syntax Changes . . . . . . . . . . . . . 2

Two-dimensional String Arrays  . . . . . 11

UNTIL Statement  . . . . . . . . . . . . 20
User Error Handling  . . . . . . . . . . 15
User-defined String Functions  . . . . . 6

Virtual Arrays . . . . . . . . . . . . . 11
Virtual Data Storage . . . . . . . . . . 11

WHILE Statement  . . . . . . . . . . . . 20

