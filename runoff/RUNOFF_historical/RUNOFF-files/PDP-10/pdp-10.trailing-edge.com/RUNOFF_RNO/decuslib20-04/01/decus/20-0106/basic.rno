\\
.PS 58,80
.NJ
.LM 0
.T UNIVERSITY OF PENNSYLVANIA MEDICAL SCHOOL BASIC
.ST INTRODUCTION
.PG
.C
INTRODUCTION
.S 3
.P 5
^THE ^UNIVERSITY OF ^PENNSYLVANIA ^MEDICAL ^SCHOOL ^^BASIC\\ IS A SEGMENTED VERSION
OF ^^DECSYSTEM-10 BASIC\\, VERSION 17^E.  ^THERE ARE CURRENTLY FIVE SEGMENTS.
.S 2
.LM 15
.NF
^^
BASIC - COMMAND/EDIT (3K)
BASCOM - COMPILE/LOAD (5K)
BASXCT - EXECUTE (7K)
BASDDT - BASIC DEBUGGER (11K)
BASERR - ERROR (1K)
\\
.F
.S 1
.LM 0
.P 5
^THE REASON FOR THIS RELEASE IS AN ATTEMPT TO REACH COMPATIBILITY WITH
THE ^^BASIC-PLUS\\ LANGUAGE ON THE ^^PDP\\-11, TO ADD MORE COMPUTING POWER
TO ^^BASIC\\, AND TO FIX ALL KNOWN BUGS IN ^VERSION 17^E.
.PG
.ST SYNTAX CHANGES
.C
SYNTAX CHANGES
.S 3
.S 1
^A.##^MULTIPLE ^STATEMENTS ON A ^SINGLE ^LINE
.S 1
.P 5
^MORE THAN ONE STATEMENT CAN BE WRITTEN ON A SINGLE LINE AS LONG AS EACH
STATEMENT (EXCEPT THE LAST) IS TERMINATED WITH A BACKSLASH (SHIFT-L).
^THUS ONLY THE FIRST STATEMENT ON A LINE CAN (AND MUST) HAVE A LINE NUMBER.  ^FOR EXAMPLE:
.S 1
.I 10
.NF
^^
10 INPUT A,B,C
\\
.S 1
IS A SINGLE STATEMENT LINE, WHILE
.S 1
.I 10
^^
20 LET X=X+1 _\ PRINT X,Y,Z _\ IF Y=2 GOTO 10
\\
.S 1
.F
IS A MULTIPLE-STATEMENT LINE CONTAINING THREE STATEMENTS: A ^^LET\\,
 A ^^PRINT\\, AND AN ^^IF-GOTO\\ STATEMENT.
.P 5
THE FOLLOWING RESTRICTIONS APPLY TO THIS CONSTRUCTION:
.S 1
.LM 15
.I -4
1)##^^DATA\\ STATEMENTS AND ^IMAGE STATEMENTS MUST BE THE ONLY STATEMENT
IN LINES IN WHICH THEY APPEAR.
.S 1
.I -4
2)##^^DEF FN\\? STATEMENTS MUST BE THE FIRST STATEMENT IN LINES IN WHICH
THEY APPEAR.
.S 1
.I -4
3)##^^REM\\ STATEMENTS AND COMMENTS INDICATED BY A SINGLE QUOTE MUST BE THE
LAST ELEMENT IN LINES IN WHICH THEY APPEAR.  (I. E. THE REMAINDER OF THE LINE IS TREATED
AS TEXT FOR THE COMMENT)
.S 1
.I -4
4)##^^FNEND\\ STATEMENTS MUST BE THE LAST STATEMENT IN LINES IN WHICH
THEY APPEAR.
.LM 0
.S 2
^B.##^A ^SINGLE ^STATEMENT ON ^MULTIPLE ^LINES.
.S 1
.P 5
^A SINGLE STATEMENT CAN BE CONTINUED ON SUCCESSIVE LINES OF THE PROGRAM.
TO INDICATE THAT A STATEMENT IS TO BE CONTINUED, THE LINE IS TERMINATED
WITH THE ^^LINE FEED\\ KEY INSTEAD OF THE ^^RETURN\\ KEY.  ^THE
^^LINE FEED\\ PERFORMS A CARRIAGE RETURN/LINE FEED OPERATION ON THE
TERMINAL AND THE LINE TO BE CONTINUED DOES NOT CONTAIN A LINE NUMBER.
^FOR EXAMPLE:
.S 1
.NF
.I 10
^^
10 LET W7=(W-X4*3)*(Z-A/
.I 10
(A-B)-17)
.S 1
.F
\\
^WHERE THE FIRST LINE WAS TERMINATED WITH THE ^^LINE FEED\\ KEY IS
EQUIVALENT TO:
.S 1
.NF
.I 10
^^
10 LET W7=(W-X4*3)*(Z-A/(A-B)-17)
\\
.S 1
.F
^NOTE THAT THE ^^LINE FEED\\ KEY DOES NOT CAUSE A PRINTED CHARACTER TO
APPEAR ON THE PAGE. PROGRAMS USING THIS CONSTRUCTION MAY NOT BE EDITTED
BY THE LINE EDITORS, ^^LINED\\ OR ^^SOS\\.
.PG
.ST BASIC STATEMENTS
.C
BASIC STATEMENTS
.S 3
^A)##^^OPEN\\
.S 1
.P 5
^THE OPEN STATEMENT ASSOCIATES A FILE ON DISK WITH AN ^I/^O CHANNEL NUMBER.
^^BASIC\\ PERMITS UP TO NINE FILES TO BE OPEN AT A GIVEN TIME, AND
THEREFORE, PERMITS INTERNAL FILE DESIGNATORS TO BE INTEGERS BETWEEN
ONE AND NINE.  ^THE GENERAL FORM OF THE OPEN STATEMENT IS AS FOLLOWS:
.NF
.I 10
^^
<LN>OPEN <\\STRING^^> (FOR INPUT) AS FILE <\\TYPE> <EXPRESSION^^>
.I 10
##################(FOR OUTPUT)
.F
.S 1
\\
^THE STRING FIELD IS A CHARACTER STRING CONSTANT, VARIABLE OR EXPRESSION
THAT CONTAINS THE EXTERNAL FILE SPECIFICATION OF THE FILE TO BE OPENED.
^THE TYPE IS EITHER _# FOR SEQUENTIAL ACCESS OR : FOR RANDOM ACCESS.
^IT MUST BE PRESENT.  ^THE EXPRESSION MUST HAVE AN INTEGER VALUE BETWEEN
ONE AND NINE, CORRESPONDING TO THE INTERNAL CHANNEL NUMBER
ON WHICH THE FIELD IS BEING OPENED.
.S 1
.I 5
^THERE ARE THREE DISTINCT FORMS FOR THE OPEN COMMAND:
.NF
.S 1
.LM 15
^^
OPEN <\\STRING^^> FOR OUTPUT
OPEN <\\STRING^^> FOR INPUT
OPEN <\\STRING^^>
.S1
.F
.I -4
^A.##^AN ^^OPEN FOR INPUT\\ STATEMENT WILL CAUSE AN AUTOMATIC ^^RESTORE\\
TO BE DONE ON THE FILE.  ^IF THE FILE DOES NOT EXIST AT THIS TIME, AN
ERROR MESSAGE WILL BE GIVEN.
.I -4
^B.##^AN ^^OPEN FOR OUTPUT\\ STATEMENT WILL CAUSE AN AUTOMATIC ^^SCRATCH\\
TO BE DONE ON THE FILE.  ^IF THE FILE EXISTS AT THIS TIME, IT WILL BE
DELETED.
.I -4
^C.##^AN ^^OPEN\\ STATEMENT WITHOUT AN ^^INPUT\\ OR ^^OUTPUT\\ DESIGNATION
WILL PERFORM NO OTHER FUNCTION EXCEPT TO ASSOCIATE THE FILE WITH THE
SPECIFIED ^I/^O CHANNEL NUMBER.
.LM 0
.S 1
.P 5
^THE ^^OPEN\\ STATEMENT DOES NOT CONTROL WHETHER THE PROGRAM ATTEMPTS
TO PERFORM INPUT OR OUTPUT ON THE FILE OR WHETHER READ AND/OR WRITE
ACCESS TO THE FILE IS GRANTED; THESE PRIVILEGES ARE CONTROLLED BY THE
FILE PROTECTION CODE.
.S 2
.TP 12
^B)##^^CLOSE\\
.S 1
.P 5
^THE ^^CLOSE\\ STATEMENT IS USED TO TERMINATE ^I/^O BETWEEN THE ^^BASIC\\
PROGRAM AND THE DISK FILE.  ^ONCE A FILE HAS BEEN CLOSED, IT CAN BE
REOPENED FOR READING OR WRITING ON ANY INTERNAL FILE DESIGNATOR.
^ALL FILES WILL AUTOMATICALLY BE CLOSED AT THE END OF PROGRAM EXECUTION
OR UPON EXECUTION OF THE ^^CHAIN\\ STATEMENT.  ^THE FORMAT OF THE
^^CLOSE\\ STATEMENT IS AS FOLLOWS:
.NF
.S 1
.I 10
^^
<LN> CLOSE <\\EXPRESSION> (,<EXPRESSION>,...)
.S 1
.F
^THE EXPRESSION INDICATED HAS THE SAME VALUE AS THE EXPRESSION
IN THE ^^OPEN\\ STATEMENT AND INDICATES THE INTERNAL CHANNEL NUMBER OF THE
FILE TO CLOSE.  ^ANY NUMBER OF FILES CAN BE CLOSED WITH A SINGLE
^^CLOSE\\ STATEMENT; IF MORE THAN ONE FILE IS TO BE CLOSED, THE EXPRESSIONS
ARE SEPARATED BY COMMAS.
.S 2
^C)##^^ON-GOSUB\\
.S 1
.P 5
^THE ^^ON-GOSUB\\ STATEMENT IS USED TO CONDITIONALLY TRANSFER CONTROL
TO ONE OF SEVERAL SUBROUTINES OR TO ONE OF SEVERAL ENTRY POINTS IN ONE
(OR MORE) SUBROUTINES.  THE STATEMENT HAS THE FOLLOWING FORM:
.NF
.S 1
.I 10
^^
<LN> ON <\\EXPRESSION^^> GOSUB <\\LIST OF LINE NUMBERS>
.F
.S 1
^DEPENDING ON THE INTEGER VALUE (TRUNCATED IF NECESSARY) OF THE EXPRESSION,
CONTROL IS TRANSFERRED TO THE SUBROUTINE WHICH BEGINS AT ONE OF THE
LINE NUMBERS LISTED.  ^ENCOUNTERING THE ^^RETURN\\ STATEMENT AFTER CONTROL
IS TRANSFERRED IN THIS WAY ALLOWS THE PROGRAM TO RESUME EXECUTION AT
THE LINE FOLLOWING THE ^^ON-GOSUB\\ LINE.
.S 2
^D)##^STATEMENT ^MODIFIERS
.S 1
.P 5
^TO INCREASE THE FLEXIBILITY AND EASE OF EXPRESSION WITHIN ^^BASIC\\,
FIVE STATEMENT MODIFIERS ARE AVAILABLE (^^IF, UNLESS, FOR, WHILE, \\AND^^,
UNTIL\\).  ^THESE MODIFIERS ARE APPENDED TO PROGRAM STATEMENTS
TO INDICATE CONDITIONAL EXECUTION OF THE STATEMENTS OR THE CREATION OF
IMPLIED ^^FOR\\ LOOPS.
.S 1
.TP 12
1)##^THE ^^IF\\ ^STATEMENT ^MODIFIER
.S 1
^THE FORM:
.S1
.I 10
^^<LN> <\\STATEMENT^^> IF <\\CONDITION>
.S 1
IS ANALOGOUS TO THE FORM:
.S 1
.I 10
^^<LN> IF <\\CONDITION^^> THEN <\\STATEMENT>
.S 1
^FOR EXAMPLE:
.S 1
.I 10
^^10 PRINT X IF X <>0
.S 1
IS THE SAME AS:
.S 1
.I 10
^^10 IF X <> 0 THEN PRINT X
.S 1
^WHEN A STATEMENT MODIFIER APPEARS TO THE RIGHT OF AN ^^IF-THEN\\ STATEMENT,
^THE MODIFIER OPERATES ONLY ON THE ^^THEN\\ CLAUSE OR THE ^^ELSE\\
CLAUSE, DEPENDING ON ITS PLACEMENT TO THE LEFT OR RIGHT OF ^^ELSE\\.
.S 1
^IT IS NOT POSSIBLE TO INCLUDE AN ^^ELSE\\ CLAUSE WHEN USING THE MODIFIER
FORM OF ^^IF\\.  ^SEVERAL MODIFIERS MAY BE USED WITHIN THE SAME
STATEMENTS.  ^FOR EXAMPLE:
.S 1
.I 10
^^70 PRINT X(I,J) IF I=J IF X(I,J) <> 0
.S 1
\\
^WHICH WILL PRINT THE VALUE OF ^^X(I,J)\\ ONLY IF THE VALUE ^^X(I,J)\\
IS NON-ZERO AND IF ^I EQUALS ^J.  ^WHENEVER THERE IS MORE THAN ONE
MODIFIER ON A LINE, THE MODIFIERS ARE EXECUTED IN A RIGHT-TO-LEFT
ORDER.  ^THAT IS, THE RIGHTMOST ONE IS EXECUTED FIRST, AND THE
LEFTMOST ONE IS EXECUTED LAST.
.S 2
.TP 6
2)##^THE ^^UNLESS\\ ^STATEMENT ^MODIFIER
.S 1
^THE FORM:
.S 1
.I 10
<^L^N> <STATEMENT> ^^UNLESS\\ <CONDITION>
.S 1
CAUSES THE STATEMENT TO BE EXECUTED ONLY IF THE CONDITION IS FALSE.  ^FOR
EXAMPLE, THE FOLLOWING STATEMENTS ARE ALL EQUIVALENT:
.S 1
.LM 10
.NF
^^
10 PRINT A UNLESS A = 0
20 PRINT A IF NOT A=0
30 IF NOT A=0 THEN PRINT A
40 IF A <> 0 THEN PRINT A
\\
.LM 0
.F
.S 1
^THIS PARTICULAR FORM SIMPLIFIES THE NEGATION OF A LOGICAL CONDITION.
.S 2
.TP 10
3)##^THE ^^FOR\\ ^STATEMENT ^MODIFIER
.S 1
^THE FORM:
.S 1
.NF
.I 10
<^L^N> <STATEMENT> ^^FOR\\ <VARIABLE>=<EXPR.>^^TO\\<EXPR.>(^^STEP\\<EXPR.>)
.S 1
OR THE FORM:
.S 1
.I 10
<^L^N> <STATEMENT> ^^FOR\\ <VARIABLE>=<EXPR.>(^^STEP\\<EXPR.>)(^^WHILE<EXPR.>)
.I 10
####################################################(^^UNTIL\\<EXPR.>)
.F
.S 1
CAN BE USED TO IMPLY A FOR LOOP ON A SINGLE LINE.  ^FOR EXAMPLE (USING
NONE OF THE OPTIONAL ELEMENTS):
.S 1
.I 10
^^
10 PRINT I, SQR(I) FOR I = 1 TO 10
.S 1
\\
^THIS STATEMENT IS EQUIVALENT TO THE FOLLOWING ^^FOR-NEXT^^ LOOP:
.S 1
.I 10
^^
10 FOR I = 1 TO 10
.I 10
20 PRINT I,SQR(I)
.I 10
30 NEXT I
\\
.S 1
^IN CASES WHERE THE ^^FOR-NEXT\\ LOOP IS EXTREMELY SIMPLE, THE NECESSITY
FOR BOTH A ^^FOR\\ AND A ^^NEXT\\ STATEMENT IS ELIMINATED.  ^NOTICE
THAT THIS IMPLIED ^^FOR\\ LOOP WILL ONLY MODIFY (AND HENCE EXECUTE
ITERATIVELY) ONE STATEMENT IN THE PROGRAM.  ^ANY NUMBER OF IMPLIED
^^FOR\\ LOOPS CAN BE USED IN A SINGLE PROGRAM.
.S 1
^AS IN THE CASE WITH ALL MODIFIERS, A ^^FOR\\ MODIFIER IN AN ^^IF\\
STATEMENT OPERATES ONLY ON THE ^^THEN\\ OR ^^ELSE\\ CLAUSE WITH WHICH
IT IS ASSOCIATED, AND NEVER ON THE THE CONDITIONAL EXPRESSION TO THE
LEFT OF THE ^THEN\\.  ^THUS, IF IT WAS DESIRED TO PRINT ALL NON-ZERO VALUES IN
A MATRIX ^X(100), THE FOLLOWING PROGRAM WOULD NOT OPERATE PROPERLY:
.S 1
^^
.LM 10
.NF
10 DIM X(100)
20 READ X(I) FOR I = 1 TO 100
30 IF X(I)<>0 THEN PRINT I,X(I) FOR I = 1 TO 100
.S 1
.LM 0
.F
^SINCE THE IMPLIED FOR LOOP AT LINE 30 APPLIES ONLY TO THE ^^THEN PRINT\\
_. _. _. PART OF THE STATEMENT, AND NOT TO THE ^^IF _. _. _. \\ PART.
^THE FIRST VALUE OF ^X TESTED IS ^X(100), SINCE ^I REMAINED AT 100 FROM
STATEMENT 20.  ^TO ACHIEVE THE DESIRED EFFECT, IT IS ONLY NECESSARY
TO CODE LINE 30, NOT AS AN ^^IF\\ STATEMENT, BUT RATHER AS A ^^PRINT\\
STATEMENT WITH NESTED MODIFIERS; FOR EXAMPLE:
.S 1
.I 10
^^30 PRINT I,X(I) IF X(I)<> 0 FOR I = 1 TO 100
.S 1
^WHEN EXPRESSED IN THE LATTER FORM, THE NESTED MODIFIER RULE
TAKES EFFECT, ALL THE VALUES OF ^X(^I) ARE TESTED AND PRINTED
AS APPROPRIATE.
.S 2
.TP 6
4)##^THE ^^WHILE\\ ^STATEMENT ^MODIFIER
.S 1
^THE FORM:
.S 1
.I 10
<^L^N> <STATEMENT> ^^WHILE\\ <CONDITION>
.S 1
IS USED TO REPEATEDLY EXECUTE THE STATEMENT WHILE THE SPECIFIED CONDITION
IS TRUE.  ^FOR EXAMPLE:
.S 1
.I 10
^^
10 LET X=X^2 WHILE X^2<1E6
\\
.S 1
IS EQUIVALENT TO:
.S 1
.I 10
^^
10 LET X=X^2
.I 10
20 IF X<1E6 THEN 10
.S 1
\\
^THE ^^WHILE\\ MODIFIER OPERATES USEFULLY ONLY IN ITERATIVE LOOPS
WHERE THE LOGICAL LOOP STRUCTURE MODIFIES THE VALUES WHICH DETERMINE LOOP
TERMINATION.  ^THIS IS A SIGNIFICANT DEPARTURE FROM ^^FOR\\ LOOPS, IN WHICH THE CONTROL VARIABLE IS AUTOMATICALLY ITERATED;
A ^^WHILE\\ STATEMENT NEED NOT HAVE A FORMAL CONTROL
VARIABLE.  ^THE FOLLOWING STATEMENTS NEVER TERMINATE PROPERLY:
.S 1
.I 10
^^10 X=X+1 WHILE I<1000
.I 10
20 PRINT I,A(I) WHILE A(I)<>0
.S 1
\\
IN BOTH CASES, THE PROGRAM FAILS TO ALTER THE VALUES WHICH ARE USED
 TO DETERMINE WHEN THE LOOP IS DONE.  ^A SUCCESSFUL APPLICATION
OF THE ^^WHILE\\ MODIFIER IS SHOWN BELOW:
.S 1
.I 10
^^
10' TEST OF SQUARE ROOT ROUTINE
.I 10
20 X=X+1 WHILE X=SQR(X^2)
.I 10
30 PRINT X
.S 2
\\
.TP 8
5)##^THE ^^UNTIL\\ ^STATEMENT ^MODIFIER
.S 1
^THE FORM:
.S 1
.I 10
<^L^N> <STATEMENT> ^^UNTIL\\ <CONDITION>
.S 1
IS USED TO REPEATEDLY EXECUTE THE STATEMENT UNTIL THE CONDITION BECOMES
TRUE; WHICH IS TO SAY, WHILE THE CONDITION IS FALSE.  ^FOR EXAMPLE:
.S 1
.I 10
^^10 X=X+1 UNTIL X<>SQR(X^2)
.S 1
\\
IS THE SAME AS
.S 1
.I 10
^^10 X=X+1
.I 10
20 IF X=SQR(X^2) THEN 10
.S 2
\\
.TP 6
6)##^MULTIPLE ^STATEMENT ^MODIFIERS
.S 1
.P 5
^MORE THAN ONE MODIFIER CAN BE USED IN A SINGLE STATEMENT.  ^MULTIPLE
MODIFIERS ARE PROCESSED FORM RIGHT TO LEFT.  ^FOR EXAMPLE:
.S 1
.I 10
^^10 LET A=B IF A>0 IF B>0
\\
.S 1
WHICH IS EQUIVALENT TO:
.S 1
.I 10
^^10 IF B>0 THEN IF A>0 THEN A=B
.S 1
\O\R
.S 1
.I 10
10 IF B>0 AND A>0 THEN LET A=B
\\
.S 1
^A TWO DIMENSIONAL MATRIX (^M BY ^N) CAN BE READ ONE ROW AT A TIME
AS FOLLOWS:
.S 1
.I 10
^^50 READ A(I,J) FOR J=1 TO M FOR I = 1 TO N
\\
.TP 6
.S 2
^E)## ^LOGICAL ^OPERATORS
.S 1
.P 5
^LOGICAL OPERATORS ARE USED IN ^^IF-THEN, WHILE, UNLESS AND UNTIL\\ STATEMENTS WHERE SOME
CONDITION IS USED TO DETERMINE SUBSEQUENT OPERATIONS WITHIN THE USER
PROGRAM.  ^FOR THIS DISCUSSION, ^A AND ^B ARE RELATIONAL EXPRESSIONS
HAVING ONLY ^^TRUE\\ (-1) AND ^^FALSE\\ (0) VALUES.
^THE LOCICAL OPERATORS ARE AS FOLLOWS:
.S 1
.NF
.TAB STOPS 5,15,25
	^OPERATOR	^EXAMPLE	^MEANING
.S 1
	^^NOT	NOT A\\	^THE LOGICAL NEGATIVE OF A
	#	#	IF ^A IS TRUE, ^^NOT A\\ IS FALSE
	^^AND	A AND B\\	^THE LOGICAL PRODUCE OF ^A AND ^B
	#	#	^^A AND B\\ IS TRUE ONLY IF
	#	#	BOTH ^A AND ^B ARE TRUE, OTHERWISE, FALSE
	^^OR	A OR B\\	^THE LOGICAL SUM OF ^A AND ^B
	#	#	^^A OR B\\ HAS THE VALUE TRUE IF EITHER
	#	#	^A OR ^B IS TRUE, OTHERWISE, FALSE
	^^XOR	A XOR B\\	^THE LOGICAL EXCLUSIVE ^^OR\\ OR ^A AND ^B
	#	#	^^A XOR B\\ IS TRUE IF EITHER ^A OR ^B
	#	#	IS TRUE BUT NOT BOTH, OTHERWISE, FALSE
	^^IMP	A IMP B\\	^THE LOGICAL IMPLICATION OR ^A AND ^B
	#	#	^^A IMP B\\ IS FALSE IF AND ONLY IF
	#	#	^A IS TRUE AND ^B IS FALSE
	^^EQV	A EQV B\\	^A IS LOGICALLY EQUIVALENT TO ^B.
	#	#	^^A EQV B\\ HAS THE VALUE TRUE IF
	#	#	^A AND ^B ARE BOTH TRUE OR BOTH FALSE.
.ST NEW FUNCTIONS
.PG
.C
NEW FUNCTIONS
.S 3
.F
.P 5
^THE FOLLOWING NEW FUNCTIONS HAVE BEEN ADDED TO THE LIST OF
^^BASIC\\ ^LIBRARY ROUTINES.
.S 2
^A)##^^TIME$\\
.LM 5
.P 5
^RETURNS AN EIGHT CHARACTER STRING REPRESENTING
THE 24-HOUR TIME OF DAY AS ^^HH:MM:SS\\.
.S 1
.I -5
^B)##^^DATE$\\
.P 5
^RETURNS A NINE CHARACTER STRING REPRESENTING THE CURRENT DATE
AS ^^DD-MON-YY\\.
.S 1
.I -5
^C)##^^ASCII(S$)\\
.P 5
^GENERATES THE ^^ASCII\ VALUE OF THE FIRST CHARACTER CONTAINED
IN THE STRING ^S$. ^I. ^E. ^^ASCII("XAB")=88\\.
.S 1
.I -5
^D)##^^FIX(N)\\
.P 5
^RETURNS THE TRUNCATED VALUE OF ^X (^^SGN(X)*INT(ABS(X)).
^I. ^E. ^^FIX(-.5)=0\\.
.S 1
.I -5
^E)##^^LINE\\
.P 5
^RETURNS THE CURRENT LINE NUMBER OF THE STATEMENT BEING EXECUTED OR
THE LINE NUMBER OF THE STATEMENT LAST EXECUTED WHEN ^C (CNTRL-C)
INTERRUPTION OCCURRED.  (USEFUL IN ^^BASDDT\\)
.S 1
.I -5
^F)##^^NUM$(N)\\
.P 5
^INDICATES A STRING OF NUMERIC CHARACTERS REPRESENTING THE VALUE OF ^N
AS IT WOULD BE OUTPUT BY A ^^PRINT\\ STATEMENTS.
^^NUM$(N)=(SPACE)N(SPACE) FOR N >= 0
NUM$(N)=-N(SPACE) FOR N < 0
.S 1
.I -5
^G)##^^PI\\
.P 5
^CONSTANT VALUE OF ^^PI\\ (3.1415927)
.S 1
.I -5
^H)##^^POS(N)\\
.P 5
^RETURNS CURRENT POSITION ON THE OUTPUT LINE.  ^N IS THE ^I/^O CHANNEL
NUMBER.  ^^POS(0)\\ RETURNS THE VALUE FOR THE USER'S TELETYPE.
.LM 0
.ST NEW EDIT LEVEL COMMANDS
.PG
.C
NEW EDIT LEVEL COMMANDS
.S 3
^A)##^^SAVFIL/SAVFILNL
.S 1
.P 5
^THESE COMMANDS, FOLLOWED BY AN OPTIONAL FILE NAME, CREATE COMPACT
CORE IMAGES OF ^^BASIC\\ PROGRAMS ON THE DISK.  ^THE SOURCE CODE
IS DELETED FROM THESE FILES, SO FOR LARGE PROGRAMS, THEY OCCUPY
SUBSTANTIALLY LESS MEMORY THAN THE CODE PRODUCED BY THE ^^RUN\\
OR ^^RUNNH\\ COMMANDS.  ^SINCE THEY ARE ALREADY COMPILED, THEIR
EXECUTION DOES NOT CARRY THE OVERHEAD OF COMPILATION FOR EACH RUN.
^THE ^^SAVFILNL\\ COMMAND DIFFERS FROM THE ^^SAVFIL\\ COMMAND
IN THAT THE LINE NUMBER TABLES ARE ALSO DELETED.  ^THIS RESULTS
IN A FURTHER SAVING OF MEMORY AT THE EXPENSE OF DELETING
LINE NUMBERS FROM ANY EXECUTION TIME ERROR MESSAGE.  ^THE FILES
CREATED BY THESE COMMANDS ARE GIVEN THE NAME SPECIFIED, IF ANY, OR
ELSE THE NAME OF THE CURRENT PROGRAM.  ^THEY ARE ALWAYS GIVEN THE
EXTENSION ^^.SAV\\, THUS ELIMINATING ANY CONFLICT WITH .^^BAS\\
FILES.  ^THEIR EXTENSION MUST BE EXPLICITLY GIVEN TO DELETE THEM
WITH THE ^^UNSAVE\\ COMMAND.
.S 2
^^B)##RUNSAV
.S 1
.P 5
^THIS COMMAND, FOLLOWED BY A FILE NAME, RUNS THE .^^SAV\\ FILE OF
THAT NAME CREATED BY THE ^^SAVFIL(NL)\\ COMMAND.  ^IT IS NOT POSSIBLE
TO START THE PROGRAM AT OTHER THAN THE FIRST LINE.  ^THE ^^CHAIN\\
STATEMENTS WITH A LINE NUMBER ARGUMENT IS REGARDED AS A SYNTAX
ERROR IN CREATING A ^^.SAV\\ FILE.  ^THE ^^CHAIN\\ STATEMENT EXECUTED FROM
A ^^.SAV\\ FILE REQUIRES A ^^.SAV\\ FILE TO BE CHAINED.  ^IT IS
THEREFORE UNNECESSAY TO SPECIFY THE FILE EXTENSION.  ^SINCE THE
SOURCE CODE IS DELETED FROM ^^.SAV\\ FILES, A NEW
SESSION IS BEGUN AFTER THE EXECUTION OF ANY OF THESE COMMANDS.
^THE ^^.SAV\\ FILES PRODUCED ARE NORMAL ^^.SAV\\ FILES WHICH CAN
BE RUN FROM THE ^MONITOR BY USE OF THE ^^RUN\\ COMMAND.
^HOWEVER, RETURN IS TO THE ^MONITOR LEVEL INSTEAD OF ^^BASIC\\
^EDIT LEVEL.
^WITH NEW
VERSIONS OF ^^BASIC\\, ^^.SAV\\ FILES MAY BECOME OBSOLETE.  ^IF
THIS IS THE CASE, A WARNING MESSAGE TO RESAVE SOON WILL BE GIVEN WHEN THE
^^.SAV\\ FILE IS RUN.  ^PLEASE HEED THE WARNING.
.S 2
^^C)##RUNFSAV\\
.S 1
.P 5
^THIS COMMAND IS SIMILAR TO THE RUNSAV COMMAND EXCEPT THAT THE
^^.SAV\\ FILE IS ASSUMED TO BE CREATED BY THE ^MONITOR ^^SAVE\\
COMMAND.  ^EXIT FFROM THE PROGRAM IS ALWAYS TO ^MONITOR LEVEL
.S 2
^^D)##DDT/DDTNH\\
.S 1
.P 5
^THIS COMMAND CALLS FOR THE ^^BASIC\\ DEBUGGER TO BE INCLUDED
AS PART OF THE EXECUTION ROUTINE ALONG WITH YOUR ^^BASIC\\ PROGRAM.
^REFER TO THE SECTION ON ^^BASDDT\\ FOR USE OF THE DEBUGGER.
.S 2
.TP 6
^^E)##GENERATE NN,MM,LL\\
.S 1
.P 5
^THIS COMMAND WILL GENERATE LINE SEQUENCE NUMBERS FOR INPUT FROM THE
TELETYPE.  ^N^N IS THE STARTING VALUE, ^M^M IS THE MAXIMUM
NUMBER, AND ^L^L IS THE INCREMENT.  ^IF ^N^N OR ^L^L IS OMITTED,
THEY WILL DEFAULT TO 10.  ^IF ^M^M IS OMITTED, 99999 WILL BE THE
MAXIMUM.  ^THEREFORE, IF NO ARGUMENTS ARE GIVEN, THEY WILL BE
10,99999,10.
^IF ^N^N IS GREATER THAN ^L^L, ONLY ONE LINE SEQUENCE NUMBER
WILL BE GENERATED.
^TO PREMATURELY END THE GENERATION OF LINE SEQUENCE
NUMBERS, THE ALTMODE CHARACTER (ECHOED AS $) IS TYPED ON THE
LINE FOLLOWED BY A ^^RETURN\\.  ^FOR EXAMPLE:
.S 1
.LM 10
.NF
^^
READY
GEN 10,,40
10 LET A=1
20 LET B=23
30 LET C=PI/2
40 FOR J = 1 TO 10
READY
GEN 60
60 D=SIN(J*C)
70 PRINT D
80 NEXT J
90$
READY
.LM 0
.F
\\
.S 2
.ST BASIC DEBUGGER
.PG
.C
BASIC DEBUGGER
.S 3
.P 5
^THIS IS A NEW RELEASE OF THE BASIC DEBUGGING TECHNIQUE (BASDDT).
MOST BASIC STATEMENTS ARE NOW INCLUDED.  BASDDT OCCUPIES ITS
OWN HIGH SEGMENT (11K) AND IN NO WAY AFFECTS RUNNING PROGRAMS
WHEN NOT USED.
.S 1
^^A)##BASDDT CONTROL COMMANDS
.S 1
.P 5
^THERE ARE SIX BASDDT CONTROL COMMANDS.  THESE COMMANDS MAY BE
ABBREVIATED TO THE FIRST THREE CHARACTERS.  AS THE NAME IMPLIES, THEY
CONTROL THE ACTION OF BASDDT.  THE BASDDT CONTROL COMMANDS MAY NOT BE 
USED IN MULTIPLE STATEMENT LINES, NOR MAY THEY BE USED IN CONJUNCTION
WITH BASDDT STATEMENTS,  THEY ARE INTENDED ONLY FOR SINGLE,
IMMEDIATE ACTION.
.S 1
.LM 10
1)##^^START N######(W\\HERE ^N IS OPTIONAL LINE NUMBER)
.S 1
^THIS COMMAND INITIALIZES BASDDT AND MUST BE USED TO
BEGIN EXECUTION OF THE PROGRAM.  PRIOR TO THE START
COMMAND, ONLY BASDDT CONTROL COMMANDS (WITH THE EXCEPTION OF
CONTINUE) ARE LEGAL.  WHEN BASDDT IS INVOKED WITH THE
EDIT COMMAND DDT(NH), BASDDT WILL RESPOND WITH:
.S 1
[BASDDT EXECUTION]
.S 1
>
.S 1
AFTER COMPILATION OF THE PROGRAM.  AT THIS POINT, IT IS
READY TO RECIEVE AND PROCESS COMMANDS.  WHENEVER THE RIGHT
ANGLE BRACKET APPEARS, BASDDT IS WAITING FOR INPUT OF A 
COMMAND OR STATEMENT.  WHEN THE USER IS READY TO BEGIN
EXECUTION OF THE PROGRAM (I.E. AFTER SETTING STOPS), HE 
SHOULD ISSUE THE START COMMAND.  THE PROGRAM WILL OPTIONNALLY
BEGIN 1) AT THE LINE NUMBER SPECIFIED IN THE START COMMAND, IF
ONE WAS INCLUDED, 2) AT THE LINE NUMBER SPECIFIED IN THE
DDT(NH) COMMAND OR 3) AT THE FIRST EXECUTABLE STATEMENT.
.S 1
2)##^^STOP N(,M,L...)\\######	(WHERE N,M,L... ARE LINE NUMBERS)
.S 1
.P 5
EXECUTION OF THE BASIC PROGRAM MAY BE SUSPENDED AT
VARIOUS LINE NUMBERS THROUGHOUT THE PROGRAM THROUGH USE OF THE
STOP COMMAND.  STOP TAKES AS ITS ARGUMENT A LIST OF LINE
NUMBERS SEPARATED BY COMMAS.  THE LINE NUMBERS MUST EXIST IN
THE USER PROGRAM.  THERE IS NO LIMIT TO THE NUMBER OF STOPS
A USER MAY HAVE.  SETTING STOPS AT NON-EXECUTABLE STATEMENTS
WILL CAUSE A STOP AT THE NEXT EXECUTABLE
STATEMENT.  WHEN A STOP IS REACHED, BASDDT WILL INFORM THE
USER AT WHICH LINE THE STOP OCCURRED.  THE STOP WILL OCCUR
PRIOR TO EXECUTION OF THAT LINE NUMBER. EXAMPLE:
.S 1
.NF
>STOP 90
>START
<STOP>_# 90
>
.S 2
.F
.TP 6
3)##CONTINUE N######(WHERE N IS OPTIONAL LINE NUMBER)
.S 1
.P 5
CONTINUE IS USED TO PROCEED FROM A STOP.  IF N
IS SPECIFIED, CONTROL WILL GO TO THAT LINE NUMBER.  HOWEVER,
UNLIKE THE BASDDT GOTO STATEMENT, CONTINUE DOES NOT CHECK
IF THE LINE NUMBER IS WITHIN A FOR-NEXT LOOP, FUNCTION OR
GOSUB ROUTINE.  CONTINUE IS AN UNCONDITIONAL TRANSFER.
EXAMPLE:
.S 1
.NF
>STOP 90,50,150
>START
<STOP>_# 50
>CONT
<STOP>_# 90
.F
.S 2
4)##LIST
.S 1
.P 5
LIST (TAKES NO ARGUMENTS) WILL PRINT ON THE USER'S
TELETYPE A LIST OF ALL PROGRAM STOPS.  EXAMPLE:
.S 1
.NF
>LIST
STOPS:####50	90	150
>
.S 1
.F
5)##REMOVE N(,M,L,...)######(WHERE N,M,L,.. ARE LINE NUMBERS)
.S 1
.P 5
REMOVE IS USED TO REMOVE A PREVIOUS PLACED STOP IN
THE USER'S PROGRAM.  IF NO ARGUMENT IS SPECIFIED, ALL
STOPS ARE REMOVED.  REMOVING A NON-EXISTENT STOP IS
CONSIDERED A NO-OP.  EXAMPLE:
.S 1
.NF
>LIST
STOPS:####50	90	150
>REMOVE 90
>LIST
STOPS:####50	150
.S 1
.F
6)##DECLARE V1(,V2,V3,V4,V5)######(WHERE V1-V5 ARE VARIABLE NAMES)
.S 1
.P 5
FOR YOUR CONVIENCE, FIVE SCALAR LOCATIONS HAVE BEEN
STORED TO USE AS AN AID TO DEBUGGING.  BEFORE THEY CAN BE
REFERENCED, THEY MUST BE ASSIGNED A LEGAL BASIC SCALAR NAME
THROUGH USE OF THE DECLARE COMMAND.  ONCE A VARIABLE
NAME HAS BEEN DECLARED, IT CANNOT BE REMOVED.  EXAMPLE:
.S 1
.NF
>DECLARE T1,T4
>LET T1=5 _\ T4=1
>PRINT T1;T4
#5 1
>
.S 2
.F
.I -10
^^B)##BASDDT STATEMENTS\\
.S 1
.P 5
THE FOLLOWING STATEMENTS CAUSE A SPECIFIC ACTION TO OCCUR.
EXCEPT WHERE NOTED, THEY ARE EXACTLY ALIKE IN NATURE
TO THE NORMAL BASIC STATEMENT EXCEPT THEY ARE EXECUTED
IMMEDIATELY.  MULTIPLE STATEMENT LINES AND MULTIPLE LINE
STATEMENTS ARE ALSO LEGAL IN BASDDT.  TWO BACKSLAHES IN
BASDDT ARE USED TO END CONTROL OF AN IF-THEN OR IF-THEN-ELSE.
EXAMPLE:
.S 1
>IF A = B THEN C=1 _\ B=2 _\ D=4
.S 1
IN THIS CASE, IF A DOES NOT EQUAL B, NO STATEMENTS WILL BE
EXECUTED.  HOWEVER, IN THE FOLLOWING EXAMPLE:
.S 1
>IF A = B THEN C=1 _\_\ B=2 _\ D = 4
.S 1
	B=2 AND D=4 WILL BE EXECUTED REGARDLESS OF THE OUTCOME
OF IF A = B.
.S 2
.NF
.LM 0
.TAB STOPS 1,17,33
STATEMENT	AVAILABLE	BASIC-BASDDT DIFFERENCE
.S 1
DATA	NO
READ	YES	NONE
PRINT	YES	NONE
LET	YES	NONE
GOTO	YES	NONE
IF-THEN	YES	USE OF TWO BACKSLASHES
IF-THEN-ELSE	YES	USE OF TWO BACKSLASHES
FOR-NEXT	YES	NONE
ON-GOTO	YES	NONE
ON-GOSUB	YES	NONE
DIM	NO
END	YES	EXITS TO EDIT MODE WITH RUNTIME MESSAGE
GOSUB	YES	NONE
INPUT	YES	NONE
STOP	NO	BASDDT CONTROL COMMAND
REM	NO	BASDDT CONTROL COMMAND FOR REMOVE
RESTORE	YES	NONE
CHANGE	YES	NONE
CHAIN	YES	CHAINED PROGRAM WILL ALSO HAVE BASDDT
MARGIN	YES	NONE
PAGE	YES	NONE
NOPAGE	YES	NONE
QUOTE	YES	NONE
NOQUOTE	YES	NONE
PRINT USING	YES	NONE
FILES	NO
FILE	NO	USE OPEN INSTEAD
OPEN	YES	NONE
CLOSE	YES	NONE
SCRATCH	YES	NONE
WRITE	YES	NONE
IF END	YES	NONE
SET	YES	NONE
.S 1
.F
ALL MATRIX INSTRUCTIONS AND FUNCTIONS ARE IMPLEMENTED.
.S 1
ALL STATEMENT MODIFIERS ARE IMPLEMENTED.
.S 1
IN ADDTION, THE BASDDT STATEMENT, BASDDT, HAS BEEN ADDED.  IT WILL
TRANSFER CONTROL TO BASDDT INPUT LEVEL.  EXAMPLE:
.S 1
.NF
.LM 10
>FOR I = 1 TO 10 _\ IF X2 > 30 THEN BASDDT _\ X2=X2+X1_^2 _\ NEXT I
>PRINT X2,I
31         8
>
.F
.LM 0
.S 2
C)##^CONTROL-C
.S 1
.P 5
^THE CONTROL-C (_^C) HAS DIFFERENT ACTIONS DEPENDING
UPON WHERE IT IS GIVEN.  AT THE INPUT LEVEL (I.E. WHEN THE
RIGHT ANGLE BRACKET IS DISPLAYED), A CONTROL-C CAUSES
AN IMMEDIATE RETURN TO EDIT LEVEL WITH NO RUNTIME MESSAGE
PRINTED.  WHEN THE CONTROL-C IS GIVEN DURING THE EXECUTION
OF THE USER'S PROGRAM OR BASDDT STATMENTS, CONTROL WILL
RETURN TO BASDDT INPUT LEVEL.  THE LINE FUNCTION CAN BE
USED TO DETERMINE WHERE CONTROL WAS INTERRUPTED.  EXAMPLE
.S 1
.NF
>CONT
_^C
_^C
>PRINT LINE
#50
.S 1
.F
WARNING- - -THE STATEMENT BEING EXECUTED MAY BE INTERRUPTED
BEFORE COMPLETION AND PARTIAL ANSWERS MAY OCCUR.
THE CONTINUE COMMAND WITHOUT A LINE NUMBER IS ILLEGAL
AFTER A CONTROL-C.
.S 2
D)##EXECUTION ERRORS
.S 1
ANY PROGRAM EXECUTION ERRORS RESULT IN A RETURN TO BASDDT
INPUT LEVEL AFTER THE PRINTING OF THE MESSAGE.  THE CONTINUE
COMMAND WITHOUT A LINE NUMBER IS ILLEGAL.
