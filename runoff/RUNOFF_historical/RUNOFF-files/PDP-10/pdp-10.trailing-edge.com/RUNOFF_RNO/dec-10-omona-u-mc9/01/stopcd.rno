.SP 1
.PS 64,70
.F
.J
.LM 0
.RM 70
.TS 10,35,45
.PG
^^SPECIFICATION\\
.FG 5;.C
^^STOPCD
.B 1;.C
LIST OF MONITOR ERROR STOPS\\
.B 10;.LM 20
^DATE:#####^JULY,#1975
.BR
^FILE:#####^^STOPCD.RNO\\
.BR
^EDITION:##3
.B10;.LM0;.RM70
^THIS DOCUMENT REFLECTS THE 6.02 RELEASE OF THE MONITOR.
.B 1
^THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT NOTICE
AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY ^DIGITAL ^EQUIPMENT ^CORPORATION.
^DIGITAL ^EQUIPMENT ^CORPORATION ASSUMES NO RESPONSIBILITY FOR ANY
ERRORS THAT MAY APPEAR IN THIS MANUAL.
.B1
^THE SOFTWARE DESCRIBED IN THIS DOCUMENT IS FURNISHED TO THE
PURCHASER UNDER A LICENSE FOR USE ON A SINGLE COMPUTER
SYSTEM AND CAN BE COPIED (WITH INCLUSION OF ^^DIGITAL\\'S 
COPYRIGHT NOTICE) ONLY FOR USE IN SUCH SYSTEM, EXCEPT AS
MAY OTHERWISE BE PROVIDED IN WRITING BY ^^DIGITAL\\.
.B1
^DIGITAL ^EQUIPMENT ^CORPORATION ASSUMES NO RESPONSIBILITY
FOR THE USE OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT THAT
IS NOT SUPPLIED BY ^^DIGITAL\\.
.B3
^COPYRIGHT##^C##1971, 1972, 1973, 1974, 1975, BY 
^DIGITAL ^EQUIPMENT ^CORPORATION, ^MAYNARD, ^MASSACHUSETTS
.PG;.LM 0;.RM 70
1.0##^^INTRODUCTION\\
.B 1
^THIS DOCUMENT DESCRIBES THE DIFFERENT TYPES OF ERROR STOPS IN THE
MONITOR AND THEN LISTS ALL THE ERROR STOPS THAT CAN OCCUR.
  ^WHEN THE MONITOR DETECTS AN INTERNAL ERROR IT
EXECUTES THE ^^STOPCD\\ MACRO WHICH PRODUCES  
A MESSAGE OF THE FORM:
.B 1;.I 10
?^^CPU\\N#^^MONITOR ERROR.  STOPCODE NAME\\ XXX
.B 1
WHERE N IS THE NUMBER OF THE ^^CPU\\ THAT EXECUTED THE ^^STOPCD\\
MACRO AND XXX IS A MNEMONIC IN THE ^^STOPCD\\ MACRO.  ^THESE MNEMONICS
ARE LISTED IN ^SECTION 2.0 OF THIS DOCUMENT.  ^ALSO LISTED ARE THE NAME OF THE
MONITOR MODULE CONTAINING THE ^^STOPCD\\, THE TYPE OF
^^STOPCD\\, AND A BRIEF EXPLANATION.
.B 1
^THERE ARE FOUR TYPES OF ^^STOPCD\\'S:
.B 1;.LM 9;.I -4
1.##^^DEBUG\\#-# ^IF A PRIORITY INTERRUPT IS IN PROGRESS, 
THE CONDITION IS NOT IMMEDIATELY HARMFUL TO
ANY JOB OR TO THE SYSTEM.  ^THE MONITOR TRANSMITS THE FOLLOWING
MESSAGE TO THE ^^CTY\\:
.B 1;.LM 14
^^?CPU\\N ^^MONITOR ERROR. STOPCODE NAME\\ XXX
.BR
^^CONTINUING SYSTEM\\
.B 1;.LM 9
AND CONTINUES.  ^NO IMMEDIATE OPERATOR ACTION IS REQUIRED.
.B 1
^IF NO PRIORITY INTERRUPT IS IN PROGRESS, A ^^DEBUG STOPCD\\
ACTS AND COUNTS AS A ^^JOB STOPCD\\.
.B 1;.I -4
2.##^^JOB\\#-# ^IF NO PRIORITY INTERRUPT IS IN PROGRESS,
 THE CONDITION JEOPARDIZES THE INTEGRITY OF THE
CURRENT JOB.  ^THE MONITOR TRANSMITS THE FOLLOWING MESSAGE TO THE
^^CTY\\:
.B 1;.LM 14
^^?CPU\\N ^^MONITOR ERROR. STOPCODE NAME\\ XXX
.BR
?^^ABORTING JOB\\
.B 1;.LM 9
AND ANOTHER MESSAGE TO THE USER'S TERMINAL:
.B1;.I 5
?^^MONITOR ERROR; UUO AT\\ XXXXXXXX
.B 1
WHERE XXXXXXXX IS ONE OF THE FOLLOWING:
.B 1;.I 5
^^USER LOC\\ N
.I 5
^^EXEC LOC\\ N; ^^EXEC CALLED FROM EXEC LOC\\ M
.I 5
^^EXEC LOC\\ N; ^^EXEC CALLED FROM USER LOC\\ M
.B 1
^THE MONITOR THEN ABORTS THE CURRENT JOB AND CONTINUES.
^NO IMMEDIATE OPERATOR ACTION IS REQUIRED.
.B 1
^IF A PRIORITY INTERRUPT IS IN PROGRESS, A ^^JOB STOPCD\\ 
ACTS LIKE A ^^STOP STOPCD\\.
.B 1;.I -4
3.##^^STOP\\#-#^THE CONDITION JEOPARDIZES THE INTEGRITY OF THE
SYSTEM AS A WHOLE.  ^THE MONITOR TRANSMITS THE FOLLOWING MESSAGE
TO THE ^^CTY\\:
.B 1;.LM 14
^^?CPU\\N ^^MONITOR ERROR.  STOPCODE NAME\\ XXX
.BR
^^RELOAD MONITOR\\
.B 1;.LM 9
^ALL JOBS ARE ABORTED AND THE SYSTEM INITIATES AN AUTOMATIC RELOAD
OF THE MONITOR.
.B 1;.I -4
4.##^^HALT\\#-#^THE CONDITION IS SO SERIOUS THAT THE ENTIRE SYSTEM
IS AFFECTED AND THE MONITOR CANNOT BE RELOADED AUTOMATICALLY.
^THE SYSTEM HALTS REQUIRING THAT THE OPERATOR MANUALLY PERFORM
THE ENTIRE ^^CRASH\\ PROCEDURE AS DESCRIBED IN THE ^SOFTWARE ^NOTEBOOKS
 IN THE ^OPERATOR'S
^PROCEDURE ENTITLED ^^CRASH\\, ^SAVING A ^CRASHED ^MONITOR AND
^RESTARTING, OR IN ^CHAPTER 5 OF THE ^OPERATOR'S ^GUIDE.
.B 3;.LM 5
^IN ADDITION, IF THE MONITOR CAN DETERMINE THE INFORMATION,  A SUPPLEMENTARY MESSAGE:
.B 1;.LM 9
^^JOB\\ N ^^ON TTY\\XXX ^^RUNNING\\ XXXXXX
.BR
^^UUO IS\\ XXXXXXXXXXXX ^^AT USER PC\\ XXXXXX
.BR
^^FILE\\ DEV:FILE.EXT[N,M]
.B 1;.LM 5
IS  TRANSMITTED TO THE ^^CTY\\ AFTER ^^?CPU\\N ^^MONITOR ERROR\\ IN ORDER TO HELP
THE OPERATOR FIND THE USER CAUSING THE PROBLEM.
.B 3;.LM 0
1.1##^^FINDING THE ^^STOPCD'S IN THE ^CODE\\
.B 1
^SOMETIMES ^^STOPCD\\'S COME UP WHICH ARE NOT DOCUMENTED.
^THIS MAY BE THE RESULT OF PATCHES SPECIFIC TO AN INSTALLATION
OR PATCHES MADE AFTER THE RELEASE OF THE MONITOR.
.B 1
^IF A ^^STOPCD\\ MESSAGE COMES UP WHICH CAN NOT BE FOUND
IN THIS MANUAL, THE FOLLOWING PROCEDURE MAY BE USED TO FIND THE
PLACE IN THE CODE WHERE THE ^^STOPCD\\ OCCURRED.
.B 1
^FIRST, CONSULT THE  LISTING OF THE MONITOR'S GLOBAL SYMBOLS
^^(GLOB\\).  ^THE
^^STOPCD\\'S ARE LISTED AS:
.B 1;.LM 20;.I -20
^^S..XXX#####MODNAM\\###WHERE ^^XXX\\ IS THE MNEMONIC FOR THE
^^STOPCD\\ AND ^^MODNAM\\ IS THE NAME OF THE MODULE WHERE
THE ^^STOPCD\\ IS CODED.
.B 1;.LM 0
^BY CHECKING THE ^^CREF\\ LISTING FOR THE GIVEN MODULE, THE
PROGRAMMER CAN DETERMINE THE LINE NUMBER WHERE THE ^^STOPCD\\
CAN BE FOUND.  ^THE COMMENTARY THAT CAN BE FOUND IN THE CODE IS
SOMETIMES SUFFICIENT FOR DETERMINING HOW AN ERROR OCCURRED.
.B 3
1.2##^^HOW TO SET THE MONITOR TO RELOAD ON DEBUG AND JOB STOPCD'S.\\
.B 1
^AS AN ADDED AID TO DEBUGGING IT IS POSSIBLE TO CAUSE A RELOAD ON ALL ^^STOPCD\\'S.
.B 1
^THERE ARE TWO WAYS IN WHICH THE SYSTEM PROGRAMMER CAN SET THE MONITOR TO RELOAD ON
EITHER THE ^^DEBUG\\ OR THE ^^JOB STOPCD\\'S.
^BOTH TECHNIQUES INVOLVE THE SETTING OF BITS FOR THE SYMBOL ^^DEBUGF\\ OR ^^DEFDEB\\.  ^THIS CAN BE DONE 
BY CHANGING THE CONTENTS OF ^^DEBUGF\\ WITH
^^FILDDT\\  OR ^^EDDT\\, OR DEFINING ^^DEFDEB\\ WITH ^^MONGEN\\. ^THE BIT VALUES ARE:
.B1;.LM21;.TS21;.I-11
BIT#0#=#1	^THIS ALLOWS SYSTEM DEBUGGING IF ^^EDDT\\ IS AVAILABLE ON THE SYSTEM.
^IF BIT 0 = 0, A RELOAD WILL OCCUR ON ALL ^^STOP STOPCD\\'S, 
IF THE SYSTEM HAS BEEN UP AT LEAST 5 MINUTES.
.B 1;.I -11
BIT#1#=#1	^THIS CAUSES A RELOAD ON ALL ^^DEBUG STOPCD\\'S.
.B 1;.I -11
BIT#2#=#1	^THIS CAUSES A RELOAD ON ALL ^^JOB STOPCD\\'S.
.B 1;.I -11
BIT#3#=#1	^THIS DISABLES AUTO RELOAD.
.B 1;.I -11
BIT#4#=#1	^THIS STOPS THE SYSTEM IF ^^CPU1\\ HALTS.
.B 2
.LM 0
^THE FOLLOWING COMMAND SEQUENCE SHOULD BE USED TO SET THE BITS THROUGH ^^FILDDT\\:
.B 1;.LM 36;.TS 36;.I -31
_.^^R FILDDT
.B 1;.I -31
FILE:##SYSTEM/S\\	;#THIS LOADS THE SYMBOL TABLE
.B 1;.I -31
^^FILE:##/M/P\\	;#ENABLES THE USER TO POKE 
.BR
;#LOCATIONS
.BR
;#IN THE RUNNING MONITOR.
.B 1;.I -31
^^DEBUGF\\/300000,,0	;#THIS TURNS ON BOTH BITS 1 AND 2
.BR
;#SO THERE WILL BE A RELOAD ON ALL 
.BR
;#^^STOPCD\\'S
.I-31
_^^^Z	;#EXIT\\
.B 1;.LM 0
^THE SAME THING MAY BE ACCOMPLISHED AT ^^MONGEN\\ TIME.
^WHEN THE HARDWARE CONFIGURATION  DIALOGUE ASKS FOR:
.B1;.I10
^^OCTAL  "SYMBOL,  VALUE"\\
.B 1
THE PROGRAMMER SHOULD ENTER:##^^DEFDEB,##300000000000.\\
.B 1
^IF ^^FILDDT\\ WAS USED  TO EFFECT THIS CHANGE ON THE RUNNING
MONITOR,  ANY CRASHES WIPE OUT THE CHANGE.
^HOWEVER, IF ^^MONGEN\\ WAS USED, THE CHANGE IS STILL IN EFFECT WHEN THE MONITOR IS RELOADED.
^IT IS ALSO POSSIBLE TO PATCH A COPY OF THE 
 MONITOR ON DISK  WITH ^^DDT\\ OR ^^FILDDT\\ TO MAKE THE CHANGE
EFFECTIVE AFTER RELOADS.
.PG;.TS 8,19,44
2.0##^^STOPCODES\\
.B 1
^^NAME	ROUTINE	TYPE	DESCRIPTION\\
.B 2;.LM 30;.TS 8,19,30;.I -30
28^B	^^XTCSER	DEBUG\\	^THE ^^DA28\\ COMMAND REGISTER
CONTAINED ERRONEOUS STATUS BITS DURING AN ^^I/O\\ OPERATION.
.B 1;.I -30
4^^IF	FSXKON	DEBUG\\	"^^RP04 INVALID FUNCTION".\\  ^^FILIO\\ TRIED 
TO DO AN ^^RP04\\ ONLY FUNCTION ON AN ^^RS04\\ LIKE ^^ECC\\
ERROR RECOVERY OR AN UNLOAD.
.B 1;.I -30
^^5WE	D85INT	DEBUG	"DC75 WRONG PDP11 CODE".\\ ^THE ^^PDP11\\
DESIGNATED AS A ^^DC75\\ WAS NOT RUNNING THE PROPER CODE.
.B 1;.I -30
^^6MS	D76INT	DEBUG\\	^^"DC76 MESSAGE IS SHORT".\\  ^A PORTION OF A MESSAGE WAS LOST BETWEEN THE ^^DC76\\ AND THE -10.
.B 1;.I -30
^^6PP	D76INT	STOP\\	"^^DC76 PUTTER PROBLEM".\\	^THERE WAS AN INTERRUPT LEVEL CALL TO PUTTER
WHILE A NON-INTERRUPT CALL WAS IN PROGRESS.
.B 1;.I -30
^^6QF	D76INT	DEBUG\\	^^"DC76 QUEUE FULL".\\  ^THE QUEUE OF MESSAGES TO THE ^^DC76\\ WAS FULL.  
^THE QUEUE WAS DESIGNED TO BE BIG ENOUGH TO HOLD THE WORST CASE MESSAGES.
.B 1;.I -30
^^AAD	FILFND	DEBUG	"ACCESS TABLE ALREADY DORMANT".\\
^AN ATTEMPT WAS MADE TO UNLINK AN ACCESS TABLE FROM AN ^^NMB\\
RING, BUT THE ACCESS TABLE WAS ALREADY DORMANT.
.B 1;.I -30
^^AAO	KISER	JOB	"ACCESS ALLOWED OFF"\\.
^WHEN THE# MONITOR
.I -30
	^^KLSER\\		WAS REMAPPING ^^IOWD\\'S FROM USER VIRTUAL
ADDRESSES TO PHYSICAL ADDRESSES, A PAGE MAP ENTRY
FETCHED FROM THE USER'S PAGE MAP HAD THE ACCESS ALLOWED BIT OFF
(VIRTUAL MEMORY MONITOR ONLY).
.B 1;.I -30
^^AES	FILFND	JOB	"ABNORMAL END OF SEARCH LIST".  FILFND\\
GOT TO THE END OF THE SEARCH LIST WHEN IT DID NOT EXPECT TO BE THERE.
.B1;.I-30
^^AHB	FILIO	DEBUG	"ALREADY HAVE BUFFER".\\ ^THE MONITOR 
 ATTEMPTED TO GET A MONITOR BUFFER WHEN IT ALREADY HAD ONE.
.B 1;.I -30
^^AHS	ONCMOD	HALT	"ALREADY HAVE STRUCTURE".\\  ^THE TABLES WHICH DRIVE ^^ONCMOD\\'S '^^DESTROY\\' OPTION DUPLICATED A
STRUCTURE NAME.
.B 1;.I -30
^^AOC	FILFND	DEBUG	"ALREADY OWN CB".\\ ^A JOB WANTED THE 
^^CB\\ RESOURCE BUT ALREADY HAD IT.
.B 1;.I -30
^^APE	KISER	JOB\\	"^^ABSOLUTE##PAGE#EXCEEDED".\\##^^MAPIO\\##FOUND
.I -22
^^KLSER\\		AN ^^IOWD\\ WHICH WOULD HAVE CAUSED AN ADDRESS CHECK.
^ALL ^^IOWD\\'S HAVE BEEN CHECKED PRIOR TO CALLING ^^MAPIO\\.
.B 1;.I -30
^^APF	VMSER	DEBUG	"ALLOCATED PAGE FREE".\\  ^WHILE 
THE PAGES ALLOCATED TO A SEGMENT WERE BEING SCANNED, A PAGE ON THE FREE
CORE LIST WAS ENCOUNTERED.
.B 1;.I -30
^^AR1	ONCMOD	DEBUG	"ASKDEC RETURNED CPOPJ1".\\ ^^ASKDEC\\ GAVE A SKIP RETURN WHEN ONE WAS NOT EXPECTED.
.B 1;.I -30
^^ARF	KISER	STOP	"ATTEMPT#TO#RETURN#FREE#PAGE".\\###^A##PAGE
.I -22
^^KLSER\\		THAT WAS GOING TO BE RETURNED TO THE FREE CORE LIST
WAS ALREADY FREE.
.B 1;.I -30
^^BAC	CORE1	JOB	"BIT ALREADY CLEAR".\\ ^AN ATTEMPT WAS MADE TO ZERO
BITS WHICH WERE NOT ONE.  ^THIS IS THE ^^SETZRS\\ ROUTINE
WHICH IS CALLED FROM MANY MODULES.
.B 1;.I -30
^^BAD	FILFND	JOB	"BLOCK ALREADY DORMANT".\\ ^AN ATTEMPT
WAS MADE TO PUT AN ALREADY DORMANT ACCESS TABLE IN THE FREE CORE LIST.
.B 1;.I -30
^^BAO	FILIO	DEBUG	"BIT ALREADY ONE".\\  ^THE MONITOR TRIED TO ALLOCATE A BLOCK WHICH WAS ALREADY ALLOCATED.
.B 1;.I -30
^^BAZ	FILIO	DEBUG	"BIT ALREADY ZERO"\\.  ^THE MONITOR
ATTEMPTED TO RETURN BLOCKS WHICH WERE ALREADY FREE.
^THIS HAPPENS WHEN A DAMAGED FILE IS DELETED.
.B 1;.I -30
^^BFO	TAPUUO	DEBUG	"BETTER FIND ONE".\\ ^WHEN AN ATTEMPT WAS MADE
TO GENERATE THE TRANSFER LIST FOR READ BACKWARDS, THE END OF THE ORIGINAL TRANSFER LIST COULD
NOT BE FOUND.
.B 1;.I -30
^^BFU	NETSER	DEBUG	"BUSY FOULED UP".\\ ^MORE THAN ONE BUFFER GOT ALLOCATED TO THE ^^DC75\\ OR ^^DAS85\\.
.B 1;.I -30
^^BMR	FILUUO	JOB	"BLOCK MISSING FROM RIB".\\  ^A BLOCK
IN THE FILE WAS NOT POINTED TO BY THE ^^RIB\\.
.B 1;.I -30
^^BNF	COMMON	HALT	"BOOTS NOT FOUND".\\
^^BOOTS\\ COULD NOT BE FOUND ON DISK.
.B 1;.I -30
^^BNR	FILUUO	JOB	"BLOCK NOT IN RIB".\\  ^A POINTER WAS LOST FROM THE ^^RIB\\.
.B 1;.I -30
^^BNT	FILFND	DEBUG	"BLOCK NOT THERE".\\  ^A CORE BLOCK (^A.^T. OR ^^UFB\\) WHICH WAS KNOWN TO EXIST COULD NOT BE FOUND.
.B 1;.I -30
^^BNZ	CORE1	DEBUG	"BIT NOT ZERO".\\  ^A CALL TO ^^CSETOS\\
ATTEMPTED TO SET A BIT WHICH WAS ALREADY ONE.
.B 1;.I -30
^^BPT	FILFND	JOB	"BAD SEARCH LIST POINTER".\\ ^A SEARCH
LIST COULD NOT BE BUILT.
.B 1;.I -30
^^BRC	COMCON	DEBUG	"BAD RETURN FROM CMPBIT".\\ ^WHEN THE FLAG BITS FOR THE DIRECTORY ENTRY WERE BEING COMPUTED,
A NONEXISTENT PAGE WAS FOUND.
.B 1;.I -30
^^BSN	SEGCON	STOP	"BAD SEGMENT NUMBER".\\ ^THERE WAS A HIGH
SEGMENT NUMBER DISCREPANCY.
.B 1;.I -30
^^BSY	XTCSER	DEBUG\\	^THE ^^DA28\\ INTERRUPTED WITH THE BUSY FLAG SET.
.B 1;.I -30
^^BTL	SCNSER	STOP	"BACKWARD TTY LINK".\\  ^THE ^^TTY\\ BUFFER WAS LINKED IMPROPERLY CAUSING
THE ROUTINE TO WRITE OVER A PREVIOUSLY RECEIVED CHARACTER.
.B 1;.I -30
^^BWA	FILIO	JOB	"BLOCK WENT AWAY".\\  ^A BLOCK THAT WAS ALLOCATED WAS NOT THERE ANYMORE.
.B 1;.I -30
^^C0P	COMMON	DEBUG	"CPU0 PARITY".\\ ^ON ^^CPU0\\ THERE WAS A PARITY
ERROR WITH NO PARITY ERROR RECOVERY CODE, AN ^^I/O\\ PAGE FAILURE,
OR A TIMER TIME-OUT.
.B 1;.I -30
^^C1N	CP1SER	DEBUG	"CPU1 NXM".\\
^NONEXISTENT MEMORY WAS ENCOUNTERED ON ^^CPU1\\.
.B 1;.I -30
^^C1P	COMMON	DEBUG	"CPU1 PARITY".\\ ^ON ^^CPU1\\ THERE WAS
A PARITY ERROR WITH NO PARITY ERROR RECOVERY CODE, AN ^^I/O\\ PAGE FAILURE, OR A
TIMER TIME-OUT.
.B 1;.I -30
^^CAO	FILUUO	DEBUG	"CLUSTER ADDRESS ODD".\\
^A CLUSTER ADDRESS COULD NOT BE CONVERTED TO A DISK BLOCK NUMBER.
.B 1;.I -30
^^CAS	REFSTR	HALT	"COULDN'T ALLOCATE SPACE".\\  ^THE REFRESHER FILLED THE DISK.
.B 1;.I -30
^^CDD	MSGSER	JOB	"CAN'T DISCONNECT DEVICE".\\  ^THE RELEASE
CALL ON ^^MPX\\ CALLED DISCONNECT AND DISCONNECT FAILED
WITH AN ILLEGAL FORMAT OR THE DEVICE NOT CONNECTED.
.B 1;.I -30
^^CFP	CLOCK1	JOB	"CAN'T FIND PDB".\\  ^^JBTPDB(J)=0\\ AT ^^SETR2\\
IN A MONITOR WHICH DOES NOT SWAP ^^PDB\\'S.
.B 1;.I -30
^^CGS	ONCMOD	HALT	"CAN NOT GET STR".\\  ^THE ^^DESTROY\\
OPTION COULD NOT CREATE A STRUCTURE DATA BLOCK.
.B 1;.I -30
^^CIF	FHXKON	DEBUG	"RC10 IS NOT FANCY".\\ ^AN ^^RP04\\
FUNCTION WAS ATTEMPTED ON AN ^^RC10\\ CONTROLLED DEVICE.
.B 1;.I -30
^^CIO	REFSTR	DEBUG	"CFP IS ODD".\\  ^THE REFRESHER NOTICED
THE NUMBER OF BLOCKS PER CLUSTER DID NOT DIVIDE INTO THE 
NUMBER OF BLOCKS PER SUPERCLUSTER.
.B 1;.I -30
^^CL0	SCNSER	STOP	"CHUNK LINK TO 0".\\  ^THE ^^TTY\\ CHUNKS
WERE MESSED UP.
.B 1;.I -30
^^CME	FILFND	DEBUG	"CFP MODULO ERROR".\\  ^^CFP\\ DID
NOT START AT AN EVEN SUPERCLUSTER BOUNDARY.
.PG
.B1;.I-30
^^CMS	VMSER	DEBUG	"CORE1 MUST SKIP". CORE1\\ GAVE A NONSKIP
RETURN WHEN ASKED FOR CORE IN USE.
.B 1;.I -30
^^CMU	SEGCON	STOP	"CORE MESSED UP".\\  ^^CHKTAL\\ FOUND
THAT THE MONITOR'S CORE USAGE TABLES DID NOT CHECK WITH EACH OTHER.
.B 1;.I -30
^^CNA	SCHED1	STOP	"CORE NOT AVAILABLE".\\  ^THE CORE ALLOCATION
ROUTINE GAVE AN ERROR RETURN WHILE ATTEMPTING TO ALLOCATE
CORE FOR A SWAP-IN, AFTER IT HAD BEEN VERIFIED THAT ENOUGH CORE
WAS AVAILABLE.
.B 1;.I -30
^^CNE	FILUUO	DEBUG	"CLUSTER NOT EVEN".\\  ^WHEN AN ATTEMPT WAS MADE
TO ALLOCATE INITIAL BLOCKS FOR A FILE, THE BLOCK WHICH WAS
COMPUTED AS THE START OF A SUPERCLUSTER DID NOT START AT AN
EVEN SUPERCLUSTER ADDRESS.
.B 1;.I -30
^^CRE	TAPSER	DEBUG	"CANNOT RECOVER ERROR".\\ ^THE ERROR RECOVERY
PROCEDURE WAS CALLED WITH AN ^I/^O REQUEST BLOCK ALREADY MARKED NONRECOVERABLE.
.B1;.I-30
^^CRP	CORE1	JOB	"CANNOT RETURN PUSH DOWN LIST". GIVEPL\\
WAS CALLED AND THE PUSH DOWN LIST WOULD NOT FIT BACK INTO THE
JOB DATA AREA.
.B1;.I-30
^^CRW	KILOCK	STOP	"CA RESOURCE WRONG".\\ ^THE ^C^A REQUEST WAS NOT
NEGATIVE. ^THE INTERLOCK ON THE ^^LOCK\\ CALL WAS NOT AVAILABLE, BUT
NO ONE WAS DOING A ^^LOCK\\ CALL.
.B1;.I-30
^^CSA	COMCON	DEBUG	"CANNOT SET ACCESS ALLOWED".\\ ^DURING THE
SAVE OF AN ^^EXE\\ FILE A PAGE WAS PAGED IN BUT HAD ITS ACCESS
ALLOWED BIT OFF. ^AN ATTEMPT TO TURN THAT BIT ON FAILED
(VIRTUAL MEMORY MONITOR ONLY).
.B1;.I-30
^^CSE	FILIO	STOP	"CHECKSUM ERROR".\\ ^THE WORD POINTED TO FOR 
CHECKSUMMING WAS NOT IN THE USER'S ADDRESS SPACE.
.B1;.I-30
^^CWN	NETSER	DEBUG	"CORE ALLOCATION WENT NEGATIVE". ^^NETSER\\
ATTEMPTED TO GIVE BACK MORE FREE CORE THAN IT HAD.
.B 1;.I -30
^^DBZ	FILIO	DEBUG	"DEPLPC BIT ZERO".\\  ^THE LAST GROUP OF POINTERS FOR A FILE WAS NOT THE LAST GROUP IN THE ^^RIB\\.
.B 1;.I -30
^^DCR	FILUUO	DEBUG	"DELRIB CPOPJ RETURN".\\  ^^DELRIB,\\ WHICH SHOULD
ALWAYS GIVE A SKIP RETURN,
DID NOT SKIP.
.B 1;.I -30
^^DDS	FILUUO	DEBUG	"DELRIB DIDN'T SKIP".\\  ^^DELRIB\\, WHICH SHOULD
ALWAYS GIVE A SKIP RETURN, DID NOT SKIP.
.PG
.B 1;.I -30
^^DER	FILUUO	DEBUG	"DELRIB RETURN ERROR".\\
^^DELRIB\\, WHICH SHOULD ALWAYS GIVE A SKIP RETURN, DID NOT SKIP.
.B1;.I-30
^^DFU	NETSER	DEBUG	"DEVICE UNRECOGNIZED". UUOCON\\ CALLED
THE NETWORK SERVICE ROUTINE WITH A DEVICE NOT ON THE NETWORK.
.B 1;.I -30
^^DHA	FILIO	DEBUG	"DON'T HAVE AU".\\  ^THE MONITOR ATTEMPTED
TO GIVE UP THE ^^AU\\ RESOURCE WHEN IT DID NOT HAVE IT.
.B 1;.I -30
^^DHB	FILIO	DEBUG	"DON'T HAVE BUFFER".\\  ^THE BUFFER RETURN ROUTINE HAD NO BUFFER TO RETURN.
.B 1;.I -30
^^DHD	FILIO	DEBUG	"DON'T HAVE DA".\\  ^THE MONITOR ATTEMPTED TO GIVE UP THE
^^DA\\ RESOURCE WHEN IT DID NOT HAVE IT.
.B 1;.I -30
^^DNF	FILUUO	DEBUG	"DDB NOT FOUND".\\  ^NO PREDECESSOR DISK
DEVICE DATA BLOCK WAS FOUND WHEN AN ATTEMPT WAS MADE TO RETURN A ^^DDB\\.
.B 1;.I -30
^^DNR	FILUUO	DEBUG	"DELRIB NONSKIP RETURN".\\
^^DELRIB\\, WHICH SHOULD ALWAYS GIVE A SKIP RETURN, DID NOT SKIP.
.B 1;.I -30
^^DNS	FILUUO	DEBUG	"DELRIB NONSKIP RETURN".\\
^^DELRIB\\, WHICH SHOULD ALWAYS GIVE A SKIP RETURN, DID NOT SKIP.
.B 1;.I -30
^^DPL	COMCON	DEBUG	"DIRECTORY PAGE LOST".\\ ^THE PAGE
THAT HAD TO BE WRITTEN OUT (NOT PAGED OUT) TO MAKE ROOM TO CREATE
THE DIRECTORY PAGE COULD NOT BE BROUGHT BACK IN (VIRTUAL MEMORY MONITOR ONLY).
.B1;.I-30
^^DPN	COMCON	DEBUG	"DIRECTORY PAGE NONEXISTENT".\\ ^THE DIRECTORY
PAGE FOR AN ^^EXE\\ FILE WAS SUPPOSED TO BE DESTROYED, BUT IT COULD NOT BE (VIRTUAL MEMORY MONITOR ONLY).
.B1;.I-30
^^DPO	SEGCON	DEBUG	"DIRECTORY PAGE OVERLAP".\\ ^ON A NONVIRTUAL
MEMORY SYSTEM ANOTHER ENTRY WAS BEING FETCHED FROM THE DIRECTORY
AND THE END OF THE PAGE WAS REACHED.  ^HOWEVER, THERE IS A LIMIT
OF ONE PAGE ON A NONVIRTUAL MEMORY SYSTEM.
.B 1;.I -30
^^EPO	ERRCON	DEBUG	"EXEC PDL OVERFLOW".\\  ^THE MONITOR'S
EXTENDED PUSHDOWN LIST OVERFLOWED.
.B 1;.I -30
^^ERB	REFSTR	DEBUG	"ERROR READING BAT BLOCK".\\  ^THE REFRESHER COULD NOT READ THE ^^BAT\\ BLOCK.
.B 1;.I -30
^^ERD	ONCMOD	DEBUG	"ERROR REFRESHING DISK".\\  ^^REFSTR\\
HAD AN ERROR REFRESHING A SPECIFIC STRUCTURE.
.B1;.I-30
^^ERF	TAPSER	STOP	"ERROR RECOVERY FAILURE".\\
^DURING ERROR RECOVERY AN ^^IORB (I/O\\ REQUEST BLOCK) OTHER THAN
THIS CONTROLLER'S ERROR RECOVERY ^^IORB\\ WAS POSTED COMPLETE TO
THE ERROR RECOVERY PROCEDURE.
.B 1;.I -30
^^ERH	REFSTR	DEBUG	"ERROR READING HOME.SYS".\\
^THE REFRESHER COULD NOT READ ^^HOME.SYS\\.
.B 1;.I -30
^^ERM	ONCMOD	DEBUG	"ERROR READING MFD".\\ ^AN ERROR OCCURRED IN
TRYING TO READ THE ^M^F^D DURING ^^ONCE\\-ONLY.
.B 1;.I -30
^^ERP	REFSTR	HALT	"EXTRA RETRIEVAL POINTER".\\  ^THE ^^HOME.SYS\\ 
^^RIB\\ FILLED UP WHILE THE DISK WAS BEING REFRESHED.
.B 1;.I -30
^^ERS	ONCMOD	DEBUG	"ERROR READING SAT".\\  ^AN ERROR OCCURRED 
WHILE READING THE ^^SAT\\ TABLE DURING ^^ONCE\\-ONLY.
.B1;.I-30
^^ESS	FILFND	JOB	"EMPTY SYSTEM SEARCH LIST".\\
.B 1;.I -30
^^EUE	ERRCON	DEBUG	"EXEC UUO ERROR".\\  ^THE MONITOR EXECUTED AN ILLEGAL ^^UUO\\ (CALL).
.B 1;.I -30
^^EWB	REFSTR	DEBUG	"ERROR WRITING BLOCK".\\  ^THE REFRESHER
HAD AN ERROR WRITING A BLOCK.
.B 1;.I -30
^^EWH	REFSTR	DEBUG	"ERROR WRITING HOME BLOCKS".\\
^THE REFRESHER COULD NOT WRITE HOME BLOCKS.
.B 1;.I -30
^^EWR	ONCMOD	DEBUG	"ERROR WHILE REFRESHING".\\  ^THE REFRESHER HAD AN ERROR WHILE REFRESHING ALL THE
DISKS IN THE SYSTEM.
.B 1;.I -30
^^FAD	FILUUO	DEBUG	"FILE ALREADY DORMANT".\\  ^AN ACCESS TABLE WAS FOUND TO BE DORMANT DURING A ^^CLOSE\\ CALL.
.B 1;.I -30
^^FDP	FILIO	DEBUG	"FIXED-HEAD DEVICE POSITIONED".\\
^A POSITION DONE INTERRUPT WAS RECEIVED FROM A FIXED HEAD DEVICE.
^THIS MAY INDICATE A HARDWARE PROBLEM.
.B1;.I-30
^^FFU	NETSER	STOP	"F FOULED UP".\\ ^AN ATTEMPT WAS MADE TO
PUT A JOB TO SLEEP, BUT THE JOB DID NOT EXIST.
.B 1;.I -30
^^FIP	VMSER	DEBUG	"FREE PAGE IN USE".\\  ^WHEN
THE FREE CORE LIST WAS BEING SCANNED, A PAGE ALLOCATED TO A SEGMENT WAS ENCOUNTERED.
.B 1;.I -30
^^FLE	SCNSER	STOP	"FREE LIST EMPTY".\\
^THE NUMBER OF FREE ^^TTY\\ CHUNKS DID NOT AGREE WITH THE
COUNT OF THE NUMBER OF FREE ^^TTY\\ CHUNKS.
.B 1;.I -30
^^FPF	KILOCK	STOP	"PAGE ON FREE LIST IS NOT FREE".\\  ^A
PAGE ON THE FREE CORE LIST WAS LINKED TO A PAGE WHICH WAS NOT
ON THE FREE CORE LIST.
.B 1;.I -30
^^FPI	KISER	STOP	"FREE##PAGE##IN#USE".\\##^A#PAGE#TAKEN#FROM
.I-30
	^^KLSER\\		THE FREE LIST WAS NOT FREE.
.PG
.B1;.I-30
^^FPN	KILOCK	STOP	"FREE PAGE NOT FOUND".\\ ^WHEN A PAGE
WAS BEING MOVED, A FREE PAGE IN ^^PAGTAB\\ WAS NOT ON THE FREE
CORE LIST.
.B 1;.I -30
^^FPZ	SCNSER	STOP	"FREE POINTER ZERO".\\
^AN ATTEMPT WAS MADE TO PLACE A CHARACTER IN THE
^^TTY\\ BUFFER WHEN THE COUNT OF THE NUMBER OF FREE CHUNKS
WAS POSITIVE, BUT THE FREE LIST WAS EMPTY.
.B 1;.I -30
^^HBE	REFSTR	DEBUG	"HOME BLOCK ERROR".\\  ^AN ERROR OCCURRED
DURING AN ATTEMPT TO READ THE HOME BLOCKS WHILE REFRESHING A FILE STRUCTURE.
.B 1;.I -30
^^HDS	XTCSER	STOP	"HIBER DID NOT SKIP"\\.  ^A CALL
TO THE ^^HIBER\\ SUBROUTINE DID NOT SKIP.
.B 1;.I -30
^^HIF	FILIO	DEBUG	"HOLE IN FILE".\\  ^ALTHOUGH THE LAST
BLOCK IN THE FILE EXISTED,  SOME BLOCK PRIOR TO THE LAST WAS MISSING.
.B 1;.I -30
^^HWU	FILIO	JOB	"HARD WRONG UNIT".\\  ^THE WRONG UNIT
ON A DISK CONTROLLER INTERRUPTED.  ^THIS IS
A HARDWARE PROBLEM.
.B 1;.I -30
^^IBI	CLOCK1	JOB	"INTERRUPT BLOCK ILLEGAL".\\
^AN INTERRUPT BLOCK WAS OUT OF BOUNDS IN PREPARATION FOR AN
INTERRUPT TO A JOB.
.B 1;.I -30
^^IBZ	FILIO	JOB	"I/O TO BLOCK ZERO".\\  ^AN ATTEMPT WAS MADE  TO READ
OR WRITE BLOCK ZERO.  ^THE ONLY WAY BLOCK 0 CAN BE READ IS
BY READING ^^HOME.SYS[1,4]\\ OR USING THE ^^SUSET.\\ CALL.
^IF NEITHER CONDITION HOLDS,  THERE IS A MONITOR ERROR.
.B 1;.I -30
^^ICC	PSISER	HALT	"INVALID CONDITION CODE".\\  ^THE
CONDITION WHICH CAUSED THIS INTERRUPT DID NOT EXIST.
.B 1;.I -30
^^ICN	SEGCON	DEBUG	"INCORE COUNT NEGATIVE".\\  ^WHEN
THE COUNT OF THE NUMBER OF JOBS IN CORE WHICH WERE
SHARING A HIGH SEGMENT WAS DECREMENTED, THE COUNT BECAME NEGATIVE.
.B 1;.I -30
^^ICW	KALOCK	DEBUG	"IN CORE COUNT IS WRONG".\\ ^A HIGH
SEGMENT WAS IN THE WAY OF A JOB TO BE LOCKED, AND THE LOW SEGMENTS
ASSOCIATED WITH THE HIGH SEGMENT COULD NOT BE FOUND.
.B 1;.I -30
^^IDC	ONCMOD	HALT	"IMPOSSIBLE DRUM CONDITION".\\
^THE NONEXISTENT "WRITE HEADER LOCKOUT" SWITCH FOR THE ^^RD10\\
WAS SET.
.B1;.I-30
^^IFI	TAPSER	STOP	"ILLEGAL FUNCTION AT INTERRUPT LEVEL".\\
^AN ILLEGAL FUNCTION WAS FOUND IN AN ^^IORB (I/O\\ REQUEST BLOCK)
WHILE AT INTERRUPT LEVEL.
.B1;.I-30
^^IFU	NETSER	DEBUG	"INTERRUPT FLAG UNRECOGNIZED". D85INT\\
CALLED ^^NETSER\\ WITH AN INVALID INTERRUPT.
.B 1;.I -30
^^IIP	FILIO	DEBUG	"IO IN PROGRESS".\\  ^AN ATTEMPT WAS MADE TO START
A MONITOR READ OR WRITE ON A ^^DDB\\
WHICH WAS ^^IO\\ ACTIVE.
.B 1;.I -30
^^IME	KISER	DEBUG	"ILL. MEM-REF FROM EXEC".\\  ^AN ^^EXEC\\ MODE
.I-30
	^^KLSER\\		PAGE FAULT TOOK PLACE.
.B1;.I-30
^^INU	TAPSER	STOP	"INTERRUPT ON NONEXISTENT UNIT". TAPSER\\
RECEIVED AN INTERRUPT TO SERVICE A NONEXISTENT UNIT.
.B 1;.I -30
^^IPF	VMSER	DEBUG	"IN USE PAGE FREE\\".  ^WHEN THE PAGES WHICH WERE
ALLOCATED TO A SEGMENT WERE BEING SCANNED, A PAGE ON THE FREE CORE
LIST WAS ENCOUNTERED.
.B 1;.I -30
^^IPM	VMSER	DEBUG	"ILLEGAL POINTER IN MEMTAB".\\  ^AN
INCONSISTENCY WAS DETECTED IN THE SWAPPING DATA BASE.
.B1;.I-30
^^IPN	VMSER	DEBUG	"IPCF PAGE NONEXISTENT".\\ ^AFTER ^^IPCF\\
PAGES WERE SWAPPED OUT, THEY WERE NOT FOUND IN THE SWAP LIST.
.B 1;.I -30
^^IRE	KISER	JOB	"IOWD##RELOCATION##ERROR".\\##^FOLLOWING##A
.I-30
	^^KLSER\\		JOB'S PAGING, AN ERROR OCCURRED IN CHANGING THE ^^IOWD\\ TO AN
ABSOLUTE ^^IOWD.\\
.B1;.I-30
^^ISS	TX1KON	DEBUG	"IMPOSSIBLE STORED STATUS".\\ ^THE ^T^X01
GENERATED ^C^U STATUS WITHOUT DEVICE END FOR A UNIT BELIEVED TO BE
OFF-LINE. ^THIS SHOULD NEVER HAPPEN.
.B 1;.I -30
^^IUN	FILUUO	DEBUG	"INVALID UNIT NUMBER".\\  ^^MFD RIB\\ FOR
A FILE STRUCTURE WAS ON AN INVALID UNIT.
.B 1;.I -30
^^JAC	UUOCON	DEBUG	"JOB DATA AREA CLOBBERED".\\  ^^JOBHCU\\
WAS GREATER THAN 17.
.B 1;.I -30
^^JDJ	ONCMOD	DEBUG	"JFFO DIDN'T JUMP".\\ ^LOGICAL UNIT NUMBER COULD NOT BE DETERMINED.
.B 1;.I -30
^^JIT	SYSINI	HALT	"JOB##IN##TRANSIT".\\###^LOCK#WAS#NON-ZERO.
.B 1;.I -30
^^JNC	FILIO	DEBUG	"JOB NOT IN CORE".\\  ^A JOB WHICH 
HAD ACTIVE DISK ^I/^O WAS NOT IN CORE.
^THIS WAS DETECTED WHEN THE INTERRUPT TOOK PLACE.
.B1;.I-30
^^KAS	TAPSER	STOP	"KONTROLLER ALREADY STARTED".\\ ^THE
CONTROLLER WAS BUSY WHEN ^^TAPSER\\ WAS READY TO START ^I/^O.
.B 1;.I -30
^^KDS	DPXKON	DEBUG	"KONEC2 DIDN'T SKIP".\\  ^THE SUBROUTINE
^^KONEC2\\ SHOULD ALWAYS GIVE A SKIP RETURN.
.B 1;.I -30
^^KID	SYSINI	HALT	"KONTROLLER IS DOWN".\\  ^A CONTROLLER WENT
DOWN DURING DISK INITIALIZATION.
.PG
.B 1;.I -30
^^KN1	CP1SER	HALT	"KT10A NOT ON CPU1".\\  ^^CPU1\\ DOES
NOT HAVE DUAL PROTECTION AND RELOCATION REGISTERS.
.B1;.I-30
^^KNF	XTCSER	STOP	"KONTROLLER NOT FREE".\\ ^A REQUEST BY AN EXTERNAL
PROCESSOR WAS MADE AND RECOGNIZED BY THE ^^DA28C\\ BUT CONFLICTED
WITH THE CURRENT USE OF THE CONTROLLER.
.B 1;.I -30
^^KNS	TAPSER	STOP	"KONTROLLER NOT SELECTED".\\ ^AN ATTEMPT WAS
MADE TO START ^I/^O ON A CONTROLLER THAT WAS NOT SELECTED.
.B1;.I-30
^^KOL	TAPSER	STOP	"KONTROLLER OFF-LINE".\\ ^START ^I/^O WAS
CALLED ON A CONTROLLER THAT WAS OFF-LINE.
.B1;.I-30
^^LN1	ERRCON	STOP	"NO TTY LINE". T\\HE CONTROLLING TELETYPE
COULD NOT BE FOUND.
.B1;.I-30
^^LNP	FILIO	DEBUG	"LAST POINTER NOT A POINTER". A\\N ALLOCATION
WAS DONE AND A ^^RIB\\ ERROR OCCURRED. ^WHEN AN ATTEMPT WAS MADE TO
DEALLOCATE THE SPACE, THE ^^RIB\\ POINTER WAS NOT VALID.
.B 1;.I -30
^^LNS	SCNSER	STOP	"LINE NOT SETUP".\\ ^^RH(U)=0\\ ON THE CALL
TO ^^TSETBI\\.
.B1;.I-30
^^LNT	ERRCON	STOP	"LDB (LINE) NOT THERE". T\\HE CONTROLLING TELETYPE
COULD NOT BE FOUND.
.B 1;.I -30
^^LPU	FILUUO	JOB	"LAST POINTER UNIT-CHANGE".\\  ^A UNIT
CHANGE POINTER WAS THE LAST POINTER IN A ^^RIB\\, WHEN 
A UNIT CHANGE POINTER SHOULD ALWAYS BE FOLLOWED BY A DATA POINTER.
.B1;.I-30
^^LTS	NETSER	DEBUG	"LINK TO SELF". B\\UFFERS POINTED TO
THEMSELVES IN A LINKED LIST.
.B 1;.I -30
^^MAU	CP1SER	DEBUG	"MASTER ALREADY UNLOCKED".\\
^^CPU0\\ ATTEMPTED TO GIVE UP (UNLOCK) THE ^^CPU\\ INTERLOCK, BUT
IT DID NOT OWN IT (HAVE IT LOCKED).
.B 1;.I -30
^^MCM	METCON	DEBUG	"MCDB MISSING".\\ ^AFTER THE METERING OF A MONITOR
DATA POINT, AN ATTEMPT TO REMOVE A ^METER ^CHANNEL ^DATA ^BLOCK FAILED.
.B 1;.I -30
^^MCN	FILFND	DEBUG	"MOUNT COUNT NEGATIVE".\\  ^THE MOUNT COUNT
ON A STRUCTURE WENT NEGATIVE.
.B 1;.I -30
^^MHB	FILIO	DEBUG	"MUST HAVE BUFFER".\\  ^AN ATTEMPT WAS MADE TO READ A
^^RIB\\ INTO A MONITOR BUFFER WHEN THERE WAS NO MONITOR
BUFFER FOR THE JOB.
.B1;.I-30
^^MIW	ONCE	STOP	"MEMORY INTERLEAVING WRONG". T\\HERE WAS A
MEMORY INTERLEAVING ERROR. ^THE OPERATOR MUST CORRECT THE PROBLEM.
.PG
.B 1;.I -30
^^MIZ	VMSER	DEBUG	"MEMTAB IS ZERO".\\  ^AN INCONSISTENCY
WAS DETECTED IN THE SWAPPING DATA BASE.
.B1;.I-30
^^MMN	ERRCON	HALT	"MONITOR MEMORY NONEXISTENT". A\\ MEMORY
DROPPED OFF-LINE, AND ONE OR MORE PAGES OF THE MONITOR WERE IN
NONEXISTENT MEMORY.
.B 1;.I -30
^^MMP	ERRCON	HALT	"MONITOR MEMORY PARITY".\\  ^THE MONITOR
REFERENCED AN INSTRUCTION OR IMPORTANT DATA
WITH BAD PARITY.
.B1;.I-30
^^MMR	KILOCK	STOP	"MOVING MONITOR PAGE NOT REQUIRED". T\\HE
EXPECTED NUMBER OF MONITOR PAGES TO BE MOVED COULD NOT BE MOVED,
BECAUSE THERE WERE NO FREE PAGES TO MOVE THEM TO.
.B1;.I-30
^^MNM	SYSINI	STOP	"MONITOR IN NONEXISTENT MEMORY".\\
^THE MONITOR OVERLAPPED A PAGE OF CORE THAT WAS PREVIOUSLY
DETERMINED TO BE NONEXISTENT.
.B1;.I-30
^^MPN	KILOCK	STOP	"MONITOR PAGE NOT FOUND". A\\ PAGE OF THE MONITOR
TO BE MOVED WAS NOT FOUND IN THE EXEC. PAGE MAP.
.B1;.I-30
^^MXM	MSGSER	JOB	"MPX:#DDB MISSING".\\ ^THE ^D^D^B CHAIN
GOT MESSED UP; THE POINTER TO AN ^^MPX DDB\\ ON THE ^D^D^B CHAIN
WAS NOT RIGHT.
.B 1;.I -30
^^NAP	FILUUO	JOB	"NOT ADDRESS POINTER".\\
^A RETRIEVAL  POINTER DID NOT POINT TO A VALID DISK ADDRESS.
.B 1;.I -30
^^NCA	CLOCK1	STOP	"NO CORE ASSIGNED".\\  ^AN ATTEMPT WAS MADE TO 
START A JOB WITH NO CORE MEMORY ASSIGNED.
.B 1;.I -30
^^NDA	FILFND	JOB	"NO DUMMY ACCESS TABLE".\\
^THE ROUTINE TO REMOVE THE DUMMY ^A.^T. (^^TAKOU\\) COULD
NOT FIND THE BLOCK TO DELETE.
.B1;.I-30
^^NDC	ONCMOD	STOP	"NO DF10C CODE". M\\ONITOR WAS NOT ASSEMBLED
FOR ^D^F10^C IN ^K^I MODE. ^SET SWITCH INSIDE CABINET DOOR TO ^K^A MODE.
.B 1;.I -30
^^NDJ	SCNSER	DEBUG	"NO DDB FOR JOB".\\  ^A JOB'S ^^TTY
DDB\\ DID NOT EXIST.  ^ALL JOBS (EVEN DETACHED JOBS) MUST HAVE A ^^DDB\\.
.B 1;.I -30
^^NDP	CLOCK1	DEBUG	"NOT DDB POINTER".\\  ^^WSYNC\\ WAS
CALLED WITH A STRANGE ADDRESS IN ^F.
.B 1;.I -30
^^NDS	CLOCK1	STOP	"NULL JOB DID SAVGET".\\  ^THE ^^MONSTR\\
ROUTINE WAS CALLED WHILE THE NULL JOB WAS RUNNING.
.B 1;.I -30
^^NED	ONCE	HALT	"NO EXEC DDT".\\  ^^ONCE\\ DETERMINED THAT THERE WERE BREAKPOINTS
SET, BUT ^^EDDT\\ WAS NOT LOADED WITH THIS MONITOR.
.PG
.B 1;.I -30
^^NER	FILUUO	DEBUG	"NO EXTENDED RIB".\\  ^THE POINTER TO
THE LAST BLOCK OF THE FILE WAS NOT IN THE ^^RIB\\ AND THERE
WAS NO EXTENDED ^^RIB\\.  ^THIS HAPPENS WHEN A POINTER GETS LOST
FOR SOME REASON.
.B 1;.I -30
^^NEV	UUOCON	STOP	"NO EVM". T\\HE ^^DDB\\ DID NOT HAVE EXEC. VIRTUAL MEMORY.
.B1;.I-30
^^NFC	SCNSER	STOP	"NO FREE CORE".\\ ^ALL THE ^^TTY\\ CHUNKS
WERE USED UP.
^THIS CONDITION WAS CHECKED FOR EARLIER AND SPACE WAS AVAILABLE.
.B 1;.I -30
^^NFS	VMSER	DEBUG	"NO FIRST SLOT".\\  ^AT THE START OF
A FRAGMENT, THE FIRST PHYSICAL PAGE OF THE FRAGMENT COULD NOT BE
FOUND IN THE PAGE MAP.
.B1;.I-30
^^NFU	SYSINI	DEBUG	"NO FIRST UNIT". T\\HERE WAS NOT A FIRST UNIT
IN THE SYSTEM SEARCH LIST.
.B1;.I-30
^^NHF	KALOCK	STOP	"NO HOLE FIT".\\  ^^HOLSRT\\ COULD NOT 
FIND A HOLE FOR THIS JOB EVEN THOUGH ^^KALOCK\\ JUST CREATED ONE.
.B1;.I-30
^^NIV	TAPUUO	STOP	"NULL INTERRUPT VECTOR ADDRESS". A\\N ^I/^O
REQUEST BLOCK WAS EXECUTED AND RETURNED TO ^^TAPUUO\\ WITH A ZERO
INTERRUPT VECTOR.
.B 1;.I -30
^^NMB	FILIO	DEBUG	"NEED MONITOR BUFFER".\\
^AN ATTEMPT WAS MADE TO WRITE A ^^RIB\\ WITHOUT A MONITOR BUFFER TO WRITE IT FROM.
.B 1;.I -30
^^NMC	ONCMOD	HALT	"NO MORE CORE".\\  ^^ONCE\\-ONLY FILLED UP CORE.
.B 1;.I -30
^^NMU	REFSTR	DEBUG	"NO MORE UNITS".\\  ^THE REFRESHER WROTE A WRONG ^^RIB\\.
.B 1;.I -30
^^NNF	FILUUO	DEBUG	"NMB NOT FOUND".  ^^GETNMB\\ COULD NOT
FIND A NAME BLOCK.  ^EITHER ^^DEVACC\\ OR ^^ACCNMB\\ WAS WRONG.
.B 1;.I -30
^^NNR	FILUUO 	JOB	"NO NEXT RIB".\\  ^DURING A ^^CLOSE\\ MONITOR CALL
THE LAST BLOCK OF THE FILE COULD NOT BE FOUND.
^THIS INDICATES THAT A DATA POINTER WAS LOST.
.B 1;.I -30
^^NNU	ONCMOD	DEBUG	"NOT NEW UNIT".\\
^THE MONITOR EXPECTED TO FIND A NEW UNIT POINTER WHILE READING  ^^SAT.SYS\\.
.B 1;.I -30
^^NOT	SCNSER	DEBUG	"NO OPR TTY".\\  ^^DEVOPR=0\\.
.B 1;.I -30
^^NPC	SCHED1	STOP	"NO PDB IN CORE".\\  ^WHEN AN ATTEMPT WAS MADE TO
REQUEUE A JOB AND RESET ITS QUANTUM
RUN TIME, NO PROCESS
DATA BLOCK WAS FOUND FOR THAT JOB.
.B 1;.I -30
^^NPD	FILIO	DEBUG	"NO POINTERS IN DDB".\\  ^AN EXTENDED ^^RIB\\
WAS NEEDED BECAUSE THE POINTERS IN THE ^^DDB\\ WERE EXHAUSTED, BUT THERE WERE NO POINTERS IN THE ^^DDB\\.
.B 1;.I -30
^^NPF	KILOCK	STOP	"NEXT PAGE FREE".\\  ^THE MONITOR
ENCOUNTERED A FREE PAGE WHILE SEARCHING A SEGMENT'S PAGES
FOR THE TARGET PAGE.
.B 1;.I -30
^^NPJ	DATMAN	DEBUG	"NO PDB FOR JOB".\\  ^A CALL TO
^^FNPDBS\\ DID NOT FIND A ^^PDB\\.
.B1;.I-30
^^NPN	KASER	STOP	"NONEXISTENT# K/PAGE# NOT FREE\\". ^A ^K OR
.I-30
	^^KISER\\		PAGE OF #NONEXISTENT #MEMORY BELONGED TO
.I -30
	^^KLSER\\		EITHER THE MONITOR OR SOME JOB. ^THIS SHOULD ONLY HAPPEN IF THE
OPERATOR CONTINUES AFTER A ^N^X^M HALT.
.B 1;.I -30
^^NPP	KISER	STOP	"NO PI IN PROGRESS".\\  ^CHANNEL 7 CODE WAS
.I-30
	^^KLSER\\		CALLED FROM ^^UUO\\ LEVEL.
^THE PAGE TABLE COULD BE MESSED UP IF THIS WERE ALLOWED.
.B 1;.I -30
^^NPU	ERRCON	STOP	"NULL PUSH-DOWN UNDERFLOW".\\
^THERE WERE MORE ^^POP\\'S ON THE NULL PUSHDOWN LIST THAN
MATCHING ^^PUSH\\'S.
.B1;.I-30
^^NRB	TAPSER	STOP	"NO REQUEST BLOCK".\\ ^A DONE INTERRUPT
OCCURRED ON A CONTROLLER OR UNIT, AND NO REQUEST BLOCK WAS FOUND
CORRESPONDING TO THE INTERRUPT.
.B 1;.I -30
^^NRF	VMSER	DEBUG	"SWPLST NOT REALLY FRAGMENTED".\\
^THERE WAS A POINTER TO A FRAGMENTED ^^SWPLST\\ ENTRY, BUT THE ENTRY
WAS NOT REALLY FRAGMENTED.
.B 1;.I -30
^^NRM	FILUUO	JOB	"NEXT RIB MISSING".\\
^THERE WERE NOT ENOUGH POINTERS IN THE ^^RIB\\ TO ACCOUNT FOR
THE NUMBER OF BLOCKS WRITTEN, AND THERE WERE NO MORE ^^RIB\\'S.
.B 1;.I -30
^^NRS	ONCMOD	DEBUG	"NO RIB IN SAT".\\  ^^SAT.SYS\\ HAD A
^^RIB\\ ERROR.
.B 1;.I -30
^^NSE	VMSER	DEBUG	"NO SWPLST ENTRY".\\  ^WHEN AN ATTEMPT WAS MADE TO
COMPUTE THE UNIT AND BLOCK NUMBER REPRESENTED BY A ^^SWPLST\\
ENTRY, THE POINTER TO ^^SWPLST\\ POINTED TO A ZERO.
.B1;.I-30
^^NSL	FILFND	JOB	"NO SUCH SEARCH LIST".\\ ^WHEN AN ATTEMPT
WAS MADE TO FIND THE SEARCH LIST POINTER FOR THE CURRENT 
JOB, EITHER THE JOB NUMBER WAS 0, THERE WAS NO ^P^D^B, OR THE
SEARCH LIST WAS NULL.
.B 1;.I -30
^^NSR	REFSTR	HALT	"NO SECOND RIB".\\  ^THE REFRESHER TRIED
TO CREATE A FILE WITH ONLY ONE ^^RIB\\.
.B 1;.I -30
^^NSS	REFSTR	DEBUG	"NO SPACE FOR SAT".\\   ^THE REFRESHER
FILLED UP THE DISK.
.B 1;.I -30
^^NSU	FILIO	DEBUG	"NO SUCH UNIT".\\  ^THE ^^RIB\\ OF A FILE
INDICATED A NONEXISTENT UNIT.
.B 1;.I -30
^^NUB	FILFND	JOB	"NO UFD BLOCK".\\  ^THERE WAS NO ^^UFD\\
FOR A FILE EVEN THOUGH THE FILE EXISTED.
.B 1;.I -30
^^NUE	FILUUO	JOB	"NO UFD ERROR".\\  ^THERE WAS NO ^^UFD\\
FOR A FILE BEING WRITTEN.
.B 1;.I -30
^^NUI	XTCSER	DEBUG	"NONEXISTENT UNIT INTERRUPT."\\
^A UNIT WHICH WAS NOT KNOWN INTERRUPTED.  ^THIS OCCURS WHEN THE
CONTENT OF THE FEATURE REGISTER IS WRONG DURING SYSTEM LOADING.
.B 1;.I -30
^^NUP	FILUUO	DEBUG	"NO UNIT CHANGE POINTER".\\  
^THE ^^RIB\\ DID NOT START WITH A UNIT CHANGE POINTER.
.B 1;.I -30
^^NUS	VMSER	DEBUG	"NO UNIT FOR SWAPPING".\\  ^THERE WAS
NO UNIT IN THE ACTIVE SWAPPING LIST CORRESPONDING TO THE
UNIT INDICATED BY AN ENTRY IN ^^SWPLST\\.
.B1;.I-30
^^NWD	FILIO	DEBUG	"NO WRITING DDB". FILIO\\ THOUGHT THERE
WERE MULTIPLE WRITERS AND HAD TO UPDATE THE ^D^D^B'S, BUT NO
WRITING ^D^D^B'S WERE FOUND.
.B 1;.I -30
^^NXU	FILIO	DEBUG	"NONEXISTENT UNIT".\\  ^A UNIT CHANGE POINTER 
POINTED TO A UNIT WHICH DOES NOT EXIST IN THIS STRUCTURE.
.B 1;.I -30
^^O1F	VMSER	DEBUG	"ONLY ONE (1) FRAGMENT".\\
^SWAPPING SPACE WAS FRAGMENTED, BUT THERE WAS ONLY ONE ENTRY IN
THE FRAGMENT TABLE.
.B 1;.I -30
^^ONC	FILUUO	DEBUG	"ODD NUMBERED CLUSTER".\\ 
^THE NUMBER OF BLOCKS ALLOCATED TO A FILE WAS NOT AN EVEN MULTIPLE
OF THE NUMBER OF CLUSTERS ALLOCATED.
.B1;.I-30
^^P2L	VMSER	STOP	"PAGE TOO LOW".\\ ^AN ADDRESS IN THE USER'S
PAGE MAP WAS TOO LOW, I.E., IN THE MONITOR.
.B 1;.I -30
^^PAO	COMCON	STOP	"PAGE ALREADY OUT\\". ^AFTER A PAGE
WAS PAGED OUT TO CREATE A DIRECTORY FOR AN ^^EXE\\ FILE, THE DIRECTORY
STILL COULD NOT BE CREATED.
.B 1;.I -30
^^PCN	IPCSER	DEBUG	"PACKET COUNT NEGATIVE". T\\HE COUNT FOR
THE SYSTEM'S UNRECEIVED SENDS WENT NEGATIVE.
.B1;.I-30
^^PDA	FILIO	DEBUG	"POINTERS WITH DIFFERENT ADDRESSES". A\\
POINTER WITHIN THE ^^RIB\\ AND MONITOR BUFFER DIFFERED.
.B 1;.I -30
^^PEW	VMSER	DEBUG	"PAGTAB ENTRY WRONG".\\  ^WHEN THE PAGES
ALLOCATED TO A SEGMENT WERE BEING SCANNED, A PAGE ON THE FREE
CORE LIST WAS ENCOUNTERED.
.B 1;.I -30
^^PEZ	KISER	STOP	"PAGPTR EQUALS ZERO".\\  #^THE# POINTER# TO 
.I-30
	^^KLSER\\		THE FREE CORE LIST WAS FOUND TO BE ZERO WHEN AN
ATTEMPT WAS MADE TO FIND A FREE PAGE.
.B 1;.I -30
^^PFA	KILOCK	STOP	"PAGE FREE ALREADY".\\  ^THE MONITOR
ENCOUNTERED A FREE PAGE WHILE SEARCHING A SEGMENT'S PAGES FOR
THE TARGET PAGE.
.B 1;.I -30
^^PFC	VMSER	STOP	"PAGE ON FREE CORE LIST".\\
^WHEN THE PAGES  ALLOCATED TO A SEGMENT WERE BEING SCANNED,
A PAGE ON THE FREE CORE LIST WAS ENCOUNTERED.
.B1;.I-30
^^PGL	COMCON	STOP	"PAGES GOT LOST". N\\O PAGES WERE FOUND
THAT COULD BE PAGED OUT TO MAKE ROOM FOR THE DIRECTORY OF AN
^^EXE\\ FILE (VIRTUAL MEMORY MONITOR ONLY).
.B 1;.I -30
^^PIE	ERRCON	STOP	"PRIORITY INTERRUPT ERROR".\\
^A JUMP OCCURRED TO 40 + 2N +..., N=1,2,...7.  ^THIS IS
CAUSED BY A DEVICE INTERRUPTING TO THE WRONG LOCATION.
.B 1;.I -30
^^PIF	VMSER	DEBUG	"PAGE IS FREE".\\  ^WHEN THE
PAGES ALLOCATED TO A SEGMENT WERE BEING SCANNED, A PAGE ON THE
FREE CORE LIST WAS ENCOUNTERED.
.B 1;.I -30
^^PIN	VMSER	DEBUG	"PAGE IN WORKING SET".\\
^A PAGE WHICH WAS VERIFIED TO NOT BE IN THE WORKING SET WAS IN IT.
.B 1;.I -30
^^PIP	KISER	DEBUG	"PI#IN#PROGRESS".\\##^A#TRAP#TOOK##PLACE#AT
.I-30
	^^KLSER		PI\\-LEVEL,  USUALLY  PUSHDOWN LIST OVERFLOW.
.B 1;.I -30
^^PIW	VMSER	DEBUG	"PAGE IS NOT IN WORKING SET".\\  
^A PAGE WHICH HAD TO BE IN THE WORKING SET WAS NOT.
.B 1;.I -30
^^PJ0	CLOCK1	DEBUG	"REQUEUE JOB 0".\\
^AN ATTEMPT WAS MADE TO REQUEUE JOB 0 (THE NULL JOB).
.B 1;.I -30
^^PLP	FILIO	DEBUG	"PAST LAST POINTER".\\
^^SCNPTR\\ COULD NOT FIND A BLOCK WHICH SHOULD HAVE BEEN IN THE FILE.
.B 1;.I -30
^^PMU	KISER	STOP	"PAGTAB#MESSED#UP".\\#
^THE TABLE USED##FOR
.I-30
	^^KLSER\\		CORE ALLOCATION WAS NOT CORRECT.
.B1;.I-30
^^PNE	FILIO	DEBUG	"POINTERS NOT EQUAL". A\\FTER THE POINTERS IN
THE ^^RIB\\ WERE UPDATED FROM THE ^D^D^B, A DISCREPANCY WAS
FOUND IN THE CLUSTER NUMBER.
.B 1;.I -30
^^PNM	FILFND	DEBUG	"PHYSICAL NAME MISMATCH".\\ ^AFTER DETERMINING THAT A NAME REFERRED
TO A DISK UNIT, THE PHYSICAL NAME WAS LOST.
.B 1;.I -30
^^PNP	KILOCK	STOP	"PAGE NOT PRESENT".\\
^THE DESTINATION COULD NOT BE FOUND IN THE FREE CORE LIST OR
IN THE PRESENT SEGMENT.
.B 1;.I -30
^^POP	CLOCK1	DEBUG	"PI ON PROGRESS".\\
^AN ^^APR\\ ERROR HAPPENED WHILE AT ^^PI\\ LEVEL.  ^THIS WAS
EITHER A ^^NXM\\ (ANY PROCESSOR)  OR A ^^PDL#OV\\ (^^KA10\\
 ONLY).  ^THE ^^KI10\\ OR ^^KL10\\  WILL STOP
WITH ^^IME\\ OR ^^PIP\\, AS WELL AS WITH THIS ^^STOPCD\\.
.B 1;.I -30
^^POR	SEGCON	STOP	"PROCESS OUT OF RANGE".\\
^AN ATTEMPT WAS MADE TO ADD A HIGH SEGMENT TO THE ADDRESS SPACE
OF A NONEXISTENT JOB.
.B 1;.I -30
^^PQE	FILIO	DEBUG	"POSITION QUEUE EMPTY".\\
^A DISK UNIT WAS IN POSITION WAIT STATE, BUT THERE WERE NO FILES
IN ITS QUEUE TO BE POSITIONED.
.B 1;.I -30
^^PSF	KISER	STOP	"PAGE IN SEGMENT FREE".\\  ^WHEN SPACE# WAS
.I-30
	^^KLSER\\		BEING ALLOCATED FOR THIS JOB, A PAGE ON THE FREE CORE LIST
WAS FOUND WITHIN THE JOB.
.B 1;.I -30
^^PTH	KLSER	HALT	"PARITY TRAP HALT".\\ ^THERE WAS A HARD
EXEC. MODE PAGE FAIL TRAP AS A RESULT OF ^^AR\\ OR ^^ARX\\ PARITY.
.B 1;.I -30
^^PTP	KLSER	HALT	"PAGE TABLE PARITY".\\
^THERE WAS A HARD PAGE FAIL TRAP AS A RESULT OF A PAGE TABLE PARITY ERROR.
.B 1;.I -30
^^PTT	CORE1	JOB	"PAST TOP  OF TABLE".\\
^A CALL TO ^^SETZRS\\ ATTEMPTED TO ZERO MORE BITS THAN EXISTED.
.B1;.I-30
^^RBQ	SCHED1	STOP	"REQUEUING TO BEGINNING OF QUEUE".\\
^AN ATTEMPT WAS MADE TO REQUEUE TO THE BEGINNING OF A QUEUE WHICH
IS ALWAYS ILLEGAL IN THE 602 SCHEDULER.
.B 1;.I -30
^^RCC	SCNSER	STOP	"RANGE CHECKED CHUNK".\\
^A CALL TO ^^TTPUTC\\ OR ^^TTGETC\\ SPECIFIED  
A CHARACTER ADDRESS (IN ^T2) WHICH WAS NOT IN THE ^^TTY\\
BUFFER POOL.  ^THIS IS SOMETIMES CAUSED BY ATTEMPTING
^^TTY\\ OUTPUT WITHOUT SETTING UP ^U TO POINT TO AN ^^LDB\\.
.B1;.I-30
^^RDP	FSXKON	DEBUG	"RS04 DOES NOT POSITION". FILIO\\ TRIED
TO DO POSITIONING ON AN ^R^S04.
.B1;.I-30
^^RDS	SEGCON	STOP	"REMAP DID NOT SKIP". M\\ONITOR WAS DOING
A REMAP AND AN ERROR OCCURRED.
.B 1;.I -30
^^REH	ERRCON	HALT	"RECURSION IN ERROR HANDLER".\\
^^A STOPCD\\ WAS EXECUTED WHILE ^^STOPCD\\ RECOVERY WAS IN PROGRESS.
.B1;.I-30
^^RFU	TAPSER	STOP	"RECOVERY FOULED UP". D\\URING ERROR
RECOVERY THE ^E^R^P (ERROR RECOVERY PROCEDURE) STATE WORD HAD AN
INVALID STATE NUMBER AT THE COMPLETION OF AN OPERATION.
.B1;.I-30
^^RIE	XTCSER	DEBUG	"REMOTE INTERRUPT ERROR".\\ ^AN ERROR
OCCURRED DURING AN INTERRUPT FROM A REMOTE PROCESSOR.
.B 1;.I -30
^^RIF	DPXKON	DEBUG	"RP10 IS NOT FANCY". A\\N ^R^P04 FUNCTION
WAS ATTEMPTED ON AN ^^RP\\10 CONTROLLED DEVICE.
.B 1;.I -30
^^RJZ	SCHED1	STOP	"REQUEUE JOB ZERO".\\
^A JOB WITH AN INVALID JOB NUMBER WAS BEING REQUEUED.
.B1;.I-30
^^RNA	TAPSER	STOP	"REQUEST NOT ACTIVE". T\\HERE WAS A DONE
INTERRUPT, AND THE REQUEST BLOCK CORRESPONDING TO IT WAS NOT ACTIVE.
.B 1;.I -30
^^ROS	SEGCON	JOB	"RAN OUT OF SEGMENTS".\\
^THERE WAS NO HIGH SEGMENT NUMBER AVAILABLE TO ADD A HIGH
SEGMENT TO A JOB'S ADDRESS SPACE.  ^THIS SHOULD NOT HAPPEN,
BECAUSE THERE ARE ALWAYS AT LEAST AS MANY HIGH SEGMENT NUMBERS
AVAILABLE AS THERE ARE JOB NUMBERS AVAILABLE.
.B 1;.I -30
^^ROU	ONCMOD	HALT	"RAN OUT OF UNITS".\\ ^WHEN AN ATTEMPT WAS MADE TO GET THE ADDRESS OF
THE NEXT DATA BLOCK IN THE STRUCTURE, THE POINTER INDICATED  THE END
OF THE LIST.
.B 1;.I -30
^^RPM	ONCMOD	DEBUG	"RETRIEVAL POINTER MISMATCH".\\
^THE UNIT CHANGE POINTER IN FILE ^^SAT.SYS\\ DID NOT POINT
TO THE NEXT UNIT IN THE FILE STRUCTURE.
.B 1;.I -30
^^S2L	SWPSER	STOP	"SWAP TOO LOW".\\
^A SWAPPING REQUEST WOULD HAVE CLOBBERED PART OF THE MONITOR
(NONVIRTUAL MEMORY MONITOR ONLY).
.B 1;.I -30
^^SAC	ERRCON	DEBUG	"STRANGE APR CONDITION".\\
^THE LOW PRIORITY ^^APR\\ SERVICE ROUTINE COULD NOT FIND ANY
ERRORS, THOUGH THE HIGH PRIORITY ^^APR\\ SERVICE ROUTINE SAID
AN ERROR TOOK PLACE.
.B 1;.I -30
^^SAU	CP1SER	DEBUG	"SLAVE ALREADY UNLOCKED".\\
^^UNLOKS\\ WAS CALLED BUT THE INTERLOCK WAS NOT SET.
.B 1;.I -30
^^SBT	FILUUO	DEBUG	"SHOULD NOT BE TRUNCATING".\\
^THE HIGHEST BLOCK NUMBER IN THE FILE WAS TOO SMALL.
.B 1;.I -30
^^SBW	VMSER	DEBUG	"SWPLST BITS WRONG".\\
^AN ENTRY IN ^^SWPLST\\ SAID THAT BOTH
^I/^O WAS IN PROGRESS AND ^I/^O WAS DONE.
.B 1;.I -30
^^SCB	XTCSER	DEBUG	"SPURIOUS CONI BITS".  
A DA28C\\ INTERRUPT OCCURRED FOR NO VALID REASON.
.B 1;.I -30
^^SCO	CP1SER	HALT	"SPLIT CYCLE ON".\\
^^CPU1\\ HAD:
.B1;.LM 34;.I -4
1.##^ADDRESS STOP SWITCH SET, OR
.B1;.I -4
2.##^FAST ^^AC\\'S TURNED OFF.
.PG;.LM 30;.TS 8,19,30;.I -30
^^SER	FILUUO	JOB	"SETDDO ERROR RETURN".\\
^THERE WAS NO ROOM TO BUILD A ^^DDB\\ EVEN THOUGH ^^GET4WD\\ HAD JUST FOUND ROOM.
.B 1;.I -30
^^SFI	FILUUO	JOB	"STR FREE-COUNT INCONSISTENT".\\
^THE STRUCTURE HAD FREE SPACE BUT NO UNITS WITHIN THE STRUCTURE HAD
FREE SPACE.  ^THE SUM OF THE PARTS EXCEEDED THE WHOLE.
.B 1;.I -30
^^SFU	FILIO	DEBUG	"SWAPPER FOULED UP".\\
^THE SWAPPER TRIED TO DO ^I/^O WITH A NONSWAPPING ^^DDB\\.
.B 1;.I -30
^^SIN	VMSER	DEBUG	"SWPCNT IS NEGATIVE".\\
^THE COUNT OF THE NUMBER OF OUTSTANDING SWAPPING REQUESTS
WENT NEGATIVE WHEN AN ENTRY FROM ^^SWPLST\\ WAS BEING DELETED.
.B 1;.I -30
^^SLF	VMSER	DEBUG	"SWPLST FULL".\\
^AN ENTRY COULD NOT BE MADE  IN THE LIST  BECAUSE THE ^^SWPLST\\
TABLE WAS FULL.
.B 1;.I -30
^^SLM	FILUUO	DEBUG	"SEARCH LIST MISSING".\\
^^SETSRC\\ COULD NOT SET UP THE SEARCH LIST EVEN THOUGH IT COULD WHEN THE MONITOR CALL STARTED.
.B 1;.I -30
^^SLZ	VMSER	DEBUG	"SLECNT IS ZERO".\\
^THE SUBROUTINE TO FIND AN ENTRY IN ^^SWPLST\\ WAS CALLED WHEN
THERE WERE NO ENTRIES IN ^^SWPLST\\.
.B 1;.I -30
^^SMU	SCHED1	DEBUG	"SWPCNT MESSED UP".\\
^THE COUNT OF THE NUMBER OF COMPLETED SWAPPING OPERATIONS WAS
POSITIVE, BUT NO COMPLETED SWAPPING REQUEST COULD BE FOUND (VIRTUAL
MEMORY MONITOR ONLY).
.B 1;.I -30
^^SNF	KILOCK	STOP	"SEGMENT NOT FOUND".\\
^A PAGE WHICH WAS NOT ON THE FREE CORE LIST WAS NOT CONTAINED IN ANY SEGMENT'S ADDRESS SPACE.
.B 1;.I -30
^^SNI	SWPSER	DEBUG	"SWAPPING NOT IN PROGRESS".\\
^^SPRCNT\\ (NUMBER OF SWAPS IN PROGRESS) WENT NEGATIVE (VIRTUAL MEMORY  MONITOR ONLY).
.B 1;.I -30
^^SOD	SCHED1	STOP	"SPACE ON DISK".\\
^THE CALL TO ^^CORGET\\ IN ^^SWAPI\\ ASSIGNED SPACE ON THE DISK.
^THAT IS NOT ALLOWED ON A SWAP-IN.
.B 1;.I -30
^^SOR	ERRCON	STOP	"SEGMENT OUT OF RANGE".\\
^THE SEGMENT NUMBER IN ^^AC##J\\ WAS LARGER THAN THE MAXIMUM
SEGMENT NUMBER IN THE SYSTEM.
.B 1;.I -30
^^SPM	FILUUO	JOB	"SECOND POINTER MISSING".\\
^THE POINTER TO THE SECOND ^^RIB\\ WAS MISSING FROM THE FIRST ^^RIB\\.
.B 1;.I -30
^^SRE	ONCMOD	DEBUG	"SAT READ ERROR".\\
^^ONCE\\-ONLY HAD AN ERROR READING THE ^^SAT\\ TABLE.
.PG;.I -30
^^SRO	SWPSER	DEBUG	"SPACE RAN OUT".\\
^^VIRTAL\\ WAS POSITIVE, BUT NO SWAPPING UNIT HAD ANY ROOM ON IT.
.B 1;.I -30
^^SSD	SWPSER	STOP	"SWAP SPACE DISAPPEARED".\\
^THE COUNT OF THE NUMBER OF WORDS OF SWAPPING SPACE FREE SHOWED
MORE SPACE THAN THE ^^SAT\\ TABLE FOR SWAPPING.
.B1;.I-30
^^SSM	TX1KON	STOP	"STORED STATUS MISSING". W\\HEN THE ^D^X10
SHOULD HAVE STORED EXTENDED STATUS, IT DID NOT.
.B 1;.I -30
^^SSO	KILOCK	STOP	"SEGMENT SWAPPED OUT".\\
^A HIGH SEGMENT WHICH WAS NEITHER DORMANT NOR IDLE HAD NO LOW
SEGMENT IN CORE SHARING IT.
.B1;.I-30
^^SWJ	VMSER	DEBUG	"SWAPPED IN WRONG JOB".\\ ^THE JOB NUMBER
OF THE JOB JUST SWAPPED IN DID NOT MATCH THE JOB NUMBER IN THE ^^UPMP\\.
.B 1;.I -30
^^SWN	SWPSER	DEBUG	"SQREQ WENT NEGATIVE".\\
^^SWPSER\\ GOT TO ^^SWPINT\\ WHEN THE SWAPPER THOUGHT NOTHING 
WAS HAPPENING (VIRTUAL MEMORY MONITOR ONLY).
.B 1;.I -30
^^TC0	XTCSER	DEBUG\\	^WORK ENTRIES WHICH WERE QUEUED WHEN
THE ^^DA28C\\ WAS BUSY WERE NOT EXECUTED.
.B 1;.I -30
^^TC1	XTCSER	STOP\\	^THE ^^LIPS\\ PROTOCOL STATUS WAS WRONG
WHEN AN ^^I/O\\ TRANSFER STARTED.
.B 1;.I -30
^^TC2	XTCSER	DEBUG\\	^A REMOTE PROCESSOR INTERRUPT OCCURRED
WHEN THE CONTROL WAS NOT IDLE, I.E., IN USE BY SOFTWARE.
.B 1;.I -30
^^TC3	XTCSER	DEBUG\\	^THE ACCOUNTING FOR PSEUDO-ACTIVE TASKS
IN THE CONTROL DATA BLOCK WAS WRONG.
.B 1;.I -30
^^TC4	XTCSER	DEBUG\\	^THE ACCOUNTING FOR PSEUDO-ACTIVE TASKS
IN A UNIT CONTROL BLOCK WAS WRONG.
.B 1;.I -30
^^TC5	XTCSER	DEBUG\\	^THE ACCOUNTING FOR PSEUDO-ACTIVE TASKS
IN A UNIT CONTROL BLOCK WAS WRONG.
.B 1;.I -30
^^TC6	XTCSER	DEBUG\\	^THE ACCOUNTING FOR PSEUDO-ACTIVE TASKS
IN THE CONTROL DATA BLOCK WAS WRONG.
.B 1;.I -30
^^TC7	XTCSER	STOP\\	^A JOB THAT WAS TRYING TO GRAB THE ^^DA28C\\
CONTROL OBTAINED IT, BUT THE CONTROL WAS NOT FREE ACCORDING TO
THE CONTROL DATA BLOCK.
.B 1;.I -30
^^TCI	FILUUO	DEBUG	"TRUNCATION CHECK INCONSISTENT".\\
^A RENAME WHICH WAS CAUSING TRUNCATION ATTEMPTED TO TRUNCATE
TOO MANY BLOCKS EVEN THOUGH THAT WAS ALREADY CHECKED.
.B 1;.I -30
^^TMP	FILIO	DEBUG	"TOO MANY POINTERS".\\
^THERE WERE MORE RETRIEVAL POINTERS THAN WOULD FIT IN A ^^RIB\\.
^THERE IS A COUNTER (^^DEVRSU\\) TO PREVENT THIS FROM HAPPENING.
.B 1;.I -30
^^TMR	REFSTR	HALT	"TOO MANY RETRIEVAL POINTERS".\\
^THE ^^SAT.SYS RIB\\ FILLED UP DURING A REFRESH.
.B 1;.I -30
^^TMU	ONCMOD	HALT	"TOO MANY UNITS".\\ ^AFTER THE LAST UNIT WAS RETRIEVED,
 ADDITIONAL DATA BLOCKS WERE POINTED TO.
.B 1;.I -30
^^TOW	CP1SER	HALT	"TRAP OFFSET WRONG".
^T\\HE ^^CPU1\\ INTERRUPT VECTOR WAS IN THE SAME PLACE AS THE
^^CPU0\\ INTERRUPT VECTOR.
.B1;.I-30
^^UAS	TAPSER	STOP	"UNIT ALREADY STARTED". T\\HE UNIT WAS
ALREADY DOING ^I/^O WHEN ^^TAPSER\\ WAS READY TO START ^I/^O.
.B 1;.I -30
^^UDE	FILIO	DEBUG	"UNIT DOESN'T EXIST".\\
^A UNIT CHANGE POINTER POINTED OFF INTO NEVER-NEVER LAND.
.B 1;.I -30
^^UDM	FILUUO	JOB	"UFD DATA MISSING".\\
^THE CORE TABLES INDICATED THAT THE ^^UFD\\ WAS LONGER THAN IT REALLY WAS.
.B 1;.I -30
^^UFI	FILUUO	DEBUG	"UNIT FREE-COUNT INCONSISTENT".\\
^NO FREE SPACE WAS FOUND ON A UNIT EVEN THOUGH THE FREE-COUNT WAS POSITIVE.
.B 1;.I -30
^^UIF	ONCMOD	HALT	"UNIT IN FILE STRUCTURE".\\
^THE TABLES WHICH DRIVE ^^ONCE\\-ONLY'S '^^DESTROY\\' OPTION DUPLICATED
A UNIT.
.B 1;.I -30
^^UIL	ERRCON	STOP	"UUO AT INTERRUPT LEVEL".\\
^AN INTERRUPT SERVICE ROUTINE  EXECUTED AN ILLEGAL MONITOR CALL.
.B1;.I-30
^^UIP	XTCSER	DEBUG	"NOT ^A  UNIQUE INTERRUPT"\\.  ^TWO DIFFERENT
TYPES OF USAGE WERE DEFINED FOR THE ^^DA28C\\ CONTROL.
.B 1;.I -30
^^UNF	FILUUO	DEBUG	"UFB NOT FOUND". A\\ RENAME WAS DONE ACROSS
^U^F^D'S AND THE ^U^F^B WAS NOT FOUND.
.B 1;.I -30
^^UNJ	COMMON	DEBUG	"UUO FROM NULL JOB".\\ ^THE NULL JOB EXECUTED A MONITOR CALL OTHER
THAN THE DOORBELL MONITOR CALL.
.B1;.I-30
^^UNL	VMSER	DEBUG	"UPMP NOT LAST". T\\HE ^^UPMP\\ WAS NOT THE
LAST PAGE SWAPPED OUT.
.B1;.I-30
^^UNS	TAPSER	STOP	"UNIT NOT SELECTED". A\\ UNIT WAS NOT
SELECTED WHEN ^^TAPSER\\ WAS READY TO START ^I/^O.
.B 1;.I -30
^^UPC	FILUUO	JOB	"UNIT CHANGE POINTER CLOBBERED".\\ ^THE POINTER TO A UNIT OF
A ^^RIB\\ WAS LOST DURING ^^RIB\\ DEFINITION.
.B 1;.I -30
^^UPI	FILIO	DEBUG	"UNIT POINTER ILLEGAL".\\
^AN ATTEMPT WAS MADE TO CREATE AN EXTENDED ^^RIB\\ 
ON A NONEXISTENT UNIT.
.B 1;.I -30
^^UWS	VMSER	DEBUG	"UNIT WRONG STATE". O\\N A HUNG SWAPPING
DEVICE THE ^U^D^B INDICATED AN UNEXPECTED STATE.
.B1;.I-30
^^WAD	VMSER	DEBUG	"WSBTBL AND AABTBL DISCREPANCY".\\
^AN ACCESS PAGE FAULT OCCURRED FOR A PAGE WHICH SHOULD HAVE HAD THE
ACCESS ALLOWED BIT ON IN THE PAGE MAP.
.B 1;.I -30
^^XTH	SCHED1	DEBUG	"XJOB TOO HIGH".\\
^THE COUNT OF THE NUMBER OF JOBS WHICH MUST BE SWAPPED OUT
AND BACK IN TO SATISFY A CORE EXPANSION REQUEST WAS POSITIVE,
BUT NO EXPANDING JOB COULD BE FOUND.
.B 1;.I -30
^^ZBC	REFSTR	DEBUG	"ZERO BLOCKS PER CLUSTER".\\
^THE REFRESHER WAS CALLED WITH ^^HOMBPC=0\\.
.B 3
