.number appendix A
.;
.ap;.ps 59 131;.ax List of all IOLIB Routines
.lm 5
.;
 This appendix lists all the IOLIB routines in several categories.
If a category contains some critical routines, these are listed
before the rest separated from them by a line.
Otherwise, within a category, the routines are listed in
alphabetical order.
 The columns in the table are mostly self-explanatory.
The 'DI' column indicates whether the routine requires that
ac(D) points to the current file and/or ac(I) points to
the IDB.
If the 'size' column contains a name instead of a
number of words, then the routine is an entry point to
the named routine.
Many routines are in IOMOD, the basic IO module.
The current size of IOMOD is 360 words long.
Note that all sizes are given in decimal.
If the 'section' column is empty, then this appendix is the defining
and only mention of that routine.
.b 2;.nf;.ts 16 25 45 100 113 122
	#	#	#	###Acs	#Size
Routine	Macro	DI	Description	destroyed	(words)	Section
=======	=====	==	===========	=========	=======	=======
.ts 15 25 30 100 115 125
.b 2;^&A.1 Basic IO Routines\&
$APDWT	APDWT$	D	open the current file for appending. If the file is being modified	T1	5	6.21
	#	#	wait for a given period before giving up.
	#	#	Inputs:  T1 : sleep seconds,,number of sleeps
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : bytes free in block (o.k. only)
	#	#	         T1 : IO error code (error only)
.b;$APEND	APEND$	D	open the current file for appending, including setting the buffer	T1	21	6.22
	#	#	pointer for buffered modes. $APEND will not work correctly for files
	#	#	with more liberal protections.
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : bytes free in block (o.k. only)
	#	#	         T1 : IO error code (error only)
.b;$CLOSE	CLOSE$	D	execute a CLOSE UUO for the current file.  All CLOSE bits are zeroed.	T1	IOMOD	6.7
	#	#	Inputs:  taken from FDB
.b;$CLOS0	CLOSE$	D	as $CLOSE but allow caller to set CLOSE bits	T1	IOMOD	6.7
	#	#	Inputs:  T1 : CLOSE bits
.b;$DELET	DELET$	DI	delete the current file	none	IOMOD	6.10
	#	#	Returns: error : non-skip (LOOKUP or RENAME failure)
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : IO error code (error only)
.b;$DLBUF	DLBUF$	DI	return a buffer ring to the memory manager	T1	IOMOD	6.18
	#	#	Inputs:  T1 : point to buffer header
.b;$ENTER	ENTER$	DI	execute an ENTER UUO on the current file	T1	IOMOD	6.5
	#	#	Inputs:  taken from FDB
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : IO error code (error only)
.b;$ENTE0	ENTER$	DI	as $ENTER, but allow the caller to set the protection and create	T1	IOMOD	6.5
	#	#	date/time.
.b;$FRCHN	FRCHN$	#	find the first free channel starting with a given channel	T1	IOMOD	#
	#	#	Inputs:  T1 : starting channel
	#	#	Returns: none free : non-skip
	#	#	         o.k.      : skip
	#	#	Outputs: T1 : channel number
.b;$GETST	GETST$	D	get the IO status halfword for the current file	T1	IOMOD	6.12
	#	#	Outputs: T1 : status halfword (rh)
.b;$LUKUP	LUKUP$	DI	execute a LOOKUP on the current file	T1	IOMOD	6.4
	#	#	Inputs:  taken from FDB
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : IO error code (error only)
.b;$INPUT	INPUT$	DI	read a physical record from the current file.	T1	IOMOD	6.2
	#	#	Inputs:  taken from FDB
	#	#	Returns: error   : non-skip
	#	#	         endfile : skip
	#	#	         o.k.    : double-skip
.b;$MKBUF	MKBUF$	DI	create a ring of buffers for the current file.  The size and number	T1	IOMOD	6.17
	#	#	of the buffers is taken from $FDBUF.
	#	#	Inputs:  T1 : point to buffer header
	#	#	         $FDBUF(D)
	#	#	Returns: no core : non-skip
	#	#	         o.k.    : skip
	#	#	Outputs: T1 : 0,,ERNEC% (error only)
.b;$MTxxx	MTxxx$	D	execute an MTAPE UUO for the current file. 'xxx' can be any of the	T1	35	6.23
	#	#	codes for MTAPE functions: e.g. MTREW$, MTBSF$. All functions wait
	#	#	for completion using MTWAT$.  MTBSF$ skips over EOF unless at BOT.
.b;$OPEN	OPEN$	DI	execute an OPEN UUO for the current file.  If the caller does not	T1	IOMOD	6.6
	#	#	specify a channel number, $OPEN chooses the 1st free channel.
	#	#	Inputs:  taken from FDB
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : IO error code (error only)
.b;$OUTIN	OUTIN$	DI	write the last physical record read back to the current file.	T1	IOMOD	6.3
	#	#	as $OUTPU, but subtracts 1 from the block number before writing.
.b;$OUTPU	OUTPU$	DI	write a physical record to the current file	T1	IOMOD	6.3
	#	#	Inputs:  taken from FDB
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : IO error code (error only)
.b;$RLEAS	RLEAS$	DI	execute a RELEAS UUO for the current file. Return all buffers to	T1	IOMOD	6.8
	#	#	the heap.
	#	#	Inputs:  taken from FDB
.b;$RLEA0	RLEAS$	DI	as $RLEAS, but don't return rings to memory manager	T1	IOMOD	6.8
.b;$RENAM	RENAM$	DI	change the name and/or other details of the current file	T1	IOMOD	6.9
	#	#	The file must have been opened.
	#	#	Inputs:  taken from FDB
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: IO error code (error only)
.b;$SETST	SETST$	D	set the status halfword for the current file	T1	IOMOD	6.13
	#	#	Inputs:  T1 : 0,,status halfword
.b;$UPDAT	UPDAT$	DI	open the current file for updating	T1	7	6.19
	#	#	Returns: error : non-skip (LOOKUP or ENTER failure)
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : IO error code (error only)
.b;$UPDWT	UPDWT$	DI	open the current file in update mode. If the file is being modified	T1	17	6.20
	#	#	wait for a given period before giving up.
	#	#	Inputs:  T1 : sleep seconds,,number of sleeps
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : IO error code (error only)
.b;$USETI	USETI$	DI	position the current file to a given physical record for input	T1	IOMOD	6.11
	#	#	This routine is only effective for disk.
	#	#	Inputs:  T1 : last record number,,this record number
.b;$USETO	USETO$	D	position the current file to a given physical record for output	T1	IOMOD	6.11
	#	#	This routine is only effective for disk.
	#	#	Inputs:  T1 : last record number,,this record number
.b;$XTCAL	XTCAL$	D	execute a CALLI UUO for the current file, setting physical-only	T1	IOMOD	6.15
	#	#	if required
	#	#	Inputs:  T1 : UUO
	#	#	         T2 : argument
	#	#	Returns: non-skip : non-skip
	#	#	         skip     : skip
.b;$XTDCL	XTDCL$	D	execute a device dependent CALLI UUO for the current file.	T1	IOMOD	6.16
	#	#	As $XTCLI, but set DSK if no device given.
.b;$XTUUO	XTUUO$	D	execute a UUO for the current file	none	IOMOD	6.14
	#	#	Inputs:  T1 : UUO (without channel number)
	#	#	Returns: non-skip : non-skip
	#	#	         skip     : skip
.pg;.ts 16 25 45 100 113 122
	#	#	#	###Acs	#Size
Routine	Macro	DI	Description	destroyed	(words)	Section
=======	=====	==	===========	=========	=======	=======
.b 2;^&A.2 Formatted Read Routines\&
.ts 15 25 30 100 115 125
.b;$READ	READ$	DI	read one byte from the current file	T1	16	7.5
	#	#	Returns: error   : non-skip
	#	#	         endfile : skip
	#	#	         o.k.    : double-skip
	#	#	Outputs: T1 : byte, right-justified (o.k. only)
	#	#	            : IO-error-code (error and endfile only)
.b;$$RBYT	RBYTE$	DI	read one byte from the current file.  Fatal errors go to $FTLIO.	T1	4	7.6
	#	#	Returns: endfile : non-skip
	#	#	         o.k.    : skip
	#	#	Outputs: T1 : byte, right-justified  (o.k. only)
	#	#	            : IO-error-code (endfile only)
.b;$$RCH0	#	DI	read a character from the current file.  Fatal errors goto $FTLIO.	T1	1	7.7
	#	#	Returns: endfile : non-skip
	#	#	         o.k.    : skip
	#	#	Outputs: T1 : character, right justified (o.k. only)
	#	#	            : IO error code (endfile only)
.b;$$RCHR	RCHAR$	DI	read a character from the current file and interpret it as	T1	1	7.8
	#	#	command character.
	#	#	Outputs: T1 : character, right justified or endline indicator
	#	#	              (0 : ALT, -1 : EOL, -2 : EOF)
.b;-------------------------------------------------------------------------------------------------------------------------
.b;$RANCH	RANCH$	DI	read one character from the current file and test whether it is	T1-T4	8	#
	#	#	alphanumeric.
	#	#	Returns: not alphanumeric : non-skip
	#	#	         alphanumeric     : skip
	#	#	Outputs: T1 : character
.b;$RANC0	RANCH$	DI	as $RANCH, but the character has already been read	T1	$RANCH	#
	#	#	Note: this routine can be used to check whether a character is
	#	#	alphanumeric.
	#	#	Inputs:  T1 : character
.b;$RCASH	RCASH$	DI	read a cash value in dollars and cents from the current file.	T1-T4	29	#
	#	#	The string may appear as '$dddd.cc' with or without the '$'.
	#	#	If there is no '.' or '$', the number is assumed to be cents.
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : delimiting character (o.k. only)
	#	#	            : syntax error code (error only)
	#	#	         T2 : value in cents
.b;$RCAS0	RCASH$	DI	as $RCASH but leading character already read	T1-T4	$RCASH	#
	#	#	Inputs:  T1 : character
.b;$RCALT	#	DI	as $RCCHR, but check first if last character was altmode, and if so,	T1	$RCCHR	7.10
	#	#	return $CHALX without reading another character
	#	#	Outputs: T1 : character
.b;$RCCHR	#	DI	read a character from the current file as a command character which	T1	70	7.10
	#	#	means that a certain amount of editing is done, to wit:
	#	#	    the editing done by $REDCH
	#	#	    leading spaces on a line are deleted
	#	#	    multiple spaces are compressed
	#	#	    trailing spaces are deleted
	#	#	    comments are ignored
	#	#	    '-' followed by <lf> is ignored (continuation line)
	#	#	Outputs: T1 : character
.b;$RDATE	RDATE$	DI	read the date from the current file in the format 'dd-mmm-yy'	T1-T4	37	#
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : delimiting character (o.k. only)
	#	#	            : syntax error code (error only)
	#	#	         T2 : date in internal format
.b;$RDAT0	RDATE$	DI	as $RDATE but leading character already read	T1-T4	$RDATE	#
	#	#	Inputs:  T1 : character
.b;$RDECL	RDECL$	DI	read a signed decimal number from the current file.  If the 1st	T1-T4	17	#
	#	#	character is '_#' read the rest as an octal number. The '_#' may also
	#	#	follow the sign.
	#	#	Outputs: T1 : delimiting character
	#	#	         T2 : number
.b;$RDEC0	RDECL$	DI	as $RDECL but leading character already read	T1-T4	$RDECL	#
	#	#	Inputs:  T1 : character
.b;$RDECM	RDECM$	DI	read a decimal number (+ possible multiplier) from the current	T1-T4	3	#
	#	#	file. The number is as $RDECL, but may have a multiplier, 'K' kilo,
	#	#	'M' mega or 'G' giga. Note that 1K = 1000, not 1024.
	#	#	Outputs: T1 : delimiting character
	#	#	         T2 : number
.b;$RDCM0	RDECM$	DI	as $RDECM but leading character already read	T1-T4	$RDECM	#
	#	#	Inputs:  T1 : character
.b;$RDVIC	RDVIC$	DI	read a device name from the current device.  $RDVIC insists on a	T1-T3	14	#
	#	#	terminating ':'. Null names are forbidden.
	#	#	Returns: error : nonskip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : delimiting character (o.k. only)
	#	#	            : syntax error code (error only)
	#	#	         T2 : device name in SIXBIT
.b;$RDVI0	RDVIC$	DI	as for $RDVIC but enter with the leading character already read	T1-T4	$RDVIC	#
	#	#	Inputs:  T1 : ASCII character
.b;$REDCH	REDCH$	DI	read a character from the current file and perform some basic	T1	24	7.9
	#	#	editing:
	#	#	    endfile is converted to _^Z
	#	#	    <CR>, <DEL>, _& <NUL> are ignored
	#	#	    <TAB> is converted to <SP>
	#	#	    <VT> _& <FF> are converted to <LF>
	#	#	    <LF> is converted to -1
	#	#	    <ESC> is converted to 0
	#	#	    _^C and _^Z are converted to -2
	#	#	Outputs: T1 : character
.b;$REDC0	REDCH$	DI	as $REDCH but the character has already been read	T1	$REDCH	7.9
	#	#	Inputs:  T1 : character
.b;$RFILE	RFILE$	DI	read a filename from the current file.  The filename may	T1-T4	170	7.11
	#	#	contain wild characters, and may include standard switches and
	#	#	switches defined by the caller.  $RFILE remembers and applies
	#	#	sticky parts of filenames.
	#	#	Returns: error : nonskip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : delimiting character (o.k. return)
	#	#	            : syntax error code (error return)
	#	#	         T2 : flags,,point to FDB containing file details
.b;$RFIL0	RFILE$	DI	as for $RFILE, but the FDB and the user switches may be given	T1-T4	$RFILE	7.11
	#	#	Inputs:  T1 : point to switch tables
	#	#	         T2 : length,,point to FDB
.b;$RKWRD	RKWRD$	DI	read a Kword value from the current file in the format 'nnnx', where	T1-T4	11	#
	#	#	x maybe 'K' or 'P' or blank. e.g. 20P, 13K, 128.
	#	#	Default is K.
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : delimiting character (o.k. only)
	#	#	            : syntax error code (error only)
	#	#	         T2 : value in words
.b;$RKWR0	RKWRD$	DI	as $RKWRD but leading character already read	T1-T4	$RKWRD	#
	#	#	Inputs:  T1 : character
.b;$RNAME	RNAME$	DI	read an alphanumeric word from the current file. Only the 1st	T1-T4	11	#
	#	#	6 characters are remembered.
	#	#	Outputs: T1 : delimiting character
	#	#	         T2 : word of SIXBIT characters
.b;$RNAM0	RNAME$	DI	as $RNAME but leading character already read	T1-T4	$RNAME	#
	#	#	Inputs:  T1 : charatcer
.b;$ROCTL	ROCTL$	DI	read a signed octal number from the current file.  If the number	T1-T4	17	#
	#	#	terminates with a period, treat the number as if it had been decimal.
	#	#	Outputs: T1 : delimiting character
	#	#	         T2 : number
.b;$ROCT0	ROCTL$	DI	as $ROCTL but leading character already read	T1-T4	$ROCTL	#
	#	#	Inputs:  T1 : character
.b;$ROCTM	ROCTM$	DI	read an octal number (+ possible multiplier) from the current	T1-T4	3	#
	#	#	file. The number is as $ROCTL, but may have a multiplier, 'K' kilo,
	#	#	'M' mega or 'G' giga. Note that 1K = 1000 octal or 512 decimal.
	#	#	Outputs: T1 : delimiting character
	#	#	         T2 : number
.b;$ROCM0	ROCTM$	DI	as $ROCTM but leading character already read	T1-T4	$ROCTM	#
	#	#	Inputs:  T1 : character
.b;$RPATH	RPATH$	DI	read a path specification from the current file.  The spec. may	T1-T4	49	7.12
	#	#	contain wild numbers and SFDs.
	#	#	Returns: error : nonskip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : delimiting character (o.k. only)
	#	#	              syntax error code (error only)
	#	#	         T2 : PPN or point to path spec. block
	#	#	         T3 : PPN mask or point to path mask block
	#	#	         T4 : flags
.b;$RPAT0	RPATH$	DI	as $RPATH but enter with leading '[' already read	T1-T4	$RPATH	7.12
	#	#	Inputs:  T1 : ASCII character
.b;$RPJPG	RPJPG$	DI	read a project-programmer pair from the current file (no []).	T1-T4	43	7.12
	#	#	Both project and programmer may be wild.
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : delimiting character (o.k. only)
	#	#	            : syntax error code (error only)
	#	#	         T2 : PPN
	#	#	         T3 : wildcard mask
	#	#	         T4 : flags
.b;$RPJP0	RPJPG$	DI	as $RPJPG but leading character already read.	T1-T4	$RPJPG	7.12
	#	#	Inputs:  T1 : character
.b;$RPPN	RPPN$	DI	read a PPN in the form [PPN] from the current device.  The PPN	T1-T4	12	7.12
	#	#	may be wild.
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : delimiting character (o.k. only)
	#	#	              syntax error code (error only)
	#	#	         T2 : PPN
	#	#	         T3 : wildcard mask
	#	#	         T4 : flags
.b;$RPPN0	RPPN$	DI	as $RPPN but leading '[' already read	T1-T4	$RPPN	7.12
	#	#	Inputs:  T1 : character
.b;$RREAL	RREAL$	DI	read a signed floating point number from the current file.	T1-T4	39	#
	#	#	The number may have a signed exponent as Esnn.
	#	#	Outputs: T1 : delimiting character
	#	#	         T2 : number
.b;$RREA0	RREAL$	DI	as $RREAL but leading character already read	T1-T4	$RREAL	#
	#	#	Inputs:  T1 : character
.b;$RSWIT	RSWIT$	DI	read a switch spec. from the current file in the form	T1-T4	122	7.13
	#	#	'/name:value', where the name is a switch name either defined by the
	#	#	caller, or a standard name, and the value is optional and may be in
	#	#	one of a number of predefined forms.
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : delimiting character (o.k. only)
	#	#	            : syntax error code (error only)
.b;$RSWI0	RSWIT$	DI	as $RSWIT but leading '/' already read	T1-T4	$RSWIT	7.13
	#	#	Inputs:  character
.b;$RTDAY	RTDAY$	DI	read a date and time from the current file in the format	T1-T4	16	#
	#	#	'dd-mmm-yy hh:mm:ss'.  Either date or time may be omitted. 
	#	#	Assumptions are today, and midnight.
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : delimiting character
	#	#	            : syntax error code (error only)
	#	#	         T2 : time in milliseconds
	#	#	         T3 : date in internal format
.b;$RTDA0	RTDAY$	DI	as $RTDAY but leading character already read	T1-T4	$RTDAY	#
	#	#	Inputs:  T1 : character
.b;$RTIME	RTIME$	DI	read the time from the current file in the format 'hh:mm:ss'	T1-T4	22	#
	#	#	Trailing fields may be omitted.
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : delimiting character (o.k. only)
	#	#	            : syntax error code (error only)
	#	#	         T2 : time in milliseconds
.b;$RTIM0	RTIME$	DI	as $RTIME but leading character already read	T1-T4	$RTIME	#
	#	#	Inputs:  T1 : character
.b;$RUCCH	RUCCH$	DI	read a character from the current file and convert lower case	T1	6	#
	#	#	alphabetics to upper case.
	#	#	Note: this routine may be called to convert a character to upper case.
	#	#	Outputs: T1 : character
.b;$RUCC0	RUCCH$	DI	as $RUCCH but character already read	T1	$RUCCH	#
	#	#	Inputs:  T1 : character
.b;$RWNAM	RWNAM$	DI	read a name from the current file, where the name can include	T1-T4	65	#
	#	#	wildcards.  The name is treated as alphanumeric and converted to
	#	#	SIXBIT unless the leading character is '_#' when it is octal with a
	#	#	possible multiplier, and is converted to binary.
	#	#	Outputs: T1 : delimiting character
	#	#	         T2 : word (SIXBIT or binary)
	#	#	         T3 : wildcard mask
	#	#	         T4 : flags
.b;$RWNA0	RWNAM$	DI	as $RWNAM but leading character already read	T1-T4	$RWNAM	#
	#	#	Inputs:  T1 : character
.b;$RWNUM	RWNUM$	DI	as $RWNAM, but octal is assumed unless the 1st character is alpha.	T1-T4	$RWNAM	#
.b;$RWNU0	RWNUM$	DI	as $RWNUM but leading character already read	T1-T4	$RWNAM	#
	#	#	Inputs:  T1 : character
.b;$RWORD	RWORD$	DI	read a word of characters from the current file delimited by <SP> or	T1-T4	12	#
	#	#	any non-SIXBIT character. Only the 1st 6 characters are remembered
	#	#	Outputs: T1 : delimiting character
	#	#	         T2 : word of SIXBIT characters
.b;$RWOR0	RWORD$	DI	as $RWORD, but leading character already read	T1-T3	$RWORD	#
	#	#	Inputs:  T1 : character
.pg;.ts 16 25 45 100 113 122
	#	#	#	###Acs	#Size
Routine	Macro	DI	Description	destroyed	(words)	Section
=======	=====	==	===========	=========	=======	=======
.b 2;^&A.3 Formatted Write Routines\&
.ts 15 25 30 100 115 125
.b;$WRITE	WRITE$	DI	write one byte to the current file.	T1	14	7.2
	#	#	Inputs:  T1 : byte, right-justified
	#	#	Returns: error : non-skip
	#	#	         o.k   : skip
	#	#	Outputs: T1 : IO-error-code (error return only)
.b;$$WBYT	WBYTE$	DI	write one byte to the current file.  Fatal errors go to $FATAL.	T1	1	7.3
	#	#	Inputs:  T1 : byte, right justified
.b;$$WCHR	WCHAR$	DI	write one character to the current file.  Fatal errors go to $FATAL.	T1	$$WBYT	7.4
	#	#	Inputs:  T1 : ASCII character, right justified
.b;-------------------------------------------------------------------------------------------------------------------------
.b;$WADDR	WADDR$	DI	write the contents of a halfword (e.g. an address) as 6 octal	T1-T3	7	#
	#	#	digits, zero filled
	#	#	Inputs:  T1 : binary halfword (rh)
.b;$WBWRD	WBWRD$	DI	write a number as blocks (128 words) rounded up	T1-T3	$WWWRD	#
	#	#	Inputs:  T1 : number of words
.b;$WCASH	WCASH$	DI	write a sum in dollars and cents in the format '$ddddd.cc'	T1-T3	15	#
	#	#	Inputs:  T1 : value in cents
.b;$WCRLF	WCRLF$	DI	write a <cr><lf>	none	5	#
	#	#	Inputs:  none
.b;$WCWRD	WCWRD$	DI	write a number as a number of words of core choosing kwords or words	T1-T3	$WWWRD	#
	#	#	Inputs:  T1 : number of words
.b;$WDATE	WDATE$	DI	write a date in the format 'dd-mmm-yy'	T1-T3	15	#
	#	#	Inputs:  T1 : date in internal form
.b;$WDECL	WDECL$	DI	write a number in decimal	T1-T3	$WRADX	#
	#	#	Inputs:  T1 : number
.b;$WDNOW	WDNOW$	DI	write the date today in the format 'dd-mmm-yy'	T1-T3	$WDATE	#
	#	#	Inputs:  none
.b;$WDVIC	WDVIC$	DI	write a device name to the current file as 'nnn:'	T1-T2	3	#
	#	#	Inputs:  T1 : device name in SIXBIT
.b;$WFCHA	WFCHA$	DI	write a character exactly, by flagging control characters with _^,	T1-T3	34	#
	#	#	lower case characters with ', and naming special control characters.
	#	#	e.g. _^A, 'Z, <BEL>
	#	#	Inputs:  T1 : ASCII character, right justified
.b;$WFILE	WFILE$	DI	write a filename to the current file	T1-T2	22	#
	#	#	Inputs:  T1 : pointer to FDB containing filename
.b;$WKWRD	WKWRD$	DI	write a number as Kwords rounded up	T1-T3	$WWWRD	#
	#	#	Inputs:  T1 : number of words
.b;$WNAME	WNAME$	DI	write a name which maybe in XWD format	T1-T2	3	#
	#	#	Inputs:  T1 : name in SIXBIT
.b;$WOCTL	WOCTL$	DI	write a number in octal	T1-T3	$WRADX	#
	#	#	Inputs:  T1 : number
.b;$WPATH	WPATH$	DI	write a path specification in []s	T1-T3	18	#
	#	#	Inputs:  T1 : PPN or pointer to PATH. UUO block
.b;$WPWOR	WPWOR$	DI	write a character followed by a word of SIXBIT characters	T1-T2	$WWORD	#
	#	#	Inputs:  T1 : ASCII prefix character
	#	#	         T2 : word of SIXBIT characters
.b;$WPWRD	WPWRD$	DI	write a core size in pages rounded up	T1-T3	$WWWRD	#
	#	#	Inputs:  T1 : size in words
.b;$WRADX	WRADX$	DI	write an integer in a given radix	T1-T3	18	#
	#	#	Inputs:  T1 : number
	#	#	         T2 : radix
.b;$WREAL	WREAL$	DI	write a word as a floating point number (F format if 	T1-T4	54	#
	#	#	0.1 .le. n .ge. 1.0 and E format otherwise)
	#	#	Inputs:  T1 : number
.b;$WTDAY	WTDAY$	DI	write a time and date in format 'hh:mm:ss dd-mmm-yy'	T1-T3	6	#
	#	#	Inputs:  T1 : time in milliseconds
	#	#	         T2 : date in internal format
.b;$WTDNW	WTDNW$	DI	write the time and date now (i.e. write a timestamp)	T1-T3	4	#
	#	#	Inputs:  none
.b;$WTEXT	WTEXT$	DI	write a text string to the current file	T1	9	#
	WLINE$	#	Inputs:  T1 : pointer to ASCIZ text string
.b;$WTIME	WTIME$	DI	write a time in hours and minutes 'hh:mm'	T1-T3	8	#
	#	#	Inputs:  T1 : time in milliseconds
.b;$WTIMS	WTIMS$	DI	write a time accurate to seconds 'hh:mm:ss'	T1-T3	9	#
	#	#	Inputs:  T1 : time in milliseconds
.b;$WTMTS	WTMTS$	DI	write a time accurate to tenths of a second 'hh:mm:ss.t'	T1-T3	8	#
	#	#	Inputs:  T1 : time in milliseconds
.b;$WTNOW	WTNOW$	DI	write the time now as 'hh:mm:ss'	T1-T3	$WTIMS	#
	#	#	Inputs:  none
.b;$WVERS	WVERS$	DI	write out all fields of a version number in standard format	T1-T3	25	#
	#	#	Inputs:  T1 : version number
.b;$WWORD	WWORD$	DI	write out a word as 6 SIXBIT characters	T1-T2	7	#
	#	#	Inputs:  T1 : word of SIXBIT characters
.b;$WWWRD	WWWRD$	DI	write a number as a number of words e.g. 123W	T1-T3	18	#
	#	#	Inputs:  T1 : number of words
.b;$WXWD	WXWD$	DI	write a word as two halfwords, blank filled, separated by ,	T1-T3	8	#
	#	#	Inputs:  T1 : word
.b;$W2FIL	W2FIL$	DI	write a 2 digit number with a given fill character	T1-T3	8	#
	#	#	Inputs:  T1 : number
	#	#	         T2 : ASCII fill character
.b;$W2FLB	W2FLB$	DI	write a number in 2 digits filled with a space	T1-T3	$W2FIL	#
	#	#	Inputs:  T1 : number
.b;$W2FL0	W2FL0$	DI	write a number in 2 digits filled with a zero	T1-T3	$W2FIL	#
	#	#	Inputs:  T1 : number
.pg;.ts 16 25 45 100 113 122
	#	#	#	###Acs	#Size
Routine	Macro	DI	Description	destroyed	(words)	Section
=======	=====	==	===========	=========	=======	=======
.b 2;^&A.4 Core Management Routines\&
.ts 15 25 30 100 115 125
.b;$$ALLC	ALLOC$	I	allocate a block of free core. This routine exists to decide between	T1	2	5.1
	#	#	dynamic and static core allocation.
	#	#	Inputs:  T1 : number of words required
	#	#	Returns: no core : non-skip
	#	#	         o.k.    : skip
	#	#	Outputs: T1 : point to word 1 of allocated block (o.k. only)
	#	#	            : 0,,ERNEC% (error only)
.b;$$DALC	DEALC$	I	deallocate a block of core by returning it to the pool of	T1	$$ALLC	5.1
	#	#	free blocks
	#	#	Inputs:  T1 : point to word 1 of core block
.b;--------------------------------------------------------------------------------------------------------------------------
.b;$CRGET	#	I	allocate a block of core from above .JBFF, by moving .JBFF and	T1	17	5.3
	#	#	obtaining more core from the monitor if need be.
	#	#	Inputs:  T1 : size of chunk required
	#	#	Returns: no core : non-skip
	#	#	         o.k.   : skip
	#	#	Outputs: T1 : point to 1st word of chunk (o.k. only)
	#	#	            : 0,,ERNEC% (error only)
.b;$CRREL	#	I	it is not possible to deallocate a chunk using static management.	none	$CRGET	5.3
	#	#	This call is a noop.
.b;$HPGET	#	I	allocate a block of core from a linked list of free chunks of core.	T1	108	5.2
	#	#	If there is insuffient space, first garbage collect the list and then
	#	#	get more space from the monitor.
	#	#	Inputs:  T1 : size of chunk required or 0 for largest available
	#	#	Returns: no core : non-skip
	#	#	         o.k.   : skip
	#	#	Outputs: T1 : point to 1st word of chunk
	#	#	            : 0,,ERNEC% (error only)
.b;$HPREL	#	I	deallocate a chunk (or chunks) of core by linking it back into	T1	$HPGET	5.2
	#	#	the chain of free chunks.  Several chunks may be deallocated together
	#	#	chaining them through their -1th word.
	#	#	Inputs:  T1 : point to 1st word of chunk
.pg;.ts 16 25 45 100 113 122
	#	#	#	###Acs	#Size
Routine	Macro	DI	Description	destroyed	(words)	Section
=======	=====	==	===========	=========	=======	=======
.b 2;^&A.5 Data Block Manipulation Routines\&
.ts 15 25 30 100 115 125
.b;$CLRFD	CLRFD$	I	create a new standard length FDB, clear it, set the length in $FDCNT	T1	20	#
	MAKFD$	#	and initialise $FDBFR and $FDSNC to -1.
	#	#	Returns: no core : non-skip
	#	#	         o.k.    : skip
	#	#	Outputs: T1 : point to FDB (o.k. only)
	#	#	            : 0,,ERNEC% (error only)
.b;$CLRF0	CLRFD$	I	as $CLRFD, but allow caller to specify address and/or length of FDB	T1	$CLRFD	#
	#	#	If the address is given, the old FDB is used.
	#	#	Inputs:  T1 : length,,address of FDB
.b;$INIID	#	I	clear the IDB, set the verbosity to standard, set MAXCOR to all core	I	10+19	#
	#	#	and set the last command character to endline. This routine contains
	#	#	the IDB.
.b;$LOSFD	LOSFD$	I	deallocate the space occupied by an FDB.  If $FDPPN points to a path	T1	7	#
	#	#	block, the path block is deallocated also. This routine only
	#	#	succeeds if dynamic core management is used.
	#	#	Inputs:  T1 : point to 1st word of FDB
.b;$PATCH	#	#	patch area loaded if FT$DBG is on	none	0+200	#
.b;$STACK	#	#	pushdown stack and pointer thereto	none	1+100	3.8
.pg;.ts 16 25 45 100 113 122
	#	#	#	###Acs	#Size
Routine	Macro	DI	Description	destroyed	(words)	Section
=======	=====	==	==========	=========	======	=======
.b 2;^&A.6 Tempcore Routines\&
.ts 15 25 30 100 115 125
.b;$TMPDL	TMPDL$	DI	delete a tempcore file from core and/or disk	T1-T3	13	8.4
	#	#	It is not an error if the file does not exist.
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : IO error code (error only)
.b;$TMPFD	TMPFD$	#	create an FDB for a tempcore file given a 3 character name	T1-T4	17	8.2
	#	#	The name of the file is nnnccc.TMP, where 'nnn' is the job number
	#	#	and 'ccc' is the 3 character name.
	#	#	Inputs:  T1 : 3 SIXBIT characters, right justified
	#	#	Outputs: D  : point to FDB
.b;$TMPIN	TMPIN$	DI	read 1 block of a tempcore file from core or from disk. If core,	T1-T4	31	8.3
	#	#	set flag FC$TCI to ensure that further calls to $INPUT give endfile
	#	#	return.
	#	#	Inputs:  taken from FDB
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : IO error code (error only)
.b;$TMPOU	TMPOU$	DI	close off a tempcore file. If the file is not yet ENTERed, try to	T1-T4	19	8.5
	#	#	write the file to tempcore.  If so, or if tempcore fails, write to
	#	#	disk and release channel.
	#	#	Returns: error : non-skip
	#	#	         o.k.  : skip
	#	#	Outputs: T1 : IO error code (error only)
.pg;.ts 16 25 45 100 113 122
	#	#	#	###Acs	#Size
Routine	Macro	DI	Description	destroyed	(words)	Section
=======	=====	==	===========	=========	=======	=======
.b 2;^&A.7 Error Routines\&
.ts 15 25 30 100 115 125
.b;$ADVIS	ADVIS$	I	write an advisory error message. Call as for $ERROR	T1-T4	$ERROR	9.5
	#	#	Inputs:  as for $ERROR
	#	#	Returns: yes
.b;$ERROR	#	I	write an error message to the error file whose point is in $IDEFD(I)	T1-T4	57	9.4
	#	#	Full documentation may be found in section 9.4
	#	#	Inputs:  T1 : message point and flags
	#	#	         T2 : value
	#	#	         T3 : UUO or error type name (optional)
	#	#	Returns: depends; yes if warning, no if fatal
.b;$FATAL	FATAL$	I	write a fatal error message. Call as for $ERROR.	T1-T4	$ERROR	9.5
	#	#	Inputs:  as for $ERROR
	#	#	Returns: never; traps to $$FERR
.b;$FTLIO	FATAL$	DI	write a fatal error message for the current file based on an IO error	T1-T4	21	9.7
	#	#	code, returned by basic IO module routines
	#	#	Inputs:  T1 : UUO-code,,error code
.b;$FTLSY	FATAL$	I	write a fatal error message based on an error code returned by	T1-T4	8	9.8
	#	#	the command scanning subroutines.
	#	#	Inputs:  T1 : syntax error code
	#	#	         T2 : value
.b;$WARN	WARN$	I	write a warning error message. Call as for $ERROR	T1-T4	$ERROR	9.5
	#	#	Inputs:  as for $ERROR
	#	#	Returns: yes
.b;$WRNIO	WARN$	DI	write a warning error message about the current file. A code is	T1-T4	$FTLIO	9.7
	#	#	returned by the routines in the basic IO module.
	#	#	Inputs:  T1 : UUO-code,,error-code
.b;$WRNSY	WARN$	I	write a warning error about bad syntax, given a code returned	T1-T4	$FTLSY	9.8
	#	#	by the command scanners on error.
	#	#	Inputs:  T1 : syntax error code
	#	#	         T2 : value
.b;$$FERR	#	#	exit to monitor mode after clearing input buffer. If CONTINUEd,	T1	5	9.9
	#	#	try to start at start address, if fail, exit.
	#	#	Returns:  only to program start address
.pg;.ts 16 25 45 100 113 122
	#	#	#	###Acs	#Size
Routine	Macro	DI	Description	destroyed	(words)	Section
=======	=====	==	===========	=========	=======	=======
.b 2;^&A.8 Utility Routines\&
.ts 15 25 30 100 115 125
.b;$POPJ	#	#	execute a POPJ P, instruction	none	IOMOD	#
.b;$POPJ1	#	#	increment the return address and POPJ, thus doing a skip return	none	IOMOD	#
.b;$POPJ2	#	#	double increment the return address and POPJ, thus doing a double	none	IOMOD	#
	#	#	skip return. Cannot be used with $SAVEn.
.b;$TOPJ	#	#	POP the top of the stack into T1 and POPJ return	T1	IOMOD	#
.b;$TOPJ1	#	#	POP the top of the stack into T1 and skip POPJ return	T1	IOMOD	#
.b;$TOPJ2	#	#	POP the top of the stack into T1 and double skip POPJ return	T1	IOMOD	#
	#	#	Cannot be used with $SAVEn.
.b;$XOPJ	#	#	POP the top off the stack (to nowhere) and POPJ return	none	IOMOD	#
.b;$XOPJ1	#	#	POP the top off the stack and skip POPJ return	none	IOMOD	#
.b;--------------------------------------------------------------------------------------------------------------------------
.b;$RESTT	RESTT$	#	restore T1-T4 from the stack	T1-T4	$SAVET	#
.b;$SAVET	SAVET$	#	save T1-T4 on the stack	none	13	#
.b;$SAVE1	SAVE1$	#	called on entry to a subroutine to save P1 and to restore P1 on exit	none	IOMOD	#
	#	#	The caller is called as a subroutine so that his eventual POPJ
	#	#	returns to $SAVE1 to restore P1.  POPJ and POPJ1 are catered for
.b;$SAVE2	SAVE2$	#	as $SAVE1, but P1 and P2 are saved and restored	none	IOMOD	#
.b;$SAVE3	SAVE3$	#	as $SAVE1, but P1, P2 and P3 are saved and restored	none	IOMOD	#
.b;$SAVE4	SAVE4$	#	as $SAVE1, but P1, P2, P3 and P4 are saved and restored	none	IOMOD	#
.b;--------------------------------------------------------------------------------------------------------------------------
.b;$BATCH	BATCH$	#	determine whether the job's terminal is a PTY	none	6	#
	#	#	Returns: not PTY : non-skip
	#	#	         PTY     : skip
.b;$BEGCC	BEGIn$	DI	initialise a program and set up CCL tempcore input file if entry	T1-T2	10	3.9
	#	#	was at 'start+1'.
.b;$BEGIN	BEGIN$	DI	initialise a program	T1-T2	5	3.9
.b;$CLBUF	CLBUF$	DI	clear command input by clearing the TTCALL TTY buffer or by reading	T1	18	#
	#	#	to endline.
.b;$CLLIN	CLLIN$	DI	clear the current command input line	none	5	#
.b;$CNVNU	CNVNU$	#	return the universal date/time now	T1-T4	$CNVUI	#
	#	#	As $CNVIU but uses the date/time from the monitor
.b;$CNVUI	CNVUI$	#	convert a date/time in universal format to internal format	T1-T4	102	#
	#	#	Inputs:  T1 : universal date,,time
	#	#	Outputs: T1 : time in milliseconds
	#	#	         T2 : date in internal format
.b;$CNVIU	CNVIU$	#	convert internal date/time to universal format	T1-T4	$CNVUI	#
	#	#	Inputs:  T1 : time in milliseconds
	#	#	         T2 : date in internal format
	#	#	Outputs: T1 : universal date,,time
.b;$FDTTY	FDTTY$	DI	check whether the current file is a terminal or not.	none	6	#
	#	#	Returns: not TTY : normal
	#	#	         TTY     : skip
.b;$MATCH	MATCH$	#	match a SIXBIT name against a table of names, selecting	T1-T3	36	10.1
	#	#	either an exact match or an unambiguous abbreviation. A name in
	#	#	the table may begin with '*' to say that the first letter is enough
	#	#	to identify this name.
	#	#	Inputs:  T1 : IOWD length,address of table
	#	#	         T2 : SIXBIT name to match
	#	#	Returns: error, no or several matches
	#	#	         o.k.  :skip
	#	#	Outputs: T1 : flag,,table index. lh=0 if exact, lt 0 if not (o.k. only)
	#	#	            : lt 0 : no match; ge 0 :several (error only)
.b;$MONRT	MONRT$	#	return to monitor mode by EXIT 1, unless job not logged in. Then	T1	13	#
	#	#	use LOGOUT.  Return to caller on 'CONTINUE'.
	#	#	Return:  only if CONTINUE is typed at monitor mode
.b;$SLEEP	SLEEP$	#	send the job to sleep for a specified period using HIBER or SLEEP	T1	9	#
	#	#	Inputs:  T1 : sleep time in seconds
.b;$ZERO	ZERO$	#	zero a chunk of core by BLT	none	10	#
	#	#	Inputs:  T1 : length,,address
.f
.number appendix B
.ap;.ps 59 132;.ax IOLIB Macros
.lm 5
 This appendix is a complete list of all IOLIB macros.
The macros are listed under several headings but within those
headings the macros are listed in alphabetical order.
The macros that are useful in writing the program, rather than
macros which merely call routines, are listed first.
The macro name is given, along with the names of any routines
called, a brief description, the call, the number of lines
of inline code generated, and a further reference.
The descriptions in this appendix are not as full as those of
the routines in appendix A, and the user should refer to appendix A
if he needs clarification.
.b 2;.nf;.ts 15 40 90 118 125
	#	#	#	Inline
Macro	Routine	Description	Call	#code	Section
=====	=======	===========	====	======	=======
.b 2;.ts 15 25 85 118 128
^&B.1 Programming Macros\&
.b;BEGIN$	$BEGIN	perform all program initialisation including concealed	BEGIN$###tfn	5	3.9
	#	mode entry points, CCL entry points, RESET UUO, stack
	#	setup, IDB initialisation and command FDB setup
	#	'tfn'  3 character tempcore filename (otherwise program name)
.b;CMDFD$	#	set ac(D) to point to the current command file.	CMDFD$	1	#
	#	Load ac(D) from $IDIFD(I).
.b;ERRFD$	#	set ac(D) to point to the current error file.	ERRFD$	1	#
	#	Load ac(D) from $IDEFD(I).
.b;FDESC$	#	create an inline FDB and fill it with values	FDESC$###dv,nm,ex,pt,md,ln	$LNFDB+	3.12
	#	'dv' device name
	#	'nm' file name
	#	'ex' extension name
	#	'pt' path spec. in <>, e.g. <104,427>
	#	'md' IO mode
	#	'ln' length of FDB, if longer than standard
.b;HISEG$	#	if first call of program, create 'TWOSEG' and 	HISEG$	0	3.11
	#	'RELOC 400000' pseudo-ops to start two-segmenting
	#	otherwise, if assembling high segment code, do nothing;
	#	otherwise, set outstanding literals into low segment
	#	and switch segments
.b;JBREN$	#	load .JBREN (reenter address) with the given address	JBREN$###ac,adr	2	#
	#	The user may choose the temporary ac.
	#	'ac'  temporary ac to be used
	#	'adr' reenter address
.b;JBVER$	#	set the version number defined by the $$V??? symbols	JBVER$	0	3.14
	#	into .JBVER in DEC format
.b;LDFD$	#	move an FDB point into ac(D)	LDFD$   adr	1	#
	#	'adr'  address of FDB point
.b;LDFDI$	#	move immediate an FDB point into ac(D)	LDFDI$   adr	1	#
	#	'adr'  FDB point
.b;LOSEG$	#	if assembling code into the low segment, do nothing	LOSEG$	0	3.11
	#	otherwise, set all outstanding literals into high
	#	segment and switch segments
.b;MAKFD$	#	write code to create or initialise an FDB and	MAKFD$###dv,nm,ex,pt,md,ln,ad	5+	3.13
	#	fill the FDB with values.
	#	'dv'  device name
	#	'nm'  file name
	#	'ex'  extension name
	#	'pt'  path spec. inside <>, e.g. <104,427,SF1>
	#	'md'  IO mode
	#	'ln'  length of FDB if non-standard
	#	'ad'  address of FDB; if none make a new FDB
	#	      if an ac, use it as point to address
.b;MSGFD$	#	set ac(D) to point to the current message file.	MSGFD$	1	#
	#	Load ac(D) from $IDOFD(I).
.b;PATCH$	#	increment $$VEDT for each patch; increment $$VMIN by one	PATCH$###<p1,p2,..pn>	0	3.14
	#	and make a symbol '$n' for each pn to be used if adding
	#	and subtracting code with IFDEF and IFNDEF
	#	'p1,..pn'  patch numbers
.b;TRMFD$	#	set ac(D) to point to the job's terminal. Zero ac(D).	TRMFD$	1	#
.b;VERSN$	#	define values for the symbols, $$VMAJ, $$VMIN	VERSN$###vm,ve,vw	0	3.14
	#	$$VEDT and $$VCOD. These symbols are used by the other
	#	version number macros and are explained in section 3.14.
	#	'vm' is the major version number
	#	've' is the edit number (updated by PATCH$)
	#	'vw' is the who last edited code
	#	the minor version is set to zero (updated by PATCH$)
	#	The versions of C and IO used are PRINTXed during assembly.
.b;VTEXT$	#	creates an ASCIZ string of the version number from	VTEXT$	1+	3.14
	#	the version number symbols e.g. '5B(107)-1'
.pg;.ts 15 40 90 118 125
	#	#	#	Inline
Macro	Routine	Description	Call	#code	Section
=====	=======	===========	====	======	=======
.b 2;^&B.2 Basic IO Macros\&
.ts 15 25 85 118 128
.b;APDWT$	$APDWT	as APEND$ but on 'file being modified' failure	APDWT$	1	6.21
	#	wait and try again a given number of times	##error return
.b;APEND$	$APEND	open a file for appending, setting buffer pointers	APEND$	1	6.22
	#	appropriately. Only works for append mode files.	##error return
.b;CLOSE$	$CLOSE	execute a CLOSE UUO. If the call has an argument, two	CLOSE$###bits	1!2	6.7
	#	instructions are generated, and the arguments are used
	#	as CLOSE UUO bits.
	#	'bits'  CLOSE UUO bits
.b;DELET$	$DELET	delete the current file	DELET$	1	6.10
	#	#	##error return
.b;DLBUF$	$DLBUF	deallocate a buffer ring	DLBUF$	1	6.18
.b;ENTER$	$ENTER	Execute an ENTER UUO for the current file. If the 	ENTER###x	1	6.5
	#	macro has an argument then the UUO may change the	##error return
	#	create date/time field
	#	'x'  any argument (just a flag)
.b;FRCHN$	$FRCHN	locate the first free software IO channel starting	FRCHN$	1	#
	#	with the contents of ac(T1)	##error return
.b;GETST$	$GETST	get the IO status halfword from the monitor. The status	GETST$	1	6.12
	#	returned in ac(t1)
.b;LUKUP$	$LUKUP	execute a LOOKUP UUO for the current file.	LUKUP$	1	6.4
	#	#	##error return
.b;INPUT$	$INPUT	execute an INPUT UUO for the current file. Make a	INPUT$	1	6.2
	#	buffer ring and find the required record if needed	##error return
	#	#	##endfile return
.b;MKBUF$	$MKBUF	build a buffer ring (see Appendix A)	MKBUF$	1	6.17
	#	#	##error return
.b;MTxxx$	$MTxxx	execute an MTAPE UUO for the current file.	MTxxx$	1	6.23
	#	'xxx' may be any of the codes for the various MTAPE
	#	functions, e.g. MTREW$ executes a rewind.
	#	All functions are followed by an MTWAT$ to wait for completion.
	#	MTBSF$ skips over the EOF unless at BOT.
.b;OPEN$	$OPEN	execute an OPEN UUO for the current file, setting	OPEN$	1	6.6
	#	defaults and finding a free channel	##error return
.b;OUTIN$	$OUTIN	output the last record input (to a disk device)	OUTIN$	1	6.3
	#	#	##error return
.b;OUTPU$	$OUTPU	execute an OUTPUT UUO for the current file	OUTPU$	1	6.3
	#	making a buffer ring and finding required record if	##error return
	#	necessary
.b;RLEAS$	$RLEAS	execute a RELEAS UUO for the current file and 	RLEAS$   x	1	6.8
	#	deallocate buffers
	#	'x'  flag.  If given, don't deallocate buffers.
.b;RENAM$	$RENAM	execute a RENAME UUO for the current file. The file	RENAM$	1	6.9
	#	have been LUKUP$ed first.	##error return
.b;SETST$	$SETST	set the IO channel status from ac(T1) into the monitor	SETST$	1	6.13
.b;UPDAT$	$UPDAT	open a file for updating	UPDAT$	1	6.19
	#	#	##error return
.b;UPDWT$	$UPDWT	as UPDAT$, but on 'file being modified' failure	UPDWT$	1	6.20
	#	wait and try again a given number of times	##error return
.b;USETI$	$USETI	find the required record for disk files. On entry	USETI$	1	6.11
	#	ac(T1) contains  'last-record,,next record'
.b;USETO$	$USETO	find the required record for output for disk files	USETO$	1	6.11
	#	On entry ac(T1) contains 'last-record,,this-record'
.b;XTCAL$	$XTCAL	execute a CALLI UUOZ for the current file, setting	XTCAL$##uuo	2	6.15
	#	physical-only if required	##error return
	#	'uuo'  CALLI UUO to be executed (arg in ac(T2))
.b;XTDCL$	$XTDCL	execute a device dependent CALLI UUO for the current	XTDCL$###uuo	2	6.16
	#	file.	##error return
	#	'uuo'  CALLI UUO to be executed
.b;XTUUO$	$XTUUO	execute an IO UUO for the current file	XTUUO$###uuo	2	6.14
	#	'uuo'  UUO name	##error return
.pg;.ts 15 40 90 118 125
	#	#	#	Inline
Macro	Routine	Description	Call	#code	Section
=====	=======	===========	====	======	=======
.b 2;^&B.3 Read macros\&
.ts 15 25 85 118 128
.b;RBYTE$	$$RBYT	read a byte, and trap to $FATAL on error	RBYTE$	1	7.6
	#	#	##endfile
.b;RCALT$	$RCALT	read a character with command editing, but if last	RCALT$	1	7.10
	#	character was altmode, return altmode instead.
.b;RCCHR$	$RCCHR	read a character with command editing	RCCHR$	1	7.10
.b;RCHAR$	$$RCHR	read a character with command editing	RCHAR$	1	7.8
.b;READ$	$READ	read a byte	READ$	1	7.5
	#	#	##error return
	#	#	##endfile
.fill
.tab stops
.b;-----------------------------------------------------------------------------------------------------------------------------
 The following macros will accept an argument.  If an argument is provided it is assumed to be the address of the leading character
of the string to be read.  If that address is ac(T1), the macro merely
assembles a jump to the secondary entry point of the routine.
If the address is elsewhere, then the macro assembles an extra instruction to move the character into ac(T1).
If there is no argument, the macro assembles a PUSHJ to the
routine as described in appendix A.
 All the macros given below return the delimiting character in ac(T1)
and the value read in ac(T2).
Some routines return a wildcard mask in ac(T3), and a few return extra
data in ac(T4).
Refer to the description of the routines for specific details of
parameters.
.nf;.ts 15 25 85 118 128
.b;RANCH$	$RANCH	read a character and check whether alphanumeric	RANCH$##ac	1!2	#
	#	error return means not alphanumeric	##error return
.b;RCASH$	$RCASH	read a cash value in dollars and cents	RCASH$ ac	1!2	#
	#	#	##error return
.b;RDATE$	$RDATE	read a date from the current file in the format	RDATE$##ac	1!2	#
	#	dd-mmm-yy.	##error return
.b;RDECL$	$RDECL	read a decimal number	RDECL$##ac	1!2	#
.b;RDECM$	$RDECM	read a decimal number possibly with a K, M or G	RDECM$##ac	1!2	#
	#	multiplier
.b;RDVIC$	$RDVIC	read a device name	RDVIC$##ac	1!2	#
.b;REDCH$	$REDCH	read a character and perform basic editing	REDCH$##ac	1!2	7.9
.b;RFILE$	$RFILE	read a file specification into an FDB. Note that this	RFILE$###ac	1!2	7.11
	#	macro is different. If there is no argument, there is	##error return
	#	no switch table, and $RFILE creates an FDB. If there
	#	is an argument, it is an ac which holds a point to the
	#	switch table (possibly zero).  If this is ac(T1), no
	#	extra code is created.  A point to an FDB or zero must
	#	be in ac(T2).
.b;RKWRD$	$RKWRD	read a core size as Kwords or pages	RKWRD$##ac	1!2	#
.b;RNAME$	$RNAME	read an alphanumeric name and convert to a SIXBIT word	RNAME$##ac	1!2	#
.b;ROCTL$	$ROCTL	read an octal number	ROCTL$##ac	1!2	#
.b;ROCTM$	$ROCTM	read an octal number possibled postfixed by a K, M or G	ROCTM$##ac	1!2	#
	#	multiplier.
.skip 1
RPATH$	$RPATH	read a path specification	RPATH$##ac	1!2	7.12
	#	#	##error return
.skip 1
RPJPG$	$RPJPG	read a project,programmer pair (no [])	RPJPG$##ac	1!2	7.12
	#	#	##error return
.b;RPPN$	$RPPN	read a PPN	RPPN$###ac	1!2	7.12
	#	#	##error return
.b;RREAL$	$RREAL	read a floating point number expressed in FORTRAN E or F	RREAL$##ac	1!2	#
	#	format.
.b;RSWIT$	$RSWIT	read a switch name and value	RSWIT$##ac	1!2	7.13
	#	#	##error return
.b;RTDAY$	$RTDAY	read a tme and date	RTDAY$##ac	1!2	#
	#	#	##error return
.b;RTIME$	$RTIME	read a time in the format hh:mm:ss	RTIME$##ac	1!2	#
	#	#	##error return
.b;RUCCH$	$RUCCH	read a character and convert lower to upper case	RUCCH$##ac	1!2	#
.b;RWNAM$	$RWNAM	read a possibly wild name	RWNAM$##ac	1!2	#
.b;RWNUM$	$RWNUM	read a possibly wild number (or name if 1st character is	RWNUM$##ac	1!2	#
	#	alphabetic).
.pg;.ts 15 40 90 118 125
	#	#	#	Inline
Macro	Routine	Description	Call	#code	Section
=====	=======	===========	====	======	=======
.b 2;.ts 15 25 85 118 128
^&B.4 Write Macros\&
.b;WADDR$	$WADDR	write an octal address in 6 digits filled by zeros	WADDR$	1	#
.b;WBWRD$	$WBWRD	write a number as a number of blocks (128 words)	WBWRD$	1	#
.b;WBYTE$	$$WBYT	write a byte but trap to $FATAL on error	WBYTE$	1	7.3
.b;WCASH$	$WCASH	write a number of cents as dollars and cents	WCASH$	1	#
.b;WCHAR$	$$WCHR	write character	WCHAR$   "c"	1!2	7.4
	#	'c'  an ASCII character
.b;WCRLF$	$WCRLF	write an endline <cr><lf>	WCRLF$	1	#
.b;WCWRD$	$WCWRD	write a number as a multiple of core size	WCWRD$	1	#
	#	which may be P, K or W.
.b;WDATE$	$WDATE	write a date as dd-mmm-yy	WDATE$	1	#
.b;WDECL$	$WDECL	write a decimal number	WDECL$   n	1!2	#
	#	'n'  a positive decimal number
.b;WDNOW$	$WDNOW	write the date now	WDNOW$	1	#
.b;WDVIC$	$WDVIC	write a device name as 'dev:'	WDVIC$	1	#
.b;WFCHA$	$WFCHA	write a funny character, making code explicit	WFCHA$	1	#
	#	by flagging control and lower case characters
.b;WFILE$	$WFILE	write the filename from an FDB	WFILE$	1	#
.b;WHELP$	$WHELP	write a help text	WHELP$	1	#
.b;WKWRD$	$WKWRD	write a core size in Kwords	WKWRD$	1	#
.b;WLINE$	$WTEXT	write a text string adding a <cr><lf>	WLINE$   <text>	1!2	#
	#	'text'  a string of ASCII characters
.b;WNAME$	$WNAME	write a name in SIXBIT or halfwords	WNAME$	1	#
.b;WOCTL$	$WOCTL	write an octal number	WOCTL$   n	1!2	#
	#	'n'  a positive octal number
.b;WPATH$	$WPATH	write a path specification (or just PPN)	WPATH$	1	#
.b;WPWOR$	$WPWOR	write a word of SIXBIT characters preceded by an	WPWOR$   "c",word	1!2!3	#
	#	ASCII character. Either argument may be ommitted.
	#	'c'  an ASCII character
	#	'word'  up to 6 SIXBIT characters
.b;WPWRD$	$WPWRD	write a core size in pages	WPWRD$	1	#
.b;WRADX$	$WRADX	write a number in a given radix (given in ac(T2))	WRADX$	1	#
.b;WREAL$	$WREAL	write a floating point number	WREAL$   n	1!2	#
	#	'n'  a number in FORTRAN E-format
.b;WRITE$	$WRITE	write a byte	WRITE$	1	7.2
	#	#	##error return
.b;WTDAY$	$WTDAY	write time and date as dd-mmm-yy hh:mm	WTDAY$	1	#
.b;WTDNW$	$WTDNW	write time and date now	WTDNW$	1	#
.b;WTEXT$	$WTEXT	write a text string	WTEXT$   <text>	1!2	#
	#	'text'  a string of ASCII characters
.b;WTIME$	$WTIME	write time as hh:mm	WTIME$	1	#
.b;WTIMS$	$WTIMS	write time as hh:mm:ss	WTIMS$	1	#	
.b;WTMTS$	$WTMTS	write time as hh:mm:ss.t	WTMTS$	1	#
.b;WTNOW$	$WTNOW	write time now as hh:mm:ss	WTNOW$	1	#
.b;WWORD$	$WWORD	write a word of SIXBIT characters	WWORD$   word	1!2	#
	#	'word'  a string of up to 6 characters
.b;WWWRD$	$WWWRD	write a number as a number of words	WWWRD$	1	#
.b;WXWD$	$WXWD	write a word as two halfwords	WXWD$	1	#
.b;W2FIL$	$W2FIL	write 2 digits, filled on left	W2FIL$	1	#
.b;W2FLB$	$W2FLB	write 2 digits, filled on left by space	W2FLB$	1	#
.b;W2FL0$	$W2FL0	write 2 digits, filled on left by zero	W2FL0$	1	#
.pg;.ts 15 40 90 118 125
	#	#	#	Inline
Macro	Routine	Description	Call	#code	Section
=====	=======	===========	====	======	=======
.b 2;.ts 15 25 85 118 128
^&B.5 Core Management Macros\&
.b;ALLOC$	$$ALLC	call the memory manager to allocate space	ALLOC$	1	5.1
	#	#	##error return
.b;DEALC$	$$DALC	call the memory manager to deallocate space	DEALC$	1	5.1
.b 2;^&B.6 Data Block Manipulation Macros\&
.b;CLRFD$	$CLRFD	maybe create, but certainly zero and initialise an	CLRFD$##adr	1!2	#
	#	FDB. If the macro has an argument use this as the address	##error return (no core)
	#	of the FDB.
	#	'adr'  address of FDB
.b;LOSFD$	$LOSFD	deallocate space occupied by FDB. Deallocates path	LOSFD$	1	#
	#	block, if any, too
.b 2;^&B.7 Tempcore Macros\&
.b;TMPDL$	$TMPDL	delete a tempcore file	TMPDL$	1	8.4
	#	#	##error return
.b;TMPFD$	$TMPFD	create an FDB for a tempcore file	TMPFD$	1	8.2
.b;TMPIN$	$TMPIN	read a tempcore file	TMPIN$	1	8.3
	#	#	##error return
.b;TMPOU$	$TMPOU	write and close a tempcore file	TMPOU$	1	8.5
	#	#	##error return
.pg;.ts 15 40 90 118 125
	#	#	#	Inline
Macro	Routine	Description	Call	#code	Section
=====	=======	===========	====	======	=======
.b 2;.ts 15 25 85 118 128
.b 2;^&B.8 Error Macros\&
.b;ADVIS$	$ADVIS	write an advisory message to the error file	ADVIS$ <text>,arg,ec,uc	1	9.6
	#	'text' the text of the message
	#	'arg'  a code for the type of argument
	#	'ec'   a 3 character code prefaciing the message
	#	'uc'   a 6 character UUO name
.b;FATAL$	$ERROR	write a fatal error message to the error file and	FATAL$   <text>,arg,ec,uc	1	9.6
	#	exit through $$FERR.
	#	'text'  the text of the message
	#	'arg'   a code for the type of the argument
	#	'ec'    a 3 character code which prefixes the message
	#	'uc'    a 6 character UUO name
.b;WARN$	$ERROR	send a warning error message to the error file	WARN$   <text>,arg,ec,uc	1	9.6
	#	'text'  the text of the error message
	#	'arg'   a code for the data type of the argument
	#	'ec'    a 3 character code prefacing the message
	#	'uc'    a 6 character UUO name
.pg;.ts 15 40 90 118 125
	#	#	#	Inline
Macro	Routine	Description	Call	#code	Section
=====	=======	===========	====	======	=======
.ts 15 25 85 118 128
.b 2;^&B.9 Utility Routine Macros\&
.b;BATCH$	$BATCH	discover whether job running from PTY	BATCH$	1	#
	#	#	##not PTY return
.b;CLBUF$	$CLBUF	clear buffer for job's terminal; read to 	CLBUF$	1	#
	#	endline otherwise
.b;CLLIN$	$CLLIN	read to endline	CLLIN$	1	#
.b;CNVNU$	$CNVNU	return now as a Universal date/time	CNVNU$	1	#
.b;CNVUI$	$CNVUI	convert Universal date/time to internal	CNVUI$	1	#
.b;CNVIU$	$CNVIU	convert internal date/time to Universal	CNVIU$	1	#
.b;FDTTY$	$FDTTY	check whether the current file in a terminal	FDTTY$	1
	#	#	##not TTY
	#	#	TTY
.b;MATCH$	$MATCH	match a SIXBIT name against a table	MATCH$	1	10.2
.b;MONRT$	$MONRT	return to monitor mode	MONRT$	1	#
.b;RESTT$	$RESTT	restore T1-T4 from the stack	RESTT$	1	#
.b;SAVET$	$SAVET	save acs T1-T4 on the stack	SAVET$	1	#
.b;SAVE1$	$SAVE1	preserve ac(P1) during a subroutine	SAVE1$	1	#
.b;SAVE2$	$SAVE2	preserve acs P1-P2 during a subroutine	SAVE2$	1	#
.b;SAVE3$	$SAVE3	preserve acs P1-P3during a subroutine	SAVE3$	1	#
.b;SAVE4$	$SAVE4	preserve acs P1-P4 during a subroutine	SAVE4$	1	#
.b;SLEEP$	SLEEP	sleep by HIBER or SLEEP UUO for given time	SLEEP$##ac	1!2	#
	#	Time may be give in 'ac'.
.b;ZERO$	$ZERO	zero a chunk or memory	ZERO$	1	#
.f
.number appendix C
.;
.ap;.ps 59 75;.ax Contents of the FDB
.lm 5
.;
.b 2;.nf;.ts 15 25
Index	Symbol	Description
=====	======	===========
.b 1;^&C.1 Words within the FDB\&
.b;.lm 25;.f
.i -20;0	$FDFPT	forward pointer.
The left half is used to link FDBs together to form a linked list.
The left half is unused but reserved for IOLIB.
.b;.i -20;1	$FDCHN	channel number.
The right half contains the software IO channel number in bits 29 to 32.
The user may select a channel number but normally he will let IOLIB do this for him.
The left half contains flags showing the status of the IO process on this file.  
The flags are described below.
.b;.i -20;2	$FDTYP	argument returned by a DEVTYP UUO on the channel.
Set by the $OPEN routine.
.b;.i -20;3	$FDNBK	current record number for the FDB,,next record number for the FDB.
The next record number may be set before calling $INPUT or $OUTPU for a disk device only.
Updated by $INPUT, $OUTPU, $USETI, $USETO and initialised by $OPEN
only if zero.
.b;.i -20;4	$FDBUF	buffering details.
The right half contains the length of each buffer in words.
The left half contains the number of buffers.
IOLIB assumes that these details are identical for input and output
sides of a channel.
Defaults are two buffers of the standard size for the device.
Set up by $OPEN.
.b;.i -20;5	$FDIOW	Point to IOWD chain for dump mode IO.
Normally zero for buffered modes, but may be the address of the next buffer if out of sequence.
.b;.i -20;6-10	$FDOPN	3 word OPEN UUO data block.
The words are described indiviually below, and in the Monitor Calls Handbook.
.b;.i -20;6	$FDSTS	IO channel status.
The $open routine takes values supplied in $FDMOD, for parity, density and physical-only, and puts them into
$FDSTS.
All other fields default to zero, in particular, the default mode
is ASCII (.IOASC).
$GETST writes the current IO status into the right half of $FDSTS.
.b;.i -20;7	$FDDEV	device name, left-justified.
The default is 'DSK' for IOLIB IO.
.b;.i -20;10	$FDBHD	buffer header addresses.
The left half is the output buffer header address and the right half is
the input buffer header address.
The buffer headers are within the FDB at $FDOBH and $FDIBH.
.b;.i -20;11-21	$FDPTH	path specification in a form suitable
for PATH. UUOs. The first 2 words are unused, the 3rd word is the PPN
and further words are SFDs terminated by a zero word.
.b;.i -20;13	$FDPPP	PPN word in the path specification
.b;.i -20;14	$FDSFD	first SFD name in the path specification
.b;.i -20;22-25	$FDOBH	output buffer header (4 words).
Also used for the path mask for command scanning.
.b;.i -20;22-27	$FDPTM	path mask block of 6 words masking
the PPN and the SFDs. Set by the filename scanner RFILE to indicate wildcards
typed.
.b;.i -20;26-31	$FDIBH	input buffer header (4 words).
Also used for part of the path mask and for the filename mask in command
scanning.
.b;.i -20;30	$FDNMM	filename name mask.
Set by the filename scanner, $RFILE, to indicate which characters were
wildcards.
.b;.i -20;32	$FDMOD	modifier word.
A vector of switches and parameters that may be set by the user by program or by command.
The individual fields in the modifier word are described below.
.b;.i -20;33	$FDMOM	modifier mask.
A vector of masks corresponding to the various fields in $FDMOD.
If the mask in $FDMOM is set, then that field in $FDMOD has been given.
.b;.i -20;34	$FDBFR	/BEFORE specification. Set by the command scanner to
give the /BEFORE date and time.
.b;.i -20;35	$FDSNC	/SINCE specification. Set by the command scanner to
give the /SINCE date and time.
.b;.i -20;36	$FDABF	/ABEFORE specification. Set by the command scanner to
give the access BEFORE date and time.
.b;.i -20;37	$FDASN	/ASINCE specification. Set by the command scanner
to give the access SINCE date and time.
.b;.i -20;40-46	$FDRIB	RIB block data.
The format of the RIB block section is as for extended disk UUOs.
A standard FDB contains the RIB block from .RBCNT to .RBVER, but
further words may be added by building an extended FDB.
The RIB data is physically the last information in an FDB.
For further details, see the Monitor Calls Handbook.
.b;.i -20;40	$FDCNT	the count of words in the extended RIB.
.b;.i -20;41	$FDPPN	either the PPN or a point to a PATH. UUO block.
MAKFD$ and FDESC$ set up $FDPPN to point to $FDPTH, but the user
may write a PPN over this pointer or even a pointer to another path
block.
.b;.i -20;42	$FDNAM	the filename in SIXBIT, left justified.
.b;.i -20;43	$FDEXT	Extension.
The left half contains the extension in 3 SIXBIT characters, left-justified.
The right half is used by the command scanner for the extension mask.
.b;.i -20;44	$FDPRV	privilege word.
Contains protection, mode and create time and date information.
.b;.i -20;45	$FDSIZ	file size in words.
.b;.i -20;46	$FDVER	version number.
.b;.i -20;46	$ENFDB	end of the FDB.
.b;.i -20;47	$LNFDB	length of an FDB in words.
.pg;.nf;.lm -20
Bits	Symbol	Description
====	======	===========
.b 2;^&C.2 Bits definitions for $FDCHN\&
.f;.lm +20
.b;.i -20;0	FC$OPN	an OPEN UUO has been done on this channel
.b;.i -20;1	FC$LUK	a LOOKUP UUO has been done on this channel.
.b;.i -20;2	FC$ENT	an ENTER UUO has been done on this channel.
.b;.i -20;3	FC$TCI	Tempcore input has been done on this channel
.b;.i -20;4	FC$CSC	channel number set by caller.
.b 4;.nf;.lm -20
.b 2;^&C.3 Bit definitions in $FDMOD and $FDMOM\&
.f;.lm +20
.b;.i -20;0	FM$NDV	null device specification.
.b;.i -20;1	FM$NUL	null extension.
The extension was specified but was null; therefore do not use a default extension.
.b;.i -20;2	FM$DIR	directory specified.
.b;.i -20;3	FM$PHY	/PHYSICAL; physical only IO on this channel.
.b;.i -20;4	FM$NOM	/OKNONE; ok if no file matches this specification.
.b;.i -20;5	FM$DFX	wild fixup unnecessary for this directory.
.b;.i -20;6-8	FM$TRM	code for terminator of file specification.
.b;.i -20;9	FM$STR	/STRS
.b;.i -20;10-23		unused
.b;.i -20;24	FM$PAR	magtape recording parity (1=even).
.b;.i -20;20-26	FM$DEN	magtape recording density (0=std, 1=250, 2=556, 3=800)
.b;.i -20;27-35	FM$PRO	protection code as 3 octal digits.
.lm -20
.number appendix D
.;
.ap;.ps 59 75;.ax Contents of the IDB
.lm 5
.;
.nf;.ts 15 25
Index	Symbol	Description
=====	======	===========
.b 2;.f;.lm +20
.i -20;0	$IDDYC	pointer to a linked list of chunks of free core for allocation to any routine that requires space.
The dynamic core pointer is not used by the static core allocater.
.b;.i -20;1	$IDTOP	maximum core that may be used by this program, set by
program or by command using the /MAXCOR switch.
The core is measured in words and the value is actually the maximum+1.
.b;.i -20;2	$IDLAC	look-ahead character.
Used by the command scanner to store the extra character when it has had
to look ahead to interpret the current character.
.b;.i -20;3	$IDCPC	PC for the command scanning coroutine.
.b;.i -20;4	$IDLSC	last character read by the command scanner $REDCH.
.b;.i -20;5	$IDNXC	next character to be read.
If this word is non-zero, it forces the command scanner to read this
character instead of reading from the input file.
.b;.i -20;6	$IDPNM	program name.
Set by the BEGIN$ macro by GETTAB.
.b;.i -20;7	$IDPPN	program PPN. As $IDPNM.
.b;.i -20;10	$IDPEX	low segment extension name (left half).
.b;.i -20;11	$IDPDV	program device name.
.b;.i -20;12	$IDIFD	input FDB pointer.
The address of the FDB being used for command input.
Set to TTY: or to a tempcore file by the BEGIN$ macro.
.b;.i -20;13	$IDOFD	output FDB pointer.
The address of the FDB  being used for message output.
Set to TTY: by the BEGIN$ macro.
.b;.i -20;14	$IDEFD	error FDB pointer.
The address of the FDB being used for error message output.
Set to TTY: by the BEGIN$ macro.
.b;.i -20;15	$IDCCL	CCL entry point flag (0=normal, -1=CCL).
Set up by the BEGIN$ macro.
.b;.i -20;16	$IDSWT	point to standard switch table.
Used by $RSWIT to compare switch against standard switches, if it doesn't match against user-provided switches.
.b;.i -20;17	$IDRUN	runoffset,,point to run FDB.
Details for program to be run on termination of this program.
.b;.i -20;20	$IDECD	error codes.
The left half contains 3 SIXBIT characters to preface all error messages written by the program.
The right half contains the verbosity code for error messages (0=low, 1=normal, 2=high).
Set to 'normal' by the BEGIN$ macro.
.b;.i -20;21	$IDHNM	file name for 'help'.
.b;.i -20;22	$IDDFD	point to FDB containing defaults for file name scanning.
.b;.i -20;23	$IDJNO	reserved,,job number: set by BEGIN$ macro
.b;.i -20;24	$IDJPP	job's PPN: set by BEGIN$ macro
.b;.i -20;25-35	$IDJPT	default path specification for this task.
Set by the BEGIN$ macro, and should be used to change the default path
spec.
.b;.i -20;36	$IDCPU	code for the CPU type, set by the BEGIN$ macro.
$CPKAX==0, and $CPKIX==1.
.b;.i -20;36	$ENIDB	end of the IDB
.b;.i -20;37	$LNIDB	length of the IDB.
.lm -20
.number appendix E
.;
.ap;.ps 59 75;.ax IO Error Codes
.lm 5
.;
.b 2;.nf;.ts 15 25
Index	Symbol	Description
=====	======	===========
.b 2;^&E.1 UUO codes\&
.b;0	UUUUO$	error for undefined UUO
.b;1	UUOPN$	OPEN UUO error
.b;2	UUENT$	ENTER UUO error
.b;3	UULUK$	LOOKUP UUO error
.b;4	UUREN$	RENAME UUO error
.b;5	UUINP$	INPUT UUO error
.b;6	UUOUT$	OUTPUT UUO error
.b;7	UURUN$	RUN UUO error
.b;10	UUGET$	GETSEG UUO error
.b;11	UUCLO$	CLOSE UUO error
.b;12	UUTMP$	TMPCOR UUO error
.pg;^&E.2 IO Error codes\&
.f;.lm +20
.b;.i -20;0-27	ER???%	LOOKUP/ENTER/RENAME error codes as defined in the Monitor Calls Handbook appendix E.
IOLIB sets some of these codes for UUOs other than LOOKUP, ENTER and
RENAME when the messages are appropriate, for instance, ERNEC%, no
core available is set when the is no space to build a buffer ring.
.b;.i -20;-1	EREOF$	endfile, which may be an error in some cases
.b;.i -20;-2	ERBKT$	block too large, which includes the 'no room or quota exceeded' cases for DSK:.
.b;.i -20;-3	ERDTE$	data error, most likely parity or checksum errors.
.b;.i -20;-4	ERDER$	device error.
This normally means real trouble with the device, although the real meaning is device dependent.
.b;.i -20;-5	ERIMP$	improper mode for device.
.b;.i -20;-6	ERQTA$	code reserved for no room or quota exceeded case.
.b;.i -20;-7	ERRSD$	restricted device.
Attempt to access a device that is available, and is not spooled by the user, but is restricted by the operator.
.b;.i -20;-10	ERNFC$	no free IO software channels.
The user program has used at least 15 out of the 16 possible.
Note that IOLIB does not attempt IO on channel 0 unless forced.
.b;.i -20;-11	ERUNK$	unknown error.
This error can be produced on IO when no error bit was set in the status word, which may be due to e.g. write-ring missing in magtape.
.f;.lm -20
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   .number appendix F
.;
.ap;.ps 59 75;.ax IOLIB Standard Error Ids
.lm 5
.;
 All the 3 character error identifications produced by IOLIB
are listed here, together with their meanings.
The error ids that correspond to LOOKUP/ENTER/RENAME error
codes are flagged by an '*'.
More details about these codes can be found in the Monitor
Calls Handbook, Appendix E.
Error ids flagged with 'S' are produced by the IOLIB command
string reading routines.
.b;.nf;.ts 10 20 30
	Id	#	Description
	==	#	===========
.f;.lm +25
.b;.i -20;AEF	*	File already exists
.b;.i -20;ASW	S	ambiguous switch name
.b;.i -20;BKT	#	block too large ($INPUT/$OUTPU)
.b;.i -20;BNF	*	block busy
.b;.i -20;CSD	*	subfile directory already exists
.b;.i -20;DER	#	device error ($INPUT/$OUTPU)
.b;.i -20;DNA	*	device not available ($OPEN also)
.b;.i -20;DNE	*	directory not empty
.b;.i -20;DTE	*	data error, e.g. checksum or parity
error ($INPUT/$OUTPU)
.b;.i -20;EOF	#	end of file ($INPUT)
.b;.i -20;FBM	*	file being modified
.b;.i -20;FNF	*	file not found
.b;.i -20;ILC	S	illegal character in input string
.b;.i -20;ILU	*	processor doesn't have 2 segment capability
.b;.i -20;IMP	#	improper IO mode for this device ($OPEN/$INPUT/$OUTPU)
.b;.i -20;IPG	S	programmer number zero or too big
.b;.i -20;IPJ	S	project number zero or too big
.b;.i -20;ISU	*	incorrect sequence of UUOs
.b;.i -20;LVL	*	too many levels of SFDs
.b;.i -20;NCE	*	can't create in directory
.b;.i -20;NDV	s	Null device name in device specification
.b;.i -20;NEC	*	not enough core (also $INPUT/$OUTPU)
.b;.i -20;NET	*	not enough table space in monitor
(also $OPEN if no spare DDBs in monitor)
.b;.i -20;NFC	#	no free IO channels($OPEN)
.b;.i -20;NOR	S	number out of range
.b;.i -20;NRM	*	no room on structure
.b;.i -20;NSD	*	no such device (also $OPEN)
.b;.i -20;NSF	*	not a save file
.b;.i -20;POA	*	no room (??)
.b;.i -20;PRT	*	protection failure
.b;.i -20;QTA	#	quota exceeded
.b;.i -20;RSD	#	restricted device ($OPEN)
.b;.i -20;SLE	*	search list empty
.b;.i -20;SNF	*	no directory
.b;.i -20;SNS	*	no segment 
.b;.i -20;STI	S	switch tables built incorrectly
.b;.i -20;TRN	*	transmission error
.b;.i -20;UKW	S	unknown keyword in switch specification
.b;.i -20;UNK	#	unknown error code
.b;.i -20;USW	S	unknown switch name
.b;.i -20;VIL	S	value illegal in switch specification
.b;.i -20;WDV	S	wild device name in device specification
.b;.i -20;WLK	*	write-locked device
.b;.i -20;2DV	S	two device names in one file specification
.b;.i -20;2EX	S	two extensions in one file specification
.b;.i -20;2NM	S	two file names in one file specification
.b;.i -20;2PT	S	two path specifications in one file
specification
.f;.lm -20