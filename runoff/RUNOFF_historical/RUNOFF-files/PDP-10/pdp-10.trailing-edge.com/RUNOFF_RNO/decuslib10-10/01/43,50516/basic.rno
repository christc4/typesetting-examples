.FLAG CAPITALIZE
.PS 58,80
.T University of Pennsylvania Medical School BASIC
.ST Introduction
.FIRST TITLE
.NF
.NJ
.LM 0
.PG
.C
Introduction
.S 3
.P 5
The University of Pennsylvania Medical School BASIC is a segmented program
derived from DECSYSTEM-10 BASIC, version 17E.  There are currently five segments.
.S 2
.LM 15
.NF
.NJ
BASIC - COMMAND/EDIT (6K/11P)
BASCOM - COMPILE/LOAD (6K/12P)
BASXCT - EXECUTE (8K/15P)
BASDDT - BASIC DEBUGGER (12K/24P)
BASCRF - BASIC CREF (5K/10P)
BASERR - ERROR (1K/2P)
.F
.J
.S 1
.LM 0
.P 5
The design goals of this program are to approach compatibility with
the BASIC-PLUS language on the PDP-ll, under the restriction that
all existing BASIC-10 programs should run unchanged, to add more computing power
and user convenience to BASIC, and to fix all known bugs in version l7E.
Certain features of PDP-11 BASIC-PLUS, such as those assuming a 16-bit
two-character word, and system functions, were considered too machine-dependent for
inclusion, and record I/O was not implemented due to conflicts with
BASIC-10 I/O. In most other respects the functionality of PDP-11
BASIC-PLUS, with some minor syntax changes to retain compatibility with
BASIC-10, has been reproduced. No existing BASIC-10 programs are known
to have been affected.
.S 1
.P 5
This document describes the enhancements made to BASIC-10, and is intended
to be used in conjunction with and as an appendix to the DECSYSTEM-10
BASIC Conversational Language Manual, DEC order code DEC-10-LBCMA-A-D.
.PG
.ST Syntax Changes
.INDEX <S<yntax <C<hanges
.C
Syntax Changes
.S 3
A)##Multiple Statements on a Single Line
.S 1
.P 5
More than one statement can be written on a single line as long as each
statement (except the last) is terminated with a backslash, _\ (SHIFT-L on teletypes).
Thus only the first statement on a line can (and must) have a line number.  For example:
.S 1
.I 10
.NF
.NJ
10 INPUT A,B,C
.S 1
is a single statement line, while
.S 1
.I 10
20 LET X=X+1 _\ PRINT X,Y,Z _\ IF Y=2 GOTO 10
.S 1
.F
.J
is a multiple-statement line containing three statements: a LET,
 a PRINT, and an IF-GOTO statement.
.P 5
The following restrictions apply to this construction:
.S 1
.LM 15
.I -4
1)##DATA statements and Image statements must be the only statement
in lines in which they appear.
.S 1
.I -4
2)##DEF FN? statements must be the first statement in lines in which
they appear.
.S 1
.I -4
3)##REM statements and comments indicated by a single quote must be the
last element in lines in which they appear.  (i_.e_. the remainder of the line is treated
as text for the comment)
.S 1
.I -4
4)##END and FNEND statements must be the last statement in lines in which
they appear.
.LM 0
.TP 10
.S 2
B)##A Single Statement on Multiple Lines.
.S 1
.P 5
A single statement can be continued on successive lines of the program.
To indicate that a statement is to be continued, the line is terminated
with the LINE FEED key instead of the RETURN key.  The
LINE FEED causes a carriage return/line feed operation on the
terminal and the line to be continued does not contain a line number.
For example:
.S 1
.NF
.NJ
.I 10
10 LET W7=(W-X4*3)*(Z-A/
.I 10
(A-B)-17)
.S 1
.F
.J
where the first line was terminated with the LINE FEED key is
equivalent to:
.S 1
.NF
.NJ
.I 10
10 LET W7=(W-X4*3)*(Z-A/(A-B)-17)
.S 1
.F
.J
Note that the LINE FEED key does not cause a printed character to
appear on the page. Programs using this construction may not be edited
by the line editors, LINED or SOS.
.TP 10
.S 2
C)##Line Length
.S 1
.P 5
The maximum length of a BASIC program line has been expanded to 255 characters.
The maximum length of a string used or generated by a BASIC program
remains 132 characters.
.PG
.ST BASIC Statements
.C
BASIC Statements
.INDEX <OPEN<
.S 3
A)##OPEN
.S 1
.P 5
The OPEN statement associates a file on disk with an I/O channel number.
BASIC permits up to nine files to be open at a given time, and,
therefore, permits internal file designators to be integers between
one and nine.  The general form of the open statement is as follows:
.S 1
.NF
.NJ
.TP 3
.I 10
_<ln_> OPEN _<string_> (FOR INPUT) AS FILE _<type_> _<expression_> (TO PLOT)
.I 10
##################(FOR OUTPUT)
.F
.J
.S 1
The string field is a character string constant, variable or expression
that contains the external file specification of the file to be opened.
The type is either _# for sequential access or _: for random access,
and must be present.  The expression must have an integer value between
one and nine, corresponding to the internal channel number
on which the file is being opened.
.S 1
.I 5
There are three distinct forms for the OPEN statement:
.NF
.NJ
.S 1
.TP 4
.LM 15
OPEN _<string_> FOR OUTPUT
OPEN _<string_> FOR INPUT
OPEN _<string_>
.S1
.F
.J
.I -4
A)##An OPEN FOR INPUT statement will cause an automatic RESTORE
to be done on the file.  If the file does not exist at this time, an
error message will be given.
.I -4
B)##An OPEN FOR OUTPUT statement will cause an automatic SCRATCH
to be done on the file.  If the file exists at this time, it will be
deleted.
.I -4
C)##An OPEN statement without an INPUT or OUTPUT designation
will perform no other function except to associate the file with the
specified I/O channel number.
.LM 0
.S 1
.P 5
The OPEN statement does not control whether the program attempts
to perform input or output on the file or whether read and/or write
access to the file is granted; these privileges are controlled by the
file protection code.
.S 1
.P 5
For an explanation of the OPEN statement argument TO PLOT, see the
description of the BASIC Plotting Package below.
.S 1
.P 5
In the OPEN statement, as well as in the FILE
and FILES statements, and any edit-level commands where it is
appropriate, project-programmer numbers can be specified for files
in the usual format - [project no.,programmer no.].
.TP 10
.S 2
B)##CLOSE
.INDEX <CLOSE<
.S 1
.P 5
The CLOSE statement is used to terminate I/O between the BASIC
program and the disk file.  Once a file has been closed, it can be
reopened for reading or writing on any internal file designator.
All files will automatically be closed at the end of program execution
or upon execution of the CHAIN statement.  The format of the
CLOSE statement is as follows:
.NF
.NJ
.S 1
.I 10
_<ln_> CLOSE _<expression_> (,_<expression_>,...)
.S 1
.F
.J
The expression indicated has the same meaning as the expression
in the OPEN statement and indicates the internal channel number of the
file to close.  Any number of files can be closed with a single
CLOSE statement; if more than one file is to be closed, the expressions
are separated by commas.
.TP 10
.S 2
C)##ON-GOSUB
.INDEX <ON-GOSUB<
.S 1
.P 5
The ON-GOSUB statement is used to transfer control conditionally
to one of several subroutines or to one of several entry points in one
(or more) subroutines.  The statement has the following form:
.NF
.NJ
.S 1
.I 10
_<ln_> ON _<expression_> GOSUB _<list of line numbers_>
.F
.J
.S 1
Depending on the integer value (truncated if necessary) of the expression,
control is transferred to the subroutine which begins at one of the
line numbers listed.  Encountering the RETURN statement after control
is transferred in this way allows the program to resume execution at
the line following the ON-GOSUB line.
.TP 10
.S 2
D)##INPUT
.INDEX <INPUT<
.S 1
.P 5
Messages to be printed at execution time can now be inserted within the
INPUT statement itself.  This message is set off by double quotes from
the other arguments of the INPUT statement and must be the first element, if used.  For example:
.S 1
.NF
.NJ
.TP 3
.I 10
10 INPUT "YOUR AGE IS";A
.F
.J
.S 1
is equivalent to:
.S 1
.NF
.NJ
.I 10
10 PRINT "YOUR AGE IS";
.I 10
20 INPUT A
.F
.J
.P 5
The use of the comma or semicolon character (or no character) to
separate a character string to be printed from the input variable
names is analogous to the PRINT statement.
.S 1
.P 5
Strings may appear anywhere in INPUT statements, however each
time a string appears the data elements following it must be entered
at the beginning of a new line. The character left-arrow or underline, __,
may optionally follow a string and its format character, if present,
and has the effect of suppressing the _? normally output by BASIC.
For example:
.NF
.NJ
.S 1
.I 10
10 INPUT "TYPE X AND Y : "__X,Y
.F
.J
.S 1
.P 5
The INPUT LINE statement followed by a single string argument
can be used to put a complete line of input, including blanks, tabs,
and commas, into the string argument of the statement:
.NF
.NJ
.S 1
.I 10
10 INPUT LINE A$
.F
.J
.TP 10
.S 2
E)##User-Defined String Functions
.INDEX <U<ser-defined <S<tring <F<unctions
.S 1
.P 5
Character string functions can be written in the same way as numeric
functions.  The function is indicated as being a string function by the
$ character after the function name.
.S 1
.P 5
User-defined string functions return character string values, although
both numeric and string values can be used as arguments to the function.
For example, the following multiple-line function returns the string
which comes first in alphabetical order:
.S 1
.TP 5
.LM 10
.NF
.NJ
10 DEF FNF$(A$,B$)
20 FNF$=A$
30 IF A$_>B$ THEN FNF$=B$
40 FNEND
.LM 0
.F
.J
.S 1
.P 5
Numbers cannot be used as arguments in a function where strings are
expected or vice versa.
.TP 10
.S 2
F)##Statement Modifiers
.INDEX <S<tatement <M<odifiers
.S 1
.P 5
To increase the flexibility and ease of expression within BASIC,
five statement modifiers are available (IF, UNLESS, FOR, WHILE, and
UNTIL).  These modifiers are appended to program statements
to indicate conditional execution of the statements or the creation of
implied FOR loops.
.TP 10
.S 1
1)##The IF Statement Modifier
.S 1
The form:
.S1
.I 10
_<ln_> _<statement_> IF _<condition_>
.S 1
is analogous to the form:
.S 1
.I 10
_<ln_> IF _<condition_> THEN _<statement_>
.S 1
For example:
.S 1
.I 10
10 PRINT X IF X _<_>0
.S 1
is the same as:
.S 1
.I 10
10 IF X _<_> 0 THEN PRINT X
.S 1
When a statement modifier appears to the right of an IF-THEN statement,
the modifier operates only on the THEN clause or the ELSE
clause, depending on its placement to the left or right of ELSE.
It is not possible to include an ELSE clause when using the modifier
form of IF.  Several modifiers may be used within the same
statements.  For example:
.S 1
.I 10
70 PRINT X(I,J) IF I=J IF X(I,J) _<_> 0
.S 1
which will print the value of X(I,J) only if the value X(I,J)
is non-zero and if I equals J.  Whenever there is more than one
modifier on a line, the modifiers are executed in a right-to-left
order.  That is, the rightmost one is executed first, and the
leftmost one is executed last.
.TP 10
.S 2
2)##The UNLESS Statement Modifier
.S 1
The form:
.S 1
.I 10
_<ln_> _<statement_> UNLESS _<condition_>
.S 1
causes the statement to be executed only if the condition is false.  For
example, the following statements are all equivalent:
.S 1
.TP 5
.LM 10
.NF
.NJ
10 PRINT A UNLESS A = 0
20 PRINT A IF NOT A=0
30 IF NOT A=0 THEN PRINT A
40 IF A _<_> 0 THEN PRINT A
.LM 0
.F
.J
.S 1
This particular form simplifies the negation of a logical condition.
.TP 10
.S 2
3)##The FOR Statement Modifier
.S 1
The form:
.S 1
.NF
.NJ
.I 10
_<ln_> _<statement_> FOR _<variable_>=_<expr._>TO_<expr._>(STEP_<expr._>)
.S 1
or the form:
.S 1
.TP 3
.I 10
_<ln_> _<statement_> FOR _<variable_>=_<expr._>(STEP_<expr._>)(WHILE_<expr._>)
.I 10
####################################################(UNTIL_<expr._>)
.F
.J
.S 1
can be used to imply a FOR loop on a single line.  For example (using
none of the optional elements):
.S 1
.I 10
10 PRINT I, SQR(I) FOR I = 1 TO 10
.S 1
This statement is equivalent to the following FOR-NEXT loop:
.S 1
.TP 4
.I 10
10 FOR I = 1 TO 10
.I 10
20 PRINT I,SQR(I)
.I 10
30 NEXT I
.S 1
In cases where the FOR-NEXT loop is extremely simple, the necessity
for separate FOR and NEXT statements is eliminated.  Notice
that this implied FOR loop will only modify (and hence execute
iteratively) one statement in the program.  Any number of implied
FOR loops can be used in a single program.
.S 1
As is the case with all modifiers, a FOR modifier in an IF
statement operates only on the THEN or ELSE clause with which
it is associated, and never on the the conditional expression to the
left of the THEN.  Thus, if it was desired to print all non-zero values in
a vector X(100), the following program would not operate properly:
.S 1
.TP 4
.LM 10
.NF
.NJ
10 DIM X(100)
20 READ X(I) FOR I = 1 TO 100
30 IF X(I)_<_>0 THEN PRINT I,X(I) FOR I = 1 TO 100
.S 1
.LM 0
.F
.J
since the implied FOR loop at line 30 applies only to the THEN PRINT
_. _. _. part of the statement, and not to the IF _. _. _.  part.
The first value of X tested is X(100), since I remained at 100 from
statement 20.  To achieve the desired effect, it is only necessary
to code line 30, not as an IF statement, but rather as a PRINT
statement with nested modifiers; for example:
.S 1
.I 10
30 PRINT I,X(I) IF X(I)_<_> 0 FOR I = 1 TO 100
.S 1
When expressed in the latter form, the nested modifier rule
takes effect, all the values of X(I) are tested and printed
as appropriate.
.TP 10
.S 2
4)##The WHILE Statement Modifier
.S 1
The form:
.S 1
.I 10
_<ln_> _<statement_> WHILE _<condition_>
.S 1
is used to repeatedly execute the statement while the specified condition
is true.  For example:
.S 1
.I 10
10 LET X=X*X WHILE X_<1E6
.S 1
is equivalent to:
.S 1
.TP 3
.I 10
10 IF X_>=1E6 GO TO 30
.I 10
20 LET X=X*X
.S 1
The WHILE modifier operates usefully only in iterative loops
where the logical loop structure modifies the values which determine loop
termination.  This is a significant departure from FOR loops, in which the control variable is automatically iterated;
a WHILE statement need not have a formal control
variable.  The following statements never terminate properly:
.S 1
.TP 3
.I 10
10 X=X+1 WHILE I_<1000
.I 10
20 PRINT I,A(I) WHILE A(I)_<_>0
.S 1
In both cases, the program fails to alter the values which are used
 to determine when the loop is done.  A successful application
of the WHILE modifier is shown below:
.S 1
.TP 4
.I 10
10' TEST OF SQUARE ROOT ROUTINE
.I 10
20 X=X+1 WHILE X=SQR(X*X) AND X_<1.E6
.I 10
30 PRINT X
.TP 10
.S 2
5)##The UNTIL Statement Modifier
.S 1
The form:
.S 1
.I 10
_<ln_> _<statement_> UNTIL _<condition_>
.S 1
is used to execute the statement repeatedly until the condition becomes
true; which is to say, while the condition is false.  For example:
.S 1
.I 10
10 X=X+1 UNTIL X_<_>SQR(X*X) OR X_>=1.E6
.S 1
is the same as
.S 1
.TP 3
.I 10
10 X=X+1
.I 10
20 IF X=SQR(X*X) AND X_<1.E6 THEN 10
.TP 10
.S 2
6)##Multiple Statement Modifiers
.S 1
.P 5
More than one modifier can be used in a single statement.  Multiple
modifiers are processed form right to left.  For example:
.S 1
.I 10
10 LET A=B IF A_>0 IF B_>0
.S 1
which is equivalent to:
.S 1
.I 10
10 IF B_>0 THEN IF A_>0 THEN A=B
.S 1
or
.S 1
.I 10
10 IF B_>0 AND A_>0 THEN LET A=B
.S 1
A matrix (M by N) can be read one row at a time
as follows:
.S 1
.I 10
50 READ A(I,J) FOR J=1 TO M FOR I = 1 TO N
.TP 10
.S 2
G)##Relational and Logical Expressions
.INDEX <R<elational and <L<ogical <E<xpressions
.INDEX <L<ogical and <R<elational <E<xpressions
.P 5
Variables and constants may be combined with relational and logical
operators in addition to arithmetic operators to form expressions.
Unless otherwise stated in the documentation, logical and relational
expressions may be substituted wherever an arithmetic
expression is legal.  In the absence of parentheses, the following
precedence of operators will be followed:
.TP 9
.LM 10
.NF
.NJ
1)##exponentiation
2)##unary minus
3)##multiplication and division
4)##addition and subtraction
5)##relational operators 
####_<,_<=,_>,_>=,=,_<_>
6)##NOT
7)##AND,OR(IOR),XOR,IMP,EQV
.S 2
.LM 0
The logical operators are as follows:
.S 1
.NF
.NJ
.TP 20
.TAB STOPS 5,15,25
	Operator	Example	Meaning
.S 1
	NOT	NOT A	The logical negative of A.
	#	#	If A is true, NOT A is false.
	AND	A AND B	The logical product of A and B.
	#	#	A AND B is true only if both
	#	#	A and B are true, otherwise, false.
	OR	A OR B	The logical sum of A and B.
	or IOR	#	A OR B has the value true if either
	#	#	A or B is true, otherwise, false.
	XOR	A XOR B	The logical exclusive or of A and B.
	#	#	A XOR B is true if either A or B is
	#	#	true but not both, otherwise, false.
	IMP	A IMP B	The logical implication of A and B.
	#	#	A IMP B is false if and only if
	#	#	A is true and B is false.
	EQV	A EQV B	A is logically equivalent to B.
	#	#	A EQV B has the value true if
	#	#	A and B are both true or both false.
.F
.J
.S 1
.P 5
There is one special restriction on the use of logical expressions:
a construct of the form F#OR#_<expression_> may not appear in a
context, e_.g_. as an element of a PRINT list, where a FOR
modifier would be valid. Furthermore it should be noted that the
ambiguous expression PI#OR#X is given the more reasonable
interpretation P#IOR#X.
.TP 10
.S 2
H)##Two-dimensional String Arrays
.INDEX <T<wo-dimensional <S<tring <A<rrays
.S 1
.P 5
Two-dimensional string arrays are now permitted in BASIC.
They are handled in the same manner as one-dimensional string
arrays.  All string functions and operations are legal.
.TP 10
.S 2
I)##Virtual Data Storage
.INDEX <V<irtual <D<ata <S<torage
.INDEX <V<irtual <A<rrays
.S 1
.P 5
Some applications may require more core memory for data storage than
is economically feasible.  BASIC addresses this need
with a simple random-access file system called virtual core.
.P 5
The BASIC virtual core system provides a mechanism for the programmer
to specify that a particular data array is not to be stored in the computer
core memory, but within the PDP-10 disk file system instead.
Data stored in disk files external to the user program remain, even after
the user leaves his terminal, and can be retrieved by name at a later
session.  Items within the file are individually addressable, as are
items within core arrays.  In fact, it is the similar way in which data
are treated in both core and these random-access files which leads to the name
virtual core.
.P 5
With virtual data storage, the user can reference any element
of one or more arrays within the file, no matter where in the file that
element resides.  This random access of data allows the user non-sequential
referencing of the data for use in any BASIC statement.  The
virtual core arrays are read into memory automatically by the system.
.TP 10
.S 1
1)##Virtual Core DIM Statement
.P 5
In order for an array of data to exist in virtual core, it must
be declared in a special form of the DIM statement.  This special
DIM statement is as follows:
.S 1
.NF
.NJ
.I 10
_<ln_> DIM_#_<integer constant_>,_<list_>
.S 1
.F
.J
where the integer constant is between 1 and 9 and corresponds to the
internal file designator on which the program has opened a disk file.
The variable list appears as it would in a DIM statement for a
core-resident array.  Thus, a 100 by 100 matrix could be defined
as:
.S 1
.NF
.NJ
.I 10
10 DIM _#1, A(100,100)
.F
.J
.S 1
Numbers and strings can be stored in virtual core arrays.  More than
one array can be specified in one virtual core field.  For example:
.NF
.NJ
.I 10
.S 1
25 DIM _#1,A(1000), B(100,100), C$(2500)
.F
.J
.S 1
allocates space for 1001 numbers for A, 10201 numbers for B, and
2501 character strings (each 16 characters long) for C$.  However,
if a virtual array is defined in this fashion, future references
should always dimension the arrays to the same size.
.TP 10
.S 1
2)##Virtual Core String Storage
.P 5
One of the few differences in data handling between core and disk
arrays occurs in the storage of strings within string arrays
in virtual core.  Strings in the computer memory are of variable
length from 0 to a maximum of 132 characters.  Strings in virtual
core arrays are of fixed length from 0 characters to a maximum
of 128 characters.  This fixed length can be defined by the program.
The system
forces the maximum length to be a power of 2; i_.e_.  one of the
following lengths:
.NF
.NJ
.S 1
.I 10
2,4,8,16,32,64,128
.F
.J
.S 1
Each element in the virtual core string need not use the maximum
length available, even though space is reserved for each element to
be the maximum size.  If the user indicates other than one of the values
above, he receives the next higher size.  thus:
.NF
.NJ
.S 1
.I 10
10 DIM _#1,X$(10)=65
.F
.J
.S 1
is equivalent to:
.S 1
.NF
.NJ
.I 10
10 DIM _#1,X$(10)=128
.F
.J
.S 1
If no length is specified, a default length of 16 characters is
assumed.  The maximum length of virtual core strings is specified
as an expression in the DIM statement, using the form:
.S 1
.NF
.NJ
_<ln_> DIM _#_<integer const._>,_<string(dim(s))_>=_<integer const._>
.S 1
.F
.J
For example:
.S 1
.NF
.NJ
.I 10
15 DIM _#1,A$(100)=32,B$(100)=4,C$(100)
.S 1
.F
.J
where A$ consists of 101 strings of 32 characters each, maximum,
B$ consists of 101 strings of 4 characters each, maximum, and
C$ consists of 101 strings of 16 characters each, maximum.
.P 5
If a length attribute is given in a DIM statement for an in-core
string array, an error will be given.
.TP 10
.S 2
3)##Opening a Virtual Core File
.S 1
.P 5
In order for the user to reference his virtual core file, he must
first associate a disk file (by name) with an internal channel
designator from 1 to 9 (which is then used in the virtual DIM
declaration).  This is done with an OPEN, OPEN FOR INPUT, or
OPEN FOR OUTPUT statement:
.S 1
.NF
.NJ
.I 5
_<ln_> OPEN _<string_> (FOR INPUT#) AS FILE @_<expression_>
########################(FOR OUTPUT)
.F
.J
.S 1
where the string is the name of a disk file and the expression
specifies an internal file designator.  The _@ sign specifies
the type for a virtual core disk file.
.TP 10
.S 2
4)##Virtual Core Programming Convention
.S 1
.P 5
Recoverable errors occur when using virtual core if the user program
does any of the following:
.S 1
.NF
.NJ
.TP 8
.LM 10
1)##References a virtual core array without first
####opening the file.
2)##Exceeds virtual core, that is defines an array
####that is greater than the disk storage quota
####allocated to them.
3)##Attempts to read or write to the virtual array
####disk file.
.LM 0
.F
.J
.TP 10
.S 1
5)##Using the Virtual Array Facility
.S 1
.P 5
The BASIC virtual array facility provides the means for a BASIC
program to operate on data structures that are too large to be
accommodated in core at one time.  To accomplish this, BASIC
uses the disk file system for storage of data arrays, and only
maintains portions of these files in core at any given time.
.P 5
All references to virtual arrays are ultimately located via
file addresses relative to the start of the file.  No symbolic information
concerning array names, dimensions, or data types is stored within the file.
Thus, different programs may use different array names to refer to the data
contained within a single virtual array file.
The user must be cautious in such operations, since it is
his (or her) responsibility to ensure that all programs referencing a
given set of virtual arrays are referencing the same data.
.P 5
Within a single BASIC program, it is possible to open
the same virtual core array file twice on the same channel for the
purpose of reallocating the data within the file.  For example:
.S 1
.NF
.NJ
.TP 4
.LM 10
145 OPEN "DATA" FOR INPUT AS FILE @1
150 DIM_#1, A$(10)=4
155 DIM_#1, B$(4)=16
.LM 0
.F
.J
.S 1
The program now has access to the file DATA through both the
array A$ and the array B$.  Each element of B$ contains
four elements of A$ (B$(0) is equivalent to the elements A$(0)
through A$(3), etc.).  Note that the file is open for input only
and that the two DIM_# statements reference that file on a
single channel number (_#1 in this case).
.S 1
.I 10
Note also that the two statements
.NF
.NJ
.S 1
.TP 3
.I 15
75 DIM_#1,A(10)
.I 15
80 DIM_#1,B(10)
.I 10
.S 1
are not equivalent to the statement;
.S 1
.I 15
90 DIM_#1,A(10),B(10)
.S 1
.F
.J
In the first case the arrays A and B are equivalent to each other and
constitute the first array in the file open on channel 1.
In the second case the arrays A and B are defined as both existing
sequentially in the file open on channel 1.
.P 5
User programs may define two-dimensional virtual arrays as well as
singly dimensioned ones.  Two-dimensional arrays are stored
on disk (and in core) linearly, row-by-row.  Thus, in the case
of a matrix X(1,2), the array appears physically as:
.NF
.NJ
.TP 7
.LM 30
X(0,0)##lowest address
X(0,1)
X(0,2)
X(1,0)
X(1,1)
X(1,2)##highest address
.LM 0
.F
.J
.S 1
The user should keep in mind that in BASIC, as in most
BASICs, array subscripts begin with 0, not 1.  An array
with dimension n, or (n,m) actually contains n+1, or
[(n+1)*(m+1)] elements.
.P 5
If a virtual array is to be referenced sequentially, it is usually
preferable to reference the rows, rather than the columns, in
sequence since there will be fewer disk accesses.
.P 5
Virtual core arrays are stored on disk in blocks, each of which may
contain maximally 128 pieces of numeric data or 512 characters of
string information. It is permissible to have two (or more)
arrays sharing the same file.  That is, the following DIM_#
statement is perfectly legal:
.S 1
.NF
.NJ
.I 10
100 DIM_#1,Z(1000),B(999),C(1000)
.F
.J
.S 1
The array B begins immediately after the 1001st element of Z
and C(0) is placed immediately after B(999).  There is, however,
an exception to this rule.  When the type of the
array changes (from numeric to string or string to numeric)
a new block will be started.  Also, if one string array follows another,
a new block will be started if an element of it would otherwise be split
across a block boundary. Consider the following case:
.S 1
.NF
.NJ
.I 10
10 DIM_#1, A$(24)=16,B$(100)=64
.F
.J
.S 1
The first 400 characters (25*16) are allocated to A$.  If the array B$
were to begin immediately after A$, one of the elements of B$
(B$(1)) would cross a block boundary (i_.e_. after B$(0) is
stored, there are only 48 characters left in the block).  Hence,
B$ begins at the start of the second block in the file rather than
immediately after A$.
.P 5
The dimensions indicated in a DIM_# statement set maximum allowable
values for subscripts, but do not define the size of the file set up.
Instead the file is expanded as elements of the arrays are used or
changed. Thus a user may specify dimensions as great as may ever be
needed without inefficiency.
.P 5
NOTE - No matrix functions (ZER, INV, etc.) are implemented for virtual arrays as
of this version.  They may, however, be implemented at a later date.
.TP 10
.S 1
J)##ON ERROR GOTO Statement
.INDEX <ON< <ERROR< <GOTO<
.INDEX <U<ser <E<rror <H<andling
.S 1
.P 5
Certain errors can be detected by BASIC while executing a user
program.  These errors fall into two broad areas: computational
errors (such as division by 0) and I/O errors (such as attempting to read
a non-existent file).  Normally the occurrence of any of
these errors causes termination of the user program execution and
the printing of a diagnostic message.
.P 5
Some applications may require the continued execution of a user program
after an error occurs.  In these situations, the user can execute an ON ERROR GOTO
statement within his program.  This statement tells BASIC that a user
subroutine exists, beginning at the specified line number, which will analyze
any I/O or computational error encountered in the program and
possibly attempt to recover from that error.
.P 5
The format of the ON ERROR GOTO statement is as follows:
.S 1
.NF
.NJ
.I 5
_<ln_> ON ERROR GOTO  (_<line number_>)
.F
.J
.S 1
This statement is placed in the program prior to any executable
statements with which the error handling routine deals.  If an error
does occur, user program execution is interrupted and the user-written error
subroutine is started at the line number indicated.  The
variable ERR, available to the program, assumes one of the values
listed below.
.INDEX <ERR< <V<ariable
.TP 15
.S 2
.C
User Recoverable Errors
.S 1
.P 5
(*) indicates that program execution continues, following
printing of the error message, if an ON ERROR GOTO statement
is not present.  Otherwise, execution terminates and the system
prints the READY message.
.S 2
.NF
.NJ
.TAB STOPS 8
1	internal error within BASIC or monitor error
2	illegal filename format
3	file opened on more than one channel
4	cannot enter file for output
5	cannot lookup file for input
6	out of static list space for string manipulations
7	string record or formula length _< 1 or _> 132
8	end-of-file
9	attempt to reference a file that was never established
10	broad class of input/output errors
18	SET argument is out of bounds
27	subroutine or function calls itself
28	line number is out of bounds
31	RETURN before GOSUB
32	mixed random access and sequential
35	output item too long for list
36	cannot erase file on specified channel
37	file not found by RESTORE command
38	input line too long
41	mixed strings and numbers
42	no fields in image
46	illegal channel number
*50	input data not in correct form
*53	attempt to take log of zero or negative number
*54	attempt to take square root of negative number
*56	singular matrix inverted
57	out of data
58	ON evaluated out of range
60	no more core available
*61	division by zero
70	attempt to output a number to a string field or vice versa
71	output line more than 132 characters
72	no character in image
73	more than 132 characters in image
74	exponent requested for * or $ field
75	attempt to output negative number to an * or $ field
76	MARGIN is too small
77	MARGIN is out of bounds
78	PAGE length is out of bounds
79	I/O to file opened as a plot file
80	attempt to write a line number _> 99999
81	impossible vector length
82	illegal character seen on input
83	string size exceeded for virtual array
84	DIMENSION error
85	CHR$ argument out of bounds
86	INSTR argument out of bounds
87	LEFT$ argument out of bounds
88	MID$ argument out of bounds
89	RIGHT$ argument out of bounds
90	SPACE$ argument out of bounds
91	VAL argument not in correct form
*92	arithmetic overflow
*93	arithmetic underflow
*94	too many elements in MAT INPUT
*95	over or underflow occurred during MAT INV
*96	magnitude of SIN or COS arg too large to be significant
*97	TAN of PI/2 or COTAN or zero
*98	underflow in integer exp.
*99	overflow in integer exp.
*100	underflow in floating exp.
*101	overflow in floating exp.
*102	zero to a negative power
*103	negative value raised to fractional power
.F
.J
.P 5
When an error is encountered in a user program, BASIC checks to
see if the program has executed the ON ERROR GOTO
statement.  If this is not the case, then a message is printed at the user's
terminal and the programs proceeds (if the error does not cause
execution to terminate).  If the ON ERROR GOTO 
statement was executed previously, then execution continues at the
specified line number where the program can test the variables ERR and ERL
to discover precisely what error occurred and decide what action
is to be taken.
.P 5
There is one error condition that causes program termination
regardless of the execution of ON#ERROR#GOTO with the message:
Too many FN's, GOSUB's or error traps. This is most often caused
by incorrect use or absence of the RESUME statement.
.TP 10
.S 2
K)##RESUME Statement
.INDEX <RESUME<
.S 1
.P 5
After the problem is corrected (if this is both possible and desired
by the programmer), execution of the user program can be resumed through
use of the RESUME statement (which is placed at the end
of the error handling routine, much like a return statement in a
normal subroutine).  The RESUME statement causes the program
statement that originally caused the error to be reexecuted.  If
execution is to be restarted at some other point within the program
(as might be the case for a non-correctable problem), the new line
number can be specified in the RESUME statement at the end
of the error handling routine.
.P 5
The format of the RESUME statement is as follows:
.S 1
.NF
.NJ
.I 10
_<ln_> RESUME (_<line number_>)
.F
.J
.S 1
For example:
.S 1
.NF
.NJ
.TP 3
.I 10
2000 RESUME
.I 10
2001 RESUME 100
.F
.J
.S 1
The line 2000 restarts the user program at the line in which the
error was detected, and is equivalent to the statement:
.S 1
.I 10
2000 RESUME 0
.P 5
A RESUME or RESUME 0 statement in an error handling routine
passes control to the line containing the statement which caused the
error.  If the statement which caused the error is on a multiple statement
line, control is passed to the first statement on the line.  Therefore,
the first statement on a multiple statement line with error handling
should be the statement which generates the trappable error.  Such
placement of the statement prevents logic errors.
.P 5
Line 2001 above restarts the user program at line 100 (which can
be used to print some terminal message for the particular
operation). The RESUME statement with a line number argument should
otherwise be used sparingly, since it can lead to a variety of
subtle error conditions.
.P 5
A RESUME statement will dismiss the error condition and should
always be included in the error handling routine. A GOTO statement
should never be used to exit from the error routine.
.TP 10
.S 2
L)##Disabling The User Error Handling Routine
.INDEX <D<isabling <U<ser <E<rror <H<andling
.S 1
.P 5
If there are portions of the user program in which any errors
detected are to be processed by the system and not by the user
program, the error subroutine can be disabled by executing the following
statement:
.S 1
.I 10
_<ln_> ON ERROR GOTO 0
.S 1
which returns control of error handling to the system.  An equivalent
form is:
.S 1
.I 10
_<ln_> ON ERROR GOTO 
.S 1
in which case line 0 is assumed.  Executing this statement causes
the system to treat errors as it would if no ON ERROR GOTO _<ln_>
had ever been executed.
.P 5
Generally, the error handling subroutine should detect and properly
handle only a few different errors; it is useful to have the BASIC
system handle other errors, if they occur.  For this reason,
BASIC allows the ON ERROR GOTO 0 statement
to be executed within the error subroutine itself.  Special treatment
is accorded this case, in that the disabling occurs retroactively;
the error which caused entry to the error subroutine is then reported and
a message printed as though no ON ERROR GOTO _<ln_> statement
had been in effect.
.P 5
As an example of this feature, suppose a user
wished only to handle the case where a file is expected
to be on disk and is not found for input.
.P 5
The program below requests the file name and attempts to read from it.
.NF
.NJ
.S 1
.TP 16
.LM 10
10 INPUT F$
20 ON ERROR GOTO 100 _\ OPEN F$ FOR INPUT AS FILE _#1
30 READ _#1,I,J
40 .
50 .
###.
###.
100 'THIS IS THE ERROR HANDLING ROUTINE
110 IF ERR _<_> 37 THEN ON ERROR GOTO 0      'FILE NOT FOUND ERROR ONLY
120 PRINT F$;" WAS NOT FOUND, IS THERE ANOTHER";
130 INPUT A$
140 IF A$ = "N" THEN STOP
150 INPUT "NEW FILE NAME";F$
160 RESUME
170 END
.LM 0
.F
.J
.P 5
In this example, if the call to the error subroutine was caused
by some error other than the file not found error, the program
would exit via the ON ERROR GOTO 0 in line 110.  This
permits an appropriate error message to be printed on the user's
terminal.
.TP 10
.S 2
M)##The ERL Variable
.INDEX <ERL< <V<ariable
.S 1
.P 5
It is sometimes useful to be able to recognize the line number at which
an error occurred.  Following an error detection, the integer
variable ERL contains the line number of the error.
.P 5
ERL would be used, for example, to indicate which of
several INPUT statements caused an error.
.P 5
The ERL variable should not be tested against a constant
for equality, since resequencing the program could change
the number of the line causing the error. Instead the LL
function (see below) should be used.
.TP 10
.S 2
N)##The PAUSE and PLOT Statements
.S 1
.P 5
The PAUSE and PLOT statements are used exclusively in connection
with graphical output, see below under BASIC Plotting Package.
.TP 10
.S 2
O)##The FOR Statement
.INDEX <FOR< <S<tatement
.S 1
.P 5
The FOR statement may be terminated by WHILE _<expression_>
or UNTIL _<expression_> instead of TO _<expression_>.
.TP 10
.S 2
P)##The WHILE and UNTIL Statements
.INDEX <WHILE< <S<tatement
.INDEX <UNTIL< <S<tatement
.S 1
.P 5
Loops may be initiated by the statements WHILE _<expression_> or
UNTIL _<expression_>. Such loops operate exactly as FOR loops, except that
there is no variable incremented for each execution of the loop. They
are terminated by the NEXT statement with no argument.
.ST New Functions
.PG
.C
New Functions
.INDEX <N<ew <F<unctions
.S 3
.F
.J
.P 5
The following new functions have been added to the list of
BASIC Library routines.
.TP 10
.S 2
A)##TIME$
.LM 5
.P 5
Returns an eight character string representing
the 24-hour time of day as HH:MM:SS.
.TP 10
.S 1
.I -5
B)##DATE$
.P 5
Returns a nine character string representing the current date
as DD-MON-YY.
.TP 10
.S 1
.I -5
C)##ASCII(S$)
.P 5
Generates the ASCII value of the first character contained
in the string S$. i_.e_. ASCII("XAB")=88.
.TP 10
.S 1
.I -5
D)##FIX(N)
.P 5
Returns the truncated value of X (SGN(X)*INT(ABS(X)).
i_.e_. FIX(-.5)=0.
.TP 10
.S 1
.I -5
E)##LINE
.P 5
Returns the current line number of the statement being executed or
the line number of the statement last executed when _^C (control-C)
interruption occurred.  (useful in BASDDT)
.TP 10
.S 1
.I -5
F)##LL(_<constant_>)
.P 5
Returns the value of its argument, which must be an 
ambiguous constant equal to a line number in the program.
This argument is recognised as a line number
by the RESEQUENCE command.
.TP 10
.S 1
.I -5
G)##NUM$(N)
.P 5
Indicates a string of numeric characters representing the value of N
as it would be output by a PRINT statement.
NUM$(N)=(SPACE)N(SPACE) FOR N _>= 0
NUM$(N)=-N(SPACE) FOR N _< 0
.TP 10
.S 1
.I -5
H)##PI
.P 5
Constant value of PI (3.1415927)
.TP 10
.S 1
.I -5
I)##POS(N)
.P 5
Returns current position on the output line.  N is the I/O channel
number.  POS(0) returns the value for the user's teletype.
.TP 10
.S 1
.I -5
J)##CRT(I%)
.INDEX <P<lotting
.P 5
If I% is non-zero, the ASCII characters with decimal
values 10-13 are legal within strings, if it is zero, they are not. The
value returned by the CRT function is the argument with which it
was last called, or zero if it has not been called before. Note that a
CRT(1%) must be executed before using the BASIC plotting
package (see below) to allow the control characters required for
screen functions on the Tektronix-4010 to be sent.
.TP 10
.S 1
.I -5
K)##DAY$
.P 5
Returns a string containing the day of the week, spelled out in full.
.TP 10
.S 1
.I -5
L)##ECHO(I%)
.P 5
If I% is non-zero, the teletype echo is turned off, if it is zero,
the echo is turned on again. The value returned is either 1% or 0%,
according to whether the echo had been turned off or on respectively
by the previous call. The echo is always turned on again when the
program ends execution or is aborted.
.TP 10
.S 1
.I -5
M)##SLEEP(I%)
.P 5
Causes the program to suspend execution for I% seconds, or until
a line is typed on the terminal. If the suspension is ended by a
time-out, a value of 0% is returned, if by terminal input, -1% is
returned. This function can be used to check if anything has been
typed, using an argument of 0%, or, for example, to prompt students
using an educational program.
.LM 0
.ST Edit Level Commands
.PG
.C
Edit Level Commands
.INDEX <E<dit <L<evel <C<ommands
.S 3
A)##SAVFIL(NL)
.INDEX <SAVFIL(NL)<
.S 1
.P 5
These commands, followed by an optional file name, create compact
core images of BASIC programs on the disk.  The source code
is deleted from these files, so for large programs, they occupy
substantially less memory than the code produced by the RUN
or RUNNH commands.  Since they are already compiled, their
execution does not carry the overhead of compilation for each run.
The SAVFILNL command differs from the SAVFIL command
in that the line number tables are also deleted.  This results
in a further saving of memory at the expense of deleting
line numbers from any execution-time error message.  The files
created by these commands are given the name specified, if any, or
else the name of the current program.  They are always given the
extension .SAV, thus eliminating any conflict with .BAS
files.  Their extension must be given explicitly to delete them
with the UNSAVE command.
.P 5
Since line number information is deleted from _.SAV files
created by the SAVFILNL command the statements RESUME and
ON ERROR GOTO without arguments and CHAIN with a line number
argument are illegal in them.
.TP 10
.S 2
B)##RUNSAV
.INDEX <RUNSAV<
.S 1
.P 5
This command, followed by a file name, runs the _.SAV file of
that name created by the SAVFIL(NL) command.  It is not possible
to start the program at other than the first line.  The CHAIN
statement with a line number argument is regarded as a syntax
error in creating a .SAV file.  The CHAIN statement executed from
a .SAV file requires a .SAV file to be chained.  It is
therefore unnecessary to specify the file extension.  Since the
source code is deleted from .SAV files, a new
session is begun after the execution of any of these commands.
The .SAV files produced are normal .SAV files which can
be run from the Monitor by use of the RUN command.
However, return is to the Monitor level instead of BASIC
Edit level.
With new
versions of BASIC, .SAV files may become obsolete.  If
this is the case, a warning message to resave soon will be given when 
the .SAV file is run.  Please heed the warning.
.TP 10
.S 2
C)##RUNFSAV
.INDEX <RUNFSAV<
.S 1
.P 5
This command is similar to the RUNSAV command except that
the .SAV file is assumed to be created by the Monitor SAVE
command.  Exit from the program is always to Monitor level.
.TP 10
.S 2
D)##DDT(NH)
.INDEX <DDT(NH)<
.S 1
.P 5
This command calls for the BASIC debugger to be included
as part of the execution routine along with your BASIC program.
Refer to the section on BASDDT for use of the debugger.
.TP 10
.S 2
E)##GENERATE (NN)(,(MM))(,(LL))
.INDEX <GENERATE<
.S 1
.P 5
This command will generate line sequence numbers for input from the
teletype.  NN is the starting value, MM is the maximum
number, and LL is the increment.  If NN or LL is omitted,
they will default to 10.  If MM is omitted, 99999 will be the
maximum.  Therefore, if no arguments are given, they will be
10,99999,10.
If NN is greater than LL, only one line sequence number
will be generated.
To prematurely end the generation of line sequence
numbers, the ALTmode or ESCape character (echoed as $) is typed on the
line followed by a RETURN. Normally the GENERATE command 
automatically inserts a blank at the beginning of each line. To
suppress this feature the GENERATE NO BLANK or GEN NOB
command can be substituted.  For example:
.S 1
.TP 14
.LM 10
.NF
.NJ
READY
GEN 10,,40
10 LET A=1
20 LET B=23
30 LET C=PI/2
40 FOR J = 1 TO 10
READY
GEN 60
60 D=SIN(J*C)
70 PRINT D
80 NEXT J
90$
READY
.LM 0
.F
.J
.TP 10
.S 2
F)##SYNTAX
.INDEX <SYNTAX<
.S 1
.P 5
This command will cause each line of input to be automatically
syntax checked upon being entered.  It will not check for
logic errors, but merely guarantee that the statement entered is
grammatically correct.  SYNTAX is the default state upon
entering BASIC.  The statement will be entered into the source text
regardless of the outcome of the syntax check.  SYNTAX may be combined with GENERATE, however,
a new line sequence number will always be generated.
For example:
.S 1
.NF
.NJ
.TP 29
.LM 10
READY
10 LET K=1
20 FOR J = 1 TO 1O
? ILLEGAL "FOR" USE#######(An O was typed instead of a 0)
20 FOR J=1 TO 10##########(User corrects the syntax error)
30 LET K=K+J_^2
40 NEXT K#################(Notice that this is a logical
##########################error and cannot be detected)
50 PRINT K
60 END
RUNNH
.S 1
? NEXT WITHOUT FOR IN LINE 40
.S 1
? FOR WITHOUT NEXT IN LINE 20
.S 1
READY
40 NEST J#################(NEXT was misspelled)
? ILLEGAL STATEMENT KEYWORD
40 NEXT J
RUNNH
.S 2
 386
.S 2
READY
.TP 10
.S 2
.F
.J
.LM 0
G)##NOSYNTAX
.INDEX <NOSYNTAX<
.S 1
.P 5
This command turns off the automatic syntax checking of the input
line.  It must be used when creating a BASIC data file from Edit level.
.TP 10
.S 2
H)##CATALOG
.INDEX <CATALOG<
.S 1
.P 5
Two switches have been added to the CATALOG command, /FAST
and /PROTECTION.  /FAST will give the directory with
four filename.ext per line.  /PROTECTION will print
the protection code following the file to which it applies.  The
switches may be abbreviated to as few as one character.
For example:
.S 1
.NF
.NJ
.TP 20
.LM 10
READY
CATALOG/FAS
.S 2
TEST##.BAS######TEST1#.BAS######STAR##.TRK######DATA##.BAS
SWITCH.INI
.S 1
READY
CAT/PROTECTION
.S 2
TEST##.BAS_<155_>
TEST1#.BAS_<155_>
STAR##.TRK_<157_>
DATA##.BAS_<055_>
SWITCH.INI_<055_>
.S 2
READY
.F
.J
.LM 0
.TP 10
.S 2
I)##CREF
.INDEX <CREF<
.S 1
.P 5
The CREF command gives a cross reference listing on the line printer.
The file will be queued to the printer after the CREF command is given.
.S 1
.P 5
There is one switch implemented for the CREF command.  /TTY will cause
the cross reference listing to come out on the user's terminal.
.TP 10
.S 2
J) PPN Specification
.INDEX <PPN< <S<pecification
.S 1
.P 5
In all commands and statements referencing files, except QUEUE,
project-programmer numbers can be specified in the usual format
following the file name - [project no.,programmer no.].
.ST BASIC Debugger
.PG
.C
BASIC Debugger
.INDEX <BASIC< <D<ebugger
.INDEX <BASDDT<
.INDEX <D<ebugging
.S 3
.P 5
This is a new release of the BASIC debugging technique (BASDDT).
Most BASIC statements are now included.  BASDDT occupies its
own high segment (11k) and in no way affects running programs
when not used.
.TP 10
.S 1
A)##BASDDT Control Commands
.S 1
.P 5
There are six BASDDT control commands.  These commands may be
abbreviated to the first three characters.  As the name implies, they
control the action of BASDDT.  The BASDDT control commands may not be 
used in multiple statement lines, nor may they be used in conjunction
with BASDDT statements,  they are intended only for single,
immediate action.
.TP 10
.S 1
.LM 10
1)##START N######(Where N is an optional line number)
.S 1
This command initializes BASDDT and must be used to
begin execution of the program.  Prior to the START
command, only BASDDT control commands (with the exception of
CONTINUE) are legal.  When BASDDT is invoked with the
edit command DDT(NH), BASDDT will respond with:
.S 1
[BASDDT EXECUTION]
.S 1
_>
.S 1
after compilation of the program.  At this point, it is
ready to receive and process commands.  Whenever the right
angle bracket appears, BASDDT is waiting for input of a 
command or statement.  When the user is ready to begin
execution of the program (i_.e_. after setting stops), he 
should issue the START command.  The program will optionally
begin 1) at the line number specified in the start command, if
one was included, 2) at the line number specified in the
DDT(NH) command or 3) at the first executable statement.
.TP 10
.S 1
2)##STOP N(,M,L...)######	(where N,M,L... are line numbers)
.S 1
.P 5
Execution of the BASIC program may be suspended at
various line numbers throughout the program through use of the
STOP command.  STOP takes as its argument a list of line
numbers separated by commas.  The line numbers must exist in
the user program.  There is no limit to the number of stops
a user may have.  Setting stops at non-executable statements
will cause a stop at the next executable
statement.  When a stop is reached, BASDDT will inform the
user at which line the stop occurred.  The stop will occur
prior to execution of that line number. Example:
.S 1
.NF
.NJ
.TP 5
_>STOP 90
_>START
_<STOP_>_# 90
_>
.TP 10
.S 2
.F
.J
3)##CONTINUE N######(where N is an optional line number)
.S 1
.P 5
CONTINUE is used to proceed from a stop.  If N
is specified, control will go to that line number.  However,
unlike the BASDDT GOTO statement, CONTINUE is an unconditional transfer.
As such, CONTINUE with an argument should be used sparingly
and with care.
Example:
.S 1
.NF
.NJ
.TP 6
_>STOP 90,50,150
_>START
_<STOP_>_# 50
_>CONT
_<STOP_>_# 90
.F
.J
.TP 10
.S 2
4)##LIST
.S 1
.P 5
LIST (takes no arguments) will print on the user's
teletype a list of all program stops.  Example:
.S 1
.NF
.NJ
.TP 4
_>LIST
STOPS:####50	90	150
_>
.TP 10
.S 1
.F
.J
5)##REMOVE N(,M,L,...)######(where N,M,L,.. are line numbers)
.S 1
.P 5
REMOVE is used to remove a previously placed stop in
the user's program.  If no argument is specified, all
stops are removed.  Removing a non-existent stop is
considered a no-op.  Example:
.S 1
.NF
.NJ
.TP 6
_>LIST
STOPS:####50	90	150
_>REMOVE 90
_>LIST
STOPS:####50	150
.TP 10
.S 1
.F
.J
6)##DECLARE V1(,V2,V3,V4,V5)######(where V1-V5 are variable names)
.S 1
.P 5
For your convenience, five scalar locations have been
reserved to use as an aid to debugging.  Before they can be
referenced, they must be assigned a legal BASIC scalar name
through use of the DECLARE command.  Once a variable
name has been declared, it cannot be removed.  Example:
.S 1
.NF
.NJ
.TP 6
_>DECLARE T1,T4
_>LET T1=5 _\ T4=1
_>PRINT T1;T4
#5 1
_>
.TP 10
.S 2
.F
.J
.I -10
B)##BASDDT Statements
.S 1
.P 5
The following statements cause a specific action to occur.
Except where noted, they are exactly alike in nature
to the normal BASIC statement except that they are executed
immediately.  Multiple statement lines and multiple line
statements are also legal in BASDDT.  Two backslashes in
BASDDT are used to end control of an IF-THEN or IF-THEN-ELSE.
Example:
.S 1
_>IF A = B THEN C=1 _\ B=2 _\ D=4
.S 1
In this case, if A does not equal B, no statements will be
executed.  However, in the following example:
.S 1
_>IF A = B THEN C=1 _\_\ B=2 _\ D = 4
.S 1
	B=2 and D=4 will be executed regardless of the outcome
of IF A = B.
.TP 15
.S 2
.NF
.NJ
.LM 0
.TAB STOPS 1,17,33
Statement	Available	BASIC-BASDDT difference
.S 1
DATA	no
READ	yes	none
PRINT	yes	none
LET	yes	none
GOTO	yes	none
IF-THEN	yes	use of two backslashes
IF-THEN-ELSE	yes	use of two backslashes
FOR-NEXT	yes	none
ON-ERROR	no
ON-GOTO	yes	none
ON-GOSUB	yes	none
DIM	no
END	yes	exits to edit mode with runtime message
GOSUB	yes	none
INPUT	yes	none
STOP	no	BASDDT control command
REM	no	BASDDT control command for REMOVE
RESUME	yes	none
RESTORE	yes	none
CHANGE	yes	none
CHAIN	yes	chained program will also have BASDDT
MARGIN	yes	none
PAGE	yes	none
NOPAGE	yes	none
QUOTE	yes	none
NOQUOTE	yes	none
PRINT USING	yes	none
FILES	no
FILE	no	use OPEN instead
OPEN	yes	none
CLOSE	yes	none
SCRATCH	yes	none
WRITE	yes	none
IF END	yes	none
SET	yes	none
PAUSE	no	#
PLOT	no	#
.S 1
.F
.J
All matrix instructions and functions are implemented.
.S 1
All statement modifiers are implemented.
.S 1
In addition, the BASDDT statement, BASDDT, has been added.  It will
transfer control to BASDDT input level.  Example:
.S 1
.NF
.NJ
.TP 5
.LM 10
_>FOR I = 1 TO 10 _\ IF X2 _> 30 THEN BASDDT _\ X2=X2+X1_^2 _\ NEXT I
_>PRINT X2,I
31         8
_>
.F
.J
.LM 0
.TP 10
.S 2
C)##Control-C
.S 1
.P 5
The control-C (_^C) has different actions depending
upon where it is given.  At the input level (i_.e_. when the
right angle bracket is displayed), a control-C causes
an immediate return to edit level with no runtime message
printed.  When the control-C is given during the execution
of the user's program or BASDDT statments, control will
return to BASDDT input level.  The LINE function can be
used to determine where control was interrupted.  Example
.S 1
.NF
.NJ
.TP 6
_>CONT
_^C
_^C
_>PRINT LINE
#50
.S 1
.F
.J
Warning- - -the statement being executed may be interrupted
before completion and partial answers may occur.
The continue command without a line number is illegal
after a control-C.
.TP 10
.S 2
D)##Execution Errors
.S 1
Any program execution errors result in a return to BASDDT
input level after the printing of the message.  Thereafter the continue
command without a line number is illegal.
.ST BASIC Plotting Package
.PG
.C
BASIC Plotting Package
.INDEX <BASIC< <P<lotting <P<ackage
.INDEX <P<lotting
.S 3
.P 5
Graphical output on the Tektronix-4010-1 can now be done in BASIC.
The Tektronix-4010-1 has a grid size of 780 vertical points and
1024 horizontal points.  All coordinates greater than the above
will be truncated to these values.
.P 5
There are two types of positioning on the Tektronix-4010-1.  The
alphanumeric cursor which represents the point at which alphanumeric
output will begin and the "pen" position which represents the point
at which graphing will begin.  BASIC PRINT statements
modify the alphanumeric cursor but will not affect the "pen"
position.  Using the BASIC PLOT functions will modify the "pen"
postion and also move the position of the alphanumeric cursor
to the "pen" position at the end of the graphing movement.  An
alphanumeric character is 14 vertical positions by 10 horizontal
positions.
.P 5
All coordinate arguments in the following definitions are
screen coordinates relative to users origin.  All scaling must be done by the user.
.S 2
The form:
.S 1
.I 10
_<ln_> PLOT F1 (,F2,F3,....)
.S 1
where Fn represents one of the following eight functions.
.TP 10
.S 1
.LM 10
.I -5
1)##INIT
.P 5
This call initializes internal plotting parameters.  It also
sets the "pen" to the lower left hand corner and defines this point
as the origin (0,0).  INIT should be the first PLOT call in the program,
unexpected results may occur otherwise.
.TP 10
.S 1
.I -5
2)##PAGE
.P 5
This call erases the screen and moves the alphanumeric cursor to
the upper left hand corner.  It does not
affect the position of the "pen".
.TP 10
.S 1
.I -5
3)##LINE(X,Y,I)
.P 5
This call will move the "pen" position to the coordinates (X,Y).  If
I is greater than 0 (I_>0), the movement will be made with the "pen"
down (that is to say a line will be drawn).  If I is less than or
equal to 0 (I_<=0), the movement will be made with the "pen" up.
.TP 10
.S 1
.I -5
4)##ORIGIN(X,Y)
.P 5
This call will move the "pen" position to (X,Y) and define it
as (0,0).
.TP 10
.S 1
.I -5
5)##STRING(X,Y,_<string expression_>)
.P 5
This call will output the _<string expression_> with the lower left
hand corner of the first character beginning at (X,Y).  The "pen"
position will be left at the lower right hand corner of the last
character typed.
.TP 10
.S 1
.I -5
6)##WHERE(X,Y)
.P 5
This call will return the coordinates of the "pen" position in (X,Y)
relative to the users origin.  For example, if the origin was
defined at absolute screen coordinates (500,500) and the "pen" position
was at absolute screen coordinates (600,50), coordinates (100,-450) would be
returned.
.TP 10
.S 1
.I -5
7)##CURSOR(X,Y,Z)
.P 5
This call causes the cross-hairs to be displayed on the screen.  After
typing any alphanumeric character, the cross-hair coordinates, relative to the
users origin, are returned in (X,Y), and the decimal representation
of the typed character is returned in Z.
.TP 10
.S 1
.I -5
8)##SAVE(N)
.P 5
This call causes the graphical output saved on disk in a file
on channel number N to be plotted.
.LM 0
.S 1
.P 5
In order to suspend program execution so that a hard copy may be
made of the screen, the PAUSE statement (with no arguments) has
been added.  Its purpose is merely to pause
until any printing keyboard character is typed.
.TP 15
.P 5
Below is a sample program which will plot a sine and cosine
curve.
.S 2
.NF
.NJ
.LM 2
100 PRINT "STEP IN FRACTION OF PI"      'ASK FOR STEPPING FACTOR
110 INPUT J2                            'GET THE STEP
120 LET J1=200/J2                       'CONVERT TO SCREEN COORDINATES
130 PLOT INIT,PAGE                      'INITIALIZE FOR PLOTTING
135                                     'AND CLEAR THE SCREEN
140 PLOT STRING(0,700,"COSINE ")        'PRINT LABEL FOR COSINE CURVE
150 PLOT WHERE(X,Y)                     'SAVE POSITION OF LINE FOR SINE CURVE
160 PLOT LINE (250,700,1)               'DRAW SOLID LINE FOR COSINE CURVE
170 PLOT STRING(0,675,"SINE ")          'PRINT LABEL FOR SINE CURVE
180 PLOT LINE (X,675,0)                 'MOVE PEN BELOW COSINE LINE
190 REM DRAW DASHED LINE TO LABEL SINE CURVE USING
200 REM STEPPING FACTOR
210 N=1                                 'BEGIN WITH PEN DOWN
220 FOR R2=X+J1 TO 250 STEP J1          'ARGUMENTS FOR DASHED LINE
230 PLOT LINE (R2,675,N)                'DRAW OR MOVE THE PEN POSITION
240 N=N+1 _\ IF N_>1 THEN N=0             'IF PEN WAS UP, MAKE IT DOWN
250                                     'AND VICE VERSA
260 NEXT R2                             'LOOP THROUGH POINTS
270 PLOT ORIGIN (0,400)                 'DECLARE ORIGIN
280 REM
290 REM DRAW THE AXIS
300 REM
310 PLOT LINE (0,-200,0),LINE(0,200,1)  'Y-AXIS  400 POINTS
320 PLOT LINE (1000,0,0),LINE (0,0,1)   'X-AXIS  1000 POINTS
330 PLOT LINE (0,COS(0)*100,0)          'MOVE WITH PEN UP TO FIRST POINT
340 FOR R2=J1 TO 1000 STEP J1           'DRAW COSSINE CURVE
350 Y=COS(PI/200*R2)*100                'CALCULATE Y POSTION
360 PLOT LINE (R2,Y,1)                  'DRAW THE LINE
370 NEXT R2                             'DO ALL THE POINTS
380 PLOT LINE (0,SIN(0)*100,0)          'POINT TO FIRST SINE POSITION
390 N=1                                 'UP-DOWN DASH LINE INDICATOR,
395                                     'START AT DOWN
400 FOR R2=J1 TO 1000 STEP J1           'DRAW DASHED SINE CURVE
410 Y=SIN(PI/200*R2)*100                'CALCULATE Y POSITION
420 PLOT LINE (R2,Y,N)                  'DRAW OR MOVE THE PEN
430 N=N+1 _\ IF N_>1 THEN N=0             'IF PEN UP, MAKE DOWN
440 NEXT R2                             'DO ALL POINTS
450 PLOT ORIGIN (0,-250)                'NEW ORIGIN FOR LABELLING
460 FOR J=0 TO 4                        'OUTPUT FIVE "PI" LABELS
465 X=J*200                             'CONVERT TO SCREEN COORDINATES
470 IF X=0 THEN PLOT STRING(X,0,"0")    '0 PI
480 IF X _<_>0 THEN PLOT STRING (X,0,STR$(J)+"*PI") 'LABEL PI(S)
490 PLOT LINE (X,240,0),LINE (X,260,1)  'DRAW HASH MARK ON AXIS
500 NEXT J                              'GO THRU LOOP
505 PAUSE                               'LET HIM MAKE A HARD COPY IF HE WANTS
510 END
.F
.J
.S 1
.P 5
Plotting output may be saved on disk and recalled at a later date.
To save plotting output, the OPEN statement of the following form
is used:
.S 1
.I 10
.NF
.NJ
.INDEX <OPEN<
_<ln_> OPEN _<file spec_> FOR OUTPUT AS FILE _#N TO PLOT
.S 1
.F
.J
The file must be opened as a sequential access file.  N must be a legal BASIC
channel number.  All graphical output (except cursor and string plotting)
will be saved in the file specified until a CLOSE
statement is executed or until the end of the program (whichever
comes first).  Only one file may be opened for output plotting at a time.
If another file is opened on channel N,
the previous file will be closed.
.P 5
To recall the file to be plotted on the screen, the OPEN
statement of the following form is used:
.S 1
.NF
.NJ
.I 10
_<ln_> OPEN _<file spec_> FOR INPUT AS FILE _#N TO PLOT
.F
.J
.S 1
As above, the file must be opened as a sequential access file and N
must be a legal BASIC channel number.  This OPEN statement merely
associates the file with a channel for plotting.  As many files as there
are channel numbers may be opened at any time.  To have the file displayed
on the screen, the SAVE(N) PLOT function is used (where
N is a channel number corresponding to the file opened to plot).  The
contents of the file will then be displayed.  
Assuming the user has already created a plot file, the following
example would be used to display it.
.S 1
.NF
.NJ
.TP 4
.LM 10
10 OPEN "PLOT.BAS" FOR INPUT AS FILE _#1 TO PLOT
20 PLOT INIT,PAGE,SAVE(1)
30 END
.LM 0
.F
.J
.PG
.ST Integer Usage
.C
Integer Usage
.INDEX <I<nteger <U<sage
.LM 0
.S 2
.P 5
Numbers on the system can be represented and manipulated in either
integer or floating point format.  The implications of representing
numbers in a certain format and the resultant benefits are described
in the following discussion.  Certain operations involving integer numbers
are more efficient if performed using a forced integer format.
.TP 10
.S 2
A)##Integer Constants and Variables
.S 1
.P 5
Normally, all numeric values (variables and constants) specified in a
BASIC program are stored internally as floating-point numbers.
Integer constants can assume values in
the range -99999999 to +99999999.
.P 5
A constant, variable or function can be specified as an integer by
terminating its name with the % character.  For example:
.S 1
.NF
.NJ
.TP 3
.TAB STOPS 10,15,20
	100%	A%	FNX%(Y)
	-4%	A1%	FNL%(N%,L%)
.S 1
.F
.J
The user is expected to indicate where an integer constant is to be
generated by using the % character.  Otherwise a floating-point value
is normally produced.
.P 5
When a floating-point value is assigned to an integer variable, the
fractional portion of that number is lost. The number is not rounded
to the nearest value (a FIX function is performed rather
than an INT function). For example:
.S 1
.I 10
A%=-1.1
.S 1
causes A% to be assigned the value -1.
.TP 10
.S 2
B)##Integer Arithmetic
.S 1
.P 5
Arithmetic performed with integer variables is performed modulo
2_^35. The number range -34359738368 to +34359738367 is treated
as continuous, with the number after +34359738367 equal to -34359738368.
.P 5
Integer division forces truncation of any remainder, for example
5%/7%=0% and 199%/100%=1%. Operations can be performed in which both integer
and floating-point data are freely mixed. The result is stored in the
format indicated as the resulting variable, for example:
.S 1
.I 10
25#LET X% = N%+FNA(R)+2
.S 1
The result of the expression on the right is truncated to provide an
integer value for X%. The result of mixing integer and floating-point
data is explained in section G below.
.TP 10
.S 2
C)##Integer I/O
.S 1
.P 5
Input and output of integer variables is performed in exactly the
same manner as operations on floating-point variables. (Remember
that in cases where a floating-point variable has an integer value it is
automatically printed as an integer but is still stored internally as
a floating-point number). It is illegal to provide a floating-point
value for an integer variable through either a READ or INPUT
statement. For example:
.S 1
.TP 26
.LM 10
.NF
.NJ
LISTNH
10 READ A,B%,C,D%,E
20 PRINT A,B%,C,D%,E
30 DATA 2.7,3,4,5.7,6.8
40 END
.S 1
READY
RUNNH
.S 2
? BAD DATA IN LINE 10
.S 1
READY
.S 1
when line 30 is changed to
.S 1
30 DATA 2.7,3,4,5,6.8
.S 1
the following is printed:
.S 1
RUNNH
.S 1
.NF
.NJ
.TAB STOPS 19,27,35,43
2.7	3	4	5	6.8
.S 1
READY
.LM 0
.F
.J
.TP 10
.S 2
D)##User-defined Integer Functions
.S 1
.P 5
Functions can be written to handle integer variables as well as
floating-point variables. A function is defined to be of integer type by
following the function name with the % character.
.P 5
A function to return the remainder when one integer is divided by
another is shown below:
.S 1
.I 10
10#DEF#FNR%(I%,J%)#=#I%#-#J%*(I%/J%)
.S 1
and could be called later in a program as follows:
.S 1
.I 10
100 PRINT#FNR%(A%,11%)
.P 5
Integer arguments can not be used where floating-point arguments are
expected and vice versa, if they are an error message will be given at compile time.
.TP 10
.S 2
E)##Use of Integers as Logical Variables
.S 1
.P 5
Integer variables or integer valued expressions can be used
in any place that a logical expression can appear.
An integer value of 0% corresponds to the logical value FALSE, and
any non-zero value is defined to be TRUE. The logical operators
(AND, OR(IOR), NOT, XOR, IMP, EQV) operate on logical (or integer)
data in a bitwise manner. The integer -1% (which is represented internally
as thirty-six binary ones) is normally used by the system when a TRUE
value is required.
.P 5
Logical values generated by BASIC always have the values -1% (TRUE)
and 0% (FALSE). The following statements illustrate the use of
integers in logical applications.
.S 1
.NF
.NJ
.LM 10
10 IF -1% THEN PRINT "TRUE" ELSE PRINT "FALSE"
20 J%=-1% _\ I%=0%
30 PRINT J% AND I%,J% OR I%
40 IF 1_<0 XOR -1% THEN PRINT "TRUE" ELSE PRINT "FALSE"
50 A$="ABCDE" _\  B$="FGHIJ"
60 K%= A$ _<_> B$ EQV I% EQV J%
70 PRINT K%
80 END
RUNNH
.S 2
TRUE
0#######-1
TRUE
-1
.S 2
READY
.F
.J
.LM 0
.TP 10
.S 2
F)##Logical Operation on Integer Data
.S 1
.P 5
BASIC permits a user program to combine integer variables or integer valued expressions using a logical operator to give bit-wise
integer results (operations on floating-points numbers are also permitted, but logical string operations are not).
.P 5
In the following truth tables, A represents the condition of one bit
in one integer value, and B represents the condition of the bit in the
corresponding bit position of another integer value. The truth tables are
as follows.
.S 1
.NF
.NJ
.TP 25
.TAB STOPS 4,7,20,24,27
A	B	A AND B	A	B	A OR B
.S 1
1	1	1	1	1	1
1	0	0	1	0	1
0	1	0	0	1	1
0	0	0	0	0	0
.S 2
A	B	A XOR B	A	B	A EQV B
.S 1
1	1	0	1	1	1
1	0	1	1	0	0
0	1	1	0	1	0
0	0	0	0	0	1
.S 2
A	B	A IMP B	A	NOT A
.S 1
1	1	1	1	0
1	0	0	0	1
0	1	1
0	0	1
.F
.J
.S 1
.P 5
The result of a logical operation is an integer value generated by 
combining the corresponding bits of two integer values according
to the rules as shown in the truth tables above. For example, the
following command prints the logical product of the integers 85 and 28.
.S 1
.TP 4
.I 10
PRINT 85% AND 28%
.S 1
.I 10
20
.S 1
Each bit in the internal representation of 85% is combined with each
corresponding bit in the internal representation of 28% according to
the rules in the AND truth tables. By consulting the AND (logical
product) truth table, it can be seen that a bit is generated in the
bit position of the result only if both bits are 1 in the corresponding
bit position of the integer values 85% and 28%. The resultant value of
20 printed  by BASIC is the integer value of the bits set in the
internal representation of the logical product.
.TP 10
.S 2
G)##Mixed-mode Arithmetic
.S 1
.P 5
The user can perform arithmetic operations using a mix of integer and
floating-point numbers. To force a floating point representation of an
integer constant, terminate it with a decimal point. Use the % character
as described above to force an integer representation of a constant.
Constants without a decimal point or % character are termed ambiguous.
The remainder of this section describes the results of arithmetic
operations using a mix of numbers.
.P 5
If both operands of an arithmetic operation are either explicitly
integer or floating-point, the system generates, respectively, integer
or floating-point results. If one operand of an arithmetic operation
is an integer and another is floating-point, the system converts the integer
to a floating-point representation and generates a floating-point result.
For example:
.S 1
.TP 3
.I 10
PRINT 1%/2%;1./2.;1%/2.;1./2%
.I 10
0#.5#.5#.5
.S 1
In the first two operations, the system generates the explicit results;
in the second two, the system converts the explicit integer and generates
floating point results.
.P 5
When an ambiguous constant appears in an arithmetic expression (for
example, 10 as opposed to 10% or 10.), the system represents it in
integer format if an integer variable (for example, I%) or an integer
constant (for example 3%) occurs anywhere to the left of the constant
in the expression. Otherwise, the system treats the ambiguous constant as
a floating point number.
.PG
.ST Index
.S 1
.C
Index
.S 1
.INDEX <I<ndex
.DO INDEX
