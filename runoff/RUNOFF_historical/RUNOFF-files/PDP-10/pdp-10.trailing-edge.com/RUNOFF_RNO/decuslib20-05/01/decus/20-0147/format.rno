.comment This file is meant to be processed by the FROFF word
.comment processor.  The squeeze and letter commands at the
.comment start of this file are used to produce large lettering
.comment for the cover of the manual.  The rest of this file
.comment probably could be processed using RUNOFF.
.comment
.left top title'>',,'FORMAT Program User''s Guide'
.OFFSET RIGHT PAGE 6
.CENTER NO FILL.page length 60.page width 72
.OUTLINE'FORMAT*PROGRAM*USERS*GUIDE*',1,1,3,1,1
.figure 6
.squeeze 3,15,24,38,50,59,62.LETTER,3,1;FORMAT
.SKIP.SQUEEZE 5,16,27,39,49,60,72,73.LETTER;PROGRAM
.skip.LETTER,3,1;USERS
.skip.LETTER,3,1;GUIDE
.END OBJECT
.skip 3
FORTRAN FORMAT Statement Generator Program
.SKIP
User's Guide
.SKIP
Donald E. Barth
.SKIP
1 December 1983
.SKIP 4
.initial page.skip left page.initial page
.CENTER NO FILL
.figure 7
.squeeze 3,15,24,38,50,59,62.LETTER,3,1;FORMAT
.SKIP.SQUEEZE 5,16,27,39,49,60,72,73.LETTER;PROGRAM
.skip.LETTER,3,1;USERS
.skip.LETTER,3,1;GUIDE
.END OBJECT
.skip 4
FORTRAN FORMAT Statement Generator Program
.SKIP
User's Guide
.skip
Donald E. Barth
.SKIP
1 December 1983
.initial page.skip left page.initial page.nofill
.figure 5
                     TABLE OF CONTENTS
                     ----- -- --------
.skip 2
.spacing 2
Chapter 1:  General Instructions
  Introduction  .  .  .  .  .  .  .  .  .  .  .  .  .  .   1
  Command Structure   .  .  .  .  .  .  .  .  .  .  .  .   2
  Case Notation for Alphabetic Letters  .  .  .  .  .  .   3
.blank
Chapter 2:  Short Descriptions of the Commands
  The Commands listed in Alphabetical Order   .  .  .  .   5
  Table of Command Argument Types .  .  .  .  .  .  .  .  15
.blank
Chapter 3:  Complete Descriptions of the Commands
  The Commands listed in Alphabetical Order   .  .  .  .  17
.blank
Chapter 4:  Commands Needed for Paging on Video Terminals
  Introduction  .  .  .  .  .  .  .  .  .  .  .  .  .  .  95
  Example of FORTRAN Code Containing Several Messages  .  98
  Short Descriptions of the Paging Commands   .  .  .  . 101
  Table of Command Argument Types .  .  .  .  .  .  .  . 105
  Complete Descriptions of the Paging Commands   .  .  . 106
.blank
Appendix A
  FORMAT Program Development History .  .  .  .  .  .  . 139
.blank
Appendix B
  List of Files Included in this Package   .  .  .  .  . 141
.spacing 1.fill
.page.initial page.skip left page.initial page.number page 1
.right top title'General Instructions',,'>'
.center
Chapter 1
.skip
.center
GENERAL INSTRUCTIONS
.skip 3
.center
Introduction
.center
------------
.skip
.fill
The FORMAT program reads a sample form or a rough version of messages,
and generates FORTRAN FORMAT statements which can be used by a FORTRAN
program to reproduce the form complete with embedded variables, or
to generate the messages with lines of uniform length.  The case
conventions, the structure of the commands, and the meanings of many
of the commands which are recognized by the FORMAT program are identical
to those accepted by the DECsystem-10 text processing program RUNOFF.
When text containing only those commands which are recognized by both
the FORMAT and RUNOFF programs is processed by the FORMAT program,
then the use of the resulting FORMAT statements generates the text
which would have been produced directly by RUNOFF.  Although the FORMAT
program provides many of the same capabilities as RUNOFF, the FORMAT
program is itself written in a system independent subset of FORTRAN
and is not an extended version of RUNOFF.  If a RUNOFF capability is
not described in this documentation, then this capability is not
provided by the FORMAT program.  In particular, the FORMAT program
does not provide any footnoting, indexing or underlining capabilities.
.skip.test page 3
For sections of text which are too long to be represented in a single
FORMAT statement, the FORMAT program can generate FORTRAN WRITE
statements which reference each of the resulting FORMAT statements.
The statement numbers of the FORMAT statements and the references to
them are incremented as necessary.  For very long messages, the text
on each page can be broken into separate FORMAT statements and sections
of predefined FORTRAN code can be inserted automatically at the tops
and bottoms of the pages.
.skip.test page 3
The lines of text which are represented in the FORMAT statements can
include output field descriptions which are kept separate from the
text which is represented in H, apostrophe or asterisk notation.  A
fixed line of text can be superimposed upon each line of text which
is represented in the resulting FORMAT statements to rule vertical
lines of characters.  If identical parallel forms are being generated,
then the input file only needs to specify the text for the left form
and this can be copied to the right as many times as are desired.
.skip
.test page 3
The FORMAT program produces 2 output files, a FORTRAN language file
and a proof file.  The FORTRAN language file must be merged into an
existing program or else the input file must have specified the rest
of the FORTRAN statements, which, together with the newly constructed
FORMAT statements, make up the program.  The proof file contains the
text which would be generated when the resulting FORMAT statements
are used.  The locations at which output field specifications are
inserted are indicated by dollar signs in this text.  The actual output
field specifications are indicated in separate lines in the proof file
before the lines into which these output field specifications are
inserted.  The proof file also contains an indication of the location
at which each FORMAT statement begins, a copy of each of the commands
in the input file, and a copy of each of the FORTRAN statements which
were specified directly by the input file.
.skip 2
.test page 6
.fill
.left margin 0
.center
Command Structure
.center
------- ---------
.skip
.test page 3
Each line of the input file which does not start with a period in the
left column contains text which is to be represented in the FORMAT
statements or contains a FORTRAN statement or a FORTRAN comment which
is to be copied into the output file unchanged except for possible
case conversion of the alphabetic letters.  Each line which starts
with a period in the left column is interpreted as a command.  A command
consists of the leading period followed either by a word or by a phrase
which identifies the command, followed for some commands by 1 or 2
numbers, by 1 or 2 characters, or by the text which extends through
the rightmost printing character on the line.  The alphabetic letters
which form the word or phrase can be supplied in lower case, in upper
case, or in a mixture of upper and lower cases.  The word, or each
of the words in a phrase, can be abbreviated by truncation leaving
at least the left letter in each word if additional words or their
abbreviations appear to the right.  Spaces are allowed before, between
and after the words in a phrase but are not required.  Only enough
letters must be typed to unambiguously identify the word or phrase
from all others.  The numbers, characters or line of text which follows
the word or phrase are referred to as the arguments of the command.
The pairs of numbers or pairs of characters which are arguments of
some commands can be separated by spaces and/or by a single comma,
but the comma is not required unless only the second number or second
character of the pair is supplied.
.skip
.test page 3
For example, a few of the many ways in which the command
.skip.indent 5
_.FLAGS SPACE *
.skip.test page 3
could be specified are
.skip.indent 5
_.FS* or .F S * or .FLS* or .FSP* or .FLSP* or .FL SP *
.skip
.test page 3
Except for those commands in which the word or phrase can be followed
by the text which extends through the rightmost printing character
on the line, any command can be followed on the same line by another
command or by a semicolon which can be followed in turn by whatever
would have otherwise have appeared on the next line.  If 2 commands
are separated by a semicolon, then spaces can appear to the left of
the semicolon and to the right of the second period, but cannot appear
between the semicolon and the second period.  If 2 commands appear
on the same line but are not separated by a semicolon, then spaces
can appear between the first command and the second period.  A leading
period or a command can be followed by an exclamation point and then
by a comment which extends through the next semicolon on the same line
or through the end of the line if a semicolon does not appear on the
same line to the right of the exclamation point.  A comment is not
terminated by the appearance of a period.
.skip
.test page 5
For example, the text
.skip.left margin 5
.nofill
_.SKIP 2
_.CENTER
This is a Title
.skip.fill
.left margin 0
.test page 6
could also be specified by any of the following single lines
.skip.indent 5
_.SKIP 2.CENTER;This is a Title
.indent 5
_.SKIP 2;.CENTER;This is a Title
.break
or
.indent 5
_.SKIP 2!comment;.CENTER!comment;This is a Title
.skip
.test page 3
An underscore character can appear before any character, such as a
leading period in a noncommand line, or a semicolon, exclamation point,
comma or another underscore in a command line, which is to be treated
as an ordinary printing character.
.fill
.skip 2
.test page 6
.center
Case Notation for Alphabetic Letters
.center
---- -------- --- ---------- -------
.skip
.test page 3
This program can process text in which the letters A through Z are
already in the desired mixture of upper and lower cases (capital letters
and small letters, respectively), or in which the alphabetic letters
A through Z are all in one case with shift indications for the other
case.
.skip
.test page 3
An _.UPPER CASE command or 2 consecutive circumflexes anywhere in the
source text indicates that the cases of all subsequent alphabetic
letters which are not otherwise marked are to be retained.  An _.UPPER
CASE command is considered to be in effect when this program is started.
A _.LOWER CASE command or 2 consecutive back slashes anywhere in the
source text indicates that all subsequent alphabetic letters which
are not otherwise marked are to be converted to their lower case forms.
Regardless of the overall case setting, any single letter which is
to be converted to its upper case form can be preceded by a single
circumflex, and any single letter which is to be converted to its lower
case form can be preceded by a single back slash.  If a _.FLAGS
CAPITALIZE command has been issued, then a less than sign can be used
at the start of a word to indicate that all of the following alphabetic
letters are to be converted to their upper case forms in the word which
extends either through the last character on the line, or up to the
next space, or up to the next less than sign, whichever comes first.
A single underscore can precede any character, such as a circumflex
or a back slash or even another underscore, which is to be treated
as a nonalphabetic printing character.  A space which is to be treated
as a nonalphabetic printing character can be indicated either by a
number sign or by a space which is preceded by an underscore.  A number
sign which is to be kept as a number sign must be preceded by a single
underscore.  Any of these flag characters can be changed or temporarily
disabled by commands in the source text.
.skip
.test page 3
If the source file contains only lower case letters, but both cases
are desired and can be processed by the FORTRAN compiler and operating
system, then, without any special action, all letters will remain in
their lower case forms except for those letters which immediately follow
a single circumflex or which are in words which are preceded by a less
than sign if a _.FLAGS CAPITALIZE command has been issued.
.skip
.test page 3
If the source file contains only upper case letters, but both cases
are desired and can be processed by the FORTRAN compiler and operating
system, then the input file should contain a _.LOWER CASE command or
2 consecutive back slashes so that subsequent letters will be translated
to their lower case forms except for those letters which immediately
follow a single circumflex or which follow a single underscore or which
are in words which are preceded by a less than sign if a _.FLAGS
CAPITALIZE command has been issued.  If there are sections of the source
text which are to be kept primarily in their original upper case forms,
then these sections can be preceded by an _.UPPER CASE command or by
2 consecutive circumflexes, and then any individual letters which need
to be converted to their lower case forms can be preceded by single
back slashes.
.skip
.test page 10
For example, the source text
.skip
.nofill
.test page 8
_.preface       WRITE(1,$)
_.nofill.flags capitalize.output width 60.offset 0
_\_\_^ONLY THE FIRST LETTER IN THIS LINE REMAINS UPPER CASE.
<THE FIRST WORD IN THIS LINE WILL BE CAPITALIZED.
_^_^_^all but the first letter of this line remains lower case.
<the first word in this line will be capitalized.
Underscores precede ___^, ___\, __<, ___# or ____ which are kept.
_.program;      END
.skip
.fill
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 8
      WRITE(1,1)
    1 FORMAT(43HOnly the first letter in this line remains ,
     111Hupper case./35HTHE first word in this line will be,
     213H capitalized./33HAll but the first letter of this ,
     324Hline remains lower case./22HTHE first word in this,
     426H line will be capitalized./20HUnderscores precede ,
     531H_^, _\, <, _# or __ which are kept.)
      END
.skip
.fill
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 5
Only the first letter in this line remains upper case.
THE first word in this line will be capitalized.
All but the first letter of this line remains lower case.
THE first word in this line will be capitalized.
Underscores precede _^, _\, <, _# or __ which are kept.
.fill
.left margin 0
.fill
.left margin 0
.page.initial page.skip left page.initial page
.RIGHT TOP TITLE'Short Descriptions of the Commands',,'>'
.center
Chapter 2
.skip.center
SHORT DESCRIPTIONS OF THE COMMANDS
.skip 3
.center
The Commands Listed in Alphabetical Order
.center
--- -------- ------ -- ------------ -----
.skip
Most of the commands which can appear in the source files which are
processed by the FORMAT program are summarized in this chapter and
are described in detail in the next chapter.  However, the commands
which are needed for parcelling out the lines in long messages into
separate pages are described later in this manual.
.skip
Above the description of each command is shown the command name in
capital letters together with a one line summary in small letters of
the numbers, characters or line of text which can appear to its right.
To make the descriptions easier to read, the command names are always
capitalized in the descriptions, but the commands would not have to
be capitalized in the actual source text which is processed by the
FORMAT program.
.left margin 5
.skip
.test page 4
.indent -5
_.BLANK number of extra blank lines to be generated
.skip
The specified number of extra blank lines are to be represented in
the FORMAT statement.  _.SKIP is similar.
.skip
.test page 7
.indent -5
_.BREAK
.skip
No additional text is to be included in the line of text currently
being represented in the FORMAT statement.  Blank lines requested by
_.BLANK or _.SKIP or implied by _.SPACING are not generated immediately.
Similar to _.EJECT which generates such blank lines immediately.
.skip
.test page 9
.indent -5
_.CARRIAGE next carriage control character
.break
or
.indent -5
_.CARRIAGE next carriage control, subsequent carriage control
.skip
The first specified character is to replace the space in the leftmost
column of the next line which is represented in the FORMAT statements.
If a second character is specified, it is to replace the space in the
leftmost column of each of the subsequent lines.  Opposite of _.NO
CARRIAGE.  _.NO CARRIAGE is the default.
.skip
.test page 11
.left margin 0
.nofill
_.CENTER width of region as unsigned number
_.CENTER offset from largest right margin as signed number
_.CENTRE width of region as unsigned number
     or
_.CENTRE offset from largest right margin as signed number
.fill
.left margin 5
.skip
The following line of text is to be centered in the region given as
an unsigned number or in the region to the left of the sum of the
largest right margin plus the signed number.  Except for the insertion
of the initial spaces, the line is to be represented with the same
number of spaces as in the original source.
.skip
.test page 5
.indent -5
_.COMMENT line of text which is to be ignored
.skip
The characters which appear to the right of the _.COMMENT command are
to be treated as the text of a comment and are otherwise to be ignored.
.skip
.test page 5
.indent -5
_.CONTINUE next statement number, statement number increment
.skip
The following text is to be represented in a new FORMAT statement.
_.INSERT and _.PREFACE commands are retained.  _.PROGRAM command is
cancelled.  _.TEXT is similar.
.skip
.test page 8
.indent -5
_.COPY number of characters to copy, number of times to copy
.skip
The indicated number of characters at the left end of each line
represented in the FORMAT statements, after the application of the
line of text specified by a _.MASK command if any, but before the
application of the character specified by the _.CARRIAGE command, are
to be copied the indicated number of additional times to the right.
Opposite of _.NO COPY.  _.NO COPY is the default.
.skip
.test page 8
.indent -5
_.DEFINE GROUP
.skip
The following lines of text through the next _.END DEFINITION command
or the next of any of the various _.DEFINE commands are to be copied
into the output file before each group of FORMAT statements which is
preceded by a _.TEXT command.  A single line to be inserted before
each group of FORMAT statements can be defined by the _.GROUP command
instead.
.skip
.test page 7
.indent -5
_.DEFINE PREFACE
.skip
The following lines of text through the next _.END DEFINITION command
or the next of any of the various _.DEFINE commands are to be copied
into the output file before each FORMAT statement.  A single line to
be inserted before each FORMAT statement can be defined by the _.PREFACE
command instead.
.skip
.test page 7
.indent -5
_.EJECT
.skip
No additional text is to be included in the line of text currently
being represented in the FORMAT statement.  All blank lines which have
been requested by _.BLANK or _.SKIP or implied by _.SPACING are
generated immediately.  Similar to _.BREAK which does not generate
such blank lines immediately.
.skip
.test page 10
.indent -5
_.END DEFINITION
.skip
Indicates that all of the lines of text have been be specified which
are to be inserted before some or all of the FORMAT statements which
are generated.  If these lines were preceded by a _.DEFINE GROUP
command, then these lines are inserted before the first FORMAT statement
and before each subsequent FORMAT statement which follows a _.TEXT
command.  If these lines were instead preceded by a _.DEFINE PREFACE
command, then these lines are inserted before every FORMAT statement.
.skip
.test page 3
.indent -5
_.END OF FILE
.skip
No additional text is to be processed.
.skip
.test page 5
.indent -5
_.FILL
.skip
Multiple spaces are to be removed from the following text and words
are to be accumulated until the next word would extend beyond the right
margin.  Opposite of _.NO FILL.  _.FILL is the default.
.skip
.test page 8
.indent -5
_.FLAGS
.break
or
.indent -5
_.FLAGS ALL
.skip
Most flag characters are enabled in the source text.  Does not change
interpretation of flag characters specified by _.FLAGS FENCE, _.FLAGS
CONTROL and _.FLAGS REMARK commands.  Opposite of _.NO FLAGS ALL.
_.FLAGS ALL is the default.
.skip
.test page 6
.indent -5
_.FLAGS CAPITALIZE character to precede capitalized words
.skip
Words in which each letter is to be capitalized can be preceded by
the specified character.  Less than sign is assumed if no character
follows the _.FLAGS CAPITALIZE command.  Opposite of _.NO FLAGS
CAPITALIZE.  _.NO FLAGS CAPITALIZE is the default.
.skip
.test page 5
.indent -5
_.FLAGS CONTROL character to precede commands
.skip
Commands in the source file are indicated by having the specified
character in the first column.  Opposite of _.NO FLAGS CONTROL.  _.FLAGS
CONTROL ___.  is the default.
.skip
.test page 5
.indent -5
_.FLAGS FENCE character to terminate and separate commands
.skip
A command can be followed by the specified character and then by
whatever would have otherwise have appeared on the next line.  Opposite
of _.NO FLAGS FENCE.  _.FLAGS FENCE ___; is the default.
.skip
.test page 8
.indent -5
_.FLAGS INSERT character to indicate location of insertions
.skip
The specified character can be used in program text to indicate the
locations at which statement numbers are to be inserted, and in text
being represented in the FORMAT statements to indicate the locations
at which output field descriptions as specified by the _.INSERT command
are to be inserted.  Opposite of _.NO FLAGS INSERT.  _.FLAGS INSERT
$ is the default.
.skip
.test page 7
.indent -5
_.FLAGS LOWER CASE character to precede lower case letters
.skip
Letters in the source text which are to be translated into lower case
can each be preceded by a single appearance of the specified character.
Two adjacent appearances of this character are equivalent to the _.LOWER
CASE command.  Opposite of _.NO FLAGS LOWER CASE.  _.FLAGS LOWER CASE
___\ is the default.
.skip
.test page 5
.indent -5
_.FLAGS QUOTE character to precede character to be used as is
.skip
The specified character can precede any special character which is
to be treated as an ordinary character.  Opposite of _.NO FLAGS QUOTE.
_.FLAGS QUOTE ____ is the default.
.skip
.test page 5
.indent -5
_.FLAGS REMARK character to separate commands from comments
.skip
The specified character can precede a comment which appears to the
right of a command.  Opposite of _.NO FLAGS REMARK.  _.FLAGS REMARK
___!  is the default.
.skip
.test page 6
.indent -5
_.FLAGS SPACE character to indicate a nonadjustable space
.skip
The specified character can be used to represent a space which is to
be treated as a portion of a word rather than as a word boundary.
Opposite of _.NO FLAGS SPACE.  _.FLAGS SPACE ___# is the default.
.skip
.test page 7
.indent -5
_.FLAGS UPPER CASE character to precede upper case letters
.skip
Letters in the source text which are to be translated to upper case
can each be preceded by a single appearance of the specified character.
Two adjacent appearances of this character are equivalent to the _.UPPER
CASE command.  Opposite of _.NO FLAGS UPPER CASE.  _.FLAGS UPPER CASE
___^ is the default.
.skip
.test page 9
.indent -5
_.GROUP line of text to precede groups of FORMAT statements
.skip
The line of text which appears to the right of the _.GROUP command
is to be copied into the output file before each group of FORMAT
statements which is preceded by a _.TEXT command.  The _.GROUP command
can be cancelled by a _.NO GROUP command.  _.NO GROUP is the default.
A group of lines to be inserted before each group of FORMAT statements
can be defined by the _.DEFINE GROUP command instead.
.skip
.test page 4
.indent -5
_.INDENT number of extra spaces to insert beyond left margin
.skip
The following line of text is to be indented from the left margin by
the indicated number of spaces.
.skip
.test page 5
.indent -5
_.INPUT WIDTH maximum number of characters in any input line
.skip
Only the indicated number of characters in each line in the input file
are to be read and processed.  Maximum width is 300.  _.INPUT WIDTH
132 is the default.
.skip
.test page 6
.indent -5
_.INSERT output field specification to replace next $ signs
.skip
The characters appearing to the right of the _.INSERT command form
an output field specification which is to replace the next group of
contiguous dollar signs.  All unused groups of characters are discarded
if either a _.NO INSERT or a _.TEXT command is issued.
.skip
.test page 5
.indent -5
_.JUSTIFY
.skip
Extra spaces are to be inserted between the words in fill mode to cause
the lines to be flush with both the left and right margins.  Opposite
of _.NO JUSTIFY.  _.JUSTIFY is the default.
.skip
.test page 6
.indent -5
_.LEADING
.skip
The FORMAT statements are to include initial blank lines requested
by _.BLANK and _.SKIP commands which appear before the text which is
to be represented.  Opposite of _.NO LEADING.  _.NO LEADING is the
default.
.skip
.test page 5
.indent -5
_.LEFT MARGIN number of spaces to left of text
.skip
The following text is to begin in the column to the right of the
indicated column.  This is in addition to the offset specified by the
_.OFFSET command.  _.LEFT MARGIN 0 and _.OFFSET 1 are the defaults.
.skip
.test page 7
.indent -5
_.LOWER CASE
.skip
Upper case letters on the following lines are to be translated to lower
case unless preceded by circumflexes or underscores or, if in flag
capitalize mode, unless in words which are preceded by less than signs.
Equivalent to appearance of 2 back slashes.  Opposite of _.UPPER CASE
which is the default.
.skip
.test page 6
.indent -5
_.MASK text to be superimposed onto each output line
.skip
The printing characters appearing to the right of the _.MASK command
are to be superimposed onto each line of text which is represented
in the FORMAT statements.  The _.MASK command is cancelled by a _.NO
MASK command.  _.NO MASK is the default.
.skip
.test page 5
.indent -5
_.NO CARRIAGE
.skip
No special character is to replace the space in the leftmost column
of each line which is represented in the FORMAT statements.  Opposite
of _.CARRIAGE.  _.NO CARRIAGE is the default.
.skip
.test page 5
.indent -5
_.NO COPY
.skip
The characters in each line represented in the FORMAT statements are
not to be copied additional times to the right.  Opposite of _.COPY.
_.NO COPY is the default.
.skip
.test page 7
.indent -5
_.NO FILL
.skip
Except for the insertion of initial spaces required for the offset,
left margin and indentation, and except for case conversions and removal
of underscores, each of the following lines of source text is to be
regenerated exactly when the resulting FORMAT statements are used.
Opposite of _.FILL.  _.FILL is the default.
.skip
.test page 8
.indent -5
_.NO FLAGS
.break
or
.indent -5
_.NO FLAGS ALL
.skip
Most flag characters are disabled in the source text.  Does not change
interpretation of flag characters specified by _.FLAGS FENCE, _.FLAGS
CONTROL and _.FLAGS REMARK commands.  Opposite of _.FLAGS ALL.  _.FLAGS
ALL is the default.
.skip
.test page 5
.indent -5
_.NO FLAGS CAPITALIZE
.skip
No special character can be used to indicate words in which each letter
is to be capitalized.  Opposite of _.FLAGS CAPITALIZE.  _.NO FLAGS
CAPITALIZE is the default.
.skip
.test page 4
.indent -5
_.NO FLAGS CONTROL
.skip
Commands cannot be included in the source text.  Opposite of _.FLAGS
CONTROL.  _.FLAGS CONTROL ___.  is the default.
.skip
.test page 6
.indent -5
_.NO FLAGS FENCE
.skip
No special character can follow a command to indicate that the text
to its right is to be treated as though this text appeared on the next
line.  Opposite of _.FLAGS FENCE.  _.FLAGS FENCE ___; is the default.
.skip
.test page 8
.indent -5
_.NO FLAGS INSERT
.skip
No special character can be used in program text to indicate the
locations at which statement numbers are to be inserted, and in text
being represented in the FORMAT statements to indicate the locations
at which output field descriptions as specified by the _.INSERT command
are to be inserted.  Opposite of _.FLAGS INSERT.  _.FLAGS INSERT $
is the default.
.skip
.test page 5
.indent -5
_.NO FLAGS LOWER CASE
.skip
No special character can be used to indicate single letters which are
to be translated into lower case.  Opposite of _.FLAGS LOWER CASE.
_.FLAGS LOWER CASE ___\ is the default.
.skip
.test page 5
.indent -5
_.NO FLAGS QUOTE
.skip
No special character can precede any special character which is to
be treated as an ordinary printing character.  Opposite of _.FLAGS
QUOTE.  _.FLAGS QUOTE ____ is the default.
.skip
.test page 4
.indent -5
_.NO FLAGS REMARK
.skip
A comment cannot appear to the right of a command.  Opposite of _.FLAGS
REMARK.  _.FLAGS REMARK ___!  is the default.
.skip
.test page 5
.indent -5
_.NO FLAGS SPACE
.skip
No special character can be used to represent a space which is to be
treated as a portion of a word rather than as a word boundary.  Opposite
of _.FLAGS SPACE.  _.FLAGS SPACE ___# is the default.
.skip
.test page 5
.indent -5
_.NO FLAGS UPPER CASE
.skip
No special character can be used to indicate single letters which are
to be translated into upper case.  Opposite of _.FLAGS UPPER CASE.
_.FLAGS UPPER CASE ___^ is the default.
.skip
.test page 4
.indent -5
_.NO GROUP
.skip
No line of text is to be inserted before each group of FORMAT
statements.  Opposite of _.GROUP.  _.NO GROUP is the default.
.skip
.test page 4
.indent -5
_.NO INSERT
.skip
All unused groups of characters specified by _.INSERT commands are
to be discarded.
.skip
.test page 4
.indent -5
_.NO JUSTIFY
.skip
Extra spaces are not to be inserted between the words in fill mode.
Opposite of _.JUSTIFY.  _.JUSTIFY is the default.
.skip
.test page 6
.indent -5
_.NO LEADING
.skip
The FORMAT statements are to exclude initial blank lines requested
by _.BLANK and _.SKIP commands which appear before the text which is
to be represented.  Opposite of _.LEADING.  _.NO LEADING is the default.
.skip
.test page 5
.indent -5
_.NO MASK
.skip
No line of text is to be superimposed onto each line which is
represented in the FORMAT statements.  Opposite of _.MASK.  _.NO MASK
is the default.
.skip
.test page 5
.indent -5
_.NO OFFSET
.skip
No spaces are to be inserted at the left edge of each line in addition
to the normal left margin and indentation.  Equivalent to _.OFFSET
0.  _.OFFSET 1 is the default.
.skip
.test page 4
.indent -5
_.NO PREFACE
.skip
No line of text is to be inserted before each FORMAT statement.
Opposite of _.PREFACE.  _.NO PREFACE is the default.
.skip
.test page 6
.indent -5
_.NO TRAILING
.skip
Blank lines requested after the preceding text by _.BLANK or _.SKIP
commands or which are necessary for multiple line spacing are discarded
before _.TEXT commands or when the end of the source file is read.
Opposite of _.TRAILING.  _.NO TRAILING is the default.
.skip
.test page 5
.indent -5
_.OFFSET number of spaces to be inserted at left edge of text
.skip
The indicated number of spaces is inserted at the left edge of each
line in addition to the normal left margin and indentation.  _.OFFSET
0 is equivalent to _.NO OFFSET.  _.OFFSET 1 is the default.
.skip
.test page 6
.indent -5
_.OUTPUT LENGTH maximum number of lines in a FORMAT statement
.skip
FORMAT statements can be constructed from no more than the indicated
number of FORTRAN language lines.  _.OUTPUT LENGTH 20 is the default,
but this program does not impose any upper limit upon this maximum.
.skip
.test page 5
.indent -5
_.OUTPUT WIDTH most characters in each FORMAT statement line
.skip
Each FORTRAN language line from which the FORMAT statements are
constructed can contain no more than the indicated number of characters.
Maximum is 72.  _.OUTPUT WIDTH 72 is the default.
.skip
.test page 13
.indent -5
_.PARAGRAPH columns to indent, multiple of line spacing
.break
or
.indent -5
_.PARAGRAPH columns to indent, -1 times number of blank lines
.skip
The next line of text is to be indented from the left margin by the
number of spaces indicated by the first argument.  If the second
argument is greater than or equal to zero, then this times the number
most recently specified by a _.SPACING command is to be the number
of extra blank lines which are to precede the next line of text.  If
the second argument is less than zero, then this without its sign is
the number of extra blank lines which are to precede the next line
of text.
.skip
.test page 8
.indent -5
_.PREFACE line of text to precede each new FORMAT statement
.skip
The line of text which appears to the right of the _.PREFACE command
is to be copied into the output file before each FORMAT statement.
The _.PREFACE command can be cancelled by a _.NO PREFACE command.  _.NO
PREFACE is the default.  A group of lines to be inserted before each
FORMAT statement can be defined by the _.DEFINE PREFACE command instead.
.skip
.test page 5
.indent -5
_.PROGRAM next statement number, statement number increment
.skip
The following text, through the next _.TEXT or _.CONTINUE command,
is to be copied unchanged into the output file without being represented
in FORMAT statements.
.skip
.test page 4
.indent -5
_.RESET
.skip
All variable conditions are to be returned to their initial settings.
.skip
.test page 6
.indent -5
_.RESUME GROUP
.skip
The line or lines of text which were defined by either a _.GROUP command
or a _.DEFINE GROUP command but which were disabled by a subsequent
_.NO GROUP command are to again be inserted before each group of FORMAT
statements.
.skip
.test page 6
.indent -5
_.RESUME PREFACE
.skip
The line or lines of text which were defined by either a _.PREFACE
command or a _.DEFINE PREFACE command but which were disabled by a
subsequent _.NO PREFACE command are to again be inserted before each
FORMAT statement.
.skip
.test page 5
.indent -5
_.RIGHT MARGIN rightmost column into which text is wrapped
.skip
If in fill mode, words are wrapped around until the next word would
extend beyond the indicated column.  _.RIGHT MARGIN 60 is the default.
.skip
.test page 6
.indent -5
_.SKIP multiple of extra line spacings to be generated
.skip
A number of extra blank lines equal to the specified multiple of the
number which appeared to the right of the previous _.SPACING command
are to be represented in the FORMAT statement.  _.BLANK is similar.
.skip
.test page 5
.indent -5
_.SPACING separation from top of one line to top of next line
.skip
One less than the indicated number of blank lines are to be inserted
between the lines of text.  _.SPACING 1 giving single spacing is the
default.
.skip
.test page 6
.indent -5
_.TEXT next statement number, statement number increment
.skip
The following text is to be represented in a new FORMAT statement.
_.INSERT and _.PROGRAM commands are cancelled.  _.CONTINUE is similar.
_.TEXT 1,1 is the default at the start of the processing of the text.
.skip
.test page 6
.indent -5
_.TRAILING
.skip
Blank lines requested after the preceding text by _.BLANK or _.SKIP
commands or which are necessary for multiple line spacing are generated
before _.TEXT commands or when the end of the source file is read.
Opposite of _.NO TRAILING.  _.NO TRAILING is the default.
.skip
.test page 5
.indent -5
_.UPPER CASE
.skip
The cases of letters on the following lines are to be retained.
Equivalent to appearance of 2 circumflexes.  Opposite of _.LOWER CASE.
_.UPPER CASE is the default.
.skip
.test page 6
.indent -5
_.USE character implying text representation notation
.skip
Hollerith (number H) notation is used to represent text in FORMAT
statements if the following character is an H.  Apostrophe or asterisk
notation is used if the character is an apostrophe or an asterisk
respectively.  _.USE H is the default.
.left margin 0.skip 2.test page 10
The commands which are listed below were described in previous versions
of this manual.  These commands have been renamed to obtain a more
consistent set of command names.  However, the old names are still
recognized, and source files containing commands having the old names
are still processed correctly.
.skip.left margin 5
.test page 4
.indent -5
_.BEGIN next statement number, statement number increment
.skip
This command has been renamed _.TEXT with the same definition.  Both
names are treated identically.
.skip
.test page 4
.indent -5
_.FORMAT next statement number, statement number increment
.skip
This command has been renamed _.CONTINUE with the same definition.
Both names are treated identically.
.skip
.test page 4
.indent -5
_.LENGTH maximum number of lines in a FORMAT statement
.skip
This command has been renamed _.OUTPUT LENGTH with the same definition.
Both names are treated identically.
.left margin 0.page.nofill
Table of Command Argument Types and Whether BREAK is Implied
----- -- ------- -------- ----- --- ------- ----- -- -------
.skip
.test page 4
Basic         Is .BREAK   Argument      Corresponding
Command         Implied   Type          NO Command
.skip
_.BLANK              yes   1 number
_.BREAK              yes   none
_.CARRIAGE           no    2 characters  .NO CARRIAGE
_.CENTER or .CENTRE  yes   1 number
_.COMMENT            no    text (ignored)
_.CONTINUE           yes   2 numbers
_.COPY               yes   2 numbers     .NO COPY
_.DEFINE GROUP       no    none          .NO GROUP
_.DEFINE PREFACE     no    none          .NO PREFACE
_.EJECT              yes   none
_.END DEFINITION     no    none
_.END OF FILE        yes   none
_.FILL               yes   none          .NO FILL
_.FLAGS ALL          no    none          .NO FLAGS ALL
_.FLAGS CAPITALIZE   no    1 character   .NO FLAGS CAPITALIZE
_.FLAGS CONTROL      no    1 character   .NO FLAGS CONTROL
_.FLAGS FENCE        no    1 character   .NO FLAGS FENCE
_.FLAGS INSERT       no    1 character   .NO FLAGS INSERT
_.FLAGS LOWER CASE   no    1 character   .NO FLAGS LOWER CASE
_.FLAGS QUOTE        no    1 character   .NO FLAGS QUOTE
_.FLAGS REMARK       no    1 character   .NO FLAGS REMARK
_.FLAGS SPACE        no    1 character   .NO FLAGS SPACE
_.FLAGS UPPER CASE   no    1 character   .NO FLAGS UPPER CASE
_.GROUP              no    text          .NO GROUP
_.INDENT             yes   1 number
_.INPUT WIDTH        no    1 number
_.INSERT             no    text          .NO INSERT
_.JUSTIFY            yes   none          .NO JUSTIFY
_.LEADING            no    none          .NO LEADING
_.LEFT MARGIN        yes   1 number
_.LOWER CASE         no    none
_.MASK               no    text          .NO MASK
_.OFFSET             yes   1 number      .NO OFFSET
_.OUTPUT LENGTH      no    1 number
_.OUTPUT WIDTH       no    1 number
_.PARAGRAPH          yes   2 numbers
_.PREFACE            no    text          .NO PREFACE
_.PROGRAM            yes   2 numbers
_.RESET              yes   none
_.RESUME GROUP       no    none          .NO GROUP
_.RESUME PREFACE     no    none          .NO PREFACE
_.RIGHT MARGIN       yes   1 number
_.SKIP               yes   1 number
_.SPACING            yes   1 number
_.TEXT               yes   2 numbers
_.TRAILING           no    none          .NO TRAILING
_.UPPER CASE         no    none
_.USE                no    1 character
.fill.left margin 0
.page.initial page.skip left page.initial page
.RIGHT TOP TITLE'Complete Descriptions of the Commands',,'>'
.center
Chapter 3
.skip.center
COMPLETE DESCRIPTIONS OF THE COMMANDS
.SKIP 3
.center
The Commands Listed in Alphabetical Order
.center
--- -------- ------ -- ------------ -----
.skip
Most of the commands which can appear in the source files which are
processed by the FORMAT program were summarized in the previous chapter
and are described in detail in this chapter.  However, the commands
which are needed for parcelling out the lines in long messages into
separate pages are described in the next chapter.
.skip
Above the description of each command is shown the command name in
capital letters together with a one line summary in small letters of
the numbers, characters or line of text which can appear to its right.
To make the descriptions easier to read, the command names are always
capitalized in the descriptions, but the commands would not have to
be capitalized in the actual source text which is processed by the
FORMAT program.
.skip
.left margin 5
.fill
.test page 6
.indent -5
_.BLANK number of extra blank lines to be generated
.skip
.test page 3
The _.BLANK command indicates that, after the representation in the
FORMAT statement of the previous text, the specified number of blank
lines are to be represented in the FORMAT statement, in addition to
any blank lines specified by other _.BLANK or _.SKIP commands, and,
if a _.SPACING command has been issued, in addition to the normal line
spacing of one less than the number which appeared to the right of
the previous _.SPACING command.  If no number appears to the right
of the _.BLANK command, then the number 1 is assumed to appear to the
right of the _.BLANK command instead.  If a _.SPACING 2 command is
in effect, then a _.BLANK 3 command would result in 3+(2-1) or 4 blank
lines being generated.  The _.BLANK command is similar to the _.SKIP
command, except that the _.SKIP command specifies the number of extra
blank lines as a multiple of the number which appeared to the right
of the previous _.SPACING command.  The _.BLANK command implies a
_.BREAK command.
.skip
.test page 3
If no text has been represented in the FORMAT statements either since
this program was started or since the last _.TEXT command was issued,
then the _.BLANK command, like the _.SKIP command and the _.BLANK or
_.SKIP command implied by the _.PARAGRAPH command, is ignored unless
a _.LEADING command is in effect.  Blank lines which have not been
generated when the end of the source file is read or when the next
_.TEXT command is issued, but which have been requested by _.BLANK
or _.SKIP commands or which are necessary for the normal line spacing,
will be appended to the FORMAT statement being constructed if a _.TRAIL
command is then in effect.  Blank lines will be discarded when the
end of the source file is read or the next _.TEXT command is issued
if a _.NO TRAIL command is then in effect or if a _.TRAIL command has
not by then been issued.
.skip
.test page 15
For example, the source text
.skip
.nofill
_.spacing 2.output width 55
_.blank
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
_.blank
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
_.blank 2
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
_.blank 3
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
.skip
.fill
.test page 11
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
    1 FORMAT(38H The quick red fox jumps over the lazy,
     123H brown dog,  then  runs//17H into the forest./
     2//43H The quick red fox jumps over the lazy brow,
     318Hn dog,  then  runs//17H into the forest.////
     445H The quick red fox jumps over the lazy brown ,
     516Hdog,  then  runs//17H into the forest./////
     645H The quick red fox jumps over the lazy brown ,
     716Hdog,  then  runs//17H into the forest.)
.fill
.skip 2
.left margin 5
.test page 6
.fill
.indent -5
_.BREAK
.skip
.test page 3
The _.BREAK command indicates that no additional text is to be included
in the line of text currently being represented in the FORMAT statement.
The line of text is assumed to be shorter than normal, and so is not
right justified by the insertion of extra spaces between the groups
of printing characters (words) on the line.  The _.BREAK command is
similar to the _.EJECT command with the exception that blank lines
requested by _.BLANK commands or _.SKIP commands or implied by _.SPACING
commands are not generated immediately when the _.BREAK command is
issued if no printing characters have been accumulated into the current
line of text.  The representation of the line of text will be followed
by a number of blank lines equal to one less than the number which
followed the previous _.SPACING command if the _.TRAIL command has
been issued or if additional text is represented.  A _.BREAK command
is also implied by most other commands which change the manner in which
the source text is represented.
.skip
.test page 11
For example, the source text
.skip
.nofill
_.output width 55.spacing 2
one
two three
_.break
four five six
seven eight nine ten
_.break
eleven twelve thirteen fourteen fifteen
sixteen seventeen eighteen nineteen twenty twenty-one
.skip
.fill
.test page 7
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
    1 FORMAT(14H one two three//19H four five six seve,
     116Hn eight nine ten//24H eleven twelve thirteen ,
     237Hfourteen  fifteen  sixteen  seventeen//4H eig,
     332Hhteen nineteen twenty twenty-one)
.fill
.skip 2
.left margin 5
.fill
.test page 8
.indent -5
_.CARRIAGE next carriage control character
.break
or
.indent -5
_.CARRIAGE next carriage control, subsequent carriage control
.skip
.test page 3
The first character in each line of text which is generated when the
resulting FORMAT statements are used can be interpreted by the FORTRAN
operating system to select the carriage motion on the output device
to which the text is written.  The _.CARRIAGE command allows the
specification of these carriage control characters.  If a _.CARRIAGE
command has not been issued, or if a _.CARRIAGE command is issued
without any following characters, or if a _.NO CARRIAGE command is
issued, then the leftmost character in each of the subsequent lines
of text which are being represented in the FORMAT statements will be
a space if a positive offset has been selected by the combination of
_.OFFSET, _.LEFT MARGIN and _.INDENT or _.PARAGRAPH commands, and
completely blank lines will be represented in the FORMAT statements
by consecutive slashes.
.skip
.test page 3
If the _.CARRIAGE command is followed by a printing character, or is
followed by a pair of printing characters optionally separated by spaces
and/or separated by a single comma, then the first character following
the _.CARRIAGE command is to replace the leftmost character in the
next line of text which is represented in the resulting FORMAT
statements, providing that the character which is to be replaced is
a space which was not quoted by an underscore and was not specified
by a number sign.  If the next line of text which is represented in
the resulting FORMAT statements is a blank line, regardless of whether
this blank line has been requested by a _.BLANK command or a _.SKIP
command or has been implied by a _.SPACING command or was encountered
in text being copied in no fill mode, then the line will contain only
the character specified by the _.CARRIAGE command.  In order for a
space, number sign, circumflex, back slash, less than sign (if in flag
capitalize mode), period, comma, semicolon, exclamation point or
underscore to be specified by the _.CARRIAGE command as the carriage
control character, this character would have to be preceded by an
underscore.
.skip
.test page 3
If a second printing character follows the _.CARRIAGE command, then,
after the next line of text has been generated, this second printing
character is to replace the leftmost character in each of the subsequent
lines of text, providing that the character which is to be replaced
is a space which was not quoted by an underscore and was not specified
by a number sign.  If a printing character does not appear between
the _.CARRIAGE command and the following comma, then the character
following the comma is considered to have also preceded the comma.
Neither the _.CARRIAGE command nor the _.NO CARRIAGE command implies
a _.BREAK command.  A _.BREAK command, or some other command which
implies a _.BREAK command, should usually be issued before the
_.CARRIAGE command since, if the lines of text are being constructed
in fill mode, the carriage control character is applied to the current
line of text only after this line of text has otherwise been completed.
.skip
.test page 16
For example, the source text
.skip
.nofill
.test page 14
_.spacing 2.right margin 54.output width 55.paragraph
_.carriage 1*.preface       WRITE(1,$)
This is the first line in the demonstration of the
insertion of the carriage control character.
_.eject.carriage 1_#.paragraph
This is the second line in the demonstration of the
insertion of the carriage control character.
_.eject.carriage 1.paragraph
This is the third line in the demonstration of the
insertion of the carriage control character.
_.eject.no carriage.paragraph
This is the fourth line in the demonstration of the
insertion of the carriage control character.
_.eject.program;      END
.skip
.fill
.test page 16
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 13
      WRITE(1,1)
    1 FORMAT(38H1     This is the first line in  the  ,
     117Hdemonstration  of/1H*/20H*the insertion of th,
     229He carriage control character./1H*/1H1/6X,2HTh,
     345His is the second line in the  demonstration  ,
     42Hof/1X/37H the insertion of the carriage contro,
     512Hl character./1X/1H1/6X,19HThis is the third l,
     630Hine in  the  demonstration  of//10H the inser,
     739Htion of the carriage control character.///6X,
     845HThis is the fourth line in the  demonstration,
     94H  of//37H the insertion of the carriage contro,
     112Hl character./)
      END
.skip
.fill
.test page 21
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 18
1     This is the first line in  the  demonstration  of
*
*the insertion of the carriage control character.
*
1
      This is the second line in the  demonstration  of
.skip
 the insertion of the carriage control character.
.skip
1
      This is the third line in  the  demonstration  of
.skip
 the insertion of the carriage control character.
.skip
.skip
      This is the fourth line in the  demonstration  of
.skip
 the insertion of the carriage control character.
.fill
.skip 2
.left margin 0
.test page 10
.nofill
_.CENTER width of region as unsigned number
_.CENTER offset from largest right margin as signed number
_.CENTRE width of region as unsigned number
     or
_.CENTRE offset from largest right margin as signed number
.fill
.left margin 5
.skip
.test page 3
The _.CENTER command indicates that the following line of source text
is to be centered and, except for the insertion of the initial spaces
needed to obtain centering, is to be represented in the FORMAT statement
with the same number of spaces as in the original source.  If no number
follows the _.CENTER command, then the following line is to be centered
between column zero and the farthest right margin which has yet been
set.  If the number following the _.CENTER command is signed, then
the following line is to be centered between column zero and the column
which is the sum of the indicated number and the farthest right margin
which has yet been set, so that the line is shifted from its centered
position by half the signed number of columns.  If the number following
the _.CENTER command is unsigned and greater than zero, then the
following line of text is to be centered between column zero and the
indicated column.  If the number following the _.CENTER command is
unsigned and zero, then the following line is to be centered between
the current left and right margins.  If the _.CENTER command was
preceded by an _.INDENT command, then the _.INDENT command is ignored.
The _.CENTER command implies a _.BREAK command both before and after
the following line of source text.
.skip
.test page 20
For example, the source text
.skip
.nofill
_.OFFSET 0;.OUTPUT WIDTH 55;.PREFACE       WRITE(1,$)
1234567890123456789012345678901234567890123456789012345
_.LEFT MARGIN 14;.RIGHT MARGIN 34
The quick red fox jumps over the lazy brown dog
_.CENTER 0;CENTER   0
_.CENTER 52;CENTER  52
_.CENTER -4;CENTER  -4
_.CENTER;CENTER   _#
_.CENTER;CENTER
_.CENTER;    CENTER
_.CENTER +12;CENTER +12
_.CENTER 76;CENTER  76
_.LEFT MARGIN 30;.RIGHT MARGIN 50;.CENTER 0
CENTER   0
The quick red fox jumps over the lazy brown dog
_.LEFT MARGIN 0
1234567890123456789012345678901234567890123456789012345
_.PROGRAM;      END
.skip
.fill
.test page 14
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
      WRITE(1,1)
    1 FORMAT(38H12345678901234567890123456789012345678,
     117H90123456789012345/14X,20HThe  quick  red  fox/
     214X,20Hjumps  over the lazy/14X,9Hbrown dog/19X,
     310HCENTER   0/21X,10HCENTER  52/23X,9HCENTER  -,
     41H4/25X,6HCENTER,4X/27X,6HCENTER/29X,6HCENTER/9X,
     522X,10HCENTER +12/33X,10HCENTER  76/35X,6HCENTER,
     63X,1H0/30X,20HThe  quick  red  fox/30X,7Hjumps  ,
     713Hover the lazy/30X,9Hbrown dog/12H123456789012,
     843H3456789012345678901234567890123456789012345)
      END
.skip
.fill
.test page 20
which would, in turn, generate the following text when run.
.skip
.nofill
1234567890123456789012345678901234567890123456789012345
              The  quick  red  fox
              jumps  over the lazy
              brown dog
                   CENTER   0
                     CENTER  52
                       CENTER  -4
                         CENTER
                           CENTER
                             CENTER
                               CENTER +12
                                 CENTER  76
                                   CENTER   0
                              The  quick  red  fox
                              jumps  over the lazy
                              brown dog
1234567890123456789012345678901234567890123456789012345
.skip 2.left margin 5.test page 6.indent -5
_.COMMENT rest of line is ignored regardless of contents
.SKIP.TEST PAGE 3.FILL
The text which appears to the right of the _.COMMENT command is treated
as a comment and is ignored.  The comment can include exclamation
points, semicolons and other periods.  Two adjacent appearances of
the upper case shift character or of the lower case shift character
are recognized, however, and the requested case shifts are applied
to the source text on the following lines.
.skip.test page 3
The _.COMMENT command can be used at the left end of each line of
explanations or instructions which are to appear in the source text
but which are not be be copied into the resulting FORTRAN output.  If
the instructions are instead to appear in the resulting FORTRAN output,
then these instructions should be incorporated into FORTRAN comment
lines starting with the letter C and must appear below a _.PROGRAM
command.
.skip.test page 3
The _.COMMENT command can be inserted at the left end of other commands
which are to be inactivated but which are to kept in the source text.
A period followed by a exclamation point could also be inserted at
the left end of commands which are to be inactivated, but if a semicolon
appears on the line, then the text to the right of the semicolon would
be treated as normal source text again.
.skip.test page 16
For example, the source text
.skip.nofill
_.output width 55.right margin 54
This sentence is followed by a simple comment.
_.comment continuing across a ; (semicolon) character
THE COMMENT WHICH APPEARS AFTER THIS WORD
_.COMMENT CONTAINING _\_\ (DOUBLE BACKSLASHES)
CONTAINS A DOUBLE BACKSLASH WHICH SELECTS UPPER TO
LOWER CASE CONVERSION IN THE FOLLOWING TEXT.
THE COMMENT WHICH APPEARS AFTER THIS WORD
_.comment.skip.nofill!.skip.nofill;.skip.nofill_^_^
CONTAINS A DOUBLE CIRCUMFLEX WHICH RESTORES THE
RETENTION OF ORIGINAL CASES.
The characters which select case conversion or
retention are acted upon even though the commands
which have been commented out are otherwise ignored.
.skip.fill.test page 15
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill
    1 FORMAT(38H This sentence is followed by a  simpl,
     117He  comment.   THE/24H COMMENT  WHICH  APPEARS,
     231H  AFTER  THIS  WORD  contains a/10H double ba,
     345Hckslash which selects  upper  to  lower  case/
     445H conversion  in  the following text.  the com,
     510Hment which/31H appears after this word CONTAI,
     624HNS A  DOUBLE  CIRCUMFLEX/17H WHICH  RESTORES ,
     738H THE RETENTION OF ORIGINAL CASES.  The/4H cha,
     845Hracters which select case conversion  or  ret,
     96Hention/36H are  acted  upon  even  though the ,
     119Hcommands which have/22H been commented out ar,
     220He otherwise ignored.)
.skip.fill.test page 12
which would, in turn, generate the following text when run.
.skip.nofill
 This sentence is followed by a  simple  comment.   THE
 COMMENT  WHICH  APPEARS  AFTER  THIS  WORD  contains a
 double backslash which selects  upper  to  lower  case
 conversion  in  the following text.  the comment which
 appears after this word CONTAINS A  DOUBLE  CIRCUMFLEX
 WHICH  RESTORES  THE RETENTION OF ORIGINAL CASES.  The
 characters which select case conversion  or  retention
 are  acted  upon  even  though the commands which have
 been commented out are otherwise ignored.
.fill
.fill
.skip 2
.left margin 5
.test page 6
.indent -5
_.CONTINUE next statement number, statement number increment
.skip
.test page 3
The _.CONTINUE command indicates that no additional text is to be
represented by the FORMAT statement currently being constructed and
that the text appearing in subsequent lines in the source file is to
be represented in a new FORMAT statement.  The preface line, if any,
indicated by a previous _.PREFACE command will be written into the
output before this next FORMAT statement.  All unused output field
descriptions previously specified by _.INSERT commands will still be
available.  The new FORMAT statement will include blank lines which
have been requested by _.SKIP or _.BLANK commands, or which are
necessary for multiple line spacing, but which have not yet been
generated.  If the _.CONTINUE command is issued within the range of
a _.PROGRAM command, then the range of the _.PROGRAM command is
terminated.  The _.CONTINUE command is identical to the _.TEXT command,
except that a _.TEXT command would discard all output field
descriptions, and, unless the _.LEADING and _.TRAILING commands are
in effect, would discard all blank lines which have not yet been
generated.
.skip
.test page 3
If a number follows the _.CONTINUE command, then this number is used
to modify the statement number of the next FORMAT statement.  If the
number is not signed, then the number will be used directly as the
statement number of the next FORMAT statement.  If the number is signed,
then the statement number of the next FORMAT statement will differ
from the statement number of the previous FORMAT statement by the
indicated amount.  If no number follows the _.CONTINUE command, or
if a comma follows the _.CONTINUE command but no number appears between
the _.CONTINUE command and this comma, then the statement number of
the next FORMAT statement will differ from that of the previous FORMAT
statement by the current value of the statement number increment.
.skip
.test page 3
Modifications of the statement number are cumulative such that if 2
or more _.TEXT and/or _.CONTINUE and/or _.PROGRAM commands are issued,
then the statement number of the next FORMAT statement will be the
result of the application of each of these commands in turn.  If the
statement number of the FORMAT statement following a section of program
text indicated by an initial _.PROGRAM command is to be modified, but
the program text includes dollar signs which are to be replaced by
this statement number, then this statement number should be modified
by the _.PROGRAM command rather than by the following _.TEXT or
_.CONTINUE command, since, if the modification is done by the _.TEXT
or _.CONTINUE command, then incorrect statement numbers will have been
inserted into the program text.  Statement numbers, if any, inserted
into a preface line defined by a _.PREFACE command will, however, always
be correct since the statement number of the next FORMAT statement
is known when the preface line is generated.
.skip
.test page 3
If the _.CONTINUE command is followed either by 2 numbers or else by
a comma and then by a number, then the right number becomes the
statement number increment after the generation of the next FORMAT
statement.  The increment can be either positive or negative.  If the
number is unsigned, then the increment is assumed to be positive.  If
the _.CONTINUE command is followed by 2 numbers, then these numbers
do not need to be separated by a comma.  If the _.CONTINUE command
is not followed by any numbers, or is followed by a single number which
is not preceded by a comma, then the statement number increment is
not changed.
.skip
.test page 10
For example, the source text
.skip
.nofill
_.preface       WRITE(1,$)
_.continue 10,5   ;This is a message in FORMAT 10
_.program         ;C     FORMAT statement $ follows
_.continue,20     ;This is a message in FORMAT 15
_.continue        ;This is a message in FORMAT 35
_.program 100-10  ;C     FORMAT statement $ follows
_.continue        ;This is a message in FORMAT 100
_.continue        ;This is a message in FORMAT 90
.skip
.test page 15
.fill
would be transformed into the following FORTRAN text when processed
by this program.
.nofill
.skip
      WRITE(1,10)
   10 FORMAT(31H This is a message in FORMAT 10)
C     FORMAT statement 15 follows
      WRITE(1,15)
   15 FORMAT(31H This is a message in FORMAT 15)
      WRITE(1,35)
   35 FORMAT(31H This is a message in FORMAT 35)
C     FORMAT statement 100 follows
      WRITE(1,100)
  100 FORMAT(32H This is a message in FORMAT 100)
      WRITE(1,90)
   90 FORMAT(31H This is a message in FORMAT 90)
.fill
.fill
.skip 2
.fill
.left margin 5
.test page 6
.indent -5
_.COPY number of characters to copy, number of times to copy
.skip
.test page 3
The _.COPY command indicates that, to the immediate right of the initial
offset in each line of text which is copied in no fill mode or which
is constructed in fill mode, the number of characters indicated by
the first number is to be duplicated the number of times indicated
by the second number.  The initial spaces requested either by the
_.OFFSET command or by the default _.OFFSET 1 command cannot be
duplicated and are not included in the character count.  The carriage
control character specified by the _.CARRIAGE command is not duplicated
even if the initial offset is zero.  If the _.MASK command has specified
a template line, then the same replacements of nonquoted spaces are
also made in the copies.  If the line which is being copied contains
dollar signs which are being replaced by output field specifications
specified by the _.INSERT command, then it is the dollar signs which
are counted to determine the width of the region being copied, not
the characters inserted in place of the dollar signs, and the same
insertions are also made in the copies.  If the first number following
the _.COPY command is less than the number of characters to the right
of the initial offset, including the template characters which might
have been defined by the _.MASK command, then all of the characters
to the right of the initial offset will be copied.  If the first number
is greater than the number of characters to the right of the initial
offset then extra spaces at the right will also be copied.  The range
of the _.COPY command can be cancelled by a subsequent _.NO COPY
command.  A _.COPY command issued within the range of a _.PROGRAM
command applies to the source text following the next _.TEXT or
_.CONTINUE command.  Both the _.COPY command and the _.NO COPY command
imply a _.BREAK command.
.skip
.test page 20
For example, the source text
.skip
.nofill
.test page 18
_.insert 5H01234
_.insert 5H56789
_.insert 6H111111
_.insert 6H222222
_.insert 6HPUBLIC
_.insert 6HSECRET
_.preface       WRITE(1,$)
_.offset 2.copy 29,1.output width 55.carriage 1,*
************************
_.left margin 2.right margin 22
_.mask *                      *
_.skip.center 0;Corporation: $$$$$
_.center 0;       Firm: $$$$$
_.skip;To gain initial access to the computer, you will
use the numbers $$$$$$ and $$$$$$ and password $$$$$$.
To run the programs, you will use the  password $$$$$$.
_.skip.left margin 0;************************
_.program;      END
.skip
.fill
.test page 28
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 6
      WRITE(1,1)
    1 FORMAT(38H1 ************************     *******,
     117H*****************/3H* *,22X,7H*     *,22X,1H*/
     218H* *  Corporation: ,5H01234,15H  *     *  Corp,
     39Horation: ,5H01234,3H  */3H* *,9X,6HFirm: ,
     45H56789,9H  *     *,9X,6HFirm: ,5H56789,3H  */
     53H* *,22X,7H*     *,22X,1H*/17H* * To   gain    ,
     638Hinitial *     * To   gain    initial */4H* * ,
     745Haccess     to    the *     * access     to   ,
     86H the */36H* * computer,  you  will *     * com,
     919Hputer,  you  will */22H* * use    the   numbe,
     133Hrs *     * use    the   numbers */4H* * ,
     26H111111,8H  and   ,6H222222,9H *     * ,
     36H111111,8H  and   ,6H222222,2H */11H* * and pas,
     46Hsword ,6HPUBLIC,23H. *     * and password ,
     56HPUBLIC,3H. */30H* * To run the programs, *    ,
     625H * To run the programs, */16H* * you   will  ,
     739Huse  the *     * you   will  use  the */3H* *,
     810H password ,6HSECRET,22H.     *     * password,
     91H ,6HSECRET,7H.     */3H* *,22X,7H*     *,22X,
     11H*)
      WRITE(1,2)
    2 FORMAT(38H* ************************     *******,
     117H*****************)
      END
.skip
.fill
.test page 19
which would, in turn, generate the following text when run.
.skip
.test page 16
.nofill
1 ************************     ************************
* *                      *     *                      *
* *  Corporation: 01234  *     *  Corporation: 01234  *
* *         Firm: 56789  *     *         Firm: 56789  *
* *                      *     *                      *
* * To   gain    initial *     * To   gain    initial *
* * access     to    the *     * access     to    the *
* * computer,  you  will *     * computer,  you  will *
* * use    the   numbers *     * use    the   numbers *
* * 111111  and   222222 *     * 111111  and   222222 *
* * and password PUBLIC. *     * and password PUBLIC. *
* * To run the programs, *     * To run the programs, *
* * you   will  use  the *     * you   will  use  the *
* * password SECRET.     *     * password SECRET.     *
* *                      *     *                      *
* ************************     ************************
.FILL.skip 2.test page 6.left margin 5.indent -5
_.DEFINE GROUP
.skip
The _.DEFINE GROUP command indicates that the following lines of source
text which do not start with periods are to be inserted before each
FORMAT statement which either is the first FORMAT statement ever
generated during this use of this program or which is the first FORMAT
statement generated after a _.TEXT command.  The lines specified by
the _.DEFINE GROUP command are not inserted before a FORMAT statement
which is generated merely because the previous FORMAT statement has
filled or merely because a _.CONTINUE command has been issued to break
the text into another FORMAT statement.  The lines which are to be
inserted before each new group of FORMAT statements will include all
of the lines which do not start with periods in the source text up
to the next _.END DEFINITION, _.PROGRAM, _.TEXT, _.CONTINUE, _.GROUP,
_.PREFACE, _.TOP or _.BOTTOM command or up to any of the various
_.DEFINE commands.  The _.GROUP command can be used instead of the
_.DEFINE GROUP command if just a single line is to be inserted before
each new group of FORMAT statements.  Unlike the _.GROUP command,
however, nothing else can appear to the right of the _.DEFINE GROUP
command on the same line unless it follows a semicolon.
.skip.test page 3
The _.DEFINE GROUP command allows the insertion of several lines of
FORTRAN text before each group of FORMAT statements which are logically
connected.  The rules which govern the construction of the lines which
are specified by the _.DEFINE GROUP command are identical to those
which are described for the _.DEFINE PREFACE command.  If both types
of lines are being inserted before a particular FORMAT statement, then
the lines specified by the _.GROUP or _.DEFINE GROUP command are
inserted before those specified by the _.PREFACE or _.DEFINE PREFACE
command.
.SKIP.TEST PAGE 20
For example, the source text
.skip.nofill
_.OUTPUT WIDTH 55.OUTPUT LENGTH 3.NO JUSTIFY
_.DEFINE GROUP
      GO TO 1000
C     NEW MESSAGE
$$$$$ CONTINUE$=
_.END DEFINITION
_.PREFACE       WRITE(ITTY,$)
The first FORMAT statement which is generated should
be preceded by both group and preface lines even
though this text is not preceded by either a .TEXT
or a .CONTINUE command.
_.CONTINUE
This text appears after a .CONTINUE command.
It should be preceded by preface but not group lines.
_.TEXT 100
This text appears after a .TEXT command and
should be preceded by both group and preface lines.
.skip.test page 24.fill
would, when processed by this program, be transformed into the following
FORTRAN text.
.skip.nofill
      GO TO 1000
C     NEW MESSAGE
    1 CONTINUE
      WRITE(ITTY,2)
    2 FORMAT(38H The first FORMAT statement which is g,
     118Henerated should be/23H preceded by both group,
     235H and preface lines even though this)
      WRITE(ITTY,3)
    3 FORMAT(38H text is not preceded by either a .TEX,
     116HT or a .CONTINUE/9H command.)
      WRITE(ITTY,4)
    4 FORMAT(38H This text appears after a .CONTINUE c,
     121Hommand.  It should be/20H preceded by preface,
     221H but not group lines.)
      GO TO 1000
C     NEW MESSAGE
  100 CONTINUE
      WRITE(ITTY,101)
  101 FORMAT(38H This text appears after a .TEXT comma,
     116Hnd and should be/25H preceded by both group a,
     217Hnd preface lines.)
.skip 2.left margin 5.fill.test page 6.indent -5
_.DEFINE PREFACE
.skip
The _.DEFINE PREFACE command indicates that the following lines of
source text which do not start with periods are to be inserted before
each new FORMAT statement in the resulting FORTRAN output.  These lines
will not appear at the location in the resulting FORTRAN output
corresponding to their location in the source text unless a new FORMAT
statement also happens to begin at that location.  The lines are copied
directly as FORTRAN code, rather than being taken as text which is
to be represented in the FORMAT statements.  The lines which are to
be inserted before each new FORMAT statement will include all of the
lines which do not start with periods in the source text up to the
next _.END DEFINITION, _.PROGRAM, _.TEXT, _.CONTINUE, _.GROUP,
_.PREFACE, _.TOP or _.BOTTOM command or up to any of the various
_.DEFINE commands.  The _.PREFACE command can be used instead of the
_.DEFINE PREFACE command if just a single line is to be inserted before
each new FORMAT statement.  Unlike the _.PREFACE command, however,
nothing else can appear to the right of the _.DEFINE PREFACE command
on the same line unless it follows a semicolon.
.skip.test page 3
If an _.END DEFINITION command appears after the lines which are to
be inserted, then the lines following the _.END DEFINITION command
will be processed in the same manner as before the _.DEFINE PREFACE
command was issued.  If a _.PROGRAM command was issued more recently
than either a _.TEXT command or a _.CONTINUE command, then the lines
of source text will be copied into the output directly rather than
being represented in a FORMAT statement.  If a _.PROGRAM command has
not been issued more recently, then the following source text will
be represented in the FORMAT statements.
.skip.test page 3
The insertion of the preface lines before each new FORMAT statement
can be terminated either by issuing a _.NO PREFACE command or by
specifying a null preface by issuing either a _.PREFACE command with
nothing to its right or a _.DEFINE PREFACE command followed immediately
by a _.END DEFINITION command.  These methods of cancelling the preface
line are not identical.  If a _.NO PREFACE command is used to cancel
the insertion of the preface lines, then a _.RESUME PREFACE command
can be issued later to resume the insertion of the same preface lines
before the subsequent new FORMAT statements.  If a _.PREFACE command
is issued without anything to its right or a _.DEFINE PREFACE command
is followed immediately by a _.END DEFINITION command, however, then
the _.RESUME PREFACE command cannot be used to resume the insertion
of the previous preface lines.  Neither the _.PREFACE command, nor
the _.DEFINE PREFACE command, nor the _.NO PREFACE command nor the
_.RESUME PREFACE command implies a _.BREAK command.
.skip.test page 3
The Lines of text which are specified by the _.DEFINE PREFACE command
are stored in the same area as are those which are specified by the
_.GROUP or _.DEFINE GROUP, _.TOP or _.DEFINE TOP and _.BOTTOM or
_.DEFINE BOTTOM commands.  There can be at most 30 lines containing
together no more than 500 characters in all of these collections of
lines.  These lines include those which have been temporarily disabled
by the _.NO GROUP, _.NO PREFACE, _.NO TOP or _.NO BOTTOM commands.
.skip.test page 3
Any dollar signs which are not preceded by underscores in the lines
which are to be inserted will be replaced each time by the statement
number of the FORMAT statement before which the lines are inserted.
The manner in which these dollar signs are handled is described in
detail in the description of the _.PREFACE command.  The description
of the _.PREFACE command should be consulted for additional information
about when and how the lines of text are inserted.
.skip.test page 17
For example, the source text
.skip.nofill
_.output width 55.output length 5
_.define preface
C
C     THIS IS A NEW FORMAT STATEMENT
      WRITE(ITTY,$)
_.end definition
This is some text which will demonstrate the insertion
of several lines of FORTRAN code before each new FORMAT
statement.  The code which is inserted can contain any
desired mixture of comments and FORTRAN instructions.
_.text
This comes after a .TEXT command
_.continue
and this comes after a .CONTINUE command.
.skip.test page 25.fill
would, when processed by this program, be transformed into the following
FORTRAN text.
.skip.nofill
C
C     THIS IS A NEW FORMAT STATEMENT
      WRITE(ITTY,1)
    1 FORMAT(38H This is some text which will demonstr,
     123Hate  the  insertion  of/18H several  lines  o,
     243Hf  FORTRAN  code  before  each  new  FORMAT/
     345H statement.  The code  which  is  inserted  c,
     416Han  contain  any)
C
C     THIS IS A NEW FORMAT STATEMENT
      WRITE(ITTY,2)
    2 FORMAT(38H desired mixture of comments and FORTR,
     116HAN instructions.)
C
C     THIS IS A NEW FORMAT STATEMENT
      WRITE(ITTY,3)
    3 FORMAT(33H This comes after a .TEXT command)
C
C     THIS IS A NEW FORMAT STATEMENT
      WRITE(ITTY,4)
    4 FORMAT(38H and this comes after a .CONTINUE comm,
     14Hand.)
.fill
.skip 2
.test page 6
.fill
.left margin 5
.indent -5
_.EJECT
.skip
.test page 3
The _.EJECT command indicates that no additional text is to be included
in the line of text currently being represented in the FORMAT statement.
The line of text is assumed to be shorter than normal, and so is not
right justified by the insertion of extra spaces between the groups
of printing characters (words) on the line.  The _.EJECT command is
similar to the _.BREAK command with the exception that all blank lines
requested by _.BLANK commands or _.SKIP commands or implied by _.SPACING
commands will be generated immediately when the _.EJECT command is
issued even if no printing characters have been accumulated into the
current line of text.  The _.EJECT command can be issued before a
_.CARRIAGE command to prevent the newly specified carriage control
character from being inserted into the start of the lines which have
been specified but not yet forced into the FORMAT statement.
.skip
.test page 10
For example, the source text
.skip
.nofill
.test page 8
one
_.skip 2
_.carriage *,*
two
_.skip 2
_.eject
_.carriage @,@
three
.skip
.fill
.test page 4
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
    1 FORMAT(4H one/1H*/1H*/4H*two/1H*/1H*/6H@three)
.fill
.fill.skip 2.left margin 5.test page 6.indent -5
_.END DEFINITION
.skip
The _.END DEFINITION command terminates the specification of lines
of FORTRAN text which was started by the previous _.DEFINE GROUP,
_.DEFINE PREFACE, _.DEFINE TOP or _.DEFINE BOTTOM command.  These lines
of FORTRAN text are to be inserted subsequently before or after the
FORMAT statements to allow use of these FORMAT statements by the program
in which these FORMAT statements will be embedded.  The lines of FORTRAN
text specified by the various _.DEFINE commands are stored in a common
area.  There can be at most 30 lines containing together no more than
500 characters in all of these collections.
.skip.test page 3
After the _.END DEFINITION command has been issued, the following lines
of source text will be processed in the same manner as before the
_.DEFINE command was issued.  If a _.PROGRAM command was issued more
recently than either a _.TEXT command or a _.CONTINUE command, then
the lines of source text will be copied into the output directly rather
than being represented in a FORMAT statement.  If a _.PROGRAM command
has not been issued more recently, then the following source text will
be represented in the FORMAT statements.
.skip.test page 3
A particular collection of lines will be copied into the resulting
FORTRAN output whenever the required conditions are encountered.  The
_.DEFINE GROUP command specifies lines of FORTRAN text which are to
be inserted before the first FORMAT statement produced by this program
and before the first FORMAT statement produced after a _.TEXT command
is issued.  The _.DEFINE PREFACE command specifies lines of FORTRAN
text which are to be inserted before each new FORMAT statement,
regardless of the reason for the break between the previous FORMAT
statement and the current FORMAT statement.  The _.DEFINE TOP and
_.DEFINE BOTTOM commands specify lines of FORTRAN text which are to
be inserted before and after the FORMAT statements for each page of
text which will be displayed on a video terminal and are described
in a later section of this manual.
.skip.test page 3
The specification of additional lines of FORTRAN text by any of the
various _.DEFINE commands can also be terminated by a subsequent
_.PROGRAM, _.TEXT, _.CONTINUE, _.GROUP, _.PREFACE, _.TOP or _.BOTTOM
command, or by any other of the various _.DEFINE commands.
.skip.test page 19
For example, the source text
.skip.nofill
_.output width 55
_.define group
C     THIS IS INSERTED BEFORE EACH NEW GROUP OF FORMATS
      WRITE(ITTY,100)
_.define preface
C     THIS IS INSERTED BEFORE EACH NEW FORMAT STATEMENT
      WRITE(ITTY,$)
_.end definition
This text will be in the first format statement.
_.continue
This comes after the first CONTINUE command.
_.program
C     THIS IS INSERTED BY A PROGRAM COMMAND
_.continue
This comes after the second CONTINUE command.
_.text
This comes after a TEXT command.
.skip.fill.test page 23
would, when processed by this program, be transformed into the following
FORTRAN text.
.skip.nofill
C     THIS IS INSERTED BEFORE EACH NEW GROUP OF FORMATS
      WRITE(ITTY,100)
C     THIS IS INSERTED BEFORE EACH NEW FORMAT STATEMENT
      WRITE(ITTY,1)
    1 FORMAT(38H This text will be in the first format,
     111H statement.)
C     THIS IS INSERTED BEFORE EACH NEW FORMAT STATEMENT
      WRITE(ITTY,2)
    2 FORMAT(38H This comes after the first CONTINUE c,
     17Hommand.)
C     THIS IS INSERTED BY A PROGRAM COMMAND
C     THIS IS INSERTED BEFORE EACH NEW FORMAT STATEMENT
      WRITE(ITTY,3)
    3 FORMAT(38H This comes after the second CONTINUE ,
     18Hcommand.)
C     THIS IS INSERTED BEFORE EACH NEW GROUP OF FORMATS
      WRITE(ITTY,100)
C     THIS IS INSERTED BEFORE EACH NEW FORMAT STATEMENT
      WRITE(ITTY,4)
    4 FORMAT(33H This comes after a TEXT command.)
.fill
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.END OF FILE
.skip
.test page 3
The _.END OF FILE command indicates that the processing of the source
text is complete.  Any additional commands or additional text appearing
on the same line to the right of the _.END OF FILE command are ignored.
No additional source text is read.  Blank lines which have not yet
been generated, but which have been requested by _.SKIP or _.BLANK
commands or which are necessary for multiple line spacing, will be
appended to the FORMAT statement currently being constructed if a
_.TRAIL command is in effect.  Blank lines will be discarded if a _.NO
TRAIL command is in effect or if a _.TRAIL command has not been issued.
An _.END OF FILE command is necessary at the end of the source file
only if the system where this program is being used does not support
end of file tests in FORTRAN READ statements.
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.FILL
.skip
.test page 3
The _.FILL command indicates that each line of text represented in
the FORMAT statements is to be filled with the next words which appear
in the source text until the following word would extend beyond the
current right margin.  If the first word is wider than the current
separation between the left and right margins, then the entire word
is fitted onto the current line.  A _.FILL command terminates the range
of the previous _.NO FILL command which would have caused each line
of text represented in the resulting FORMAT statements to contain the
same number of words per line and the same number of spaces preceding
and between words as in the source text.  A _.FILL command is assumed
to be in effect when this program is started.  A _.FILL command issued
within the range of a _.PROGRAM command applies to the source text
following the next _.TEXT or _.CONTINUE command.  The _.FILL command
implies a _.BREAK command.
.skip
.test page 3
Within the range of the _.FILL command, a space separates adjacent
words which appear on the same line of text represented in the FORMAT
statements, regardless of whether these words appeared on separate
lines of the source text or appeared on the same line separated by
additional spaces.  A second space follows each colon, semicolon,
exclamation point, question mark and period which is not preceded by
an underscore character but which is followed by another word.  If
a _.NO JUSTIFY command has not been issued, or if a _.JUSTIFY command
has been issued more recently than a _.NO JUSTIFY command, then
additional spaces are inserted between the words to cause the line
of text to extend to the current right margin, providing that a _.BREAK
command does not follow and is not implied to follow the rightmost
word on the line.
.skip
.test page 18
For example, the source text
.skip
.nofill
_.FILL.OFFSET 0.RIGHT MARGIN 55.OUTPUT WIDTH 55
_.PREFACE       WRITE(1,$)
     The                    FILL                command
        indicates           that                each
           line             of               text
              represented   in             the
                 FORMAT     statements   is
                    to      be    filled
_.NO JUSTIFY;           with the  next
                    words   which appear
                 in         the      source
              text          until          the
           following        word            would
_.NOFILL;extend              beyond               the
     current                right               margin.
_.PROGRAM;      END
.skip
.fill
.test page 12
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
      WRITE(1,1)
    1 FORMAT(38HThe FILL command  indicates  that  eac,
     117Hh  line  of  text/24Hrepresented in the FORMA,
     228HT statements is to be filled/13Hwith the next,
     338H words which appear in the source text/4Hunti,
     426Hl the following word would/6Hextend,14X,3Hbey,
     53Hond,15X,3Hthe/5X,7Hcurrent,16X,5Hright,15X,1Hm,
     66Hargin.)
      END
.skip
.fill
.test page 9
which would, in turn, generate the following text when run.
.skip
.nofill
The FILL command  indicates  that  each  line  of  text
represented in the FORMAT statements is to be filled
with the next words which appear in the source text
until the following word would
extend              beyond               the
     current                right               margin.
.fill
.skip
.test page 3
In the above example, the first line in the text which is generated
when the FORTRAN text is run is justified since a _.BREAK command is
not implied following the rightmost word on the line.  The second line
is not justified since a _.BREAK command is implied by the _.NO JUSTIFY
command which follows the rightmost word on the line.  The third and
fourth lines are within the range of the _.NO JUSTIFY command and so
are not justified.  The fifth and sixth lines are within the range
of the _.NOFILL command and so are direct copies of the corresponding
lines in the source text.
.skip 2
.test page 8
.fill
.left margin 5
.indent -5
_.FLAGS
.break
or
.indent -5
_.FLAGS ALL
.skip
.test page 3
The _.FLAGS ALL command indicates that all flag characters which were
initially active, or which have been individually activated by the
corresponding _.FLAGS commands, and which have not been individually
disabled by the corresponding _.NO FLAGS commands, are to be active
in the source text.  The following flag characters are activated by
the _.FLAGS ALL command.
.skip
.left margin 10
.indent -3
$##(dollar sign) or whatever character has been most recently selected
by a _.FLAGS INSERT command.
.indent -3
_\##(back slash) or whatever character has been most recently selected
by a _.FLAGS LOWER CASE command.
.indent -3
__##(underscore) or whatever character has been most recently selected
by a _.FLAGS QUOTE command.
.indent -3
_###(number sign) or whatever character has been most recently selected
by a _.FLAGS SPACE command.
.indent -3
_^##(circumflex) or whatever character has been most recently selected
by a _.FLAGS UPPER CASE command.
.indent -3
<##(less than sign) if a _.FLAGS CAPITALIZE command has been issued,
or whatever character has been most recently selected by a _.FLAGS
CAPITALIZE command.  This flag character will remain inactive if a
_.FLAGS CAPITALIZE command has not been issued.
.left margin 5
.skip
.test page 3
All of these flag characters can be temporarily disabled by the issuing
of a _.NO FLAGS or a _.NO FLAGS ALL command.  The _.FLAGS ALL command
and the _.NO FLAGS ALL command do not change the interpretation of
the flag characters which identify and terminate commands.  The flag
characters which are to be interpreted and acted upon in a preface
line specified by the _.PREFACE command or in a field specification
defined by the _.INSERT command must be those which are active when
the preface line or the field specification is defined, regardless
of what flag characters happen to be active when the preface line or
the field specification is used.  Neither the _.FLAGS ALL command nor
the _.NO FLAGS ALL command implies a _.BREAK command.
.skip
.test page 18
For example, the source text
.skip
.test page 16
.nofill
_.OUTPUT WIDTH 55.RIGHT MARGIN 55.OFFSET 0.NOFILL
_.UPPERCASE.INSERT 3_^_^H_\_\THE
_.CONTINUE.PREFACE       _\_\WRITE(1,$)
_\_\_^THE QUICK_#__RED <FOX JUMPS OVER $$$ LAZY __BROWN <DOG.
_.PROGRAM
_\_\_^THE QUICK_#__RED <FOX JUMPS OVER $$$ LAZY __BROWN <DOG.
_.NO FLAGS
_.CONTINUE.FLAGS CAPITALIZE.UPPER CASE.INSERT 3_^_^H_\_\THE
_\_\_^THE QUICK_#__RED <FOX JUMPS OVER $$$ LAZY __BROWN <DOG.
_.PROGRAM.PREFACE       _\_\WRITE(1,$)
_\_\_^THE QUICK_#__RED <FOX JUMPS OVER $$$ LAZY __BROWN <DOG.
_.FLAGS
_.UPPER CASE_.CONTINUE
_\_\_^THE QUICK_#__RED <FOX JUMPS OVER $$$ LAZY __BROWN <DOG.
_.PROGRAM
_\_\_^THE QUICK_#__RED <FOX JUMPS OVER $$$ LAZY __BROWN <DOG.
.skip
.fill
.test page 15
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.test page 12
.nofill
      write(1,1)
    1 FORMAT(30HThe quick Red <fox jumps over ,3Hthe,
     117H lazy Brown <dog.)
The quick Red <fox jumps over   2 lazy Brown <dog.
      write(1,2)
    2 FORMAT(38H_\_\_^THE QUICK_#__RED <FOX JUMPS OVER $$$ ,
     117HLAZY __BROWN <DOG.)
_\_\_^THE QUICK_#__RED <FOX JUMPS OVER $$$ LAZY __BROWN <DOG.
      _\_\WRITE(1,$)
    3 FORMAT(29HThe quick Red FOX jumps over ,
     13_^_^H_\_\THE,16H lazy Brown DOG.)
The quick Red FOX jumps over   4 lazy Brown DOG.
.fill
.skip
.test page 3
It should be noted that the final preface line and the final field
specification were defined in the above example while the flag
characters were inactive so these flag characters are treated as nonflag
characters even though the preface line and the field specification
are applied later when the flag characters are again active.
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.FLAGS CAPITALIZE character to precede capitalized words
.skip
.test page 3
The _.FLAGS CAPITALIZE command indicates that the single character
appearing as its argument can be used in the following source text
at the start of words in which the alphabetic letters are to be
converted to upper case.  The case mode which is in effect when the
specified capitalization flag character is found in the following source
text, regardless of whether this case mode is the default retention
of cases which can also be specified by double circumflexes or by the
_.UPPER CASE command, or is the translation of upper case into lower
case which is specified by double back slashes or by the _.LOWER CASE
command, will be restored following the next space, the next end of
line or the next appearance of the specified capitalization flag
character.  The _.FLAGS CAPITALIZE command does not imply a _.BREAK
command.
.skip
.test page 3
The capitalization flag character specified by the _.FLAGS CAPITALIZE
command should not currently be active as some other flag indication,
and should not be one of the alphabetic letters A through Z.  The
capitalization flag character is recognized in all of the following
source text, including the text being represented in the FORMAT
statements, the text within the range of _.PROGRAM commands, and within
commands and their arguments.  Within the range of the _.FLAGS
CAPITALIZE command, underscores must precede all appearances of the
capitalization flag character which are to be treated like other
characters.  If no capitalization flag character is specified by the
_.FLAGS CAPITALIZE command, then the last character so specified by
a previous _.FLAGS CAPITALIZE command will be used, or the less than
sign will be used if no character has previously been specified by
any _.FLAGS CAPITALIZE command.
.skip
.test page 3
No capitalization flag character is active when this program is started.
The capitalization flag character specified by the _.FLAGS CAPITALIZE
command can temporarily be treated as a nonflag character if a _.NO
FLAGS CAPITALIZE command is issued, but will again become active when
a _.FLAGS CAPITALIZE command is issued.  The capitalization flag
character, like all other flag characters in the source text, can also
temporarily be treated as a nonflag character if a _.NO FLAGS or _.NO
FLAGS ALL command is issued, but will again become active when a _.FLAGS
or _.FLAGS ALL command is issued, providing that a _.FLAGS CAPITALIZE
command has been issued more recently than a _.NO FLAGS CAPITALIZE
command.  Words which are marked by the capitalization flag character
in a preface line defined by the _.PREFACE command or in a field
specification defined by the _.INSERT command are converted to upper
case when the preface line or the field specification is defined,
regardless of what the capitalization flag character happens to be
when the preface line or the field specification is used.
.skip
.test page 23
For example, the source text
.skip
.nofill
_.nofill.offset 0.out width 55.preface       WRITE(1,$)
_.flag capitalize
_^_^UPPER lower <Le_^S_^s_\T_\han<UPPERlower UPPER lower
UPPER lower <Le_^S_^s_\T_\han UPPER lower
UPPER lower <Le_^S_^s_\T_\han
UPPER lower
_.fcap %
_\_\UPPER lower %Le_^S_^s_\T_\han%UPPER*lower UPPER lower
UPPER lower %Le_^S_^s_\T_\han UPPER lower
UPPER lower %Le_^S_^s_\T_\han
UPPER lower
_.no flag
_^_^UPPER lower %Le_^S_^s_\T_\han%UPPERlower UPPER lower
_\_\UPPER lower %Le_^S_^s_\T_\han%UPPER*lower UPPER lower
_.flag
_^_^UPPER lower %Le_^S_^s_\T_\han%UPPERlower UPPER lower
_\_\UPPER lower %Le_^S_^s_\T_\han%UPPER*lower UPPER lower
_.no flag capitalize
_^_^UPPER lower %Le_^S_^s_\T_\han%UPPERlower UPPER lower
_\_\UPPER lower %Le_^S_^s_\T_\han%UPPER*lower UPPER lower
_.program;      END
.skip
.fill
.test page 17
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
      WRITE(1,1)
    1 FORMAT(38HUPPER lower LESSthANUPPERlower UPPER l,
     14Hower/32HUPPER lower LESSthAN UPPER lower/3HUPP,
     217HER lower LESSthAN/11HUPPER lower/9Hupper low,
     334Her LESSthANupper*lower upper lower/8Hupper lo,
     424Hwer LESSthAN upper lower/17Hupper lower LESSt,
     53HhAN/11Hupper lower/24H_^_^upper lower %le_^s_^s_\t_\,
     626Hhan%upperlower upper lower/15H_\_\upper lower %,
     736Hle_^s_^s_\t_\han%upper*lower upper lower/6HUPPER ,
     836Hlower LESSthANUPPERlower UPPER lower/6Hupper ,
     937Hlower LESSthANupper*lower upper lower/5HUPPER,
     139H lower %LeSSthan%UPPERlower UPPER lower/3Hupp,
     242Her lower %leSSthan%upper*lower upper lower)
      end
.skip
.fill
.test page 17
which would, in turn, generate the following text when run.
.skip
.nofill
UPPER lower LESSthANUPPERlower UPPER lower
UPPER lower LESSthAN UPPER lower
UPPER lower LESSthAN
UPPER lower
upper lower LESSthANupper*lower upper lower
upper lower LESSthAN upper lower
upper lower LESSthAN
upper lower
_^_^upper lower %le_^s_^s_\t_\han%upperlower upper lower
_\_\upper lower %le_^s_^s_\t_\han%upper*lower upper lower
UPPER lower LESSthANUPPERlower UPPER lower
upper lower LESSthANupper*lower upper lower
UPPER lower %LeSSthan%UPPERlower UPPER lower
upper lower %leSSthan%upper*lower upper lower
.fill
.skip 2
.fill
.test page 6
.left margin 5
.indent -5
_.FLAGS CONTROL character to precede commands
.skip
.test page 3
The _.FLAGS CONTROL command indicates that the single character
appearing as its argument can be used in the following source text
at the start of lines which are to be interpreted as commands rather
than as text which is to be represented in the FORMAT statements.  If
no character is specified by the _.FLAGS CONTROL command, then the
last character so specified by a previous _.FLAGS CONTROL command will
be used, or the period will be used if no character has previously
been specified by any _.FLAGS CONTROL command.  The _.FLAGS CONTROL
command does not imply a _.BREAK command.
.skip
.test page 3
The control flag character specified by the _.FLAGS CONTROL command
should not currently be active as some other flag indication, and should
not be one of the alphabetic letters A through Z.  If the _.FLAGS
CONTROL command is followed on the same line by another command, then
these commands should be separated by a semicolon rather than by the
appearance of either the original control flag character or of the
new control flag character, since the new control flag character is
not active until after the _.FLAGS CONTROL command is interpreted,
and the original control flag character will not be active when the
next command is interpreted.
.skip
.test page 3
If the control flag character appears at the start of a line which
is not a command line or if the control flag character appears within
a command line but does not indicate the start of another command,
then the control flag character must be preceded by an underscore.
The control flag character specified by the _.FLAGS CONTROL command
can also be treated as a nonflag character if a _.NO FLAGS COMMAND
is issued.  Of course, if the _.NO FLAGS CONTROL command is issued,
then no further commands can appear in the source text.
.skip
.test page 5
For example, the source text
.skip
.nofill
.test page 3
_.flag control *.this is the first line
*output width 55;and this is the second line.
*flag control =;=preface       WRITE(1,$)
.skip
.fill
.test page 6
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
.test page 3
      WRITE(1,1)
    1 FORMAT(38H .this is the first line and this is t,
     115Hhe second line.)
.fill
.skip 2
.fill
.test page 6
.left margin 5
.indent -5
_.FLAGS FENCE character to terminate and separate commands
.skip
.test page 3
The _.FLAGS FENCE command indicates that the single character appearing
as its argument can be used in command lines in the following source
text to terminate any command except those which take the rest of the
line of text as their arguments.  The text which follows the use of
the separation flag character can be any text which could appear on
the next line if nothing else appeared to the right of the command.
The separation flag character is required between two commands on the
same line only if the first command is followed by an exclamation point
and then by a comment.  If no character is specified by the _.FLAGS
FENCE command, then the last character so specified by a previous
_.FLAGS FENCE command will be used, or the semicolon will be used if
no character has previously been specified by any _.FLAGS FENCE command.
The _.FLAGS FENCE command does not imply a _.BREAK command.
.skip
.test page 3
The separation flag character specified by the _.FLAGS FENCE command
should not currently be active as some other flag indication, and should
not be one of the alphabetic letters A through Z.  If the _.FLAGS FENCE
command is followed on the same line by another command, then either
the _.FLAGS FENCE command should not itself be terminated by a
separation flag character or else the _.FLAGS FENCE command should
be terminated by the original separation flag character rather than
by the appearance of the new separation flag character since the new
separation flag character is not active until after the _.FLAGS FENCE
command is interpreted.
.skip
.test page 3
If the separation flag character appears in a comment in a command
line but is not to terminate the comment, or appears as a character
argument of a command, then the separation flag character must be
preceded by an underscore.  The separation flag character can
temporarily be treated as a nonflag character if a _.NO FLAGS FENCE
command is issued, but will again become active when a _.FLAGS FENCE
command is issued.
.skip
.test page 4
For example, the source text
.skip
.nofill
.test page 2
_.flag fence @!a comment;.indent 5@This text is to be
_.output width 55@represented in the FORMAT statement.
.skip
.fill
.test page 5
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.test page 2
.nofill
    1 FORMAT(6X,35HThis text is to be represented in t,
     120Hhe FORMAT statement.)
.skip 2
.fill
.test page 6
.left margin 5
.indent -5
_.FLAGS INSERT character to indicate location of insertions
.skip
.test page 3
The _.FLAGS INSERT command indicates that the single character appearing
as its argument can be used in the source text on the lines following
a _.PROGRAM command and in the text to the right of a _.PREFACE command
to indicate locations at which the statement number of the next FORMAT
statement is to be inserted.  If more contiguous appearances of the
insertion flag character are found than there are digits in the
statement number, then additional spaces are inserted to the left of
the statement number so that the total number of characters which are
inserted equals the number of insertion flag characters in the group.
The character specified by the _.FLAGS INSERT command can also be used
within the source text which is being represented in the resulting
FORMAT statements to indicate locations at which the output field
descriptions specified by the _.INSERT command are to be inserted.
The number of contiguous appearances of the insertion flag character
in the text being represented in the FORMAT statements indicates the
number of characters which will be generated when a FORTRAN variable
is written out using the field specification.  The number of contiguous
appearances of the insertion flag character is the number of character
positions which must be reserved for the appearance of this variable
when the words in the source text are wrapped around and justified
by this program.  The _.FLAGS INSERT command does not imply a _.BREAK
command.
.skip
.test page 3
The insertion flag character specified by the _.FLAGS INSERT command
should not currently be active as some other flag indication, and should
not be one of the alphabetic letters A through Z.  Within the range
of the _.FLAGS INSERT command, underscores must precede all appearances
of the insertion flag character which are to be treated like any other
character.  If no insertion flag character is specified by the _.FLAGS
INSERT command, then the last character so specified by a previous
_.FLAGS INSERT command will be used, or the dollar sign will be used
if no character has previously been specified by any _.FLAGS INSERT
command.
.skip
.test page 3
The insertion flag character specified by the _.FLAGS INSERT command
can temporarily be treated as a nonflag character if a _.NO FLAGS INSERT
command is issued, but will again become active when a _.FLAGS INSERT
command is issued.  The insertion flag character, like all other flag
characters in the source text, can also temporarily be treated as a
nonflag character if a _.NO FLAGS or _.NO FLAGS ALL command is issued,
but will again become active when a _.FLAGS or _.FLAGS ALL command
is issued, providing that a _.NO FLAGS INSERT command has not been
issued more recently than a _.FLAGS INSERT command.  The character
which is to be replaced by the statement number in a preface line
defined by the _.PREFACE command is the insertion flag character which
is active when the preface line is defined, regardless of what the
insertion flag character happens to be when the preface line is used.
.skip
.test page 14
For example, the source text
.skip
.nofill
.test page 12
_.flags insert @.output width 55.program 100,10
_.insert 1I8
_.insert 1A8
_.preface       WRITE(1$2,@)
_^_^C     NEXT FORMAT STATEMENT IS @.
_.continue;_\_\_^MAXIMUM AMOUNT OF LOAN IS $@@@@@@@@.
_.flags insert $.program
_^_^C     NEXT FORMAT STATEMENT IS $.
_.continue;_\_\_^MAXIMUM AMOUNT OF LOAN IS __$$$$$$$$$.
_.no flags.program
_^_^C     NEXT FORMAT STATEMENT IS $.
_.continue;_\_\_^MAXIMUM AMOUNT OF LOAN IS __$$$$$$$$$.
.skip
.fill
.test page 13
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
.test page 10
C     NEXT FORMAT STATEMENT IS 100.
      WRITE(1$2,100)
  100 FORMAT(28H Maximum amount of loan is $,1I8,1H.)
C     NEXT FORMAT STATEMENT IS 110.
      WRITE(1$2,110)
  110 FORMAT(28H Maximum amount of loan is $,1A8,1H.)
_^_^c     next format statement is $.
      WRITE(1$2,120)
  120 FORMAT(38H _\_\_^maximum amount of loan is __$$$$$$$,
     13H$$.)
.skip 2
.fill
.test page 6
.left margin 5
.indent -5
_.FLAGS LOWER CASE character to precede lower case letters
.skip
.test page 3
The _.FLAGS LOWER CASE command indicates that the single character
appearing as its argument can be used in the source text before any
alphabetic letter in the range A through Z which is to be converted
to its lower case form.  Two adjacent lower case shift characters
indicate that all subsequent alphabetic letters are to be converted
to lower case, except for the next letter immediately following either
an underscore or a circumflex and except for all letters in the word
immediately following a less than sign if within the range of a _.FLAGS
CAPITALIZE command.  The range of the lower case shift lock indicated
either by the 2 adjacent lower case shift characters or by the
equivalent _.LOWER CASE command can be terminated either by 2 adjacent
circumflexes or by the equivalent _.UPPER CASE command.  The _.FLAGS
LOWER CASE command does not imply a _.BREAK command.
.skip
.test page 3
The lower case shift character specified by the _.FLAGS LOWER CASE
command should not currently be active as some other flag indication,
and should not be one of the alphabetic letters A through Z.  Within
the range of the _.FLAGS LOWER CASE command, underscores must precede
all appearances of the lower case shift character which are to be
treated like any other character.  If no lower case shift character
is specified by the _.FLAGS LOWER CASE command, then the last character
so specified by a previous _.FLAGS LOWER CASE command will be used,
or the back slash will be used if no character has previously been
specified by any _.FLAGS LOWER CASE command.
.skip
.test page 3
The lower case shift character specified by the _.FLAGS LOWER CASE
command can temporarily be treated as a nonflag character if a _.NO
FLAGS LOWER CASE command is issued, but will again become active when
a _.FLAGS LOWER CASE command is issued.  The lower case shift character,
like all other flag characters in the source text, can also temporarily
be treated as a nonflag character if a _.NO FLAGS or _.NO FLAGS ALL
command is issued, but will again become active when a _.FLAGS or
_.FLAGS ALL command is issued, providing that a _.NO FLAGS LOWER CASE
command has not been issued more recently than a _.FLAGS LOWER CASE
command.  Letters which are preceded by the lower case shift character
or which are within the range of a lower case shift lock in a preface
line defined by the _.PREFACE command or in a field specification
defined by the _.INSERT command are converted to lower case when the
preface line or the field specification is defined, regardless of what
the case shift characters happen to be when the preface line or the
field specification is used.
.skip
.test page 8
For example, the source text
.skip
.nofill
.test page 6
_.flag capitalize.nofill.output width 55
_\_\_\T_\H_\I_\S _\l_\i_\n_\e WILL be _^_^_\A_\L_\L _\l_\o_\w_\e_\r case
_^_^_^t_^h_^i_^s _^L_^I_^N_^E WILL <be _\_\_^A_^L_^L _^u_^p_^p_^e_^r <CASE
_.flag lower case -.flag upper case +.flag capitalize @
---T-H-I-S -l-i-n-e WILL be ++-A-L-L -l-o-w-e-r case
+++t+h+i+s +L+I+N+E WILL @be --+A+L+L +u+p+p+e+r @CASE
.skip
.fill
.test page 7
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
.test page 4
    1 FORMAT(33H this line will be all lower case/2H T,
     131HHIS LINE WILL BE ALL UPPER CASE/10H this line,
     223H will be all lower case/18H THIS LINE WILL BE,
     315H ALL UPPER CASE)
.skip 2
.fill
.test page 6
.left margin 5
.indent -5
_.FLAGS QUOTE character to precede character to be used as is
.skip
.test page 3
The _.FLAGS QUOTE command indicates that the single character appearing
as its argument can be used in the source text before any character
which is to be treated as an ordinary nonalphabetic nonflag printing
character.  The _.FLAGS QUOTE command does not imply a _.BREAK command.
.skip
.test page 3
The quotation flag character specified by the _.FLAGS QUOTE command
should not currently be active as some other flag indication, and should
not be one of the alphabetic letters A through Z.  Within the range
of the _.FLAGS QUOTE command, the quotation flag character must precede
all appearances of the quotation flag character which are to be treated
like any other character.  If no quotation flag character is specified
by the _.FLAGS QUOTE command, then the last character so specified
by a previous _.FLAGS QUOTE command will be used, or the underscore
will be used if no character has previously been specified by any
_.FLAGS QUOTE command.
.skip
.test page 3
The quotation flag character specified by the _.FLAGS QUOTE command
can temporarily be treated as a nonflag character if a _.NO FLAGS QUOTE
command is issued, but will again become active when a _.FLAGS QUOTE
command is issued.  The quotation flag character, like all other flag
characters in the source text, can also temporarily be treated as a
nonflag character if a _.NO FLAGS or _.NO FLAGS ALL command is issued,
but will again become active when a _.FLAGS or _.FLAGS ALL command
is issued, providing that a _.NO FLAGS QUOTE command has not been issued
more recently than a _.FLAGS QUOTE command.  If characters within the
definition of a preface line by the _.PREFACE command or of a field
specification by the _.INSERT command are to be treated as nonflag
printing characters in spite of their usual interpretations, then these
characters should be preceded by the quotation flag character which
is active when the preface line or the field specification is defined,
regardless of what quotation flag character happens to be active when
the preface line or the field specification is used.
.skip
.test page 14
For example, the source text
.skip
.nofill
.test page12
_.flags quote *.left margin 3.output width 55
Some typical flag characters are
_.indent -3
*_#_#_#the number sign
_.indent -3
*_^_#_#the circumflex
_.indent -3
*_\_#_#the back slash
_.indent -3
*$_#_#the dollar sign
_.indent -3
___#_#the underscore
.skip
.fill
.test page 7
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
.test page 4
    1 FORMAT(4X,32HSome typical flag characters are/
     119H _#  the number sign/18H _^  the circumflex/1H ,
     217H_\  the back slash/19H $  the dollar sign/2H __,
     316H  the underscore)
.skip 2
.fill
.test page 6
.left margin 5
.indent -5
_.FLAGS REMARK character to separate commands from comments
.skip
.test page 3
The _.FLAGS REMARK command indicates that the single character appearing
as its argument can be used in command lines in the following source
text to indicate that the following text through the end of the line
or through the next appearance of a semicolon on the same line is to
be treated as a comment and is to be ignored.  Less than signs in the
comment do not apply after the end of the comment, but all case shift
locks indicated in the comment by double back slashes or by double
circumflexes are applied to the text following the comment.  The remark
flag character is inactive following those commands which take the
rest of the line of text as their arguments.  If no character is
specified by the _.FLAGS REMARK command, then the last character so
specified by a previous _.FLAGS REMARK command will be used, or the
exclamation point will be used if no character has previously been
specified by any _.FLAGS REMARK command.  The _.FLAGS REMARK command
does not imply a _.BREAK command.
.skip
.test page 3
The remark flag character specified by the _.FLAGS REMARK command should
not currently be active as some other flag indication, and should not
be one of the alphabetic letters A through Z.  If the _.FLAGS REMARK
command is followed on the same line by a comment, then the comment
should be indicated by the original remark flag character since the
new remark flag character will not be active until the _.FLAGS REMARK
command is interpreted.
.skip
.test page 3
If the remark flag character appears within a command line but is not
to indicate the start of a comment, then the remark flag character
must be preceded by an underscore.  The remark flag character specified
by the _.FLAGS REMARK command can also be treated as a nonflag character
if a _.NO FLAGS REMARK command is issued, but will again become active
when a _.FLAGS REMARK command is issued.
.skip
.test page 11
For example, the source text
.skip
.nofill
.test page 9
_.!.indent 5!command which has been commented out
_.flags capitalize!comment separating commands;.offset 0
_.preface one<two!three four
FIRST LINE
_.continue! 2_\_\back slashes;.preface five<six;seven eight
_.!capitalization stops at end of <comment;SECOND LINE
_.flag remark @!at sign inactive;.text@ 2_^_^circumflexes
_.preface nine<ten.eleven twelve
THIRD LINE
.skip
.fill
.test page 9
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
.test page 6
oneTWO!THREE four
    1 FORMAT(10HFIRST LINE)
fiveSIX;SEVEN eight
    2 FORMAT(11Hsecond line)
nineTEN.ELEVEN twelve
    3 FORMAT(10HTHIRD LINE)
.fill
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.FLAGS SPACE character to indicate a nonadjustable space
.skip
.test page 3
The _.FLAGS SPACE command indicates that the single character appearing
as its argument can be used in the following source text to indicate
the location of a space which is to be treated as though it were a
printing character.  The use of the space holding character is
completely equivalent to the use of a space preceded by an underscore.
The _.FLAGS SPACE command does not imply a _.BREAK command.
.skip
.test page 3
The space holding character specified by the _.FLAGS SPACE command
should not currently be active as some other flag indication, and should
not be one of the alphabetic letters A through Z.  The space holding
character is recognized in all of the following source text, including
the text being represented in the FORMAT statements, the text within
the range of _.PROGRAM commands, and within the arguments of commands.
Within the range of the _.FLAGS SPACE command, underscores must precede
all appearances of the space holding character which are to be left
unchanged rather than be converted to spaces.  If no space holding
character is specified by the _.FLAGS SPACE command, then the last
character so specified by a previous _.FLAGS SPACE command will be
used, or the number sign will be used if no character has previously
been specified by any _.FLAGS SPACE command.
.skip
.test page 3
The space holding character specified by the _.FLAGS SPACE command
can temporarily be treated as a nonflag character if a _.NO FLAGS SPACE
command is issued, but will again become active when a _.FLAGS SPACE
command is issued.  The space holding character, like all other flag
characters in the source text, can also temporarily be treated as a
nonflag character if a _.NO FLAGS or _.NO FLAGS ALL command is issued,
but will again become active when a _.FLAGS or _.FLAGS ALL command
is issued, providing that a _.NO FLAGS SPACE command has not been issued
more recently than a _.FLAGS SPACE command.  Nonadjustable spaces in
a preface line defined by the _.PREFACE command or in a field
specification defined by the _.INSERT command should be indicated by
the space holding character in effect when the preface line or the
field specification is defined, regardless of what the space holding
character happens to be when the preface line or the field specification
is used.
.skip
.test page 9
For example, the source text
.skip
.nofill
.test page 7
_.output width 55
_.insert 10Hthe   ___#_#_#_#
_.insert 10Hthe   *_#_#_#
_.preface _#_#_#_#_#_#write(1___#2,$)
This   demonstrates   $space_#_#_#holding   character.
_.flags space *.break
This   demonstrates   $space***holding   character.
.skip
.fill
.test page 7
would, when processed by this program, be transformed into the following
FORTRAN text.
.skip
.nofill
.test page 4
      write(1_#2,1)
    1 FORMAT(19H This demonstrates ,10Hthe   _#   ,2Hsp,
     124Hace   holding character./17H This demonstrate,
     22Hs ,10Hthe   *   ,26Hspace   holding character.)
.skip 2
.fill
.test page 6
.left margin 5
.indent -5
_.FLAGS UPPER CASE character to precede upper case letters
.skip
.test page 3
The _.FLAGS UPPER CASE command indicates that the single character
appearing as its argument can be used in the source text before any
alphabetic letter in the range A through Z which is to be converted
to its upper case form.  Two adjacent upper case shift characters
indicate that the cases of all subsequent alphabetic letters are to
be left unchanged, except for the next letter immediately following
either a back slash or a single circumflex and except for all letters
in the word immediately following a less than sign if within the range
of a _.FLAGS CAPITALIZE command.  The range of the retained case shift
lock indicated either by the 2 adjacent upper case shift characters
or by the equivalent _.UPPER CASE command can be terminated either
by 2 adjacent back slashes or by the equivalent _.LOWER CASE command.
The _.FLAGS UPPER CASE command does not imply a _.BREAK command.
.skip
.test page 3
The upper case shift character specified by the _.FLAGS UPPER CASE
command should not currently be active as some other flag indication,
and should not be one of the alphabetic letters A through Z.  Within
the range of the _.FLAGS UPPER CASE command, underscores must precede
all appearances of the upper case shift character which are to be
treated like any other character.  If no upper case shift character
is specified by the _.FLAGS UPPER CASE command, then the last character
so specified by a previous _.FLAGS UPPER CASE command will be used,
or the circumflex will be used if no character has previously been
specified by any _.FLAGS UPPER CASE command.
.skip
.test page 3
The upper case shift character specified by the _.FLAGS UPPER CASE
command can temporarily be treated as a nonflag character if a _.NO
FLAGS UPPER CASE command is issued, but will again become active when
a _.FLAGS UPPER CASE command is issued.  The upper case shift character,
like all other flag characters in the source text, can also temporarily
be treated as a nonflag character if a _.NO FLAGS or _.NO FLAGS ALL
command is issued, but will again become active when a _.FLAGS or
_.FLAGS ALL command is issued, providing that a _.NO FLAGS UPPER CASE
command has not been issued more recently than a _.FLAGS UPPER CASE
command.  Letters which are preceded by the upper case shift character
in a preface line defined by the _.PREFACE command or in a field
specification defined by the _.INSERT command are converted to upper
case when the preface line or the field specification is defined,
regardless of what the case shift characters happen to be when the
preface line or the field specification is used.
.skip
.test page 12
For example, the source text
.skip
.nofill
.test page 10
_.flag capitalize.nofill.output width 55
_.upper case
_^this _\F_\O_\L_\L_\O_\W_\S _\a_\n .UPPER <case command.
_.lower case
_^THIS _\F_\O_\L_\L_\O_\W_\S a ._^L_^O_^W_^E_^R <case command.
_^_^_^this _\F_\O_\L_\L_\O_\W_\S _\t_\w_\o CIRCUM<flex characters.
_\_\_^THIS _\F_\O_\L_\L_\O_\W_\S two _^B_^A_^C_^K <slash characters.
_.flag lower case -.flag upper case+.flag capitalize @
+++this -F-O-L-L-O-W-S -t-w-o PLUS @sign characters.
--+THIS -F-O-L-L-O-W-S two +M+I+N+U+S @sign characters.
.skip
.fill
.test page 9
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
.test page 6
    1 FORMAT(37H This follows an .UPPER CASE command./
     136H This follows a .LOWER CASE command./6H This ,
     234Hfollows two CIRCUMFLEX characters./8H This fo,
     332Hllows two BACK SLASH characters./9H This fol,
     430Hlows two PLUS SIGN characters./11H This follo,
     529Hws two MINUS SIGN characters.)
.FILL.skip.test page 6.left margin 5.indent -5
_.GROUP line of text to precede groups of FORMAT statements
.skip
The characters which appear to the right of the _.GROUP command on
the same line are to be copied into the output file on a separate line
before each FORMAT statement which either is the first FORMAT statement
ever generated during this use of this program or which is the first
FORMAT statement generated after a _.TEXT command.  The character to
the immediate right of the _.GROUP command must be a space.  The line
of text which is to be copied into the output file before each new
group of FORMAT statements starts with the second character to the
right of the _.GROUP command, whether or not this is a printing
character, and extends through the rightmost printing character on
the line.  The line specified by the _.GROUP command is not inserted
before a FORMAT statement which is generated merely because the previous
FORMAT statement has filled or merely because a _.CONTINUE command
has been issued to break the text into another FORMAT statement.
.skip.test page 3
If more than a single line must be inserted before each new group of
FORMAT statements, then a _.DEFINE GROUP command followed by the lines
of text and then by an _.END DEFINITION command should be used to
specify the lines instead.  Regardless of which method is used to
specify the line or lines, the insertions of the line or lines are
performed similarly.

.skip.test page 3
The _.GROUP command allows the insertion of a line of FORTRAN text
before each group of FORMAT statements which are logically connected.
For example, this line might cause a transfer back to the calling
program after the completion of the use of the previous group of FORMAT
statements.  The rules which govern the construction of the line which
is specified by the _.GROUP command are identical to those which are
described for the _.PREFACE command.  If both types of lines are being
inserted before a particular FORMAT statement, then the lines defined
by the _.GROUP or _.DEFINE GROUP command are inserted before those
specified by the _.PREFACE or _.DEFINE PREFACE command.
.SKIP.TEST PAGE 12
For example, the source text
.skip.nofill
_.output width 55.output length 2
_.group       GO TO 1000
_.preface $$$$$ WRITE(ITTY,$=$)
This is the first text in the example.
It should be preceded by both a group
and a preface line.
_.continue
This text follows a .CONTINUE command.
_.text 100
This text follows a .TEXT command.
.skip.test page 16.fill
would, when processed by this program, be transformed into the following
FORTRAN text.
.skip.nofill
      GO TO 1000
    1 WRITE(ITTY,2)
    2 FORMAT(38H This is the  first  text  in  the  ex,
     123Hample.   It  should  be)
    3 WRITE(ITTY,4)
    4 FORMAT(38H preceded by both a group and a prefac,
     17He line.)
    5 WRITE(ITTY,6)
    6 FORMAT(38H This text follows a .CONTINUE command,
     11H.)
      GO TO 1000
  100 WRITE(ITTY,101)
  101 FORMAT(35H This text follows a .TEXT command.)
.fill
.fill
.skip 2
.left margin 5
.test page 6
.fill
.indent -5
_.INDENT number of extra spaces to insert beyond left margin
.skip
.test page 3
The _.INDENT command indicates that the left end of the next line of
text which is represented in the FORMAT statement is to be indented
the indicated number of spaces from the left margin which is in effect
when the first word in the line is found.  The number which follows
the _.INDENT command can be either positive indicating the insertion
of extra initial spaces, or negative indicating the deletion of spaces
from the left margin.  If the number is missing, then a positive
indentation of 5 spaces is assumed.  The indentation is applied
regardless of whether the next line is copied in no fill mode or is
constructed in fill mode.  If the _.INDENT command was preceded by
a _.CENTER command, then the _.CENTER command is ignored.  The _.INDENT
command implies a _.BREAK command before the following line of source
text.
.skip
.test page 14
For example, the source text
.skip
.nofill
.test page 12
_.offset 0.left margin 0.right margin 55.output width 55
_.indent 5.preface       WRITE(1,$)
The flag characters which are listed below are
deactivated by the .NO FLAGS command.
_.left margin 5
_.indent -3
__$_#_#(dollar sign) or whatever character has been
selected by a .FLAGS INSERT command.
_.indent -3
___#_#_#(number sign) or whatever character has been
selected by a .FLAGS SPACE command.
_.PROGRAM;      END
.skip
.fill
.test page 12
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 9
      WRITE(1,1)
    1 FORMAT(5X,35HThe flag characters which  are  lis,
     115Hted  below  are/26Hdeactivated by the .NO FLA,
     211HGS command./30H  $  (dollar  sign)  or  whate,
     325Hver  character  has  been/5X,13Hselected by a,
     423H .FLAGS INSERT command./18H  _#  (number  sign,
     537H)  or  whatever  character  has  been/5X,2Hse,
     633Hlected by a .FLAGS SPACE command.)
      END
.skip
.fill
.test page 9
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 6
     The flag characters which  are  listed  below  are
deactivated by the .NO FLAGS command.
  $  (dollar  sign)  or  whatever  character  has  been
     selected by a .FLAGS INSERT command.
  _#  (number  sign)  or  whatever  character  has  been
     selected by a .FLAGS SPACE command.
.skip 2
.test page 6
.fill
.left margin 5
.indent -5
_.INPUT WIDTH maximum number of characters in any input line
.skip
.test page 3
The _.INPUT WIDTH command specifies the maximum number of characters
which are to be read from in each line in the input file.  If an input
line contains more than the specified number of characters, then the
characters which appear to the right of the specified number of
characters are ignored.  The input line width specified by the _.INPUT
WIDTH command applies to all following lines, but not to the line in
which it is specified.  The _.INPUT WIDTH command does not imply a
_.BREAK command.
.skip
.test page 3
If the number which follows the _.INPUT WIDTH command is unsigned,
then this number will be used as the line width for the following input
lines.  If the number which follows the _.INPUT WIDTH command is signed,
then the previous input line width is adjusted by the indicated amount.
The input line width is 132 when this program is started.  The input
line width cannot exceed 300 characters.
.skip
.test page 6
For example, the source text
.skip
.nofill
.test page 4
_.input width 5.text 10
12345This is not read
_.iw+5This is not read
1234567890This is not read
.skip
.fill
.test page 4
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
   10 FORMAT(17H 12345 1234567890)
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.INSERT output field specification to replace next $ signs
.skip
.test page 3
The _.INSERT command specifies the group of characters which is to
replace the next group of contiguous dollar signs which are not preceded
by underscores in the text being represented in the FORMAT statements.
The character to the immediate right of the _.INSERT command must be
a space.  The group of characters which is to be inserted starts with
the second character to the right of the _.INSERT command, whether
or not this is a printing character, and extends through the rightmost
printing character on the line.  If an _.INSERT command has not been
issued, or if no printing character appears to the right of the _.INSERT
command, then the next group of contiguous dollar signs is removed,
but the group of characters to be inserted is of zero length so no
characters are inserted in place of the group of dollar signs.  If
2 or more _.INSERT commands have specified groups of characters which
have not yet been used to replace groups of contiguous dollar signs,
then these groups of characters are applied in the order in which they
were defined.  Unless the lengths of 3 arrays in this program are
increased, no more than 50 groups of characters having an aggregate
length of no more than 500 characters can have been specified but remain
unused at any time.  All unused groups of characters are discarded
if either a _.NO INSERT command or a _.TEXT command is encountered.
Neither the _.INSERT command nor the _.NO INSERT command implies a
_.BREAK command.
.skip
.test page 3
The text on either side of the group of contiguous dollar signs being
replaced is represented in H or apostrophe notation, whichever has
been selected by the _.USE command.  The characters which are being
inserted will be interpreted as an output field specification when
the FORMAT statements are used.  If in fill mode, the number of dollar
signs in the group being replaced is used in determining the length
of the line being accumulated, so the number of dollar signs in the
group being replaced should equal the number of characters which will
be generated by the output field specification when the FORMAT
statements are used.  For example, 9 dollar signs would be used to
mark the location in the text at which a 9 character date representation
such as 12-Jan-80 is to be generated using a 1I2,1H-,1A3,1H-,1I2 output
field specification.  Commas are inserted on either side of the original
location of the group of dollar signs so the _.INSERT command should
not specify commas at the start and at the end of the text being
inserted.  The text being inserted can be split onto the next
continuation line of the FORMAT statement following any comma in the
text being inserted.
.skip
.test page 3
Within the text being inserted, an underscore character, which will
not be copied into the FORMAT statement, can appear before any
character, such as a comma, space, number sign, circumflex, back slash,
less than sign (if in flag capitalize mode) or another underscore,
which is to be treated as a nonflag character.  If a comma in the text
being inserted is not at a location at which the text being inserted
can be split onto the next continuation line of the FORMAT statement,
then the comma should be preceded by an underscore.  If the text being
inserted is to end with a space, then this space should be preceded
by an underscore.  The _.INSERT command cannot be followed on the same
line either by a comment or by another command, so semicolons and
exclamation points in the text to be inserted do not need to be preceded
by underscores.
.skip
.test page 12
For example, the source text
.skip
.nofill
_.program 10
      DATA KOUNT,IDAY,IYEAR/12345,12,80/
      DATA IMONTH/3HJan/
      WRITE(1,$)KOUNT,IDAY,IMONTH,IYEAR
_.insert 1I5
_.insert 1I2,1H-,1A3,1H-,1I2
_.continue.output width 55
$$$$$ items were produced on $$$$$$$$$.
_.program
      END
.skip
.fill
.test page 17
would, when processed by this program, be transformed into the following
proof file
.skip
.nofill
_.program 10
      DATA KOUNT,IDAY,IYEAR/12345,12,80/
      DATA IMONTH/3HJan/
      WRITE(1,10)KOUNT,IDAY,IMONTH,IYEAR
_.insert 1I5
_.insert 1I2,1H-,1A3,1H-,1I2
_.continue
_.output width 55
   10 FORMAT(
1I5
1I2,1H-,1A3,1H-,1I2
 $$$$$ items were produced on $$$$$$$$$.
_.program
      END
.skip
.fill
.test page 9
and would also be transformed into the following FORTRAN text
.skip
.nofill
      DATA KOUNT,IDAY,IYEAR/12345,12,80/
      DATA IMONTH/3HJan/
      WRITE(1,10)KOUNT,IDAY,IMONTH,IYEAR
   10 FORMAT(1H ,1I5,24H items were produced on ,1I2,
     11H-,1A3,1H-,1I2,1H.)
      END
.skip
.fill
.test page 4
which would, in turn, generate the following text when run.
.skip
.nofill
 12345 items were produced on 12-Jan-80.
.fill
.skip 2
.left margin 5
.test page 6
.fill
.indent -5
_.JUSTIFY
.skip
.test page 3
The _.JUSTIFY command indicates that the lines of text which are
constructed in fill mode are to be extended to the right margin by
the addition of extra spaces between the words.  The extra spaces are
added between the words starting at the right end in the first, third
and every other line following a _.BREAK command or following any
command which implies a _.BREAK command, and are added starting at
the left in the alternate lines.  Extra spaces are, however, never
inserted in the final line before a _.BREAK command or before any
command which implies a _.BREAK command.  The _.JUSTIFY command implies
a _.BREAK command
.skip
.test page 3
A _.JUSTIFY command is assumed to be in effect when this program is
started.  A _.NO JUSTIFY command should be issued instead if lines
which are constructed in fill mode are not required to have exactly
the same lengths, but the lines are still to be filled with the most
words which do not extend beyond the right margin.  If a _.NO JUSTIFY
command is in effect, then words are separated by single spaces and
sentences by two spaces.  A _.JUSTIFY or a _.NO JUSTIFY command issued
within the range of a _.PROGRAM command applies to the lines of text
constructed in fill mode following the next _.TEXT or _.CONTINUE
command.  A _.JUSTIFY or a _.NO JUSTIFY command issued within the range
of a _.NO FILL command applies to the lines of text constructed
following the next _.FILL command.
.skip
.test page 19
For example, the source text
.skip
.nofill
.test page 17
_.output width 55.right margin 55.offset 0
_.no justify.preface       WRITE(1,$)
The .JUSTIFY and the .NO JUSTIFY commands do not
apply to text which is within the range of .NO FILL
commands  and does not apply to the text which is
within the range of the .PROGRAM command.
_.justify.skip
The .JUSTIFY and the .NO JUSTIFY commands do not
apply to text which is within the range of .NO FILL
commands  and does not apply to the text which is
within the range of the .PROGRAM command.
_.nofill.skip
The .JUSTIFY and the .NO JUSTIFY commands do not
apply to text which is within the range of .NO FILL
commands  and does not apply to the text which is
within the range of the .PROGRAM command.
_.program;      END
.skip
.fill
.test page 19
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 16
      WRITE(1,1)
    1 FORMAT(38HThe .JUSTIFY and the .NO JUSTIFY comma,
     116Hnds do not apply/25Hto text which is within t,
     229Hhe range of .NO FILL commands/12Hand does not,
     338H apply to the text which is within the/4Hrang,
     426He of the .PROGRAM command.//14HThe .JUSTIFY a,
     541Hnd the .NO JUSTIFY commands do not  apply/1Ht,
     645Ho  text which is within the range of .NO FILL,
     79H commands/33Hand does not apply to the  text  ,
     822Hwhich  is  within  the/19Hrange of the .PROGR,
     911HAM command.//29HThe .JUSTIFY and the .NO JUST,
     119HIFY commands do not/22Happly to text which is,
     229H within the range of .NO FILL/12Hcommands  an,
     337Hd does not apply to the text which is/5Hwithi,
     436Hn the range of the .PROGRAM command.)
      END
.skip
.fill
.test page 17
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 14
The .JUSTIFY and the .NO JUSTIFY commands do not apply
to text which is within the range of .NO FILL commands
and does not apply to the text which is within the
range of the .PROGRAM command.
.skip
.test page 3
The .JUSTIFY and the .NO JUSTIFY commands do not  apply
to  text which is within the range of .NO FILL commands
and does not apply to the  text  which  is  within  the
range of the .PROGRAM command.
.skip
.test page 3
The .JUSTIFY and the .NO JUSTIFY commands do not
apply to text which is within the range of .NO FILL
commands  and does not apply to the text which is
within the range of the .PROGRAM command.
.skip 2
.test page 6
.left margin 5
.fill
.indent -5
_.LEADING
.skip
.test page 3
The _.LEADING command indicates that blank lines which are requested
prior to the specification of any text which is to appear in the FORMAT
statements, either when this program is first started or following
a _.TEXT command, are to be represented in the next FORMAT statement
if an _.EJECT command is issued or if some text which is to be
represented in the FORMAT statement is actually specified.  Such leading
blank lines can be requested by a _.BLANK or a _.SKIP command.  Leading
blank lines are discarded if a _.NO LEADING command is in effect or
if a _.LEADING command has not been issued.  Neither the _.LEADING
command nor the _.NO LEADING command implies a _.BREAK command.
.skip
.test page 14
For example, the source text
.skip
.nofill
.test page 12
_.spacing 2.output width 55.skip
The quick red fox jumps over the lazy brown dog, then
runs into the forest
_.text.leading.skip
The quick red fox jumps over the lazy brown dog, then
runs into the forest
_.text.trailing.skip
The quick red fox jumps over the lazy brown dog, then
runs into the forest
_.text.no leading.skip
The quick red fox jumps over the lazy brown dog, then
runs into the forest
.skip
.fill
.test page 13
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
.test page 10
    1 FORMAT(38H The quick red fox jumps over the lazy,
     123H brown dog,  then  runs//16H into the forest)
    2 FORMAT(//36H The quick red fox jumps over the la,
     125Hzy brown dog,  then  runs//15H into the fores,
     21Ht)
    3 FORMAT(//36H The quick red fox jumps over the la,
     125Hzy brown dog,  then  runs//15H into the fores,
     21Ht/)
    4 FORMAT(38H The quick red fox jumps over the lazy,
     123H brown dog,  then  runs//16H into the forest/)
.skip 2
.fill
.left margin 5
.test page 6
.indent -5
_.LEFT MARGIN number of spaces to left of text
.skip
.test page 3
The _.LEFT MARGIN command specifies the number of spaces which are
to be inserted to the left of each of the lines of text which are being
represented in the FORMAT statements in either fill or no fill modes.
The left margin specified by the _.LEFT MARGIN command is in addition
to the leftmost spaces specified by the _.OFFSET command or in addition
to the single left space which is obtained if neither the _.OFFSET
command nor the _.NO OFFSET command has been issued.  An _.INDENT or
_.PARAGRAPH command can be issued prior to a particular paragraph to
temporarily change the left margin for the leading line in that
paragraph.  If the number which follows the _.LEFT MARGIN command is
unsigned, then this number will be used as the left margin.  If the
number which follows the _.LEFT MARGIN command is signed, then the
previous left margin is adjusted by the indicated amount.  If no number
follows the _.LEFT MARGIN command then the left margin is reset to
zero.  The _.LEFT MARGIN command implies a _.BREAK command.
.skip
.test page 3
If the lines of text are being constructed in fill mode, then the left
margin specified by the _.LEFT MARGIN command should be to the left
of the right margin specified by the _.RIGHT MARGIN command or to the
left of column 60 if a _.RIGHT MARGIN command has not been issued.
The right margin is ignored if the lines of text are being copied in
no fill mode.  The only spaces which are inserted are those which are
specified by the _.OFFSET command if a signed number following the
_.LEFT MARGIN command causes the left margin to be negative.
.skip
.test page 18
For example, the source text
.skip
.nofill
.test page 16
_.preface       WRITE(1,$)
_.output width 55;Default left margin and default offset
_.left margin 10 ;Left margin 10 obtained as .lm 10
_.left margin -5 ;Left margin 5 obtained as .lm-5
_.left margin -5 ;Left margin 0 obtained as .lm-5
_.left margin -5 ;Left margin -5 which is treated as 0
_.left margin +5 ;Left margin 0 obtained as .lm+5
_.left margin +5 ;Left margin 5 obtained as .lm+5
_.offset 6       ;Unchanged left margin and offset 6
_.left margin 10 ;Left margin 10 obtained as .lm 10
_.left margin -5 ;Left margin 5 obtained as .lm-5
_.left margin -5 ;Left margin 0 obtained as .lm-5
_.left margin -5 ;Left margin -5 which is treated as 0
_.left margin +5 ;Left margin 0 obtained as .lm+5
_.left margin +5 ;Left margin 5 obtained as .lm+5
_.program ;      END
.skip
.fill
.test page 18
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 15
      WRITE(1,1)
    1 FORMAT(38H Default left margin and default offse,
     11Ht/11X,33HLeft margin 10 obtained as .lm 10/6X,
     231HLeft margin 5 obtained as .lm-5/10H Left marg,
     322Hin 0 obtained as .lm-5/19H Left margin -5 whi,
     418Hch is treated as 0/23H Left margin 0 obtained,
     59H as .lm+5/6X,30HLeft margin 5 obtained as .lm+,
     61H5/11X,34HUnchanged left margin and offset 6/9X,
     77X,33HLeft margin 10 obtained as .lm 10/11X,2HLe,
     829Hft margin 5 obtained as .lm-5/6X,9HLeft marg,
     922Hin 0 obtained as .lm-5/6X,16HLeft margin -5 w,
     120Hhich is treated as 0/6X,18HLeft margin 0 obta,
     213Hined as .lm+5/11X,24HLeft margin 5 obtained a,
     37Hs .lm+5)
      END
.skip
.fill
.test page 17
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 14
 Default left margin and default offset
           Left margin 10 obtained as .lm 10
      Left margin 5 obtained as .lm-5
 Left margin 0 obtained as .lm-5
 Left margin -5 which is treated as 0
 Left margin 0 obtained as .lm+5
      Left margin 5 obtained as .lm+5
           Unchanged left margin and offset 6
                Left margin 10 obtained as .lm 10
           Left margin 5 obtained as .lm-5
      Left margin 0 obtained as .lm-5
      Left margin -5 which is treated as 0
      Left margin 0 obtained as .lm+5
           Left margin 5 obtained as .lm+5
.fill
.skip 2
.fill
.left margin 5
.test page 6
.indent -5
_.LOWER CASE
.skip
.test page 3
The _.LOWER CASE command indicates that all upper case alphabetic
letters which are not specially marked are to be converted to their
lower case forms in the source text which follows the end of the command
or, if the _.LOWER CASE command is followed by a comment, in the source
text which follows the comment.  The lower case conversion selected
by the _.LOWER CASE command is not applied to any letter which is
immediately preceded by an underscore indicating that its case is to
be retained, is not applied to any letter which is immediately preceded
by a circumflex indicating that it is to be converted to upper case,
and is not applied to letters which are both within the range of a
_.FLAGS CAPITALIZE command and within a word which is preceded by a
less than sign indicating that these letters are to be converted to
upper case.  The _.LOWER CASE command is equivalent to the appearance
of 2 consecutive back slashes except that the 2 back slashes can appear
anywhere and that the lower case conversion indicated by the 2 back
slashes is applied immediately to all of the following text.  The cases
of alphabetic letters are retained unless the _.LOWER CASE command
has been issued or unless 2 consecutive back slashes have been found.
The retention of cases can also be reselected either by the _.UPPER
CASE command or by the appearance of 2 consecutive circumflexes.
Neither the _.LOWER CASE command nor the _.UPPER CASE command implies
a _.BREAK command.
.skip
.test page 13
For example, the source text
.skip
.nofill
.test page 11
_.nofill.output width 55.preface       WRITE(1,$)
_.noflags.flags capitalize;noflags
  UPPER lower U_^P_\P__ER l_^o_\w__er
  U<PPER l<ower U<PPE<R l<owe<r <U_^P_\P__ER <l_^o_\w__er
_.lower case.flags;lower case
  UPPER lower U_^P_\P__ER l_^o_\w__er
  U<PPER l<ower U<PPE<R l<owe<r <U_^P_\P__ER <l_^o_\w__er
_.upper case;upper case
  UPPER lower U_^P_\P__ER l_^o_\w__er
  U<PPER l<ower U<PPE<R l<owe<r <U_^P_\P__ER <l_^o_\w__er
_.program;      END
.skip
.fill
.test page 12
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 9
      WRITE(1,1)
    1 FORMAT(8H noflags/3X,24HUPPER lower U_^P_\P__ER l_^o,
     15H_\w__er/3X,34HU<PPER l<ower U<PPE<R l<owe<r <U_^P,
     215H_\P__ER <l_^o_\w__er/11H lower case/3X,9Hupper low,
     314Her uPpEr lOwer/3X,24HuPPER lOWER uPPEr lOWEr ,
     411HUPpER LOweR/11H upper case/3X,12HUPPER lower ,
     511HUPpER lOwer/3X,27HUPPER lOWER UPPER lOWEr UPp,
     68HER LOweR)
      END
.skip
.fill
.test page 12
which would, in turn, generate the following text when run.
.skip
.test page 9
.nofill
 noflags
   UPPER lower U_^P_\P__ER l_^o_\w__er
   U<PPER l<ower U<PPE<R l<owe<r <U_^P_\P__ER <l_^o_\w__er
 lower case
   upper lower uPpEr lOwer
   uPPER lOWER uPPEr lOWEr UPpER LOweR
 upper case
   UPPER lower UPpER lOwer
   UPPER lOWER UPPER lOWEr UPpER LOweR
.skip 2
.test page 6
.fill
.left margin 5
.indent -5
_.MASK text to be superimposed onto each output line
.skip
.test page 3
The printing characters which follow the _.MASK command on the same
line replace the nonquoted spaces to the right of the initial offset
in each line of text which is copied in no fill mode or which is
constructed in fill mode.  All printing characters, all spaces which
were preceded by underscores or which were represented by number signs,
and all initial spaces requested by an _.OFFSET command or by the
default _.OFFSET 1, are left unchanged in each line of text which is
represented in the FORMAT statements.  The character to the immediate
right of the _.MASK command must be a space.  The group of characters
which is to be superimposed onto each output line starts with the second
character to the right of the _.MASK command, whether or not this is
a printing character, and extends through the rightmost printing
character on the line.  No characters are superimposed onto the output
lines if the _.MASK command is issued without any following characters,
or if no _.MASK command has yet been issued, or if a _.NO MASK command
has been issued more recently than a _.MASK command.  A _.MASK command
issued within the range of a _.PROGRAM command applies to the source
text following the next _.TEXT or _.CONTINUE command.  Neither the
_.MASK command nor the _.NO MASK command implies a _.BREAK command.
A _.BREAK or _.EJECT command should be issued before the _.MASK or
_.NO MASK command unless it is really desired to change the template
line which is to be applied to the line which is currently being
accumulated in fill mode or to the blank lines which have not yet been
written out to the FORMAT statements.
.skip
.test page 3
Within the text specified by the _.MASK command, an underscore
character, which will not be copied into the FORMAT statement, can
appear before any character, such as a number sign, circumflex, back
slash, less than sign (if in flag capitalize mode) or another
underscore, which is to be treated as a nonflag character.  The _.MASK
command cannot be followed on the same line either by a comment or
by another command, so semicolons and exclamation points in the text
to be superimposed do not need to be preceded by underscores.
.skip
.test page 13
For example, the source text
.skip
.test page 11
.nofill
_.left margin 2.right margin 13.preface       WRITE(1,$)
_.carriage 1.offset 5.copy 17,2.mask *             *
_.indent -1.output width 55;=============
_.insert 3Hhow
_.insert 5H.MASK
_.insert 3Hand
_.insert 5H.COPY
_.skip;This shows $$$ $$$$$ $$$ $$$$$ commands work.
_.skip.indent -1;=============
_.break.no mask.no copy.skip;Not in range of either.
_.program;      END
.skip
.fill
.test page 18
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 15
      WRITE(1,1)
    1 FORMAT(38H1    *=============*  *=============* ,
     116H *=============*/5X,1H*,13X,4H*  *,13X,4H*  *,
     213X,1H*/5X,34H* This  shows *  * This  shows *  ,
     315H* This  shows */5X,2H* ,3Hhow,3X,5H.MASK,2H *,
     44H  * ,3Hhow,3X,5H.MASK,6H *  * ,3Hhow,3X,
     55H.MASK,2H */5X,2H* ,3Hand,3X,5H.COPY,6H *  * ,
     63Hand,3X,5H.COPY,6H *  * ,3Hand,3X,5H.COPY,2H */
     75X,42H* commands    *  * commands    *  * comman,
     87Hds    */5X,7H* work.,7X,10H*  * work.,7X,3H*  ,
     97H* work.,7X,1H*/5X,1H*,13X,4H*  *,13X,4H*  *,9X,
     14X,1H*/5X,35H*=============*  *=============*  *,
     214H=============*//7X,3HNot,6X,2Hin/7X,7Hrange  ,
     34H  of/7X,7Heither.)
      END
.skip
.fill
.test page 16
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 13
1    *=============*  *=============*  *=============*
     *             *  *             *  *             *
     * This  shows *  * This  shows *  * This  shows *
     * how   .MASK *  * how   .MASK *  * how   .MASK *
     * and   .COPY *  * and   .COPY *  * and   .COPY *
     * commands    *  * commands    *  * commands    *
     * work.       *  * work.       *  * work.       *
     *             *  *             *  *             *
     *=============*  *=============*  *=============*
.skip
       Not      in
       range    of
       either.
.skip 2
.fill
.left margin 5
.test page 6
.indent -5
_.NO CARRIAGE
.skip
.test page 3
The first character in each line of text which is generated when the
resulting FORMAT statements are used can be interpreted by the FORTRAN
operating system to select the carriage motion on the output device
to which the text is written.  The _.NO CARRIAGE command indicates
that the leftmost character in the line of text which is currently
being constructed for representation in the FORMAT statements, and
in each of the subsequent lines of text, will be a space if a positive
offset has been selected by the combination of _.OFFSET, _.LEFT MARGIN
and _.INDENT or _.PARAGRAPH commands, and completely blank lines will
be represented in the FORMAT statements by consecutive slashes.  The
_.NO CARRIAGE command terminates the insertion of the carriage control
character, if any, selected by the previous _.CARRIAGE command.  No
carriage control character is in effect when this program is first
started.  Neither the _.NO CARRIAGE command nor the _.CARRIAGE command
implies a _.BREAK command.  A _.BREAK command, or some other command
which implies a _.BREAK command, should usually be issued before the
_.NO CARRIAGE command since, if the lines of text are being constructed
in fill mode, the carriage control character is applied to the current
line of text only after this line of text has otherwise been completed.
.skip
.test page 12
For example, the source text
.skip
.nofill
.test page 10
_.carriage 1,*.right margin 54.output width 55
_.preface       WRITE(1,$)
The .NO CARRIAGE command terminates the generation of
the carriage control character specified by the
previous .CARRIAGE command.
_.break.no carriage
The .NO CARRIAGE command terminates the generation of
the carriage control character specified by the
previous .CARRIAGE command.
_.program;      END
.skip
.fill
.test page 12
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 9
      WRITE(1,1)
    1 FORMAT(38H1The .NO CARRIAGE command terminates t,
     117Hhe generation  of/24H*the   carriage  control,
     231H  character  specified  by  the/10H*previous ,
     318H.CARRIAGE command./23H The .NO CARRIAGE comma,
     432Hnd terminates the generation  of/9H the   ca,
     545Hrriage  control  character  specified  by  th,
     61He/28H previous .CARRIAGE command.)
      END
.skip
.fill
.test page 9
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 6
1The .NO CARRIAGE command terminates the generation  of
*the   carriage  control  character  specified  by  the
*previous .CARRIAGE command.
 The .NO CARRIAGE command terminates the generation  of
 the   carriage  control  character  specified  by  the
 previous .CARRIAGE command.
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.NO COPY
.skip
.test page 3
The _.NO COPY command indicates that the text specified by the source
file is to be represented only once in the resulting FORMAT statements
instead of being duplicated to form 2 or more parallel columns
containing the same text.  A _.NO COPY command issued within the range
of a _.COPY command terminates the production of the parallel columns
selected by the _.COPY command.  A _.NO COPY command issued within
the range of a _.PROGRAM command applies to the source text following
the next _.TEXT or _.CONTINUE command.  Both the _.COPY command and
the _.NO COPY command imply a _.BREAK command.
.skip
.test page 10
For example, the source text
.skip
.nofill
.test page 8
_.right margin 20.copy 25,1.carriage 1,*.offset 3
_.output width 55.preface       WRITE(1,$)
The .NO COPY command terminates the range of the
previous .COPY command.
_.no copy
Both the .COPY command and the .NO COPY command imply
a .BREAK command
_.program;      END
.skip
.fill
.test page 12
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 9
      WRITE(1,1)
    1 FORMAT(38H1  The .NO COPY command     The .NO CO,
     110HPY command/31H*  terminates the range     ter,
     217Hminates the range/24H*  of   the    previous ,
     34X,20Hof   the    previous/17H*  .COPY command.,
     411X,14H.COPY command./23H*  Both    the    .COPY/
     523H*  command  and the .NO/18H*  COPY command im,
     65Hply a/17H*  .BREAK command)
      END
.skip
.fill
.test page 11
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 8
1  The .NO COPY command     The .NO COPY command
*  terminates the range     terminates the range
*  of   the    previous     of   the    previous
*  .COPY command.           .COPY command.
*  Both    the    .COPY
*  command  and the .NO
*  COPY command imply a
*  .BREAK command
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.NO FILL
.skip
.test page 3
The _.NO FILL command indicates that each line of source text which
is not within the range of a _.PROGRAM command and which does not begin
with a period is to be shifted to the right by the number of spaces
which has been selected by the combination of _.OFFSET, _.LEFT MARGIN
and _.INDENT or _.PARAGRAPH commands, and is then to be represented
in the FORMAT statements with the same number of words per line and
with the same number of spaces, in addition to those inserted at the
left, as in the source text.  The right margin is ignored.  The _.NO
FILL command terminates the range of the previous _.FILL command which
would have caused each line of text to be filled with as many words
as will fit on the line when separated by at least single spaces.  A
_.FILL command is assumed to be in effect when this program is started.
A _.NO FILL command issued within the range of a _.PROGRAM command
applies to the source text following the next _.TEXT or _.CONTINUE
statement.  A _.JUSTIFY, _.NO JUSTIFY or _.RIGHT MARGIN command issued
within the range of a _.NO FILL command applies to the source text
following the next _.FILL command.  Both the _.NO FILL command and
the _.FILL command imply a _.BREAK command.
.skip
.test page 16
For example, the source text
.skip
.nofill
.test page 14
_.output width 55.right margin 55.offset 0
_.nofill.preface       WRITE(1,$)
  The .NO FILL        command is       not   equivalent
  to  the combination of      a        .FILL command
  and a   .NO         JUSTIFY command.
_.fill
  The .NO FILL        command is       not   equivalent
  to  the combination of      a        .FILL command
  and a   .NO         JUSTIFY command.
_.no   justify
  The .NO FILL        command is       not   equivalent
  to  the combination of      a        .FILL command
  and a   .NO         JUSTIFY command.
_.program;      END
.skip
.fill
.test page 14
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 11
      WRITE(1,1)
    1 FORMAT(14H  The .NO FILL,8X,10Hcommand is,7X,1Hn,
     115Hot   equivalent/24H  to  the combination of,
     26X,1Ha,8X,13H.FILL command/13H  and a   .NO,9X,
     316HJUSTIFY command./25HThe  .NO  FILL  command  ,
     430His  not  equivalent   to   the/11Hcombination,
     544H  of  a  .FILL  command  and  a  .NO JUSTIFY/
     68Hcommand./34HThe .NO FILL command is not equiva,
     711Hlent to the/30Hcombination of a .FILL command,
     818H and a .NO JUSTIFY/8Hcommand.)
      END
.skip
.fill
.test page 16
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 9
  The .NO FILL        command is       not   equivalent
  to  the combination of      a        .FILL command
  and a   .NO         JUSTIFY command.
The  .NO  FILL  command  is  not  equivalent   to   the
combination  of  a  .FILL  command  and  a  .NO JUSTIFY
command.
The .NO FILL command is not equivalent to the
combination of a .FILL command and a .NO JUSTIFY
command.
command.
The .NO FILL command is not equivalent to the
combination of a .FILL command and a .NO JUSTIFY
command.
.skip 2
.left margin 5
.fill
.test page 8
.indent -5
_.NO FLAGS
.break
or
.indent -5
_.NO FLAGS ALL
.skip
.test page 3
The _.NO FLAGS ALL command indicates that the flag characters which
are listed below are to be inactive in the source test.  Every
appearance of these flag characters is to be left unchanged and is
to be treated like the appearance of any other nonflag printing
character.
.skip
.left margin 10
.indent -3
$##(dollar sign) or whatever character has been most recently selected
by a _.FLAGS INSERT command.
.indent -3
_\##(back slash) or whatever character has been most recently selected
by a _.FLAGS LOWER CASE command.
.indent -3
__##(underscore) or whatever character has been most recently selected
by a _.FLAGS QUOTE command.
.indent -3
_###(number sign) or whatever character has been most recently selected
by a _.FLAGS SPACE command.
.indent -3
_^##(circumflex) or whatever character has been most recently selected
by a _.FLAGS UPPER CASE command.
.indent -3
<##(less than sign) or whatever character has been most recently
selected by a _.FLAGS CAPITALIZE command.  This flag character is
initially inactive and will remain inactive unless a _.FLAGS CAPITALIZE
command is issued.
.left margin 5
.skip
.test page 3
All flag characters which were initially active, or which have been
individually activated by the corresponding _.FLAGS commands, and which
have not been individually deactivated by the corresponding _.NO FLAGS
commands, will be reactivated if a subsequent _.FLAGS ALL command is
issued.  The _.FLAGS ALL command and the _.NO FLAGS ALL command do
not change the interpretation of the flag characters which identify
and terminate commands.  The flag characters which are to be interpreted
and acted upon in a preface line defined by the _.PREFACE command or
in a field specification defined by the _.INSERT command must be those
which are active when the preface line or the field specification is
defined, regardless of what flag characters happen to be active when
the preface line or the field specification is used.  Neither the
_.FLAGS ALL command nor the _.NO FLAGS ALL command implies a _.BREAK
command.
.skip 2
.left margin 5
.test page 6
.fill
.indent -5
_.NO FLAGS CAPITALIZE
.skip
.test page 3
Every appearance of the less than sign, or of whatever character has
been most recently selected by a _.FLAGS CAPITALIZE command, is to
be left unchanged and is to be treated like the appearance of any other
character.  No flag character is to be available to mark words in which
every letter is to be capitalized.  The capitalization flag character
can be reactivated by a subsequent _.FLAGS CAPITALIZE command.  No
capitalization flag character is active when this program is started.
.skip 2
.left margin 5
.test page 6
.fill
.indent -5
_.NO FLAGS CONTROL
.skip
.test page 3
The source text contains no additional commands.  Lines which start
with periods, or with whatever character has been most recently selected
by a _.FLAGS CONTROL command, are not to be interpreted as commands.
This command probably should not be issued.
.skip 2
.fill
.left margin 5
.test page 6
.indent -5
_.NO FLAGS FENCE
.skip
.test page 3
Every appearance in a command line of the semicolon, or of whatever
character has been most recently selected by a _.FLAGS FENCE command,
is to be treated as a part of the argument list or comment in which
it appears.  No flag character is available which, when used in a
command line, causes the text to the right of the flag character to
be treated as though this text were on the following line.  The
separation flag character can be reactivated by a subsequent _.FLAGS
FENCE command.
.skip 2
.left margin 5
.test page 6
.fill
.indent -5
_.NO FLAGS INSERT
.skip
.test page 3
Every appearance of the dollar sign, or of whatever character has been
most recently selected by a _.FLAGS INSERT command, is to be left
unchanged and is to be treated like the appearance of any other
character.  No flag character is available to mark locations in preface
lines and in program text at which the statement numbers of the next
FORMAT statements are to be inserted.  No flag character is available
to mark locations in the text being represented in the FORMAT statements
at which the field specifications defined by the _.INSERT command are
to be inserted.  The insertion flag character can be reactivated by
a subsequent _.FLAGS INSERT command.
.skip 2
.fill
.left margin 5
.test page 6
.indent -5
_.NO FLAGS LOWER CASE
.skip
.test page 3
Every appearance of the back slash, or of whatever character has been
most recently selected by a _.FLAGS LOWER CASE command, is to be left
unchanged and is to be treated like the appearance of any other
character.  No flag character is available to mark individual alphabetic
letters which are to be converted to their lower case forms.  The lower
case shift character can be reactivated by a subsequent _.FLAGS LOWER
CASE command.
.skip 2
.fill
.left margin 5
.test page 6
.indent -5
_.NO FLAGS QUOTE
.skip
.test page 3
Every appearance of the underscore, or of whatever character has been
most recently selected by a _.FLAGS QUOTE command, is to be left
unchanged and is to be treated like the appearance of any other
character.  No flag character is available which can precede other
characters which are to be treated as nonflag printing characters.
The quotation flag character can be reactivated by a subsequent _.FLAGS
QUOTE command.
.skip 2
.fill
.left margin 5
.test page 6
.indent -5
_.NO FLAGS REMARK
.skip
.test page 3
Every appearance in a command line of the exclamation point, or of
whatever character has been most recently selected by a _.FLAGS REMARK
command, is to be treated as a part of the argument list in which it
appears.  No flag character is available which can be used in command
lines to indicate that the following text, through the end of the line
or through the next appearance of a semicolon on the same line, is
to be treated as a comment and is to be ignored.  The remark flag
character can be reactivated by a subsequent _.FLAGS REMARK command.
.skip 2
.fill
.left margin 5
.test page 6
.indent -5
_.NO FLAGS SPACE
.skip
.test page 3
Every appearance of the number sign, or of whatever character has been
most recently selected by a _.FLAGS SPACE command, is to be left
unchanged and is to be treated like the appearance of any other
character.  No flag character is available which can be used to indicate
the location of a space which is to be treated as though it were a
printing character.  However, a space preceded by an underscore can
still be used for this purpose.  The space holding character can be
reactivated by a subsequent _.FLAGS SPACE command.
.skip 2
.fill
.left margin 5
.test page 6
.indent -5
_.NO FLAGS UPPER CASE
.skip
.test page 3
Every appearance of the circumflex, or of whatever character has been
most recently selected by a _.FLAGS UPPER case command, is to be left
unchanged and is to be treated like the appearance of any other
character.  No flag character is available to mark individual alphabetic
letters which are to be converted to their upper case forms.  The upper
case shift character can be reactivated by a subsequent _.FLAGS UPPER
CASE command.
.skip 2.fill.test page 6.left margin 5.indent -5
_.NO GROUP
.break
The _.NO GROUP command indicates that the FORTRAN text which was
specified by a previous _.GROUP or _.DEFINE GROUP command is not to
be generated before the first FORMAT statement produced after each
_.TEXT command.  A _.RESUME GROUP command can, however, be issued later
to resume the insertion of the same FORTRAN text before each new group
of FORMAT statements.  Neither the _.NO GROUP command nor the _.GROUP
command nor the _.DEFINE GROUP command implies either a _.BREAK or
a _.CONTINUE command.
.skip.test page 3
The _.NO GROUP command is not equivalent to a _.GROUP command issued
without any text to its right, since the latter would discard the
FORTRAN text which previously was inserted before each new group of
FORMAT statements.  After the _.NO GROUP command been issued, this
FORTRAN text still occupies the storage reserved for the lines which
can also be defined by the _.PREFACE or _.DEFINE PREFACE, _.TOP or
_.DEFINE TOP, and _.BOTTOM or _.DEFINE BOTTOM commands.  These commands
can define a total of no more than 30 lines containing together no
more than 500 characters.
.skip.test page 3
The FORTRAN text specified by the _.GROUP command or the _.DEFINE GROUP
command is not generated until enough lines of text have been
constructed to fill the first line of the first FORMAT statement.  If
a _.NO GROUP command is issued before enough lines of text have been
constructed to completely fill the first line of the first FORMAT
statement, then the FORTRAN text will not be generated even if this
FORTRAN text was active during the construction of the first line of
text which is represented in the FORMAT statement.  Consequently, it
is better to issue a _.GROUP, _.DEFINE GROUP, _.NO GROUP, or _.RESUME
GROUP command after the _.TEXT, _.CONTINUE or _.PROGRAM command which
terminates the previous FORMAT statement, rather than before.
.skip
.test page 8
For example, the source text
.skip
.test page 7
.nofill
_.group       GO TO 1000
_.preface $$$$$ WRITE(1,$=$)
This is the first line
_.text
This is the second line
_.text.no group
This is the third line
.skip
.fill
.test page 8
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
.test page 8
      GO TO 1000
    1 WRITE(1,2)
    2 FORMAT(23H This is the first line)
      GO TO 1000
    3 WRITE(1,4)
    4 FORMAT(24H This is the second line)
    5 WRITE(1,6)
    6 FORMAT(23H This is the third line)
.skip 2
.fill
.left margin 5
.test page 6
.indent -5
_.NO INSERT
.skip
.test page 3
The _.NO INSERT command indicates that all groups of characters which
have been specified by the _.INSERT command since this program was
started, or since the last _.NO INSERT or _.TEXT command was issued,
and which have not yet been used, are to be discarded.  If a group
of contiguous dollar signs is encountered in the text which is being
represented in the FORMAT statements before a subsequent _.INSERT
command is issued, then the group of dollar signs will be removed but
nothing will be inserted into its place.  The _.NO INSERT command is
usually not necessary since the groups of characters which are defined
by the _.INSERT command are always discarded after use anyway.
.skip
.test page 3
Neither the _.NO INSERT command nor the _.INSERT command implies a
_.BREAK command.  Insertions into lines of text which are being
constructed in fill mode are made after the line has otherwise been
completed, either when a command which implies a _.BREAK command is
encountered or when the first word which would overflow the line is
encountered.  If the _.NO INSERT command is issued before the line
has been completed, then any groups of characters which would otherwise
have been available for insertion into the line will be discarded
instead.
.skip
.test page 10
For example, the source text
.skip
.nofill
.test page 8
_.output width 55
_.insert 7Hcommand
_.insert 6Hgroups
_.insert 3Hthe
The .NO INSERT $$$$$$$ discards $$$$$$ of characters
which were defined by $$$ .INSERT command, but which
_.no insert
remain unused.
.skip
.fill
.test page 7
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
.test page 4
    1 FORMAT(16H The .NO INSERT ,7Hcommand,9H discards,
     11H ,6Hgroups,22H of  characters  which/7H were  ,
     213Hdefined  by  ,28H  .INSERT  command,  but  wh,
     310Hich remain/8H unused.)
.skip
.fill
In the FORMAT statement shown above, merely a comma appears where the
word 3Hthe would have been inserted if the _.NO INSERT command had
not been issued.
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.NO JUSTIFY
.skip
.test page 3
The _.NO JUSTIFY command indicates that lines of text which are
constructed in fill mode are to have only one space between a pair
of words and two spaces between any of the punctuation marks colon,
semicolon, exclamation point, question mark and period and the following
word.  If merely a single space is required between one of these
punctuation marks and the following word, then the punctuation mark
must be preceded by an underscore.  The lines of text are not extended
to the right margin by the addition of extra spaces between the words.
The _.NO JUSTIFY command terminates the range of the previous _.JUSTIFY
command.  A _.JUSTIFY command, which causes the lines of text which
are constructed in fill mode to be extended to the right margin, is
assumed to be in effect when this program is started.  A _.NO JUSTIFY
or a _.JUSTIFY command issued within the range of a _.PROGRAM command
applies to the text following the next _.TEXT or _.CONTINUE command.
A _.NO JUSTIFY or a _.JUSTIFY command issued within the range of a
_.NO FILL command applies to the lines of text constructed following
the next _.FILL command.  Both the _.NO JUSTIFY command and the
_.JUSTIFY command imply a _.BREAK command.
.skip
.test page 11
For example, the source text
.skip
.nofill
.test page 9
_.no justify.output width 55.right margin 55
_.offset 0.preface       WRITE(1,$)
Lines    of    text   which     are    constructed
   in  fill   mode,     but without justification,
 have   the   words wrapped  around          until
  the  next    word   would  extend         beyond
  the right margin,     but     the          lines
  are   not      of uniform length.
_.program;      END
.skip
.fill
.test page 10
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 7
      WRITE(1,1)
    1 FORMAT(38HLines of text which are constructed in,
     115H fill mode, but/26Hwithout justification, hav,
     226He the words wrapped around/15Huntil the next ,
     334Hword would extend beyond the right/8Hmargin, ,
     440Hbut the lines are not of uniform length.)
      END
.skip
.fill
.test page 7
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 4
Lines of text which are constructed in fill mode, but
without justification, have the words wrapped around
until the next word would extend beyond the right
margin, but the lines are not of uniform length.
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.NO LEADING
.skip
.test page 3
The _.NO LEADING command indicates that blank lines requested by a
_.BLANK or a _.SKIP command are to be discarded if no other text has
been represented in the FORMAT statements since this program was started
or since a _.TEXT command was issued.  A _.NO LEADING command is assumed
to be in effect when this program is started.  Initial blank lines
are represented only if a _.LEADING command is issued before the blank
lines are requested.  Neither the _.NO LEADING command nor the _.LEADING
command implies a _.BREAK command.
.skip
.test page 11
For example, the source text
.skip
.nofill
.test page 9
_.leading.skip.output width 55
Leading blank lines requested by .SKIP commands are
generated within the range of a .LEADING command
_.text.skip
Leading blank lines requested by .SKIP commands are
generated within the range of a .LEADING command
_.text.no leading.skip
Leading blank lines requested by .SKIP commands are
discarded within the range of a .NO LEADING command
.skip
.fill
.test page 12
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
.test page 9
    1 FORMAT(/37H Leading  blank  lines  requested  by,
     124H  .SKIP   commands   are/17H generated within,
     232H the range of a .LEADING command)
    2 FORMAT(/37H Leading  blank  lines  requested  by,
     124H  .SKIP   commands   are/17H generated within,
     232H the range of a .LEADING command)
    3 FORMAT(38H Leading  blank  lines  requested  by ,
     123H .SKIP   commands   are/18H discarded within ,
     234Hthe range of a .NO LEADING command)
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.NO MASK
.skip
.test page 3
The _.NO MASK command indicates that the template line specified by
a previous _.MASK command is no longer to be superimposed onto each
line of text which is represented in the resulting FORMAT statements.
The _.NO MASK command is equivalent to a _.MASK command issued without
any text to its right.  A _.NO MASK command is assumed to be in effect
when this program is started.  Neither the _.NO MASK command nor the
_.MASK command implies a _.BREAK command.  A _.BREAK or _.EJECT command
should be issued before the _.NO MASK or _.MASK command unless it is
really desired to change the template line which is to be applied to
the line which is currently being accumulated in fill mode or to the
blank lines which have not yet been written out to the FORMAT
statements.
.skip
.test page 11
For example, the source text
.skip
.nofill
.test page 9
_.output width 55.preface       WRITE(1,$)
_.left margin 5.right margin 45.carriage 1,*
_.mask  @                                              @
The .NO MASK command terminates the range of the
previous .MASK command.
_.mask  %                                              %
The .NO MASK command has no effect if a .MASK command
has not been issued.
_.nomask.program;      END
.skip
.fill
.test page 10
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 7
      WRITE(1,1)
    1 FORMAT(38H1 @   The  .NO  MASK  command  termina,
     112Htes  the   @/29H* %   range  of  the  previou,
     221Hs  .MASK command.   %/20H* %   The .NO MASK c,
     330Hommand has no effect if  a   %/11H*     .MASK,
     429H command has not been issued.)
      END
.skip
.fill
.test page 7
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 4
1 @   The  .NO  MASK  command  terminates  the   @
* %   range  of  the  previous  .MASK command.   %
* %   The .NO MASK command has no effect if  a   %
*     .MASK command has not been issued.
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.NO OFFSET
.skip
.test page 3
The _.NO OFFSET command indicates that each line of text which is
represented in the FORMAT statements is not to be shifted further to
the right than is indicated by the combination of the _.LEFT MARGIN
and _.INDENT or _.PARAGRAPH commands.  The _.NO OFFSET command is
equivalent to an _.OFFSET 0 command.  An _.OFFSET 1 command is assumed
to be in effect when this program is started.  Both the _.NO OFFSET
and _.OFFSET commands imply a _.BREAK command.
.skip
.test page 9
For example, the source text
.skip
.nofill
.test page 7
_.offset 1.indent 5.right margin 50.output width 55
_.preface       WRITE(1,$)
The default .OFFSET 1 command provides an empty column
for the carriage control character.
_.no offset.indent 5;The .NO OFFSET command prevents the
generation of this empty column.
_.program;      END
.skip
.fill
.test page 10
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 7
      WRITE(1,1)
    1 FORMAT(6X,35HThe default .OFFSET  1  command  pr,
     110Hovides  an/31H empty column for the carriage ,
     218Hcontrol character./5X,20HThe   .NO   OFFSET  ,
     325H command   prevents   the/16Hgeneration of th,
     416His empty column.)
      END
.skip
.fill
.test page 7
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 4
      The default .OFFSET  1  command  provides  an
 empty column for the carriage control character.
     The   .NO   OFFSET   command   prevents   the
generation of this empty column.
.FILL
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.NO PREFACE
.skip
.test page 3
The _.NO PREFACE command indicates that the FORTRAN text specified
by a previous _.PREFACE command or _.DEFINE PREFACE command is not
to be generated before each of the next FORMAT statements.  A _.RESUME
PREFACE command can, however be issued later to resume the insertion
of the same FORTRAN text before each new FORMAT statement.  Neither
the _.NO PREFACE command nor the _.PREFACE command nor the _.DEFINE
PREFACE command implies either a _.BREAK or a _.CONTINUE command.
.skip.test page 3
The _.NO PREFACE command is not equivalent to a _.PREFACE command issued
without any text to its right, since the latter would discard the
FORTRAN text which previously was inserted before each FORMAT statement.
After the _.NO PREFACE command been issued, this FORTRAN text still
occupies the storage reserved for the lines which can also be defined
by the _.GROUP or _.DEFINE GROUP, _.TOP or _.DEFINE TOP, and _.BOTTOM
or _.DEFINE BOTTOM commands.  These commands can define a total of
no more than 30 lines containing together no more than 500 characters.
.skip.test page 3
The FORTRAN text specified by the _.PREFACE command or the _.DEFINE
PREFACE command is not generated until enough lines of text have been
constructed to fill the first line of the next FORMAT statement.  If
a _.NO PREFACE command is issued before enough lines of text have been
constructed to completely fill the first line of the next FORMAT
statement, then the FORTRAN text will not be generated even if this
FORTRAN text was active during the construction of the first line of
text which is represented in the FORMAT statement.  Consequently, it
is better to issue a _.PREFACE, _.DEFINE PREFACE, _.NO PREFACE, or
_.RESUME PREFACE command after the _.TEXT, _.CONTINUE or _.PROGRAM
command which terminates the previous FORMAT statement, rather than
before.
.skip
.test page 8
For example, the source text
.skip
.test page 6
.nofill
_.preface       WRITE(1,$)
This is the first line
_.continue
This is the second line
_.continue.no preface
This is the third line
.skip
.fill
.test page 8
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
.test page 5
      WRITE(1,1)
    1 FORMAT(23H This is the first line)
      WRITE(1,2)
    2 FORMAT(24H This is the second line)
    3 FORMAT(23H This is the third line)
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.NO TRAILING
.skip
.test page 3
The _.NO TRAILING command indicates that the FORMAT statements are
not to include trailing blank lines resulting from _.SKIP or _.BLANK
commands issued after all other text has been represented in the FORMAT
statements and are not to include the blank lines implied by multiple
spacing after the final line of text represented in the FORMAT
statements.  A _.NO TRAILING command is assumed to be in effect when
this program is first started.  If, instead, a _.TRAILING command has
been issued more recently than a _.NO TRAILING command, then each _.TEXT
command and the reading of the end of the file (or the issuing of an
_.END OF FILE command) generates all of the blank lines which have
been requested or which are necessary for multiple line spacing
following the final line of text represented in the FORMAT statements.
Neither the _.NO TRAILING command nor the _.TRAILING command implies
a _.BREAK command.
.skip
.test page 10
For example, the source text
.skip
.nofill
.test page 8
_.no trailing.spacing 1
This is the first line
_.skip.text.spacing 2
This is the second line
_.text.trailing.spacing 1
This is the third line
_.skip.text.spacing 2
This is the fourth line
.skip
.fill
.test page 7
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
    1 FORMAT(23H This is the first line)
    2 FORMAT(24H This is the second line)
    3 FORMAT(23H This is the third line/)
    4 FORMAT(24H This is the fourth line/)
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.OFFSET number of spaces to be inserted at left edge of text
.skip
.test page 3
The _.OFFSET command indicates that each line of text which is
represented in the FORMAT statements is to be shifted to the right
by the insertion of the indicated number of extra spaces at the left.
If the number which follows the _.OFFSET command is unsigned, then
this number will be used as the number of extra spaces which are to
be inserted at the left end of each line in addition to the spaces
specified by the combination of _.LEFT MARGIN and _.INDENT or
_.PARAGRAPH commands.  If the number which follows the _.OFFSET command
is signed, then the previous offset is adjusted by the indicated amount.
The carriage control character, if any, specified by the _.CARRIAGE
command will be superimposed upon the leftmost of the spaces in the
offset specified by the _.OFFSET command.  A template line specified
by a _.MASK command would be applied to the text to the right of the
offset.  A _.COPY command would duplicate the characters to the right
of the offset after application of the template line, if any.  An offset
of 1 column which provides a space as the carriage control character
on each line is assumed to be in effect when this program is started.
No initial spaces other than those specified by the combination of
_.LEFT MARGIN and _.INDENT or _.PARAGRAPH commands are inserted if
an _.OFFSET 0 command or the equivalent _.NO OFFSET command is issued.
The _.OFFSET and _.NO OFFSET commands both imply a _.BREAK command.
.skip
.test page 14
For example, the source text
.skip
.nofill
.test page 12
_.left margin 5.right margin 44.output width 55
_.preface       WRITE(1,$)
_.mask @                                               @
_.offset 1.indent 5.carriage 1,*
The offset specified by the .OFFSET command is in
addition to that specified by the .LEFT MARGIN
and .INDENT or .PARAGRAPH commands.
_.offset 6.indent 5.carriage 1,*
The offset specified by the .OFFSET command is in
addition to that specified by the .LEFT MARGIN
and .INDENT or .PARAGRAPH commands.
_.program;      END
.skip
.fill
.test page 15
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 12
      WRITE(1,1)
    1 FORMAT(2H1@,9X,30HThe  offset   specified   by  ,
     19H the    @/33H*@    .OFFSET  command is in addi,
     217Htion to that    @/24H*@    specified  by  the,
     326H  .LEFT  MARGIN   and    @/15H*@    .INDENT o,
     422Hr .PARAGRAPH commands.,12X,1H@/7H1     @,9X,
     539HThe  offset   specified   by   the    @/3H*  ,
     63X,42H@    .OFFSET  command is in addition to th,
     77Hat    @/35H*     @    specified  by  the  .LEF,
     820HT  MARGIN   and    @/21H*     @    .INDENT or,
     921H .PARAGRAPH commands.,12X,1H@)
      END
.skip
.fill
.test page 11
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 8
1@         The  offset   specified   by   the    @
*@    .OFFSET  command is in addition to that    @
*@    specified  by  the  .LEFT  MARGIN   and    @
*@    .INDENT or .PARAGRAPH commands.            @
1     @         The  offset   specified   by   the    @
*     @    .OFFSET  command is in addition to that    @
*     @    specified  by  the  .LEFT  MARGIN   and    @
*     @    .INDENT or .PARAGRAPH commands.            @
.fill
.skip 2
.left margin 5
.test page 6
.indent -5
_.OUTPUT LENGTH maximum number of lines in a FORMAT statement
.skip
.test page 3
The _.OUTPUT LENGTH command specifies the maximum number of FORTRAN
language lines from which each FORMAT statement can be constructed.
The number of lines set by the _.OUTPUT LENGTH command should not be
greater than the maximum number of lines accepted by the compiler which
will be used to process the resulting FORMAT statements.  _.OUTPUT
LENGTH 20 is the default, but this program does not impose any upper
limit upon this maximum.  The combination of the _.OUTPUT LENGTH command
and the _.OUTPUT WIDTH command set the maximum number of characters
in a single FORMAT statement, but do not otherwise restrict the maximum
number of lines of text which can be represented in each FORMAT
statement.  The _.OUTPUT LENGTH command, like most other commands which
merely describe the manner in which the text is represented in the
FORMAT statements, does not imply a _.BREAK command.
.skip
.test page 16
For example, the source text
.skip
.nofill
_.offset 0.output width 55.output length 3
_.preface       WRITE(1,$)
The FORMAT command indicates that no additional text
is to be represented by the FORMAT statement currently
being constructed and that the text appearing in
subsequent lines in the source file is to be
_.output length 10
represented in a new FORMAT statement. The preface
line, if any, indicated by a previous PREFACE command
will be written into the output before this next FORMAT
_.output length 3
statement. All unused output field descriptions
previously specified by INSERT commands will still be
available.
.skip
.fill
.test page 20
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
      WRITE(1,1)
    1 FORMAT(38HThe FORMAT command indicates that no a,
     122Hdditional text  is  to/19Hbe  represented  by,
     241H  the  FORMAT  statement  currently being)
      WRITE(1,2)
    2 FORMAT(38Hconstructed and that the text appearin,
     122Hg in subsequent  lines/19Hin  the  source  fi,
     241Hle  is  to be represented in a new FORMAT/1Hs,
     345Htatement.   The  preface  line,  if  any,  in,
     414Hdicated  by  a/27Hprevious  PREFACE  command ,
     533H will  be written into the output)
      WRITE(1,3)
    3 FORMAT(38Hbefore this next FORMAT statement.  Al,
     122Hl unused output  field/19Hdescriptions  previ,
     241Hously  specified  by INSERT commands will)
      WRITE(1,4)
    4 FORMAT(19Hstill be available.)
.skip 2
.left margin 5
.test page 6
.fill
.indent -5
_.OUTPUT WIDTH most characters in each FORMAT statement line
.skip
.test page 3
The _.OUTPUT WIDTH command specifies the maximum number of characters
in each FORTRAN language line from which the FORMAT statements are
constructed, including the 5 characters in the statement number field
and the single character in the continuation field.  _.OUTPUT WIDTH
72 is the greatest width which can be specified and is the default.
The combination of the _.OUTPUT LENGTH command and the _.OUTPUT WIDTH
command set the maximum number of characters in a single FORMAT
statement, but do not otherwise restrict the maximum number of lines
of text which can be represented in each FORMAT statement.  The _.OUTPUT
WIDTH command, like most other commands which merely describe the manner
in which the text is represented in the FORMAT statements, does not
imply a _.BREAK command.
.skip
.test page 9
For example, the source text
.skip
.nofill
_.output width 35
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
_.output width 45
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
_.output width 55
.skip
.fill
.test page 9
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
    1 FORMAT(18H The quick red fox,
     125H jumps over the lazy brow,
     218Hn dog,  then  runs/13H into  the  f,
     335Horest.   The  quick  red fox jumps ,
     413Hover the lazy/28H brown dog, then runs into t,
     510Hhe forest.)
.fill
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.PARAGRAPH columns to indent, multiple of line spacing
.break
or
.indent -5
_.PARAGRAPH columns to indent, -1 times number of blank lines
.skip
.test page 3
The _.PARAGRAPH command indicates that the next line of text which
is represented in the FORMAT statements is to be indented by the
indicated number of spaces from the left margin which is effect when
the first word in the line is found.  The indicated number of initial
spaces are added to the left margin if the first number following the
_.PARAGRAPH command is greater than or equal to zero.  The indicated
number of spaces are deleted from the left margin if the first number
which follows the _.PARAGRAPH command is less than zero.  If the first
number following the _.PARAGRAPH command is missing, then the
indentation specified by the previous _.PARAGRAPH command will be
applied or a positive indentation of 5 columns is assumed if no previous
_.PARAGRAPH command has specified a first argument.
.skip
.test page 3
If the second argument following the _.PARAGRAPH command is greater
than or equal to zero, then a number of blank lines equal to the
specified multiple of the number which appeared to the right of the
previous _.SPACING command, or the specified number of blank lines
directly if a _.SPACING command has not yet been issued, are to be
represented in the FORMAT statement between the previous line of text
and the next line of text, in addition to any blank lines specified
by previous _.BLANK or _.SKIP commands, and, if a _.SPACING command
has been issued, in addition to a number of blank lines equal to one
less than the number which appeared to the right of the previous
_.SPACING command.  If the second argument following the _.PARAGRAPH
command is less than zero, then the number of extra blank lines is
equal to the negative of the value specified by the argument rather
than to the multiple of the number which was specified by the _.SPACING
command.  If the second argument following the _.PARAGRAPH command
is missing, then the second argument specified by the previous
_.PARAGRAPH command will be applied, or a second argument of -1
indicating 1 extra blank line in addition to the blank lines needed
for the normal line spacing is assumed if no previous _.PARAGRAPH
command has specified a second argument.  If no text has been
represented in the FORMAT statements either since the start of the
source was read or since the last _.TEXT command was issued, then the
extra blank lines specified by the _.PARAGRAPH command are not generated
even if a _.LEADING command is in effect.
.skip
.test page 3
If the second argument following the _.PARAGRAPH command is greater
than zero, then the _.PARAGRAPH command is equivalent to the combination
of an _.INDENT command and a _.SKIP command.  If the second argument
following the _.PARAGRAPH command is equal to zero, then the _.PARAGRAPH
command is equivalent to an _.INDENT command.  If the second argument
following the _.PARAGRAPH command is less than zero, then the
_.PARAGRAPH command is equivalent to the combination of an _.INDENT
command and a _.BLANK command having as its argument the second argument
of the _.PARAGRAPH command without its sign.  If a _.SPACING 2 command
is in effect, then a _.PARAGRAPH 5,3 command would result in (2-1)+(3*2)
= 7 blank lines being generated before the next line which would be
indented 5 columns to the right.  A _.PARAGRAPH 5,-6 command would
produce the same results.  The _.PARAGRAPH command implies a _.BREAK
command.
.skip
.test page 18
For example, the source text
.skip
.nofill
.test page 16
_.output width 55.left margin 5.right margin 54
_.carriage 1,*.paragraph.preface       WRITE(1,$)
This line is at the start of the source and will only
be indented.
_.spacing 2.paragraph 10
(spacing-1)-(negative argument) = (1-1)-(-1) = 1 blank
line since the default .SPACING 1 command was in effect
at the end of the previous line.
_.paragraph
(2-1)-(-1) = 2 blank lines precede this paragraph since
the .SPACING 2 command was in effect at the end of the
previous line.
_.paragraph -5,2
(spacing-1)+(spacing*(positive argument)) = (2-1)+(2*2)
= 5 lines precede this paragraph.
_.program;      END
.skip
.fill
.test page 19
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 14
      WRITE(1,1)
    1 FORMAT(1H1,10X,30HThis line is at the start of t,
     114Hhe source  and/27H*     will only be indented,
     21H./1H*/1H*,15X,29H(spacing-1)-(negative    argu,
     310Hment)    =/1H*/27H*     (1-1)-(-1)  =  1  bla,
     428Hnk  line  since  the default/1H*/9H*     .SP,
     545HACING 1 command was in effect at  the  end  o,
     61Hf/1H*/24H*     the previous line./1H*/1H*/1H*,
     715X,39H(2-1)-(-1) = 2 blank lines precede this/
     81H*/41H*     paragraph  since  the  .SPACING  2 ,
     914Hcommand was in/1H*/23H*     effect at the end,
     122H of the previous line./1H*/1H*/1H*/1H*/1H*/
     231H*(spacing-1)+(spacing*(positive,6X,8Hargument,
     32H)),7X,1H=/1H*/29H*     (2-1)+(2*2) = 5 lines p,
     422Hrecede this paragraph.)
      END
.skip
.fill
.test page 28
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 25
1          This line is at the start of the source  and
*     will only be indented.
*
*               (spacing-1)-(negative    argument)    =
*
*     (1-1)-(-1)  =  1  blank  line  since  the default
*
*     .SPACING 1 command was in effect at  the  end  of
*
*     the previous line.
*
*
*               (2-1)-(-1) = 2 blank lines precede this
*
*     paragraph  since  the  .SPACING  2 command was in
*
*     effect at the end of the previous line.
*
*
*
*
*
*(spacing-1)+(spacing*(positive      argument))       =
*
*     (2-1)+(2*2) = 5 lines precede this paragraph.
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.PREFACE line of text to precede each new FORMAT statement
.skip
.test page 3
The characters which appear to the right of the _.PREFACE command on
the same line are to be copied into the output file on a separate line
before each new FORMAT statement which is generated.  The character
to the immediate right of the _.PREFACE command must be a space.  The
line of text which is to be copied into the output file before each
new FORMAT statement starts with the second character to the right
of the _.PREFACE command, whether or not this is a printing character,
and extends through the rightmost printing character on the line.  A
_.PREFACE command issued within the range of a _.PROGRAM command applies
to the source text following the next _.TEXT or _.CONTINUE command.
If more than a single line must be inserted before each new FORMAT
statement, then a _.DEFINE PREFACE command followed by the lines of
text and then by an _.END DEFINITION command should be used to define
the preface lines instead.  Regardless of which method is used to define
the preface line or lines, the insertions of the preface line or lines
are performed similarly.
.skip.test page 3
The insertion of the preface line before each new FORMAT statement
can be terminated either by issuing a subsequent _.NO PREFACE command,
or by establishing a null preface by issuing another _.PREFACE command
without anything to its right.  These 2 methods of cancelling the
preface line are not identical.  If a _.NO PREFACE command is used
to cancel the insertion of the preface line, then a _.RESUME PREFACE
command can be issued later to resume the insertion of the same preface
line before the subsequent new FORMAT statements.  If a _.PREFACE
command is issued without anything to its right, however, then the
_.RESUME PREFACE command cannot be used to resume the insertion of
the previous preface line.  Neither the _.PREFACE command, nor the
_.NO PREFACE command nor the _.RESUME PREFACE command implies a _.BREAK
command.
.skip.test page 3
The Line of text which is defined by the _.PREFACE command is stored
in the same area as are those which are specified by the _.GROUP or
_.DEFINE GROUP, _.TOP or _.DEFINE TOP and _.BOTTOM or _.DEFINE BOTTOM
commands.  There can be at most 30 lines containing together no more
than 500 characters in all of these collections of lines.  These lines
include those which have been temporarily disabled by the _.NO GROUP,
_.NO PREFACE, _.NO TOP or _.NO BOTTOM commands.
.skip
.test page 3
The _.PREFACE command would typically be used to insert single line
FORTRAN language WRITE statements before each of the FORMAT statements
which represents portions of a long section of text.  In the line of
text specified by the _.PREFACE command, all groups of contiguous dollar
signs which are not preceded by underscores will be replaced each time
the line of text is copied into the output file by the statement number
of the following FORMAT statement.  If the group of dollar signs
contains more dollar signs than there are digits in the number, then
additional spaces are inserted to the left of the statement number
so that the total number of characters which are inserted equals the
number of dollar signs in the group.  If the group of dollar signs
does not contain more dollar signs than there are digits in the number,
then all of the digits are represented, but no extra spaces are
inserted.
.skip.test page 3
The group of dollar signs can be followed immediately by either a plus
or a minus sign and then by a number to cause the value which is
inserted in place of the group of dollar signs to be larger or smaller
than the statement number of the following FORMAT statement by the
indicated amount.  The value of the next statement number can itself
be modified if an equal sign appears between the dollar sign and the
plus or minus sign, or between the dollar sign and the actual value
which the next statement number is to have.  If an equal sign appears
to the immediate right of the dollar sign, however, then neither this
expression nor the resulting value is copied into the resulting preface
line at this point.
.skip.test page 6
For example,
.skip
.left margin +7
.i-7.test page 3
$######would be replaced by the value of the next statement number.
No extra spaces would be inserted.
.skip
.i-7.test page 3
$$$$###would be replaced by the next statement number.  If this is
less than 1000, then enough spaces are inserted at the left to produce
at least 4 characters.
.skip
.i-7.test page 3
$+#####would be replaced by the sum of the next statement number and
the statement number increment.  The value of the next statement number
would not itself be changed.  $- would subtract the increment instead.
.skip
.i-7.test page 3
$+10###would be replaced by 10 more than the value of the next statement
number.  The value of the next statement number would not itself be
changed.
.skip
.i-7.test page 3
$=#####would set the value of the next statement number to the sum
of its current value and the statement number increment.  Neither the
$= nor the resulting value would appear at this point in the preface
line when it is copied into the output file.  There could be several
adjacent dollar signs, but the extra dollar signs would be ignored.
$=+ would have the same effect.  $=- would subtract the increment
instead.
.skip
.i-7.test page 3
$=100##would set the value of the next statement number to 100.  Neither
the $=100 nor the resulting value would appear at this point in the
preface line when it is copied into the output file.
.skip
.i-7.test page 3
$=+10##would increase the value of the next statement number by 10.
Neither the $=+10 nor the resulting value would appear at this point
in the preface line when it is copied into the output file.
.left margin -7
.skip
.test page 3
Within the text specified by the _.PREFACE command, an underscore
character, which will not be copied into the output file, can appear
before any character, such as a number sign, circumflex, back slash,
less than sign (if in flag capitalize mode), a dollar sign or another
underscore, which is to be treated as a nonflag character.  The
_.PREFACE command cannot be followed on the same line either by a
comment or by another command, so semicolons and exclamation points
in the line of text specified by the _.PREFACE command do not need
to be preceded by underscores.
.skip
.test page 7
For example, the source text
.skip
.nofill
.test page 5
_.output length 2.output width 55.right margin 30.
_.preface       IF(KONTRL.EQ.1)WRITE(1,$$$)
The .PREFACE command allows several FORMAT statements
representing a single section of text to be used under
the same conditions.
.skip
.fill
.test page 11
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
.test page 8
      IF(KONTRL.EQ.1)WRITE(1,  1)
    1 FORMAT(31H The  .PREFACE  command  allows/4H sev,
     127Heral    FORMAT   statements)
      IF(KONTRL.EQ.1)WRITE(1,  2)
    2 FORMAT(31H representing a single  section/4H of ,
     127H text  to be used under the)
      IF(KONTRL.EQ.1)WRITE(1,  3)
    3 FORMAT(17H same conditions.)
.skip.test page 3.fill
The following example demonstrates one manner in which manipulation
of the statement numbers might be used to prevent duplication.  The
$=$$$ which appears in the definition of the preface line is treated
as consisting of 2 parts.  The $= first changes the value of the next
statement number by the current increment, then, since a dollar has
no special meaning to the right of an equal sign, nor for that matter
to the right of a plus or minus sign or to the right of a number, the
$$$ is replaced by this new number.
.skip.test page 5.nofill
_.output length 2.output width 55.right margin 30.
_.preface $$$$$ IF(KONTRL.EQ.1)WRITE(1,$=$$$)
The .PREFACE command allows several FORMAT statements
representing a single section of text to be used under
the same conditions.
.skip.test page 3.fill
This would be converted to the following FORTRAN text when processed
by this program.
.skip.test page 8.nofill
    1 IF(KONTRL.EQ.1)WRITE(1,  2)
    2 FORMAT(31H The  .PREFACE  command  allows/4H sev,
     127Heral    FORMAT   statements)
    3 IF(KONTRL.EQ.1)WRITE(1,  4)
    4 FORMAT(31H representing a single  section/4H of ,
     127H text  to be used under the)
    5 IF(KONTRL.EQ.1)WRITE(1,  6)
    6 FORMAT(17H same conditions.)
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.PROGRAM next statement number, statement number increment
.skip
.test page 3
The _.PROGRAM command indicates that no additional text is to be
represented by the FORMAT statement currently being constructed and
that the source text appearing on the following lines of the input
file, through the next _.TEXT or _.CONTINUE command or through the
reading of the end of the file (or the issuing of an _.END OF FILE
command) is to be copied into the output file directly rather than
being represented in a FORMAT statement.  No extra spaces are inserted
at the start of the lines within the range of the _.PROGRAM command
regardless of whether an _.OFFSET command has been issued, and no extra
blank lines are inserted between these lines even if a _.SPACING command
has been issued.  Case conversions and removal of underscores before
characters to be copied literally continue to be performed within the
range of the _.PROGRAM command, and dollar signs are replaced, as
described below, by the number of the next FORMAT statement which can
be generated.
.skip
.test page 3
In the lines within the range of the _.PROGRAM command, an underscore
character, which will not be copied into the output file, can appear
before any character, such as a number sign, circumflex, back slash,
less than sign (if in flag capitalize mode), dollar sign, another
underscore, initial period, or rightmost space, which is to be treated
as though it were an ordinary printing character.  All lines beginning
with a period in the left column will be interpreted as commands.  In
order to output a line starting with a period, this period must be
preceded by an underscore character.
.skip
.test page 3
In the noncommand lines following the _.PROGRAM command, all groups
of contiguous dollar signs which are not preceded by underscore
characters will be replaced by the statement number of the FORMAT
statement which would be generated when either a _.TEXT or a _.CONTINUE
command is next encountered.  If the group of dollar signs contains
more dollar signs than there are digits in the number, then additional
spaces are inserted to the left of the statement number so that the
total number of characters which are inserted equals the number of
dollar signs in the group.  If the group of dollar signs does not
contain more dollar signs than there are digits in the number, then
all of the digits are represented, but no extra spaces are inserted.
.skip
.test page 3
The numbers which can follow the _.PROGRAM command are identical to
those which can follow the _.TEXT and _.CONTINUE commands.  The first
number which can follow any of these commands modifies the statement
number of the next FORMAT statement.  The second number which can follow
any of these commands becomes the statement number increment after
the generation of the next FORMAT statement.  The description of the
_.CONTINUE command describes the interpretation of these numbers in
detail.  If the statement number of the FORMAT statement following
a section of program text indicated by an initial _.PROGRAM command
is to be modified, but the program text includes dollar signs which
are to be replaced by this statement number, then this statement number
should be modified by the _.PROGRAM command rather than by the following
_.TEXT or _.CONTINUE command, since, if the modification is done by
the _.TEXT or _.CONTINUE command, then incorrect statement numbers
will have been inserted into the program text.
.skip
.test page 12
For example, the source text
.skip
.nofill
_.spacing 2.output width 55.offset 0
_.text 10,10    ;Statement ten
_.program       ;Next statement will be number $$$.
_.continue      ;Statement twenty
_.program+5,100 ;Next statement will be number $$.
_.trail         !blank lines will now end statements
__.Underscore before initial period and dollar sign __$.
_.continue      ;Statement twenty-five
_.program       ;Next statement will be number $.
_.continue      ;Statement one hundred and twenty-five
.skip
.fill
.test page 11
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
   10 FORMAT(13HStatement ten)
Next statement will be number  20.
   20 FORMAT(/16HStatement twenty)
Next statement will be number 25.
_.Underscore before initial period and dollar sign $.
   25 FORMAT(/21HStatement twenty-five/)
Next statement will be number 125.
  125 FORMAT(37HStatement one hundred and twenty-five/)
.fill
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.RESET
.skip
.test page 3
The _.RESET command returns all conditions which can be changed by
commands and by case shift locks in the source text to their original
settings.  If additional text appears on the same line to the right
of the _.RESET command then the original set of flag characters will
be recognized in this additional text, and the cases of alphabetic
letters will be retained at the start of this additional text.  The
width of the line in which the _.RESET command is found is set by the
input line width in effect when the line was read, but the next line
read from the source file will be of the original width.
.skip
.test page 3
The following commands are implied by the _.RESET command.
.left margin 10
.skip
.nofill
_.FILL
_.FLAGS ALL
_.FLAGS CONTROL __.
_.FLAGS FENCE __;
_.FLAGS INSERT $
_.FLAGS LOWER CASE ___\
_.FLAGS QUOTE ____
_.FLAGS REMARK __!
_.FLAGS SPACE ___#
_.FLAGS UPPER CASE ___^
_.INPUT WIDTH 132 (applies to next line read)
_.JUSTIFY
_.LEFT MARGIN 0
_.NO BOTTOM
_.NO CARRIAGE
_.NO COPY
_.NO FLAGS CAPITALIZE
_.NO GROUP
_.NO INSERT
_.NO LEADING
_.NO MASK
_.NO PAGE CARRIAGE
_.NO PAGING
_.NO PREFACE
_.NO TOP
_.NO TRAILING
_.OFFSET 1
_.OUTPUT LENGTH 20
_.OUTPUT WIDTH 72
_.PAGE LENGTH 22
_.RIGHT MARGIN 60
_.SPACING 1
_.TEXT 1,1
_.UPPER CASE
_.USE H
.left margin 5
.SKIP.TEST PAGE 3.FILL
The _.NO BOTTOM, _.NO PAGE CARRIAGE, _.NO PAGING, _.NO TOP and _.PAGE
LENGTH commands which are listed in the above table are used when the
text in lengthy messages is being divided into pages for display on
a video terminal.  These commands are described in the next chapter
of this manual.
.skip.TEST PAGE 3
.fill
After the _.RESET command has been issued, a _.PARAGRAPH command without
arguments would be assumed to be equivalent to _.PARAGRAPH 5,-1,3.
The third number after the _.PARAGRAPH command is used only when the
text is being divided into pages.
.fill.skip 2.test page 6.left margin 5.indent -5
_.RESUME GROUP
.skip
If a _.NO GROUP command has been issued to prevent the insertion into
the output file of the FORTRAN text specified by the previous _.GROUP
or _.DEFINE GROUP command, then the _.RESUME GROUP command resumes
the insertion of this FORTRAN text before the first FORMAT statement
produced after each _.TEXT command.  A _.RESUME GROUP command is implied
by each new _.GROUP or _.DEFINE GROUP command.  If a _.NO GROUP command
has not been issued, then the _.RESUME GROUP command is unnecessary
and has no effect.
.skip.test page 3
The FORTRAN text specified by a _.GROUP or _.DEFINE GROUP command is
not generated until enough lines of output text have been specified
to fill the first line of the first FORMAT statement.  Whether this
FORTRAN text is generated or not depends, at the time the first line
of the FORMAT statement has been completed, upon whether this FORTRAN
text has been specified by a _.GROUP or _.DEFINE GROUP command, and
upon whether this FORTRAN text has been deactivated by a subsequent
_.NO GROUP command or reactivated by a subsequent _.RESUME GROUP
command.  Consequently, it is better to issue a _.GROUP, _.DEFINE GROUP,
_.NO GROUP, or _.RESUME GROUP command after the _.TEXT, _.CONTINUE
or _.PROGRAM command which terminates the previous FORMAT statement,
rather than before.
.skip.test page 12
For example, the source text
.skip.nofill
_.output width 55
_.group       WRITE(ITTY,$)
This text comes after the definition of a group
line by the .GROUP command.
_.text.no group
This text comes after the .NO GROUP command.
There will not be a group line before this FORMAT.
_.text.resume group
This text comes after the .RESUME GROUP command.
The group line will again appear before this FORMAT.
.skip.fill.test page 13
would be transformed into the following FORTRAN text when processed
by this program.
.skip.nofill
      WRITE(ITTY,1)
    1 FORMAT(38H This text comes after the definition ,
     123Hof a group line by  the/16H .GROUP command.)
    2 FORMAT(38H This text comes after the .NO GROUP c,
     123Hommand.  There will not/18H be a group line b,
     218Hefore this FORMAT.)
      WRITE(ITTY,3)
    3 FORMAT(38H This text comes after the .RESUME GRO,
     123HUP command.  The  group/18H line will again a,
     225Hppear before this FORMAT.)
.fill
.fill.skip 2.test page 6.left margin 5.indent -5
_.RESUME PREFACE
.skip
If a _.NO PREFACE command has been issued to prevent the insertion
into the output file of the FORTRAN text specified by the previous
_.PREFACE or _.DEFINE PREFACE command, then the _.RESUME PREFACE command
resumes the insertion of this FORTRAN text before each new FORMAT
statement.  A _.RESUME PREFACE command is implied by each new _.PREFACE
or _.DEFINE PREFACE command.  If a _.NO PREFACE command has not been
issued, then the _.RESUME PREFACE command is unnecessary and has no
effect.
.skip.test page 3
The FORTRAN text specified by a _.PREFACE or _.DEFINE PREFACE command
is not generated until enough lines of output text have been specified
to fill the first line of the next FORMAT statement.  Whether this
FORTRAN text is generated or not depends, at the time the first line
of the FORMAT statement has been completed, upon whether this FORTRAN
text has been specified by a _.PREFACE or _.DEFINE PREFACE command,
and upon whether this FORTRAN text has been deactivated by a subsequent
_.NO PREFACE command or reactivated by a subsequent _.RESUME PREFACE
command.  Consequently, it is better to issue a _.PREFACE, _.DEFINE
PREFACE, _.NO PREFACE, or _.RESUME PREFACE command after the _.TEXT,
_.CONTINUE or _.PROGRAM command which terminates the previous FORMAT
statement, rather than before.
.skip.test page 12
For example, the source text
.skip.nofill
_.output width 55
_.preface       WRITE(ITTY,$)
This text comes after the definition of a preface
line by the .PREFACE command.
_.continue.no preface
This text comes after the .NO PREFACE command.
There will not be a preface line before this FORMAT.
_.continue.resume preface
This text comes after the .RESUME PREFACE command.
The preface line will again appear before this FORMAT.
.skip.fill.test page 14
would be transformed into the following FORTRAN text when processed
by this program.
.skip.nofill
      WRITE(ITTY,1)
    1 FORMAT(38H This text comes after the definition ,
     123Hof a  preface  line  by/18H the .PREFACE comm,
     24Hand.)
    2 FORMAT(38H This text comes after the .NO PREFACE,
     123H command.   There  will/18H not be a preface ,
     224Hline before this FORMAT.)
      WRITE(ITTY,3)
    3 FORMAT(38H This text comes after  the  .RESUME  ,
     123HPREFACE  command.   The/18H preface line will,
     233H again appear before this FORMAT.)
.fill
.skip 2
.left margin 5
.test page 6
.fill
.indent -5
_.RIGHT MARGIN rightmost column into which text is wrapped
.skip
.test page 3
The _.RIGHT MARGIN command specifies the maximum number of characters
in each line of text which is constructed in fill mode, including the
left margin specified by the _.LEFT MARGIN command, the indentation
which is specified either by an _.INDENT or a _.PARAGRAPH command,
and the words of text and the spacings between words which are
accumulated on the current line either until the next word would cause
the total number of characters in the line to exceed the right margin
specified by the _.RIGHT MARGIN command or until a command which implies
a _.BREAK command is encountered.  If the number which follows the
_.RIGHT MARGIN command is unsigned, then this number will be used as
the right margin.  The right margin is assumed to be 60 if a _.RIGHT
MARGIN command has not yet been encountered.  If the number which
follows the _.RIGHT MARGIN command is signed, then the previous right
margin is adjusted by the indicated amount.  If no number follows the
_.RIGHT MARGIN command then the right margin is reset to the farthest
right margin which it has yet been set.  The _.RIGHT MARGIN command
implies a _.BREAK command.
.skip
.test page 3
The right margin is the maximum length of the line of text before the
application of the template line specified by a _.MASK command and
before the line is duplicated by a _.COPY command.  The right margin
does not include the leftmost spaces specified by the _.OFFSET command
or the single left space which is obtained if neither the _.OFFSET
command nor the _.NO OFFSET command has been issued.  The combination
of the right margin and the initial offset specified by the _.OFFSET
command cannot exceed 300.  The right margin is always assumed to be
large enough for the current line to include at least 1 word.  The
right margin is ignored if the lines of text are being represented
in no fill mode.
.skip
.test page 10
For example, the source text
.skip
.nofill
.test page 8
_.output width 55.carriage 1,*.preface       WRITE(1,$)
_.left margin 5.right margin 30.indent 5
The .RIGHT MARGIN command implies a .BREAK command.
_.right margin 40.indent -5
The .RIGHT MARGIN command applies only to text which is
constructed in fill mode.
_.nofill;The right margin is ignored in no fill mode.
_.program;      END
.skip
.fill
.test page 11
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 8
      WRITE(1,1)
    1 FORMAT(1H1,10X,20HThe  .RIGHT   MARGIN/7H*     c,
     124Hommand  implies a .BREAK/14H*     command./
     241H*The .RIGHT MARGIN command  applies  only/1H*,
     35X,35Hto  text  which  is  constructed in/4H*   ,
     412H  fill mode./29H*     The right margin is ign,
     521Hored in no fill mode.)
      END
.skip
.fill
.test page 10
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 7
1          The  .RIGHT   MARGIN
*     command  implies a .BREAK
*     command.
*The .RIGHT MARGIN command  applies  only
*     to  text  which  is  constructed in
*     fill mode.
*     The right margin is ignored in no fill mode.
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.SKIP multiple of extra line spacings to be generated
.skip
.test page 3
The _.SKIP command indicates that, after the representation in the
FORMAT statement of the previous text, a number of blank lines equal
to the specified multiple of the number which appeared to the right
of the previous _.SPACING command, or the specified number of blank
lines directly if a _.SPACING command has not yet been issued, are
to be represented in the FORMAT statement, in addition to any blank
lines specified by other _.BLANK or _.SKIP commands, and, if a _.SPACING
command has been issued, in addition to a number of blank lines equal
to one less than the number which appeared to the right of the previous
_.SPACING command.  If no number appears to the right of the _.SKIP
command, then the number 1 is assumed to appear to the right of the
_.SKIP command instead.  If a _.SPACING 2 command is in effect, then
a _.SKIP 3 command would result in (3*2)+(2-1) or 7 blank lines being
generated.  The _.SKIP command is similar to the _.BLANK command, except
that the _.BLANK command always specifies the number of extra blank
lines directly.  The _.SKIP command implies a _.BREAK command.
.skip
.test page 3
If no text has been represented in the FORMAT statements either since
this program was started or since the last _.TEXT command was issued,
then the _.SKIP command, like the _.BLANK command and the _.SKIP or
_.BLANK command implied by the _.PARAGRAPH command, is ignored unless
a _.LEADING command is in effect.  Blank lines which have not been
generated when the end of the source file is read or when the next
_.TEXT command is issued, but which have been requested by _.SKIP or
_.BLANK commands or which are necessary for the normal line spacing,
will be appended to the FORMAT statement being constructed if a _.TRAIL
command is then in effect.  Blank lines will be discarded when the
end of the source file is read or the next _.TEXT command is issued
if a _.NO TRAIL command is then in effect or if a _.TRAIL command has
not by then been issued.
.skip
.test page 15
For example, the source text
.skip
.nofill
_.spacing 2.output width 55
_.skip
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
_.skip
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
_.skip 2
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
_.skip 3
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
.skip
.fill
.test page 11
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
    1 FORMAT(38H The quick red fox jumps over the lazy,
     123H brown dog,  then  runs//17H into the forest./
     2///42H The quick red fox jumps over the lazy bro,
     319Hwn dog,  then  runs//17H into the forest./////
     4/44H The quick red fox jumps over the lazy brown,
     517H dog,  then  runs//17H into the forest.///////
     6/44H The quick red fox jumps over the lazy brown,
     717H dog,  then  runs//17H into the forest.)
.fill
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.SPACING separation from top of one line to top of next line
.skip
.test page 3
The _.SPACING command specifies the separation from the top of one
line of text to the top of the next line of text when the resulting
FORMAT statements are used.  The number specified by the _.SPACING
command is one greater than the number of blank lines which are to
separate lines of text which are constructed in fill mode or which
are copied in no fill mode.  The intervening blank lines which are
required when the _.SPACING command has specified a value greater than
1 are generated after each line of text, not before.  No blank lines
follow the final line of text unless a _.TRAILING command is in effect.
The _.SPACING command implies a _.BREAK command.  A _.SPACING 1 command
which gives single spacing with no intervening blank lines is assumed
to be in effect when this program is started.  If a line of text is
being constructed when the _.SPACING command is encountered, then the
number of blank lines which follow that line of text is determined
by the line spacing which was in effect during the construction of
that line of text, not by the newly specified spacing.
.skip
.test page 13
For example, the source text
.skip
.nofill
.test page 11
_.output width 55.right margin 54
_.carriage 1,*.preface       WRITE(1,$)
A .SPACING 1 command is assumed to be in effect when
this program is started.
_.spacing 2
No blank lines precede this since the .SPACING 2
command forced out previous line before taking effect.
_.blank 2;Normal spacing and 2 blank lines
_.skip 2;Normal spacing and 2 multiples of 2 blank lines
_.paragraph 5,2;Paragraph similar to .skip 2.indent 5
_.program;      END
.skip
.fill
.test page 14
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 11
      WRITE(1,1)
    1 FORMAT(38H1A .SPACING 1 command is assumed to be,
     117H in  effect  when/24H*this program is started,
     21H./41H*No blank lines  precede  this  since  th,
     314He  .SPACING  2/1H*/23H*command forced out pre,
     432Hvious line before taking effect./1H*/1H*/1H*/
     533H*Normal spacing and 2 blank lines/1H*/1H*/1H*/
     61H*/1H*/37H*Normal spacing and 2 multiples of 2 ,
     711Hblank lines/1H*/1H*/1H*/1H*/1H*/10H*     Para,
     833Hgraph similar to .skip 2.indent 5)
      END
.skip
.fill
.test page 24
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 21
1A .SPACING 1 command is assumed to be in  effect  when
*this program is started.
*No blank lines  precede  this  since  the  .SPACING  2
*
*command forced out previous line before taking effect.
*
*
*
*Normal spacing and 2 blank lines
*
*
*
*
*
*Normal spacing and 2 multiples of 2 blank lines
*
*
*
*
*
*     Paragraph similar to .skip 2.indent 5
.FILL
.skip 2.TEST PAGE 6
.left margin 5
.indent -5
_.TEXT next statement number, statement number increment
.skip
.test page 3
The _.TEXT command indicates that no additional text is to be
represented by the FORMAT statement currently being constructed and
that the text appearing in subsequent lines in the source file is to
be represented in a new FORMAT statement.  The preface line, if any,
indicated by a previous _.PREFACE command will be written into the
output before this next FORMAT statement.  All unused output field
descriptions previously specified by _.INSERT commands will be
discarded.  If the _.TEXT command is issued within the range of a
_.PROGRAM command, then the range of the _.PROGRAM command is
terminated.  Blank lines which have not yet been generated, but which
have been requested by _.SKIP or _.BLANK commands or which are necessary
for multiple line spacing, will be appended to the FORMAT statement
currently being constructed if a _.TRAILING command is in effect.  Such
trailing blank lines will be discarded before the new FORMAT statement
is begun if a _.NO TRAILING command is in effect or if a _.TRAILING
command has not been issued.  If the _.TEXT command is followed by
_.SKIP or _.BLANK commands before the next text which is to be
represented in the FORMAT statements, then these leading blank lines
will be represented only if a _.LEADING command is in effect.  Such
leading blank lines are discarded if a _.NO LEADING command is in effect
or if a _.LEADING command has not been issued.  The _.TEXT command
is identical to the _.CONTINUE command, except that a _.CONTINUE command
would retain all previously specified but unused field descriptions,
and, providing that there is additional text to be represented, a
_.CONTINUE command would represent all blank lines which have not yet
been generated.
.skip
.test page 3
The numbers which can follow the _.TEXT command are identical to those
which can follow the _.CONTINUE and _.PROGRAM commands.  The first
number which can follow any of these commands modifies the statement
number of the next FORMAT statement.  The second number which can follow
any of these commands becomes the statement number increment after
the generation of the next FORMAT statement.  The description of the
_.CONTINUE command describes the interpretation of these numbers in
detail.  If the statement number of the FORMAT statement following
a section of program text indicated by an initial _.PROGRAM command
is to be modified, but the program text includes dollar signs which
are to be replaced by this statement number, then this statement number
should be modified by the _.PROGRAM command rather than by the following
_.TEXT or _.CONTINUE command, since, if the modification is done by
the _.TEXT or _.CONTINUE command, then incorrect statement numbers
will have been inserted into the program text.
.skip
.test page 18
For example, the source text
.skip
.nofill
_.spacing 2.output width 55
_.text 10,10;.preface       WRITE(1,$)
_.insert I2
_.insert F2
The quick red fox jumps $$ feet over the lazy brown dog
_.text
The quick red fox jumps $$ feet over the lazy brown dog
_.skip;.text +100
_.insert I2
_.insert F2
_.insert A2
The quick red fox jumps $$ feet over the lazy brown dog
_.continue,5
The quick red fox jumps $$ feet over the lazy brown dog
_.skip;_.continue
The quick red fox jumps $$ feet over the lazy brown dog
.skip
.fill
.test page 17
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
      WRITE(1,10)
   10 FORMAT(25H The quick red fox jumps ,I2,7H feet o,
     122Hver the lazy brown dog)
      WRITE(1,20)
   20 FORMAT(25H The quick red fox jumps ,9H feet ove,
     120Hr the lazy brown dog)
      WRITE(1,120)
  120 FORMAT(25H The quick red fox jumps ,I2,7H feet o,
     122Hver the lazy brown dog)
      WRITE(1,130)
  130 FORMAT(/25H The quick red fox jumps ,F2,6H feet ,
     123Hover the lazy brown dog)
      WRITE(1,135)
  135 FORMAT(///25H The quick red fox jumps ,A2,4H fee,
     125Ht over the lazy brown dog)
.fill
.skip 2
.left margin 5
.fill
.test page 6
.indent -5
_.TRAILING
.skip
.test page 3
The _.TRAILING command indicates that the FORMAT statements are to
include blank lines resulting from _.SKIP or _.BLANK commands issued
after all text has been represented in the FORMAT statements and are
to include the blank lines necessary for multiple line spacing following
the final line of text represented in the FORMAT statements.  If a
_.TRAILING command has not been issued, or if a _.NO TRAILING command
has been issued more recently than a _.TRAILING command, then each
_.TEXT command and the reading of the end of the file (or the issuing
of an _.END OF FILE command) instead discards all blank lines which
did not precede text which has been represented in the FORMAT
statements.  Neither the _.TRAILING command nor the _.NO TRAILING
command implies a _.BREAK command.
.skip
.test page 15
For example, the source text
.skip
.nofill
_.spacing 2.output width 55.use'.offset 0.text 10
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
_.text 20
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
_.skip.text 30.trail
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
_.text 40
The quick red fox jumps over the lazy brown dog,
then runs into the forest.
_.skip
.skip
.fill
.test page 11
would be transformed into the following FORTRAN text when processed
by this program.
.nofill
.skip
   10 FORMAT('The quick red fox jumps over the lazy b',
     1'rown dog,  then  runs'//'into the forest.')
   20 FORMAT('The quick red fox jumps over the lazy b',
     1'rown dog,  then  runs'//'into the forest.')
   30 FORMAT('The quick red fox jumps over the lazy b',
     1'rown dog,  then  runs'//'into the forest.'/)
   40 FORMAT('The quick red fox jumps over the lazy b',
     1'rown dog,  then  runs'//'into the forest.'///)
.fill
.skip 2
.fill
.left margin 5
.test page 6
.indent -5
_.UPPER CASE
.skip
.test page 3
The _.UPPER CASE command indicates that the cases of all alphabetic
letters which are not specially marked are to be retained in the source
text which follows the end of the command or, if the _.UPPER CASE
command is followed by a comment, in the source text which follows
the comment.  Regardless of the issuing of the _.UPPER CASE command,
any letter which is preceded by a back slash is still converted to
its lower case form, any letter which is preceded by a circumflex is
still converted to its upper case form, and, providing that a _.FLAGS
CAPITALIZE command has been issued, any letter which is in a word which
is preceded by a less than sign is also converted to its upper case
form.  The _.UPPER CASE command is equivalent to the appearance of
2 consecutive circumflexes except that the 2 circumflexes can appear
anywhere and that the retention of cases indicated by the 2 circumflexes
is applied immediately to all of the following text.  An _.UPPER CASE
command is assumed to be in effect when this program is started.  Upper
case letters will instead be converted to their lower case forms if
the _.LOWER CASE command or the equivalent 2 consecutive back slashes
are issued.  Neither the _.UPPER CASE command nor the _.LOWER CASE
command implies a _.BREAK command.
.skip
.test page 13
For example, the source text
.skip
.nofill
.test page 11
_.offset 0.right margin 55.output width 55
_.flags capitalize.preface       WRITE(1,$)
An <.upper _^c_^a_^s_^e _\C_\O_\M_\M_\A_\N_\D does not have to be
issued when this program is first started.
_.lower case
_^A <.LOWER _^C_^A_^S_^E _\C_\O_\M_\M_\A_\N_\D CAN BE ISSUED TO
CAUSE CONVERSION TO LOWER CASE.
_.upper case
The <.upper _^c_^a_^s_^e _\C_\O_\M_\M_\A_\N_\D can, of course, be
reissued at any time.
_.program;      END
.skip
.fill
.test page 11
would, when processed by this program, be transformed into the following
FORTRAN text
.skip
.nofill
.test page 8
      WRITE(1,1)
    1 FORMAT(38HAn .UPPER CASE command does not have t,
     117Ho be issued  when/24Hthis  program  is first ,
     231Hstarted.  A .LOWER CASE command/10Hcan be iss,
     345Hued to cause conversion to lower  case.   The/
     445H.UPPER  CASE command can, of course, be reiss,
     510Hued at any/5Htime.)
      END
.skip
.fill
.test page 8
which would, in turn, generate the following text when run.
.skip
.nofill
.test page 5
An .UPPER CASE command does not have to be issued  when
this  program  is first started.  A .LOWER CASE command
can be issued to cause conversion to lower  case.   The
_.UPPER  CASE command can, of course, be reissued at any
time.
.skip 2
.left margin 5
.test page 6
.fill
.indent -5
_.USE character implying text representation notation
.skip
.test page 3
The _.USE command specifies the notation which is to be used to
represent the text in the FORMAT statements being generated.  If the
next printing character following the _.USE command is either an upper
or lower case letter H, then the text will be represented in Hollerith
notation as the number of characters followed by the letter H in the
case indicated and then by the characters of the text.  If the next
printing character following the _.USE command is not the letter H,
then that character will be appended to both ends of the text and will
be doubled wherever it appears within the text.  _.USE' would select
apostrophe notation, and _.USE* would select the asterisk notation
used by some computers which do not include the apostrophe in their
character sets.  The _.USE command, like most other commands which
merely describe the manner in which the text is represented in the
FORMAT statements, does not imply a _.BREAK command.
.skip
.test page 3
One or more spaces can appear between the _.USE command and the
following printing character, but are not required.  In order for a
space, number sign, circumflex, back slash, less than sign (if in flag
capitalize mode), period, semicolon, exclamation point or underscore
to be specified by the _.USE command as the delimiting character, this
character would have to be preceded by an underscore.
.skip
.test page 7
For example, the source text
.skip
.nofill
_.out width 55;one * two ** three ' four '' five
_.break.use'  ;one * two ** three ' four '' five
_.break.use * ;one * two ** three ' four '' five
_.break.useH  ;one * two ** three ' four '' five
_.break.use h ;one * two ** three ' four '' five
.skip
.fill
.test page 8
would be transformed into the following FORTRAN text when processed
by this program.
.skip
.nofill
    1 FORMAT(34H one * two ** three ' four '' five/' ',
     1'one * two ** three '' four '''' five'/* one ***,
     2* two **** three ' four '' five*/12H one * two *,
     322H* three ' four '' five/19h one * two ** three,
     415h ' four '' five)
.fill
.left margin 0
.fill
.left margin 0
.page.initial page.skip left page.initial page
.RIGHT TOP TITLE'Commands Needed for Paging on Video Terminals',,'>'
.center
Chapter 4
.skip
.center
COMMANDS NEEDED FOR PAGING ON VIDEO TERMINALS
.skip 3
.center
Introduction
.center
------------
.skip
On some computer systems, the lines which have been displayed on a
video terminal are counted and the system pauses each time that enough
new text has been generated to fill the screen.  When the text on the
screen is erased, enough lines are displayed from the top down until
the screen fills again, and then the typing of text pauses.  If the
screen is already full, then each new line is displayed first at the
bottom of the screen.  The lines already on the screen are shifted
upward as new lines are added and the top line disappears.  The typing
of text pauses each time that the first line which was displayed after
the previous pause would be lost.
.skip.test page 3
After each pause, the user is expected to instruct the system to resume
the typing of the text.  This assures that the user has a chance to
read all of the text which is on the screen.  The extra interaction
is acceptable to the user if most of the text which is displayed was
generated by the program.  However, the user will already have read
the text on the screen anyway if the user is interacting every few
lines with the program.  If the program usually types much less than
a full screen after each interaction with the user, then it may be
better to turn off the automatic pausing each time that the screen
is filled, and to instead have the program, rather than the computer
system upon which the program is being run, parcel out the lines in
the longer messages.
.skip.test page 3
The commands described in the previous portion of this manual are
sufficient for the construction of short messages, for the construction
of long messages which will be typed onto paper, and for the
construction of long messages which will be displayed on video terminals
which pause automatically each time the screen fills.  However, if
the system cannot pause each time the screen fills on a video terminal,
or if this function is turned off so that short sections of dialog
are not interrupted unexpectedly, then the program will have to count
the lines in long messages and pause at the proper points.  The FORTRAN
code to produce these pauses could be inserted by hand.  This could
be done by finding the points in the message at which the screen fills,
breaking the lines in the source text at these points, and then
inserting at each of these points a _.PROGRAM command followed by the
FORTRAN code which waits for the user to do something such as press
the RETURN key.  If the text is being justified, then number signs
which produce spaces in the resulting text would have to be inserted
into the bottom line on each page to get the bottom line to be the
same length as the rest of the lines on the page.  Of course, if the
message is ever revised, or if the margins or the number of lines which
can be displayed on a single screen are ever changed, then the _.PROGRAM
commands and the following FORTRAN code and the number signs which
were used to obtain the extra spaces would have to be removed before
determining the breaks between the new pages.
.skip.test page 3
The FORMAT program provides a set of commands which perform all of
the operations necessary for dividing the messages into pages each
just large enough to fill the screen.  These commands are described
in this chapter.  The resulting FORTRAN code has the general form which
is outlined below.  Where FORTRAN code is indicated as being inserted
at the start of a message, at the start of a new page, or after a
completed page, each of these types of insertions can consist of several
lines and can contain unique statement numbers both in the statement
number field and in the text of the statements.  The WRITE statements
represent the FORTRAN code which is specified by the _.PREFACE command
and which is inserted before each individual FORMAT statement, but
this code could also consist of several lines.  The multiple dots
indicate lines which are not shown in the outline but which would fill
out the page in an actual application.
.nofill.skip.test page 31
      FORTRAN code to begin a new message

      FORTRAN code to clear screen before new page

      WRITE(ITTY,101)
  101 FORMAT(' Text at top of first page'/ ... )
         .
         .
      WRITE(ITTY,103)
  103 FORMAT( ... /' Text in middle of first page'/ ... )
         .
         .
      WRITE(ITTY,105)
  105 FORMAT( ... /' Text at bottom of first page')

      FORTRAN code to pause at bottom of page

      FORTRAN code to clear screen before new page

      WRITE(ITTY,106)
  106 FORMAT(' Text at top of second page'/ ... )
         .
         .
      WRITE(ITTY,103)
  108 FORMAT( ... /' Text in middle of second page'/ ... )
         .
         .
      WRITE(ITTY,110)
  110 FORMAT( ... /' Text at bottom of second page')

      FORTRAN code to pause at bottom of page
.fill.skip
The parcelling out of lines into pages is activated by issuing a
_.PAGING command.  The number of lines displayed on the page is set
to zero when this program is started and after each new _.TEXT command.
The lines which are counted are, of course, the lines which result
when the FORMAT statements are used, not the lines in the source text
which is being processed.  If a _.PAGING command has not been issued,
then page breaks are not automatically inserted into the messages but
the counting of lines is still performed.  A new page can be forced
at any point.  The number of lines remaining unused at the bottom of
the page can be tested and a new page can be forced if too few lines
remain unused.  The bottoms of the pages can be filled out with extra
blank lines, or enough blank lines can be inserted to cause the next
line to be any desired distance from the bottom of the page.  The
character inserted into column 1 as a carriage control can also be
made different for the first line on a page.

.skip.test page 3
Since the parcelling out of lines into pages depends upon the insertion
of FORTRAN code before and after the text on each page, the number
of lines which can be displayed on each page must be indicated in the
text which the FORMAT program processes.  Consequently, the resulting
FORTRAN program can only be used on terminals which can display at
least this number of lines on the screen.  The source text must be
changed and the FORMAT program must be run again if the resulting
FORTRAN code is to be used with a video terminal which cannot display
as many lines on the screen.  It is suggested that the smallest screen
size be made the standard if the resulting FORTRAN program is to be
used with terminals having different screen sizes.  However, provided
that the type of terminal being used is known, the FORTRAN text which
is inserted at the tops and at the bottoms of the pages can be written
in such a manner that the same resulting FORTRAN code can be used with
hardcopy terminals, with video terminals which can only scroll new
text into the bottom of the screen, and with video terminals which
can clear the screen under program control.  It is only necessary that
the code to clear the screen and to pause at the bottom of the screen
be skipped if a hardcopy terminal is used, and that the code which
clears the screen be skipped if the terminal cannot clear the screen.
.PAGE.FILL
.CENTER
Example of FORTRAN Code Containing Several Messages
.center
------- -- ------- ---- ---------- ------- --------
.skip.test page 3.fill
If the FORMAT program is used to process a group of messages, then
the resulting FORTRAN code should also include the logic necessary
to select among these messages.  The resulting FORTRAN code might be
similar to the subroutine which is outlined below.  This subroutine
can display any 1 of 3 messages.  Paging is activated only during the
processing of the second message, which is assumed to be longer than
the others.  Even if paging is activated for the longer messages, it
should still be turned off for messages which use much less than a
full page.
.skip.test page 10.nofill
      SUBROUTINE HELP(ITTY,KNDMSG)
C     ITTY   = UNIT NUMBER ON WHICH TO DISPLAY MESSAGE
C     KNDMSG = SELECTS WHICH MESSAGE IS DISPLAYED
      GO TO(100,200,300),KNDMSG
      GO TO 4
  100 CONTINUE
      WRITE(ITTY,101)
  101 FORMAT(' Short first message')
      GO TO 4
  200 CONTINUE
      WRITE(ITTY,1)
      WRITE(ITTY,201)
  201 FORMAT(' First lines on 1st page of 2nd message')
         .
      write and format statements for middle of page
         .
      WRITE(ITTY,205)
  205 FORMAT(' Final lines on 1st page of 2nd message')
      WRITE(ITTY,2)
      READ(ITTY,3)IPAUSE
      WRITE(ITTY,1)
      WRITE(ITTY,206)
  206 FORMAT(' First lines on 2nd page of 2nd message')
         .
      write and format statements for middle of page
         .
      WRITE(ITTY,210)
  210 FORMAT(' Final lines on 2st page of 2nd message')
      WRITE(ITTY,2)
      READ(ITTY,3)IPAUSE
      GO TO 4
  300 CONTINUE
      WRITE(ITTY,301)
  301 FORMAT(' Short third message')
    1 FORMAT('1Top line on page')
    2 FORMAT(' Press RETURN to continue')
    3 FORMAT(1A1)
    4 RETURN
      END
.fill
.skip.test page 3
The original source text which would be processed to produce the
subroutine shown above is outlined below.  The FORTRAN statements at
the start and end of the subroutine were programmed in the conventional
manner and are merely copied into the resulting file.  The FORTRAN
statements starting with the SUBROUTINE statement and extending through
the computed GO TO statement appear after a _.PROGRAM command in the
original source text.  Likewise, the FORMAT, RETURN and END statements
at the end of the subroutine also appear after a _.PROGRAM command.
The GO TO 4 statement which transfers back to the calling program after
the previous message and the labeled CONTINUE statement which defines
the start of the section to which the computed GO TO transfers are
defined by a _.DEFINE GROUP command and are inserted before the start
of each message.  The WRITE(ITTY,1) statement which clears each page
is defined by a _.DEFINE TOP command and is inserted at the top of
each page.  The WRITE(ITTY,2) statement and READ(ITTY,3)IPAUSE statement
which tell the user that the program is pausing and then wait for the
user to press the RETURN key are defined by a _.DEFINE BOTTOM command
and are inserted at the bottom of each page.
.skip.nofill.test page 10
.define group
      GO TO 4
$$$$$ CONTINUE$=
_.define top
      WRITE(ITTY,1)
_.define bottom
      WRITE(ITTY,2)
      READ(ITTY,3)IPAUSE
_.define preface
      WRITE(ITTY,$)
_.program
      SUBROUTINE HELP(ITTY,KNDMSG)
C     ITTY   = UNIT NUMBER ON WHICH TO DISPLAY MESSAGE
C     KNDMSG = SELECTS WHICH MESSAGE IS DISPLAYED
      GO TO(100,200,300),KNDMSG
_.use '
_.text 100
         .
      text of short first message
         .
_.text 200
_.paging
         .
      text of long second message
         .
_.page
_.no paging
_.text 300
         .
      text of short third message
         .
_.program
    1 FORMAT('1Top line on page')
    2 FORMAT(' Press RETURN to continue')
    3 FORMAT(1A1)
    4 RETURN
      END
.fill.skip.test page 3
If the resulting FORTRAN code is to be used with different types of
terminals, then the FORTRAN code which is inserted at the tops and
bottoms of the pages must perform differently depending upon the type
of terminal being used.  For example, if a variable named IVIDEO is
defined so that
.skip.left margin 9
.indent-9
IVIDEO#=#-1, if a hardcopy terminal is being used
.skip.test page 3.indent -2
=#0, if a video terminal is being used which can scroll but which cannot
clear the screen under program control
.skip.test page 3.indent -2
=#1, if a video terminal is being used which can both scroll and clear
the screen under program control
.skip.left margin 0.test page 3
then all of these types of terminals would be handled properly if the
text which is inserted at the tops and at the bottoms of the pages
is similar to
.skip.test page 7.nofill
_.DEFINE TOP
      IF(IVIDEO.LE.0)GO TO 5
         .
      code to clear the screen
         .
    5 CONTINUE
_.END DEFINITION
.SKIP
and
.skip.TEST PAGE 7
_.DEFINE BOTTOM
      IF(IVIDEO.LT.0)GO TO 6
         .
      code to pause when the screen fills
         .
    6 CONTINUE
_.END DEFINITION
.FILL
.page
.fill.left margin 0
.center
Short Descriptions of the Paging Commands
.center
----- ------------ -- --- ------ --------
.skip.fill.left margin 0
Most of the commands which are summarized in this section of the manual
and which are described in detail later in this chapter are used only
when the lines in long messages are being parcelled out into pages.
In addition, the _.BLANK, _.LEADING, _.NO LEADING, _.NO TRAILING,
_.PARAGRAPH, _.SKIP and _.TRAILING commands, which were described in
an earlier chapter, are interpreted slightly differently when paging
is being performed.  These differences are also described here.
.skip
Above the description of each command is shown the command name in
capital letters together with a one line summary in small letters of
the numbers, characters or line of text which can appear to its right.
To make the descriptions easier to read, the command names are always
capitalized in the descriptions, but the commands would not have to
be capitalized in the actual source text which is processed by the
FORMAT program.
.left margin 5
.skip.test page 5.indent -5
_.BLANK number of single spaced lines at page bottom times -1
.skip
Enough blank lines are inserted so that there is just enough room left
at the bottom of the page for the indicated number of single spaced
lines.  See also the _.SKIP command.
.skip.test page 9.indent -5
_.BOTTOM line of text to be inserted at bottom of each page
.skip
The line of text which appears to the right of the _.BOTTOM command
is to be copied into the output file after the FORMAT statement which
contains the final line which is to be displayed on each page.  The
_.BOTTOM command can be cancelled by a _.NO BOTTOM command.  _.NO BOTTOM
is the default.  A group of lines to be inserted at the bottom of each
page can be defined by the _.DEFINE BOTTOM command instead.
.skip.test page 8.indent -5
_.DEFINE BOTTOM
.skip
The following lines of text through the next _.END DEFINITION command
or the next of any of the various _.DEFINE commands are to be copied
into the output file after the FORMAT statement which contains the
final line which is to be displayed on each page.  A single line to
be inserted at the bottom of each page can be defined by the _.BOTTOM
command instead.
.skip.test page 8.indent -5
_.DEFINE TOP
.skip
The following lines of text through the next _.END DEFINITION command
or the next of any of the various _.DEFINE commands are to be copied
into the output file before the FORMAT statement which contains the
first line which is to be displayed on each page.  A single line to
be inserted at the top of each page can be defined by the _.TOP command
instead.
.skip.test page 6.indent -5
_.LEADING
.skip
Blank lines are to be retained at the top of each new page.  Opposite
of _.NO LEADING which is the default.  Blank lines at the bottom of
the page are discarded unless a _.TRAILING command has been issued.
.skip.test page 4.indent -5
_.NO BOTTOM
.skip
No line of text is to be inserted at the bottom of each new page.
Opposite of _.BOTTOM.  _.NO BOTTOM is the default.
.skip.test page 4.indent -5
_.NO LEADING
.skip
Blank lines are discarded at the top of each page.  Opposite of
_.LEADING.  _.NO LEADING is the default.
.skip.test page 5.indent -5
_.NO PAGE CARRIAGE
.skip
No special character is to replace the space in the leftmost column
of the lines which are included on each.  Opposite of _.PAGE CARRIAGE.
_.NO PAGE CARRIAGE is the default.
.skip.test page 8.indent -5
_.NO PAGING
.skip
The current FORMAT statement is not terminated and a new page is not
begun each time that the page fills.  However, _.PAGE commands can
still be issued to begin a new page and _.TEST PAGE and _.TEST SPACING
commands can still be issued to begin a new page if there are less
than the indicated number of lines remaining unused on the page.
Opposite of _.PAGING.  _.NO PAGING is the default.
.skip.test page 4.indent -5
_.NO TOP
.skip
No line of text is to be inserted at the top of each new page.  Opposite
of _.TOP.  _.NO TOP is the default.
.skip.test page 6.indent -5
_.NO TRAILING
.skip
Blank lines are discarded at the bottom of each page.  The page is
not filled out with blank lines to make the number of lines on the
page equal the page size indicated by the _.PAGE LENGTH command.
Opposite of _.TRAILING.  _.NO TRAILING is the default.
.skip.test page 11.indent -5
_.PAGE
.skip
The following text is to be displayed on a new page.  If there is
already something on the current page, then the current FORMAT statement
is terminated and the line defined by the _.BOTTOM command is copied
into the output file.  If subsequent lines of text are represented
in the FORMAT statements, then the line defined by the _.TOP command
is copied into the output file before the next FORMAT statement and
the first character defined by the _.PAGE CARRIAGE command replaces
the space in the leftmost column of the first line represented in the
next FORMAT statement.
.skip.test page 7.indent -5
_.PAGE CARRIAGE carriage control for top line, for next lines
.skip
The first character which is specified is to replace the space in the
leftmost column of the first line on each page.  If a second character
is specified, it is to replace the space in the leftmost column of
each of the subsequent lines on the page.  Opposite of _.NO PAGE
CARRIAGE which is the default.
.skip.test page 5.indent -5
_.PAGE LENGTH maximum number of lines on single page
.skip
If paging is enabled, then a new page is begun each time that the
indicated number of lines have been represented on the current page.
.skip.test page 11.indent -5
_.PAGE POSITION line count on page as unsigned number
.break
or
.indent -5
_.PAGE POSITION adjustment of line count as signed number
.skip
If the number following the _.PAGE POSITION is unsigned, then this
number is taken to be the number of lines already represented on the
current page.  If the number is signed, then the number of lines already
on the page is taken to be the number already on the page adjusted
by the indicated number.  This command does not insert or remove any
lines from the page but merely places the page boundary after a
different line.
.skip.test page 6.indent -5
_.PAGING
.skip
The current FORMAT statement is terminated and a new page is begun
each time that the page fills.  This parcelling out of lines into pages
continues through the rest of the file.  Opposite of _.NO PAGING which
is the default.
.skip.test page 6.indent-5
_.PARAGRAPH indent, skip lines, unused lines needed on page
.skip
If a _.PAGING command has been issued, then a new page is begun if
there is not enough room left on the current page for the indicated
number of additional lines of text at the current line spacing.  The
next line of text will be placed into a new paragraph.
.skip.test page 6.indent -5
_.RESUME BOTTOM
.skip
The line or lines of text which were defined by either a _.BOTTOM
command or a _.DEFINE BOTTOM command but which were disabled by a
subsequent _.NO BOTTOM command are to again be inserted at the bottom
of each new page.
.skip.test page 6.indent -5
_.RESUME TOP
.skip
The line or lines of text which were defined by either a _.TOP command
or a _.DEFINE TOP command but which were disabled by a subsequent _.NO
TOP command are to again be inserted at the top of each new page.
.skip.test page 5.indent -5
_.SKIP number of normal spaced lines at page bottom times -1
.skip
Enough blank lines are inserted so that there is just enough room left
at the bottom of the page for the indicated number of lines at the
current line spacing.  See also the _.BLANK command.
.skip.test page 4.indent -5
_.TEST PAGE number of single spaced lines needed on page
.skip
A new page is begun if there is not enough room left on the page for
the indicated number of additional single spaced lines of text.
.skip.test page 5.indent -5
_.TEST SPACING number of multiple spaced lines needed on page
.skip
A new page is begun if there is not enough room left on the page for
the indicated number of additional lines of text at the current line
spacing.
.skip.test page 8.indent -5
_.TOP line of text to be inserted at top of each page
.skip
The line of text which appears to the right of the _.TOP command is
to be copied into the output file before the FORMAT statement which
contains the first line which is to be displayed on each page.  The
_.TOP command can be cancelled by a _.NO TOP command.  _.NO TOP is
the default.  A group of lines to be inserted at the top of each page
can be defined by the _.DEFINE TOP command instead.
.skip.test page 10.indent -5
_.TRAILING
.skip
The bottom of each page will be filled with enough blank lines to make
the number of lines on the page equal the page size specified by the
_.PAGE LENGTH command.  Opposite of _.NO TRAILING which is the default.
Blank lines at the top of the page are discarded unless a _.LEADING
command has been issued.  Blank lines before a _.TEXT command or at
the end of the document are discarded unless a _.TRAILING command has
been issued and an extra _.PAGE command appears at these locations.
.page.left margin 0.nofill
Table of Command Argument Types and Whether BREAK is Implied
----- -- ------- -------- ----- --- ------- ----- -- -------
.skip
Basic         Is .BREAK   Argument      Corresponding
Command         Implied   Type          NO Command
.skip
_.BLANK              yes   negative number
_.BOTTOM             no    text          .NO BOTTOM
_.DEFINE BOTTOM      no    several lines .NO BOTTOM
_.DEFINE TOP         no    several lines .NO TOP
_.LEADING            no    none          .NO LEADING
_.PAGE               yes   none
_.PAGE CARRIAGE      no    2 characters  .NO PAGE CARRIAGE
_.PAGE LENGTH        no    1 number
_.PAGE POSITION      yes   1 number
_.PAGING             yes   none          .NO PAGING
_.PARAGRAPH          yes   3 numbers
_.RESUME BOTTOM      no    none
_.RESUME TOP         no    none
_.SKIP               yes   negative number
_.TEST PAGE          yes   1 number
_.TEST SPACING       yes   1 number
_.TOP                no    text          .NO TOP
_.TRAILING           no    none          .NO TRAILING
.fill
.left margin 0
.page
.center
Complete Descriptions of the Paging Commands
.center
-------- ------------ -- --- ------ --------
.skip
Most of the commands which were summarized earlier in this chapter
and which are described in detail in this section of the manual are
used only when the lines in long messages are being parcelled out into
pages.  In addition, the _.BLANK, _.LEADING, _.NO LEADING, _.NO
TRAILING, _.PARAGRAPH, _.SKIP and _.TRAILING commands, which were
described in an earlier chapter, are interpreted slightly differently
when paging is being performed.  These differences are also described
here.
.skip
Above the description of each command is shown the command name in
capital letters together with a one line summary in small letters of
the numbers, characters or line of text which can appear to its right.
To make the descriptions easier to read, the command names are always
capitalized in the descriptions, but the commands would not have to
be capitalized in the actual source text which is processed by the
FORMAT program.
.skip
.left margin 5
.fill
.test page 6
.indent -5
.left margin 5.indent -5
_.BLANK number of single spaced lines at page bottom times -1
.skip
If the _.BLANK command is followed by a negative number, then enough
blank lines are to be generated before the next line of text which
is represented in the FORMAT statements to cause there to be room for
only the indicated number of single spaced lines to be printed at the
bottom of the page.  The _.SKIP command can similarly be followed by
a negative number to cause enough blank lines to be generated to allow
room for only the indicated number of lines to be printed at the current
line spacing at the bottom of the page.
.skip.test page 3
If a _.SPACING 2 command has been issued to give double spacing, then
a _.SKIP-5 command would be equivalent to a _.BLANK-9 command, not
to a _.BLANK-10 command, since the line spacing after the bottom double
spaced line would not be included in the line count.  Except for the
adjustment of the number appearing to the right of the _.SKIP command
to allow for the current line spacing, the _.BLANK and _.SKIP commands
perform identically.  The description of the _.SKIP command appearing
later in this section of the manual should be consulted for additional
information.
.left margin 5
.skip 2.test page 4.indent -5
_.BOTTOM line of text to be inserted at bottom of each page
.SKIP
The characters which appear to the right of the _.BOTTOM command on
the same line are to be copied into the output file on a separate line
after the FORMAT statements which represent each completed page.  The
character to the immediate right of the _.BOTTOM command must be a
space.  The line of text which is to be copied into the output file
after each completed page starts with the second character to the right
of the _.BOTTOM command, whether or not this is a printing character,
and extends through the rightmost printing character on the line.  The
line of text specified by the _.BOTTOM command is copied into the output
file as a line of ordinary FORTRAN text.  This line is not represented
in the FORMAT statements.  For example, the line of text specified
by the _.BOTTOM command might be used to cause the program to pause
after a page of text has been displayed until the user types something
on the terminal.  The rules which govern the specification of the line
which is defined by the _.BOTTOM command are identical to those which
are described earlier in the manual for the _.PREFACE command.
.skip.test page 3
Provided that there is already something on the page, the line of text
specified by the _.BOTTOM command is copied into the output file
whenever a _.PAGE command is issued, or whenever a _.TEST PAGE or a
_.TEST SPACING command fails, or, provided that a _.PAGING command
has been issued, whenever either the page fills or a _.PARAGRAPH command
is issued near the bottom of the page.  If a _.TRAILING command has
been issued, then enough blank lines are first represented in the FORMAT
statement to fill the rest of the page before the line specified by
the _.BOTTOM is copied into the output file.  It is not necessary that
a _.PAGING command have been issued before the _.PAGE or the _.TEST
PAGE or the _.TEST SPACING command.
.skip.test page 3
If more than a single line must be inserted after the FORMAT statements
which represent each completed page, then a _.DEFINE BOTTOM command
followed by the lines of text and then by an _.END DEFINITION command
should be used to define the lines instead.  Regardless of which method
is used to define the line or lines, the insertions of the line or
lines are performed similarly.  The line of text specified by the
_.BOTTOM command or the lines specified by the _.DEFINE BOTTOM command
will continue to be inserted into the output file after the FORMAT
statements representing each completed page of text until a subsequent
_.NO BOTTOM command is issued.  The insertion of the line or lines
will be resumed if a _.RESUME BOTTOM command is issued after the _.NO
BOTTOM command.
.skip.test page 3
If the current page is empty and a _.PAGE POSITION command has not
been issued, then a _.PAGE or _.TEST PAGE or _.TEST SPACING command
will not fill the page with blank lines and will not cause the line
of text specified by the _.BOTTOM command to be inserted into the output
file.  If paging has been enabled, but the page is not completely full
when a _.TEXT command is encountered or when the end of the source
file is reached, then the rest of the page is not filled with blank
lines and the line of text specified by the _.BOTTOM command is not
inserted unless a _.TEST PAGE or a _.TEST SPACING command which fails
or a _.PAGE command is inserted before the _.TEXT command or before
the end of the input file.  Inserting an extra _.PAGE command before
the _.TEXT command or before the end of the input file will not cause
any problems even if the final page is completely full.
.skip.test page 12
For example, the source text
.skip.nofill.test page 10
_.page length 5.right margin 14.output width 55
_.paging.page carriage 1.no justify.trailing
_.preface       WRITE(ITTY,$)
_.bottom       READ(ITTY,999)LTRDMY
This is some text on the first page.
It will be filled with relatively little text.
_.page
This comes after the page command.
_.program
  999 FORMAT(1A1)
.skip.fill.TEST PAGE 14
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill.test page 11
      WRITE(ITTY,1)
    1 FORMAT(13H1This is some/12H text on the/6H first,
     16H page./11H It will be/12H filled with)
      READ(ITTY,999)LTRDMY
      WRITE(ITTY,2)
    2 FORMAT(11H1relatively/13H little text.///)
      READ(ITTY,999)LTRDMY
      WRITE(ITTY,3)
    3 FORMAT(11H1This comes/15H after the page/5H comm,
     14Hand.)
  999 FORMAT(1A1)
.skip.fill.TEST PAGE 10
which would, in turn, generate the following pages of text
when run.
.skip.nofill
.NOFILL.TEST PAGE 7
*****************  *****************  *****************
*1This is some  *  *1relatively    *  *1This comes    *
* text on the   *  * little text.  *  * after the page*
* first page.   *  *               *  * command.      *
* It will be    *  *               *  *****************
* filled with   *  *               *
*****************  *****************
.FILL
.left margin 5
.skip 2.test page 6.indent -5
_.DEFINE BOTTOM
.SKIP
The _.DEFINE BOTTOM command indicates that the following lines of source
text which do not start with periods are to be copied into the output
file after the FORMAT statements which represent each completed page.
The lines which are to be inserted into the output file will include
all of the lines which do not start with periods in the source text
up to the next _.END DEFINITION, _.PROGRAM, _.TEXT, _.CONTINUE, _.GROUP,
_.PREFACE, _.TOP or _.BOTTOM command or up to any of the various
_.DEFINE commands.  If just a single line is to be inserted, then it
could also be defined by a _.BOTTOM command.  The single line would
appear to the right of the _.BOTTOM command on the same line.  Unlike
the _.BOTTOM command, however, the first line of text cannot appear
to the right of the _.DEFINE BOTTOM command on the same line unless
a semicolon appears between the _.DEFINE BOTTOM command and the rest
of the line.
.skip.test page 3
Regardless of whether a _.BOTTOM command or a _.DEFINE BOTTOM command
is used to define the line or lines, the insertions of the line or
lines are performed similarly.  The line of text specified by the
_.BOTTOM command or the lines specified by the _.DEFINE BOTTOM command
will continue to be inserted into the output file after the FORMAT
statements representing each completed page of text until a subsequent
_.NO BOTTOM command is issued.  The insertion of the line or lines
will be resumed if a _.RESUME BOTTOM command is issued after the _.NO
BOTTOM command.
.skip.test page 3
The Lines of text which are specified by the _.DEFINE BOTTOM command
are stored in the same area as are those which are specified by the
_.GROUP or _.DEFINE GROUP, _.PREFACE or _.DEFINE PREFACE and _.TOP
or _.DEFINE TOP commands.  There can be at most 30 lines containing
together no more than 500 characters in all of these collections of
lines.  These lines include those which have been temporarily disabled
by the _.NO GROUP, _.NO PREFACE, _.NO TOP or _.NO BOTTOM commands.
.skip.test page 3
The description of the _.BOTTOM command should be consulted for more
information concerning the text which can be inserted at the bottoms
of the pages.
.left margin 5
.skip 2.test page 6.indent -5
_.DEFINE TOP
.SKIP
The _.DEFINE TOP command indicates that the following lines of source
text which do not start with periods are to be copied into the output
file before the FORMAT statement which represents the top line on each
new page.  The lines which are to be inserted into the output file
will include all of the lines which do not start with periods in the
source text up to the next _.END DEFINITION, _.PROGRAM, _.TEXT,
_.CONTINUE, _.GROUP, _.PREFACE, _.TOP or _.BOTTOM command or up to
any of the various _.DEFINE commands.  If just a single line is to
be inserted, then it could also be defined by a _.TOP command.  The
single line would appear to the right of the _.TOP command on the same
line.  Unlike the _.TOP command, however, the first line of text cannot
appear to the right of the _.DEFINE TOP command on the same line unless
a semicolon appears between the _.DEFINE TOP command and the rest of
the line.
.skip.test page 3
Regardless of whether a _.TOP command or a _.DEFINE TOP command is
used to define the line or lines, the insertions of the line or lines
are performed similarly.  The line of text specified by the _.TOP
command or the lines specified by the _.DEFINE TOP command will continue
to be inserted into the output file before the FORMAT statement which
represents the top line on each new page until a subsequent _.NO TOP
command is issued.  The insertion of the line or lines will be resumed
if a _.RESUME TOP command is issued after the _.NO TOP command.
.skip.test page 3
The Lines of text which are specified by the _.DEFINE TOP command are
stored in the same area as are those which are specified by the _.GROUP
or _.DEFINE GROUP, _.PREFACE or _.DEFINE PREFACE and _.BOTTOM or
_.DEFINE BOTTOM commands.  There can be at most 30 lines containing
together no more than 500 characters in all of these collections of
lines.  These lines include those which have been temporarily disabled
by the _.NO GROUP, _.NO PREFACE, _.NO TOP or _.NO BOTTOM commands.
.skip.test page 3
The description of the _.TOP command should be consulted for more
information concerning the text which can be inserted at the tops of
the pages.
.skip 2.left margin 5.test page 6.indent -5
_.LEADING
.skip
The _.LEADING command causes blank lines which are requested at the
tops of pages to be represented in the FORMAT statements.  The
_.TRAILING command causes blank lines which are requested at the bottoms
of pages or which are requested just before a _.TEXT command or at
the end of the input file to be represented in the FORMAT statements.
If both a _.LEADING command and a _.TRAILING command have been issued,
then blank lines which are requested near the bottom of a page for
which there is not enough room at the bottom of the page will be
represented at the top of the next page.
.skip.test page 3
The _.LEADING command is the opposite of the _.NO LEADING command.
_.NO LEADING is the default.  If a _.LEADING command has not been
issued, or if a _.NO LEADING command has been issued more recently,
then blank lines requested at the top of a page or which overflow the
bottom of the previous page will be discarded.
.skip.test page 12.fill
For example, the source text
.skip.nofill.test page 11
_.page length 5.right margin 14.no justify
_.paging.page carriage 1.output width 55
_.preface       WRITE(ITTY,$)
_.skip
A LEADING command hasn't been issued.
_.skip 2.page.leading.skip 1
A LEADING command is now active.
_.trailing.skip 2
Both LEADING and TRAILING are active.
.skip.test page 12.fill
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill
      WRITE(ITTY,1)
    1 FORMAT(10H1A LEADING/15H command hasn't/6H been ,
     17Hissued.)
      WRITE(ITTY,2)
    2 FORMAT(1H1/10H A LEADING/15H command is now/2H a,
     16Hctive./)
      WRITE(ITTY,3)
    3 FORMAT(1H1/13H Both LEADING/13H and TRAILING/1H ,
     111Hare active.)
.skip.fill.test page 10
which would, in turn, generate the following pages of text when run.
.skip.nofill
*****************  *****************  *****************
*1A LEADING     *  *1              *  *1              *
* command hasn't*  * A LEADING     *  * Both LEADING  *
* been issued.  *  * command is now*  * and TRAILING  *
*****************  * active.       *  * are active.   *
                   *               *  *****************
                   *****************
.fill.left margin 5
.skip 2.test page 6.indent-5
_.NO BOTTOM
.skip
The line of text specified by a previous _.BOTTOM command or the lines
of text specified by a previous _.DEFINE BOTTOM command are no longer
to be inserted at the bottom of each completed page.  A _.RESUME BOTTOM
command can, however, be issued later to cause the line or lines defined
earlier to again be inserted at the bottom of each completed page.
.skip.test page 3
The _.NO BOTTOM command is not equivalent to issuing a _.BOTTOM command
without anything to its right or to issuing a _.DEFINE BOTTOM command
immediately followed by an _.END DEFINITION command.  Neither a _.BOTTOM
command without anything to its right nor a _.DEFINE BOTTOM command
immediately followed by an _.END DEFINITION command would allow a
_.RESUME BOTTOM command to be issued later to cause the line or lines
defined earlier to again be inserted at the bottom of each page.
.skip 2.left margin 5.test page 6.indent -5
_.NO LEADING
.skip
The _.NO LEADING command causes blank lines which are requested at
the tops of pages to be discarded.  The _.NO TRAILING command causes
blank lines which are requested at the bottoms of pages or which are
requested just before a _.TEXT command or at the end of the input file
to be discarded.  If both a _.LEADING command and a _.TRAILING command
have not been issued, or if either a _.NO LEADING command or a _.NO
TRAILING command has been issued more recently, then blank lines which
are requested near the bottom of a page for which there is not enough
room at the bottom of the page will likewise be discarded.
.skip.test page 3
The _.NO LEADING command is the opposite of the _.LEADING command.
_.NO LEADING is the default.  If a _.LEADING command has not been
issued, or if a _.NO LEADING command has been issued more recently,
then blank lines requested at the top of a page or which overflow the
bottom of the previous page will be discarded.
.fill.left margin 5
.skip 2.test page 6.indent-5
_.NO PAGE CARRIAGE
.skip
No character is to be inserted in place of the space at the left end
of each line on the page.  The _.NO PAGE CARRIAGE command is equivalent
to the _.PAGE CARRIAGE command issued without any following characters.
The _.NO PAGE CARRIAGE command is not equivalent to a _.PAGE
CARRIAGE#__#,__# command since the latter would cause spaces to be
used as the carriage control characters.  The _.NO PAGE CARRIAGE command
would cause skipped lines to be represented in the resulting FORMAT
statements by merely slashes while the _.PAGE CARRIAGE#__#,__# command
would cause skipped lines to be represented by /1X.
.skip
_.NO PAGE CARRIAGE is the default.
.SKIP.TEST PAGE 10
For example, the source text
.skip.nofill
_.page length 5.right margin 14.output width 55
_.preface       WRITE(1,$)
_.paging.page carriage 1,+.spacing 2.no justify
This is double spaced on the first page.
_.page.page carriage __ ,__
This has space as carriage control.
_.page.no page carriage
This does not have carriage control.
.skip.fill.test page 12
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill
      WRITE(1,1)
    1 FORMAT(15H1This is double/1H+/14H+spaced on the/
     11H+/12H+first page.)
      WRITE(1,2)
    2 FORMAT(15H This has space/1X/12H as carriage/1X/
     19H control.)
      WRITE(1,3)
    3 FORMAT(14H This does not//14H have carriage//1H ,
     18Hcontrol.)
.skip.fill.test page 10
which would, in turn, generate the following pages of text when run.
.skip.nofill
*****************  *****************  *****************
*1This is double*  * This has space*  * This does not *
*+              *  *               *  *               *
*+spaced on the *  * as carriage   *  * have carriage *
*+              *  *               *  *               *
*+first page.   *  * control.      *  * control.      *
*****************  *****************  *****************
.fill
.fill.left margin 5.skip 2.test page 6.indent -5
_.NO PAGING
.skip
The lines displayed on each page are still to be counted, but a new
page is not to be generated whenever the page fills.  The carriage
control character, if any, which will be inserted into the left end
of each line will be that specified by the _.CARRIAGE command, rather
than by the _.PAGE CARRIAGE command.  Subsequent _.PARAGRAPH commands
will not test the number of lines remaining unused on the page.  The
_.NO PAGING command terminates the parcelling out of lines into separate
pages which might have been initiated by a previous _.PAGING command
and terminates the construction of explicitly declared pages which
might have been initiated by a _.PAGE command or by a _.TEST PAGE or
_.TEST SPACING command which failed.  The _.NO PAGING command terminates
the current output line but does not terminate the FORMAT statement
and does not change the number of lines which are considered to be
on the page.  _.NO PAGING is the default.
.skip.test page 3
A _.TEST PAGE or a _.TEST SPACING command can still be used after a
_.NO PAGING command has been issued to cause a new page to be started
if enough room for a specified number of lines does not remain unused
at the bottom of the page.  If a _.TEST PAGE command or a _.TEST SPACING
command fails, i.e_.  there is not enough unused room on the page,
or if a _.PAGE command is issued, then the current FORMAT statement
will be treated as containing the end of a page and a new page will
be started.  The _.TEST PAGE command or _.TEST SPACING command which
fails or the _.PAGE command will cause the current FORMAT statement
to be finished, the text specified by a _.BOTTOM or _.DEFINE BOTTOM
command to be inserted after the FORMAT statement, the text specified
by a _.TOP or _.DEFINE TOP command to be inserted before the next FORMAT
statement and the carriage control characters specified by a _.PAGE
CARRIAGE command to be used for the following lines.  A new page will
not, however, be started whenever the current page fills.  If a _.TEST
PAGE command or a _.TEST SPACING command succeeds, i.e_.  there is
enough unused room on the page, then the _.TEST PAGE command or the
_.TEST SPACING command merely terminates the current line and is
equivalent to a _.BREAK command.
.fill.left margin 5
.skip 2.test page 6.indent-5
_.NO TOP
.skip
The line of text specified by a previous _.TOP command or the lines
of text specified by a previous _.DEFINE TOP command are no longer
to be inserted at the top of each page.  A _.RESUME TOP command can,
however, be issued later to cause the line or lines defined earlier
to again be inserted at the top of each page.
.skip.test page 3
The _.NO TOP command is not equivalent to issuing a _.TOP command
without anything to its right or to issuing a _.DEFINE TOP command
immediately followed by an _.END DEFINITION command.  Neither a _.TOP
command without anything to its right nor a _.DEFINE TOP command
immediately followed by an _.END DEFINITION command would allow a
_.RESUME TOP command to be issued later to cause the line or lines
defined earlier to again be inserted at the top of each page.
.skip 2.left margin 5.test page 6.indent -5
_.NO TRAILING
.skip
The _.NO TRAILING command causes blank lines which are requested at
the bottoms of pages or which are requested just before a _.TEXT command
or at the end of the input file to be discarded.  The _.NO LEADING
command causes blank lines which are requested at the tops of pages
to be discarded.  If both a _.LEADING command and a _.TRAILING command
have not been issued, or if either a _.NO LEADING command or a _.NO
TRAILING command has been issued more recently, then blank lines which
are requested near the bottom of a page for which there is not enough
room at the bottom of the page will likewise be discarded.
.skip.test page 3
The _.NO TRAILING command is the opposite of the _.TRAILING command.
_.NO TRAILING is the default.  If a _.TRAILING command has not been
issued, or if a _.NO TRAILING command has been issued more recently,
then blank lines requested at the bottom of a page will be discarded.
.left margin 5.skip 2.test page 6.indent -5
_.PAGE
.skip.test page 3
The next lines which are represented in the FORMAT statements are to
be placed on a new page.  It is not necessary that a _.PAGING command
have been issued.  If some text is on the current page, and if a
_.TRAILING command has been issued, then enough blank lines will be
generated to fill the page.  The line of text specified by the _.BOTTOM
command is then inserted into the output file.  The current page is
terminated by generating the blank lines which fill the current page
and by inserting the line of text specified by the _.BOTTOM command
even if paging is not being performed when the _.PAGE command is issued.
.skip.test page 3
If a _.LEADING command has not been issued, then blank lines requested
by a subsequent _.BLANK or _.SKIP command will be ignored until
something else is placed into the new page.  The line of text specified
by the _.TOP command will be inserted into the output file before the
next FORMAT statement.  If the leftmost character in the first line
represented in the next FORMAT statement is a space, then this space
will be replaced by the first character specified by the _.PAGE CARRIAGE
command.  If the leftmost character in each of the second and subsequent
lines represented in the next FORMAT statements is a space then this
space will be replaced by the second character specified by the _.PAGE
CARRIAGE command.
.skip.test page 3
If a _.PAGING command has been issued, then the new page will end when
the number of additional lines specified by the _.PAGE LENGTH command
have been represented in the FORMAT statements.  If a _.LEADING command
and a _.TRAILING command have not both been issued, but a _.BLANK or
a _.SKIP command requests a group of blank lines which extend across
the end of the new page, then the lines beyond the end of the new page
will be lost.  If both a _.LEADING command and a _.TRAILING command
have been issued, and a _.BLANK or a _.SKIP command requests a group
of blank lines which extend across the end of the new page, then all
of these lines will be represented even if it requires 1 or more fully
blank pages to do so.
.skip.test page 3
If a new page of text is started by a _.PAGE command, but a _.PAGING
command has not been issued, then this new page will not be terminated
when the page fills.  Consequently, a _.BLANK or _.SKIP command which
extends beyond the end of the page will generate all of the lines which
it specifies, rather than having the blank lines be cut off when the
page becomes full, provided that at least 1 printing line appears after
the blank lines.  However, the number of lines on the page will still
be counted and can be tested by a _.TEST PAGE or _.TEST SPACING command.
The page will extend to the next _.TEST PAGE or _.TEST SPACING command
which fails, or to the next _.PAGE or _.TEXT command.  If a _.TRAILING
command has been issued, then the _.TEST PAGE or _.TEST SPACING command
which fails or the _.PAGE command would fill the rest of the page with
blank lines if it is not already full.  The _.TEST PAGE or _.TEST
SPACING or _.PAGE command would then cause the line specified by the
_.BOTTOM command to be inserted.
.skip.test page 3
If a new page of text is started by a _.PAGE command, but a _.PAGING
command has not been issued, then a subsequent _.TEXT command would
turn off paging entirely.  If a _.TEXT command is encountered, but
a _.PAGING command has not been issued, then the carriage controls
specified by a _.PAGE CARRIAGE command would not be inserted into the
left column of the following lines which are represented in the FORMAT
statements, and the line of text specified by a _.TOP command would
not be inserted before the next FORMAT statement which is generated.
If a _.PAGING command has been issued, then the _.TEXT command would
start a new page instead.  Regardless of whether a _.PAGING command
has been issued or not, the line of text specified by a _.BOTTOM command
is not inserted into the output file at the end of the page if the
page is terminated by a _.TEXT command or is at the end of the input
file unless the page just happens to be full.  If the final page is
to be filled with blank lines and is to be followed by the line of
text specified by the _.BOTTOM command, then an extra _.PAGE command
should precede the _.TEXT command or the end of the input file.
.skip.test page 11
For example, the source text
.skip.nofill
_.page length 5.right margin 14.output width 55
_.no justify
_.preface       WRITE(1,$)
_.page carriage 1
_.paging.trailing
This page will be terminated early.
_.page
This sentence is long enough that it will
have to be continued onto a second page.
.fill.skip.test page 11
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill
      WRITE(1,1)
    1 FORMAT(15H1This page will/14H be terminated/2H e,
     15Harly.//)
      WRITE(1,2)
    2 FORMAT(14H1This sentence/15H is long enough/2H t,
     111Hhat it will/11H have to be/15H continued onto)
      WRITE(1,3)
    3 FORMAT(15H1a second page.)
.skip.test page 10.fill
which would, in turn, produce the following pages of text when run.
.skip.nofill
*****************  *****************  *****************
*1This page will*  *1This sentence *  *1a second page.*
* be terminated *  * is long enough*  *****************
* early.        *  * that it will  *
*               *  * have to be    *
*               *  * continued onto*
*****************  *****************
.fill
.left margin 5.skip 2.test page 6.indent -5
_.PAGE CARRIAGE carriage control for top line, for next lines
.skip.test page 3
The _.PAGE CARRIAGE command can be followed by 2 printing characters.
If the first character is specified, then this character will replace
the space at the left end of the top line on each page.  If both
characters are specified, then the second character will replace the
space at the left end of the second and following lines on each page.
If only the first character is specified, then the space at the left
end of the second and following lines on each page is not replaced.
If only the second character is specified, then this character will
replace the space at the left end of each line on each page.  If no
characters follow the _.PAGE CARRIAGE command, then the space at the
left end of each line on the page will not be replaced.  Depending
upon the FORTRAN system with which the resulting FORMAT statements
are used, the character at the left end of each line may be used as
a carriage control to set the line spacing when the text is displayed.
.skip.test page 3
The structure of the _.PAGE CARRIAGE command is identical to that
described earlier in this manual for the _.CARRIAGE command.  Any number
of spaces or a single comma can separate the characters if both are
specified, but the spaces or the single comma are not necessary.  If
only the first character is given, then it does not matter if this
is followed by a comma.  If only the second character is specified,
then this must be preceded by a single comma.  In order to have any
of the flag characters or punctuation marks be used as the carriage
control characters, these must be preceded by an underscore character.
.skip.test page 3
The characters specified by the _.PAGE CARRIAGE command are inserted
only while paging is being performed, either due to a _.PAGE or _.PAGING
command having been issued, or due to a _.TEST PAGE or _.TEST SPACING
command having failed.  The _.PAGE CARRIAGE command can be issued before
paging begins, but the characters specified by the command will not
be inserted until paging begins.  The second character originally
specified by a _.CARRIAGE command will again be inserted in place of
the leftmost space on each line if paging was enabled by a _.PAGING
command and is then terminated by a subsequent _.NO PAGING command,
or if paging was implied by a _.PAGE command or by a _.TEST PAGE or
_.TEST SPACING command which failed and is then terminated by a
subsequent _.TEXT command.  If a _.CARRIAGE command has not specified
a second character, then the space at the left end of each line will
be left unchanged when paging is terminated.  The characters specified
by the _.PAGE CARRIAGE command will be inserted again if paging is
resumed later.
.skip.test page 3
The characters specified by the _.PAGE CARRIAGE command are inserted
only if the character at the left end of the line is a space or if
the line is completely blank.  It does not matter if the space at the
left end of the line was requested by an _.OFFSET command, a _.LEFT
MARGIN command, an _.INDENT command or a _.PARAGRAPH command.  A blank
line into which the character is inserted might have been requested
by a _.BLANK or _.SKIP command or might be the line before a paragraph
or might be a line required to fill out a page.  The characters
specified by the _.PAGE CARRIAGE command are not inserted if any
printing character appears at the left end of the line.  Unless either
a _.NO OFFSET command or a _.OFFSET 0 command has been issued, each
line will be offset to the right to allow room for the insertion of
these characters.
.skip.test page 12
The commands shown below would produce the results described to the
right.
.skip.nofill.test page 9
_.PAGE CARRIAGE 1,* !insert 1 at start of first line
                   !and * at start of following lines
_.PAGE CARRIAGE *,* !insert * at start of each line

_.PAGE CARRIAGE ,*  !same as the above

_.PAGE CARRIAGE 1   !insert 1 at start of first line
                   !but nothing into following lines
_.PAGE CARRIAGE 1,  !same as the above
.skip.test page 13.fill
For example, the source text
.skip.nofill.test page 11
_.page length 5.right margin 14.output width 55
_.no justify.trailing.paging
_.preface       WRITE(1,$)
_.carriage,+
_.page carriage 1-
This is on a fixed length page.
_.page.no paging
Paging is not being performed at this point.
_.page
A page command started this page
which will not end after a fixed number of lines.
.skip.test page 13.fill
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill
      WRITE(1,1)
    1 FORMAT(13H1This is on a/13H-fixed length/5H-page,
     11H./1H-/1H-)
      WRITE(1,2)
    2 FORMAT(14H+Paging is not/6H+being/11H+performed ,
     12Hat/12H+this point./1H+)
      WRITE(1,3)
    3 FORMAT(15H1A page command/13H-started this/3H-pa,
     18Hge which/13H-will not end/14H-after a fixed/
     210H-number of/7H-lines.)
.skip.fill.test page 12
which would, in turn, generate the following pages of text when run.
.skip.nofill
*****************  *****************  *****************
*1This is on a  *  *+Paging is not *  *1A page command*
*-fixed length  *  *+being         *  *-started this  *
*-page.         *  *+performed at  *  *-page which    *
*-              *  *+this point.   *  *-will not end  *
*-              *  *+              *  *-after a fixed *
*****************  *****************  *-number of     *
                                      *-lines.        *
                                      *****************
.fill
.FILL.SKIP 2.TEST PAGE 6.LEFT MARGIN 5.INDENT -5
_.PAGE LENGTH maximum number of lines on single page
.skip
The _.PAGE LENGTH command specifies the number of lines which are
expected to appear on a single page.  If the number appearing to the
right of the _.PAGE LENGTH command is not signed, then this number
is used directly as the number of lines which are expected on a page.
If the number is signed, then the number of lines which are expected
on a page is adjusted by this amount.  The _.PAGE LENGTH command does
not itself cause the lines to be parcelled out into pages of the
indicated length.
.skip.test page 3
The number of lines displayed on the page is set to zero by each _.TEXT
or _.PAGE command or by each _.TEST PAGE or _.TEST SPACING command
which fails.  If a _.PAGING command has been issued, then the number
of lines displayed on the page is also set to zero each time that the
current page fills.  The number of lines which are considered to be
on the page can be modified by the _.PAGE POSITION command.  Each line
which is represented in the FORMAT statements increases the number
of lines on the page by 1.
.skip.test page 3
If a _.PAGING command has been issued, then a new page will be started
each time that the number of lines specified by the _.PAGE LENGTH
command have been represented on the current page, as well as each
time that a _.PARAGRAPH command is issued closer to the end of the
page than is specified by the third number which appears to the right
of the _.PARAGRAPH command.  Regardless of whether a _.PAGING command
has been issued, a new page will be started whenever a _.TEST PAGE
or a _.TEST SPACING command requests verification of the availability
of more lines than would remain unused on a page of the length specified
by the _.PAGE LENGTH command.
.skip.test page 3
If a _.TRAILING command has been issued, then the bottom of each page
will be filled with enough blank lines to make the total number of
lines on the page be at least equal to the number of lines specified
by the _.PAGE LENGTH command.  The bottom of the page is not filled
with blank lines and the text specified by a _.BOTTOM or _.DEFINE BOTTOM
command is not inserted into the output file if the page is terminated
by a _.TEXT command of if the page is terminated by reaching the end
of the input file.
.skip.test page 3
The page size is assumed to be 22 lines if a _.PAGE LENGTH command
has not been issued.  If the video terminal can display a total of
24 lines, then this reserves 2 extra lines at the bottom of the screen
which can be used for instructions about how the user is expected to
signal to the program that the next page should be displayed.
.skip.test page 13.fill
For example, the source text
.skip.nofill.test page 11
_.right margin 14.output width 55.no justify
_.trailing.paging.page carriage 1
_.preface       WRITE(ITTY,$)
_.page length 5
_This page will end with a PARAGRAPH command.
_.paragraph
_This page will end with a TEST PAGE command.
_.test page 2
_This final page will end with a PAGE command.
_.page
.skip.test page 12.fill
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill
      WRITE(ITTY,1)
    1 FORMAT(15H1This page will/11H end with a/5H PARA,
     15HGRAPH/9H command./)
      WRITE(ITTY,2)
    2 FORMAT(15H1     This page/14H will end with/2H a,
     110H TEST PAGE/9H command./)
      WRITE(ITTY,3)
    3 FORMAT(11H1This final/14H page will end/6H with ,
     16Ha PAGE/9H command./)
.skip.fill.test page 10
which would, in turn, generate the following pages of text when run.
.skip.nofill
*****************  *****************  *****************
*1This page will*  *1     This page*  *1This final    *
* end with a    *  * will end with *  * page will end *
* PARAGRAPH     *  * a TEST PAGE   *  * with a PAGE   *
* command.      *  * command.      *  * command.      *
*               *  *               *  *               *
*****************  *****************  *****************
.FILL
.skip 2.left margin 5.test page 8.indent -5.fill
_.PAGE POSITION line count on page as unsigned number
.break
or
.indent -5
_.PAGE POSITION adjustment of line count as signed number
.skip
The number of lines which are considered to be on the current page
is set to or adjusted by the indicated number.  If the number appearing
to the right of the _.PAGE POSITION command is not signed, then the
number of lines is set to the indicated number directly.  If the number
is signed, then the number of lines is incremented by the indicated
number.  The lines indicated by the _.PAGE POSITION command are assumed
to be single spaced so the number of lines is not multiplied by the
current line spacing.  If a _.PAGING command has been issued and the
_.PAGE POSITION command would fill or overflow the page, then the
current page is finished and the line count on the new page is set
to zero.
.skip.test page 3
A new top of page is generated if the page is empty when the _.PAGE
POSITION command is issued and if the start of a new page has been
requested previously either by a _.PAGING command or by a _.PAGE command
or by a _.TEST PAGE or a _.TEST SPACING command which failed.  The
_.PAGE POSITION command can be issued without a following number to
generate a new top of page if the current page is empty but not change
the line count on the page.  If the _PAGE POSITION command is issued
without a number, then another _.PAGE POSITION command with a number
should appear before any other text is represented in the FORMAT
statements.  A new bottom of page is generated if the lines indicated
as being on the page would fill or overflow the page, provided that
a _.PAGING command has been issued so that the lines are being parcelled
out into pages.  Both a new top of page and a new bottom of page will
be generated if the lines are being parcelled out into pages and nothing
is on the page when a _.PAGE POSITION command which fills or overflows
the page is issued.
.skip.test page 3
The _.PAGE POSITION command is used to adjust the number of lines on
the page to allow the program which uses the resulting FORMAT statements
to independently insert lines into the page.  Since the current page
should be finished before the lines are inserted if these lines would
extend across the page boundary, a _.TEST PAGE command should be issued
before the _.PROGRAM command which precedes the FORTRAN source code
which inserts the lines.  Since the _.TEST PAGE command might generate
a bottom of a page, a _.PAGE POSITION command without a following number
should also appear before the _.PROGRAM command to generate a new top
of page before the inserted lines if and only if the page is then empty.
If the text is being multiply spaced, or if a _.BLANK or a _.SKIP
command is issued just before the _.TEST PAGE command, then a _.TRAILING
command should be active when the _.PROGRAM command is issued so that
the blank lines will be represented in the FORMAT statements before
the FORTRAN source code which inserts the lines.  If it is not desired
to have the _.TRAILING command be active elsewhere, then it can be
issued just before the _.PROGRAM command and the _.NO TRAILING command
can be issued just after the _.PROGRAM command.  The FORTRAN source
code should be followed by a _.CONTINUE command if the text which is
to be represented in the following FORMAT statements is to appear on
the same page as the inserted lines.  The _.CONTINUE command should
be followed in turn by the _.PAGE POSITION command and its following
number.  The _.PAGE POSITION command with its following number should
not be issued before the _.PROGRAM command since that could cause a
new bottom of page to be generated prematurely if the inserted lines
would fill the page.
.skip.test page 16
A typical sequence for these various commands, for the FORTRAN SOURCE
code, and for the text which is to be represented in the FORMAT
statements on either side of the inserted lines is shown below.
.nofill.skip.test page 11
      .
Text to be on page before inserting 10 lines
      .
_.blank.test page 10.page position
_.trailing.program.no trailing
      GO TO 1000 !Transfer to code to insert 10 lines
 1001 CONTINUE   !Return here after inserting 10 lines
_.continue.page position +10.blank
      .
Text to be on page after inserting 10 lines
      .
.fill
.skip.test page 10
For example, the source text
.skip.nofill
_.paging.page length 5.right margin 14.output width 55
_.no justify
_.top       WRITE(ITTY,1)
_.define bottom
      WRITE(ITTY,2)
      READ(ITTY,3)LTRRTN
_.preface       WRITE(ITTY,$)
_.program
      DATA ITTY/5/
      KOUNT=0
      CALL HELP(ITTY,1)
      DO 2 LINE=1,4
      KOUNT=KOUNT+1
      WRITE(ITTY,1)KOUNT
    1 FORMAT(' INSERT',1I3)
    2 CONTINUE
      CALL HELP(ITTY,2)
      DO 4 LINE=1,3
      KOUNT=KOUNT+1
      WRITE(ITTY,3)KOUNT
    3 FORMAT(' INSERT',1I3)
    4 CONTINUE
      CALL HELP(ITTY,3)
      DO 6 LINE=1,4
      KOUNT=KOUNT+1
      WRITE(ITTY,5)KOUNT
    5 FORMAT(' INSERT',1I3)
    6 CONTINUE
      CALL HELP(ITTY,4)
      STOP
      END
      SUBROUTINE HELP(ITTY,KIND)
      GO TO(100,200,300,400),KIND
  100 CONTINUE
_.text 500
_.page position
_.program
      GO TO 4
C
C     AFTER FIRST INSERTION
  200 CONTINUE
_.continue
_.page position 4
This is after 1st insertion.
_.test page 3
_.page position
_.program
      GO TO 4
C
C     AFTER SECOND INSERTION
  300 CONTINUE
_.continue
_.page position +3
This is after 2nd insertion.
_.test page 4
_.page position
_.program
      GO TO 4
C
C     AFTER THIRD INSERTION
  400 CONTINUE
_.continue
_.page position +4
_.program
    1 FORMAT('1Read message')
    2 FORMAT(' Press RETURN',__$)
    3 FORMAT(1A1)
    4 RETURN
      END
.skip.test page 10.fill
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill
      DATA ITTY/5/
      KOUNT=0
      CALL HELP(ITTY,1)
      DO 2 LINE=1,4
      KOUNT=KOUNT+1
      WRITE(ITTY,1)KOUNT
    1 FORMAT(' INSERT',1I3)
    2 CONTINUE
      CALL HELP(ITTY,2)
      DO 4 LINE=1,3
      KOUNT=KOUNT+1
      WRITE(ITTY,3)KOUNT
    3 FORMAT(' INSERT',1I3)
    4 CONTINUE
      CALL HELP(ITTY,3)
      DO 6 LINE=1,4
      KOUNT=KOUNT+1
      WRITE(ITTY,5)KOUNT
    5 FORMAT(' INSERT',1I3)
    6 CONTINUE
      CALL HELP(ITTY,4)
      STOP
      END
      SUBROUTINE HELP(ITTY,KIND)
      GO TO(100,200,300,400),KIND
  100 CONTINUE
      WRITE(ITTY,1)
      GO TO 4
C
C     AFTER FIRST INSERTION
  200 CONTINUE
      WRITE(ITTY,501)
  501 FORMAT(14H This is after)
      WRITE(ITTY,2)
      READ(ITTY,3)LTRRTN
      WRITE(ITTY,1)
      WRITE(ITTY,502)
  502 FORMAT(15H 1st insertion.)
      GO TO 4
C
C     AFTER SECOND INSERTION
  300 CONTINUE
      WRITE(ITTY,503)
  503 FORMAT(14H This is after)
      WRITE(ITTY,2)
      READ(ITTY,3)LTRRTN
      WRITE(ITTY,1)
      WRITE(ITTY,504)
  504 FORMAT(15H 2nd insertion.)
      GO TO 4
C
C     AFTER THIRD INSERTION
  400 CONTINUE
      WRITE(ITTY,2)
      READ(ITTY,3)LTRRTN
    1 FORMAT('1Read message')
    2 FORMAT(' Press RETURN',$)
    3 FORMAT(1A1)
    4 RETURN
      END
.skip.test page 12.fill
which would, in turn, generate the following text when run.
.skip.nofill
*****************  *****************  *****************
*1Read message  *  *1Read message  *  *1Read message  *
* INSERT  1     *  * 1st insertion.*  * 2nd insertion.*
* INSERT  2     *  * INSERT  5     *  * INSERT  8     *
* INSERT  3     *  * INSERT  6     *  * INSERT  9     *
* INSERT  4     *  * INSERT  7     *  * INSERT 10     *
* This is after *  * This is after *  * INSERT 11     *
* Press RETURN  *  * Press RETURN  *  * Press RETURN  *
*****************  *****************  *****************
.fill.skip.test page 3
The dollar sign at the right end of the FORMAT statement which is used
to tell the user to press the RETURN key is a DECsystem10/20 notation
which prevents the production of a carriage return after the text which
is specified by the FORMAT statement.  This causes the cursor or
printhead to remain to the right of the final line on the page until
the user presses the RETURN key.  This dollar sign must be quoted with
an underscore in the original text which is processed by the FORMAT
program to prevent its being replaced by the number of the next FORMAT
statement.
.skip 2.test page 6.left margin 5.fill.indent -5
_.PAGING
.skip
The _.PAGING command indicates that each time the number of lines
specified by the _.PAGE LENGTH command have been included on the current
page, then the current FORMAT statement is to be terminated and a new
page is to be started.  The text specified by a _.BOTTOM command or
by a _.DEFINE BOTTOM command is inserted into the output file after
the FORMAT statement which specifies the bottom line of the page just
finished.  The text specified by a _.TOP command or by a _.DEFINE TOP
command is inserted before the FORMAT statement which specifies the
top line on the next page.
.skip.test page 3
The issuing of the _.PAGING command does not immediately cause a new
page to be started unless the current page is already full when the
paging command is issued.  If something is already on the current page
when the _.PAGING command is issued, but the page is not full, then
the rest of the lines on the current page will have the second character
specified by the _.PAGE CARRIAGE command as their carriage control
characters.  The top line on the next page will have the first character
specified by the _.PAGE CARRIAGE command as its carriage control
character and the second and subsequent lines on the next page will
have the second character specified by the _.PAGE CARRIAGE command
as their carriage control characters.  If the current page either is
empty or is already full when _.PAGING command is issued, then the
next line of text which is represented in the FORMAT statements will
be the top line on a new page.
.skip.test page 3
The number of lines on the page is set to zero by each _.TEXT or _.PAGE
command, or by each _.TEST PAGE or _.TEST SPACING command which fails.
A _.CONTINUE command would start a new line in the output, but does
not return the line count to zero.  A _.PAGE POSITION command can be
used to modify the number of lines which are considered to already
be on the page.  None of these commands terminate the parcelling out
of the lines into pages once a _.PAGING command has been issued.  The
_.PAGING command does not change the number of lines on the page when
it is issued unless the page is already full.
.skip.test page 3
The parcelling out of the lines into pages can be terminated by a
subsequent _.NO PAGING command.  The counting of the lines on the page
continues after the _.NO PAGING command has been issued, but the
carriage control characters for the subsequent lines will be specified
by the previous _.CARRIAGE command, rather than by the _.PAGE CARRIAGE
command.  _.NO PAGING is the default.
.skip.test page 3
It is not necessary that a _.PAGING command have been issued in order
to obtain output which is divided into pages.  The _.PAGING command
merely causes the output to be divided into pages each time the page
fills.  The pages can also be declared explicitly.  A _.PAGE command
or a _.TEST PAGE or a _.TEST PAGING command which fails would terminate
the current page and start a new page even if a _.PAGING command has
not been issued.  Regardless of which method is used to terminate the
current page and to start the new page, the text specified by a _.BOTTOM
command or by a _.DEFINE BOTTOM command is inserted into the output
file after the current FORMAT statement, the text specified by a _.TOP
command or by a _.DEFINE TOP command is inserted before the next FORMAT
statement, and the carriage control characters specified by the _.PAGE
CARRIAGE command appear at the left ends of the subsequent lines.
.skip.test page 3
If a _.PAGING or _.PAGE command or a _.TEST PAGE or _.TEST SPACING
command which fails has been issued, then a _.TEXT command will
terminate the current page, but the bottom of the page will not be
filled with blank lines, and the text specified by a _.BOTTOM command
or by a _.DEFINE BOTTOM command will not be inserted unless the page
is already full when the _.TEXT command is issued.  If it is desired
that an end of page always be produced, filled with blank lines if
a _.TRAILING command has been issued, and followed by the text specified
by a _.BOTTOM or _.DEFINE BOTTOM command, then the _.TEXT command should
be preceded by an extra _.PAGE command.
.skip.test page 3
If a _.PAGING command has been issued, then a TEXT command will cause
the text specified by a _.TOP command or by a _.DEFINE TOP command
to be inserted before the next FORMAT statement and will cause the
characters specified by the _.PAGE CARRIAGE command to be used as the
carriage control characters for the subsequent lines.  However, if
a _.PAGING command has not been issued, then the _.TEXT command will
terminate the use of the carriage control characters specified by the
_.PAGE CARRIAGE command and the text specified by a _.TOP command or
by a _.DEFINE TOP command will not be inserted before the next FORMAT
statement.
.skip.test page 10.fill
For example, the source text
.skip.nofill.test page 11
_.page length 5.right margin 14.output width 55
_.no justify.trailing
_.page carriage +-
_.preface       WRITE(ITTY,$)
_.top       WRITE(ITTY,1)
_.define bottom
      WRITE(ITTY,2)
      READ(ITTY,3)LTRRTN
_.program
      DATA ITTY/5/
_.text 100
This text will not be divided into pages.
_.paging
This text will be split into pages and will
use carriage control set by PAGE CARRIAGE.
Text set by TOP and BOTTOM commands will
be inserted at page boundary.
_.no paging
This text will not be divided into pages.
_.program
    1 FORMAT('1Read message')
    2 FORMAT(' Press RETURN',__$)
    3 FORMAT(1A1)
      END
.skip.test page 10.fill
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill
      DATA ITTY/5/
      WRITE(ITTY,100)
  100 FORMAT(15H This text will/15H not be divided/1H ,
     111Hinto pages./15H-This text will/11H-be split i,
     23Hnto)
      WRITE(ITTY,2)
      READ(ITTY,3)LTRRTN
      WRITE(ITTY,1)
      WRITE(ITTY,101)
  101 FORMAT(15H+pages and will/13H-use carriage/3H-co,
     112Hntrol set by/15H-PAGE CARRIAGE./10H-Text set ,
     22Hby)
      WRITE(ITTY,2)
      READ(ITTY,3)LTRRTN
      WRITE(ITTY,1)
      WRITE(ITTY,102)
  102 FORMAT(15H+TOP and BOTTOM/14H-commands will/2H-b,
     113He inserted at/15H-page boundary./9H This tex,
     26Ht will/15H not be divided/12H into pages.)
    1 FORMAT('1Read message')
    2 FORMAT(' Press RETURN',$)
    3 FORMAT(1A1)
      END
.skip.fill.test page 13
which would, in turn, generate the following pages of text when run.
.skip.nofill
*****************  *****************  *****************
* This text will*  *1Read message  *  *1Read message  *
* not be divided*  *+pages and will*  *+TOP and BOTTOM*
* into pages.   *  *-use carriage  *  *-commands will *
*-This text will*  *-control set by*  *-be inserted at*
*-be split into *  *-PAGE CARRIAGE.*  *-page boundary.*
* Press RETURN  *  *-Text set by   *  * This text will*
*****************  * Press RETURN  *  * not be divided*
                   *****************  * into pages.   *
                                      *****************
.fill
.fill.left margin 5
.skip 2.test page 6.indent-5
_.PARAGRAPH indent, skip lines, unused lines needed on page
.skip
The _.PARAGRAPH command indicates that the following lines which are
represented in the FORMAT statements will form a new paragraph.  A
number of blank lines equal to the second argument times the line
spacing which has been set by the previous _.SPACING command will appear
between the previous text and the start of the paragraph.  The first
line of the paragraph will be indented from the left margin by the
number of columns specified by the first argument.  The first 2
arguments of the _.PARAGRAPH command are described in detail earlier
in this manual.
.skip
The third argument is ignored if a _.PAGING command has not been issued,
or if the current page is empty.  If a _.PAGING command has been issued,
then the third argument specifies the minimum number of lines of text
for which there must still be room to be printed on the page at the
current line spacing and in addition to the spacing between the
paragraphs.  If there is not enough room on the current page, and if
a _.TRAILING command has been issued, then the rest of the current
page will be filled with blank lines.  Regardless of whether of a
_.TRAILING command has been issued, if the test fails, then the FORMAT
statement currently being assembled will be closed, and text specified
by a _.BOTTOM or _.DEFINE BOTTOM command will be inserted.  If some
text which is to be in the new paragraph follows, then the text
specified by a _.TOP or _.DEFINE TOP command will be inserted before
the text specified by a _.PREFACE of _.DEFINE PREFACE command, and
the carriage control for the first line of the paragraph will be set
to the first character specified by the previous _.PAGE CARRIAGE
command.
.skip.test page 3
If the third argument is missing, then the value of the third argument
set by the previous _.PARAGRAPH command will be used.  The third
argument will be assumed to have the value 3 if the third argument
has not been specified in any previous _.PARAGRAPH command.
.skip
If a _.SPACING 2 command has been issued to get double spacing, then
a _.PARAGRAPH 5,1,3 command would require that there be at least 8
unused lines on the page.  This is the sum of the 1 blank line after
the last line of the previous paragraph, the 2 blank lines between
the paragraphs requested by the second argument, the 3 printed lines
requested by the third argument, and the total of 2 blank lines between
these printed lines.  The total number of lines can be calculated as
.skip.test page 5.left margin +5.no justify
1 less than the current line spacing
.indent -5
plus#the second argument times the current line spacing
.indent -5
plus#the third argument
.indent-5
plus#1 less than the third argument times 1 less than the line spacing.
.left margin -5.justify
.skip.test page 18
For example, the source text
.skip.nofill
_.page length 10.right margin 24.output width 55
_.paging.page carriage 1.trailing
_.preface       WRITE(ITTY,$)
_.bottom       READ(ITTY,101)IPAUSE
_.paragraph
This demonstrates that the .PARAGRAPH commands checks
if there is enough room at the bottom of the page for
a reasonable number of lines to be printed.
_.paragraph
This follows a .PARAGRAPH command.  There wasn't enough
room on the first page for this paragraph.
_.paragraph
This also follows a .PARAGRAPH command. However, There
is enough room on the page for it.
_.program
  101 FORMAT(1A1)
.skip.fill.test page 19
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill
      WRITE(ITTY,1)
    1 FORMAT(25H1     This   demonstrates/9H that    ,
     116Hthe   .PARAGRAPH/25H commands checks if there/
     225H is  enough  room  at the/16H bottom of the p,
     39Hage for a/25H reasonable   number   of/5H line,
     416Hs to be printed.///)
      READ(ITTY,101)IPAUSE
      WRITE(ITTY,2)
    2 FORMAT(25H1     This   follows    a/9H .PARAGRA,
     12HPH,6X,8Hcommand./25H There wasn't enough room/
     225H on  the  first  page for/16H this paragraph./
     3/6X,19HThis also follows a/11H .PARAGRAPH,6X,1Hc,
     47Hommand./25H However, There is enough/7H room o,
     518Hn the page for it.)
      READ(ITTY,101)IPAUSE
  101 FORMAT(1A1)
.skip.fill.test page 15
which would, in turn, generate the following 2 pages of text when run.
.skip.nofill.test page 12
*************************** ***************************
*1     This   demonstrates* *1     This   follows    a*
* that    the   .PARAGRAPH* * .PARAGRAPH      command.*
* commands checks if there* * There wasn't enough room*
* is  enough  room  at the* * on  the  first  page for*
* bottom of the page for a* * this paragraph.         *
* reasonable   number   of* *                         *
* lines to be printed.    * *      This also follows a*
*                         * * .PARAGRAPH      command.*
*                         * * However, There is enough*
*                         * * room on the page for it.*
*************************** ***************************
.fill
.fill.skip 2.left margin 5.test page 6.indent -5
_.RESUME BOTTOM
.skip
The text specified by the previous _.BOTTOM or _.DEFINE BOTTOM command,
but which was subsequently disabled by a _.NO BOTTOM command, is once
again to be inserted into the output file after the FORMAT statement
which contains the bottom line on each page.  A _.RESUME BOTTOM command
is implied by each new _.BOTTOM or _.DEFINE BOTTOM command.  The
_.RESUME BOTTOM command has no effect if a _.NO BOTTOM command has
not been issued.  The _.RESUME BOTTOM command cannot be used to restore
the insertion of the text specified by a previous _.BOTTOM or _.DEFINE
BOTTOM command but which was disabled by a subsequent _.BOTTOM or
_.DEFINE BOTTOM command which did not specify any text which was to
be inserted.
.fill.skip 2.left margin 5.test page 6.indent -5
_.RESUME TOP
.skip
The text specified by the previous _.TOP or _.DEFINE TOP command, but
which was subsequently disabled by a _.NO TOP command, is once again
to be inserted into the output file before the FORMAT statement which
contains the top line on each page.  A _.RESUME TOP command is implied
by each new _.TOP or _.DEFINE TOP command.  The _.RESUME TOP command
has no effect if a _.NO TOP command has not been issued.  The _.RESUME
TOP command cannot be used to restore the insertion of the text
specified by a previous _.TOP or _.DEFINE TOP command but which was
disabled by a subsequent _.TOP or _.DEFINE TOP command which did not
specify any text which was to be inserted.
.fill.skip 2.test page 6
.left margin 5.indent -5
_.SKIP number of normal spaced lines at page bottom times -1
.skip
If the _.SKIP command is followed by a negative number, then enough
blank lines are to be generated before the next line of text which
is represented in the FORMAT statements to cause there to be room for
only the indicated number of lines to be printed at the current line
spacing at the bottom of the page.  The _.BLANK command can similarly
be followed by a negative number to place the next line a specified
number of single spaced lines from the bottom of the page, rather then
allowing enough room for the indicated number of lines to be printed
at the current line spacing at the bottom of the page.
.skip.test page 3
A _.LEADING command does not have to be active when the _.SKIP command
is issued with a negative argument either at the top of a page or before
any printing characters have been represented in the FORMAT statements.
Enough blank lines will be generated when the next line which contains
printing characters is represented in the FORMAT statement to place
this line at the proper location on the page regardless of whether
the page was empty when the _.SKIP command was issued.  The _.SKIP
command with a negative argument is ignored if the location of the
next line would already be at or below the indicated position.
.skip
The _.SKIP command can be issued with a negative argument even if a
_.PAGING command has not been issued.  If a _.PAGING command has not
been issued, then the page will be assumed to extend from the _.TEXT
command, _.PAGE command or _.TEST SPACING or _.TEST PAGE command which
generated the last break between the pages.  If a _.PAGING command
has not been issued, then a _.PARAGRAPH command will not have caused
the break between the pages.
.skip
The effect of a _.SKIP command issued with a negative argument is quite
different from that of a _.TEST SPACING command.  The _.SKIP command
moves the next printed line down on the page so that there is room
for only the indicated number of lines to be printed on the page.  The
_.SKIP command never generates a new page.  The _.TEST SPACING command
never changes the location of the next line if there is enough room
left on the page for the indicated number of lines to be printed.  The
_.TEST SPACING command instead insures that there is enough room left
on the page for the indicated number of lines to be printed, and starts
a new page if there is not.
.skip
A _.SKIP command issued with a negative argument can be followed by
a _.TEST SPACING command to place the following lines together at the
bottom of the current page if they will fit or on the top of the next
page if they will not fit.  Reversing the order of these 2 commands
would insure that the following lines would appear together at the
bottom of the current page if they fit, or on the bottom of the
following page if they do not fit on the bottom of the current page.
.skip
If a _.SPACING 2 command has been issued to obtain double spacing,
then a _.SKIP-3 command would generate enough blank lines to place
the next line at a location 5 lines from the bottom of the page so
that there would be only enough room left on the page for 3 printed
lines and the 2 blank lines between them.  A _.BLANK-3 command would
place the next line at a location 3 lines from the bottom of the page
regardless of the line spacing.
.skip.test page 15
For example, the source text
.skip.nofill
_.page length 10.right margin 24.output width 55
_.paging.page carriage 1
_.preface       WRITE(ITTY,$)
_.bottom       READ(ITTY,101)IPAUSE
This is single spaced at the top of the page.
_.skip-2
This is single spaced at the bottom of the page.
_.spacing 2
This is double spaced at the top of the page.
_.skip-2
This is double spaced at the bottom of the page.
_.program
  101 FORMAT(1A1)
.skip.fill.test page 14
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill
      WRITE(ITTY,1)
    1 FORMAT(25H1This is single spaced at/9H the top ,
     112Hof the page.///////23H This is single spaced ,
     22Hat/24H the bottom of the page.)
      READ(ITTY,101)IPAUSE
      WRITE(ITTY,2)
    2 FORMAT(25H1This is double spaced at//9H the top ,
     112Hof the page./////25H This is double spaced at/
     2/24H the bottom of the page.)
      READ(ITTY,101)IPAUSE
  101 FORMAT(1A1)
.skip.fill.test page 15
which would, in turn, generate the following text when run.
.skip.nofill
*************************** ***************************
*1This is single spaced at* *1This is double spaced at*
* the top of the page.    * *                         *
*                         * * the top of the page.    *
*                         * *                         *
*                         * *                         *
*                         * *                         *
*                         * *                         *
*                         * * This is double spaced at*
* This is single spaced at* *                         *
* the bottom of the page. * * the bottom of the page. *
*************************** ***************************
.fill
.skip 2.test page 6.LEFT MARGIN 5.indent -5
_.TEST PAGE number of single spaced lines needed on page
.skip
A new page is to be started if there is not enough room left on the
current page for the indicated number of additional single spaced lines
of text.  The maximum number of lines which are assumed to fit into
the current page is the number which was set by the previous _.PAGE
LENGTH command.  The page is assumed to hold 22 lines if a _.PAGE LENGTH
command has not been issued.
.skip.test page 3
The _.TEST SPACING command can similarly be used to check if there
is enough room left on the current page for the indicated number of
additional lines spaced according to the most recently issued _.SPACING
command.  If a _.SPACING 2 command has been issued to give double
spacing, then a _.TEST SPACING 5 command would be equivalent to a _.TEST
PAGE 9 command, since a blank line would not have to fit into the page
below the bottom printed line.  Except for the adjustment of the number
appearing to the right of the _.TEST SPACING command to allow for the
current line spacing, the _.TEST PAGE and _.TEST SPACING commands
perform identically.  The description of the _.TEST SPACING command
should be consulted for additional information.
.skip 2.left margin 5.test page 6.indent -5
_.TEST SPACING number of multiple spaced lines needed on page
.skip
A new page is to be started if there is not enough room left on the
current page for the indicated number of additional lines of text to
be displayed at the line spacing set by the previous _.SPACING command.
The maximum number of lines which are assumed to fit into the current
page is the number which was set by the previous _.PAGE LENGTH command.
The page is assumed to hold 22 lines if a _.PAGE LENGTH command has
not been issued.
.skip.test page 3
It is not necessary that the lines are being parcelled out into pages
when the _.TEST SPACING command is issued.  A _.TEST PAGE or _.TEST
SPACING command which fails, i.e_.  which requires more than the
remaining unused space on the page, or a _.TEXT or _.PAGE command,
sets the line count on the new page to zero.  All subsequent lines
are counted and are considered to be on the same page until a new page
is started regardless of whether a _.PAGING command has been issued.
.skip.test page 3
If the _.TEST SPACING command succeeds, i.e_.  if there is enough room
left on the current page to display the indicated number of lines at
the current line spacing, then the _.TEST SPACING command terminates
the current output line but does not start a new page and is equivalent
to a _.BREAK command.  If the _.TEST SPACING command fails, i.e_.  if
there is not enough room remaining unused on the current page, then
the page is filled with blank lines if a _.TRAILING command has been
issued, the current FORMAT statement is finished, and the text specified
by a _.BOTTOM or _.DEFINE BOTTOM command is inserted after the FORMAT
statement.  Also, if the test fails, then the text specified by a _.TOP
or _.DEFINE TOP command will be inserted before the next FORMAT
statement, and the carriage control characters specified by the _.PAGE
CARRIAGE command will be inserted at the left ends of the lines of
text on the new page.  If a _.PAGING command has not been issued, then
the next _.TEXT command will resume the insertion of the carriage
control character specified by the _.CARRIAGE command.
.skip.test page 3
If NUMBER1 is the number specified by the _.TEST SPACING command and
if NUMBER2 is the number specified by the _.SPACING command, then,
in order for a new page not to be necessary, there must be room enough
on the current page for NUMBER1 printed lines and for (NUMBER1-1) groups
of (NUMBER2-1) blank lines between the printed lines.  The number of
required lines can then be expressed as
.skip.indent 5
NUMBER1+((NUMBER1-1)*(NUMBER2-1))
.skip
which is equivalent to
.skip.indent 5
1+(NUMBER2*(NUMBER1-1))
.skip
where the asterisk represents multiplication.  If a _.SPACING 2 command
has been issued so that the output text is being double spaced, then
a _.TEST SPACING 5 command would test for the availability of 9 lines
which can be calculated either as 5+((5-1)*(2-1)) = 5+(4*1) = 9 or
as 1+(2*(5-1)) = 1+(2*4) = 9.
.skip.test page 3
The _.TEST PAGE command is similar to the _.TEST SPACING command except
that the _.TEST PAGE command checks if there is enough room left on
the current page for a specific number of single spaced lines.  If
a _.SPACING command has not been issued, or if a _.SPACING 1 command
has been issued most recently, so that the lines of text are being
single spaced, then the _.TEST SPACING command and the _.TEST PAGE
command are equivalent.
.skip.test page 13.fill
For example, the source text
.skip.nofill.test page 11
_.page length 7.right margin 14.output width 55
_.trailing.spacing 2
_.page carriage +-
_.preface       WRITE(ITTY,$)
_.top       WRITE(ITTY,1)
_.define bottom
      WRITE(ITTY,2)
      READ(ITTY,3)LTRRTN
_.program
      DATA ITTY/5/
_.text 100
TEST SPACING
_.test spacing 3
commands are
_.test spacing 3
interspersed
_.test page 5
among these
_.test page 5
double spaced
_.test spacing 3
lines of text.
_.program
    1 FORMAT('1Read message')
    2 FORMAT(' Press RETURN',__$)
    3 FORMAT(1A1)
      END
.skip.test page 10.fill
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill
      DATA ITTY/5/
      WRITE(ITTY,100)
  100 FORMAT(13H TEST SPACING//13H commands are////)
      WRITE(ITTY,2)
      READ(ITTY,3)LTRRTN
      WRITE(ITTY,1)
      WRITE(ITTY,101)
  101 FORMAT(13H+interspersed/1H-/12H-among these/1H-/
     11H-/1H-/1H-)
      WRITE(ITTY,2)
      READ(ITTY,3)LTRRTN
      WRITE(ITTY,1)
      WRITE(ITTY,102)
  102 FORMAT(14H+double spaced/1H-/15H-lines of text./
     11H-)
    1 FORMAT('1Read message')
    2 FORMAT(' Press RETURN',$)
    3 FORMAT(1A1)
      END
.skip.fill.test page 14
which would, in turn, generate the following pages of text when run.
.skip.nofill
*****************  *****************  *****************
* TEST SPACING  *  *1Read message  *  *1Read message  *
*               *  *+interspersed  *  *+double spaced *
* commands are  *  *-              *  *-              *
*               *  *-among these   *  *-lines of text.*
*               *  *-              *  *-              *
*               *  *-              *  *****************
*               *  *-              *
* Press RETURN  *  *-              *
*****************  * Press RETURN  *
                   *****************
.fill
.left margin 5
.skip 2.fill.test page 4.indent -5
_.TOP line of text to be inserted at top of each page
.skip
The characters which appear to the right of the _.TOP command on the
same line are to be copied into the output file on a separate line
before the FORMAT statement which represents the top line on each new
page.  The character to the immediate right of the _.TOP command must
be a space.  The line of text which is to be copied into the output
file before the start of each new page starts with the second character
to the right of the _.TOP command, whether or not this is a printing
character, and extends through the rightmost printing character on
the line.  The line of text specified by the _.TOP command is copied
into the output file as a line of ordinary FORTRAN text.  This line
is not represented in the FORMAT statements.  The line of text specified
by the _.TOP command might be used to clear the screen on a video
terminal before the text on the page is displayed or to place a standard
header onto the screen.  The rules which govern the specification of
the line which is defined by the _.TOP command are identical to those
which are described elsewhere in this manual for the _.PREFACE command.
Dollar signs can appear in the line specified by the _.TOP command
to indicate locations at which the next statement numbers are to be
inserted, and these statement numbers can be manipulated as described
for the _.PREFACE command.
.skip.test page 3
Provided that a _.TRAILING command has been issued and that there is
already something on the page, enough blank lines are represented in
the FORMAT statement to fill the current page whenever a _.PAGE command
is issued, or whenever a _.TEST PAGE or a _.TEST SPACING command fails,
or, provided that a _.PAGING command has been issued, whenever the
page fills.  Then the line of text specified by the _.TOP command is
copied into the output file just before the next line of text is placed
on the next page.  It is not necessary that a _.PAGING command have
been issued before the _.PAGE or the _.TEST PAGE or the _.TEST SPACING
command.
.skip.test page 3
If more than a single line must be inserted before the FORMAT statement
which represents the top line on each new page, then a _.DEFINE TOP
command followed by the lines of text and then by an _.END DEFINITION
command should be used to define the lines instead.  Regardless of
which method is used to define the line or lines, the insertions of
the line or lines are performed similarly.  The line of text specified
by the _.TOP command or the lines specified by the _.DEFINE TOP command
will continue to be inserted into the output file before the FORMAT
statement representing the top line on each new page of text until
a subsequent _.NO TOP command is issued.  The insertion of this text
will be resumed if a _.RESUME TOP command is issued after the _.NO
TOP command.
.skip.test page 3
The _.GROUP or _.DEFINE GROUP command defines lines which are inserted
before a logical section of text which could be continued onto several
pages.  The _.TOP or _.DEFINE TOP command defines lines which are
inserted before each new page.  The _.PREFACE or _.DEFINE PREFACE
command defines lines which are inserted before each individual FORMAT
statement.  Typically, the _.GROUP or _.DEFINE GROUP command would
be used to define a transfer back to the calling program when the
previous section was completed and would construct the numbered
statement to which the calling program would transfer to use the current
section.  The _.TOP or _.DEFINE TOP command would define the FORTRAN
statements needed to clear the screen before the first and each
subsequent page.  The _.PREFACE or _.DEFINE PREFACE command would insert
the WRITE statements needed to use the FORMAT statements.  If several
of these types of lines are being inserted before a particular FORMAT
statement, then the lines defined by the _.GROUP or _.DEFINE GROUP
command are inserted first, followed by the lines specified by the
_.TOP or _.DEFINE TOP command, followed in turn by the lines specified
by the _.PREFACE or _.DEFINE PREFACE command.
.skip.test page 10
For example, the source text
.skip.nofill
_.page length 5.right margin 14.output width 55
_.no justify
_.preface       WRITE(ITTY,$)
_.top       WRITE(ITTY,100)
_.define bottom
      WRITE(ITTY,101)
      READ(ITTY,102)LTRDMY
_.end definition
_.paging.trailing
_.program;      ITTY=5
_.text;This page will be terminated early.
_.page
This sentence is long enough that it will
have to be continued onto a second page.
_.page
_.program
  100 FORMAT('1Sample Screen'/)
  101 FORMAT(/' Press RETURN',___$)
  102 FORMAT(1A1)
      END
.skip.test page 10.fill
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill
      ITTY=5
      WRITE(ITTY,100)
      WRITE(ITTY,1)
    1 FORMAT(15H This page will/14H be terminated/2H e,
     15Harly.//)
      WRITE(ITTY,101)
      READ(ITTY,102)LTRDMY
      WRITE(ITTY,100)
      WRITE(ITTY,2)
    2 FORMAT(14H This sentence/15H is long enough/2H t,
     111Hhat it will/11H have to be/15H continued onto)
      WRITE(ITTY,101)
      READ(ITTY,102)LTRDMY
      WRITE(ITTY,100)
      WRITE(ITTY,3)
    3 FORMAT(15H a second page.////)
      WRITE(ITTY,101)
      READ(ITTY,102)LTRDMY
  100 FORMAT('1Sample Screen'/)
  101 FORMAT(/' Press RETURN',$)
  102 FORMAT(1A1)
      END
.skip.fill.test page 14
which would, in turn, generate the following pages of text when run.
.skip.nofill
*****************  *****************  *****************
*1Sample Screen *  *1Sample Screen *  *1Sample Screen *
*               *  *               *  *               *
* This page will*  * This sentence *  * a second page.*
* be terminated *  * is long enough*  *               *
* early.        *  * that it will  *  *               *
*               *  * have to be    *  *               *
*               *  * continued onto*  *               *
*               *  *               *  *               *
* Press RETURN  *  * Press RETURN  *  * Press RETURN  *
*****************  *****************  *****************
.skip.fill
The dollar sign in the FORMAT statement in the above example is a
DECsystem10/20 notation for preventing a carriage return from being
included at the end of a line which is displayed on the terminal.  This
allows the screen cursor to remain to the right of the request until
the user presses the RETURN key.
.skip 2.left margin 5.test page 6.indent -5
_.TRAILING
.skip
The _.TRAILING command indicates that each page which is terminated
by a _.PAGE command or by a _.TEST PAGE or _.TEST SPACING command which
fails is to be filled with enough blank lines to make the number of
lines on the page be equal to the page size specified by the _.PAGE
LENGTH command.  If both a _.TRAILING command and a _.PAGING command
have been issued, then a _.PARAGRAPH command which appears closer to
the bottom of the page than the number of lines specified by the third
number appearing to the right of the _.PARAGRAPH command will also
fill the bottom of the page with blank lines.  Regardless of whether
a _.PAGING command has been issued, a page which is terminated by a
_.TEXT command or which is at the end of the input file will not be
filled with blank lines.  However, if a _.TRAILING command has been
issued, then any blank lines requested by a _.BLANK or _.SKIP command
just before the _.TEXT command or at the end of the input file, and
the interline spacing requested by a _.SPACING command, will be
represented at the bottom of the page.
.skip.test page 3
If both a _.TRAILING command and a _.LEADING command have been issued,
then any blank lines requested at the bottom of a page for which there
is not enough room on that page will be shown at the top of the next
page.  If both of these commands have not been issued, then blank lines
which are requested at the bottom of a page, but for which there is
not enough room on that page, are discarded.
.skip.test page 3
If the output text is not being paged, then the _.LEADING command can
be used to obtain blank lines requested at the start or immediately
after a _.TEXT command, and the _.TRAILING command can be used to obtain
blank lines requested at the end of the input file or immediately before
a _.TEXT command.  Regardless of whether the output text is being paged,
the _.TRAILING command changes the timing of the representation of
blank lines which are requested just before a _.PROGRAM command.  If
the _.TRAILING command has not been issued, then it is not known when
the _.PROGRAM command is issued whether the blank lines will be needed,
so the blank lines must be reserved until after the next _.CONTINUE
command.  If the _.TRAILING command has been issued, then the blank
lines requested immediately before a _.PROGRAM command are represented
in the FORMAT statement before the lines of the text appearing after
the _.PROGRAM command are copied as FORTRAN statements into the output
file.
.skip.test page 3
The _.TRAILING command is the opposite of the _.NO TRAILING command.
If a _.NO TRAILING command has been issued, or if a _.TRAILING command
has not been issued, then the bottoms of the pages are not filled with
blank lines and none of the blank lines requested immediately before
a _.TEXT command or at the end of the input file are represented in
the FORMAT statements.
.skip.test page 10.fill
For example, the source text
.skip.nofill.test page 11
_.page length 5.right margin 14.no justify
_.paging.page carriage 1.output width 55
_.preface       WRITE(ITTY,$)
A TRAILING command hasn't been issued.
_.page.trailing
A TRAILING command is now active.
_.test page 3
This comes after the TEST PAGE command.
.skip.test page 12.fill
would, when processed by this program, be transformed into the following
FORTRAN text
.skip.nofill
      WRITE(ITTY,1)
    1 FORMAT(11H1A TRAILING/15H command hasn't/5H been,
     18H issued.)
      WRITE(ITTY,2)
    2 FORMAT(11H1A TRAILING/15H command is now/5H acti,
     13Hve.//)
      WRITE(ITTY,3)
    3 FORMAT(11H1This comes/15H after the TEST/5H PAGE,
     19H command.)
.skip.fill.test page 10
which would, in turn, generate the following pages of text when run.
.skip.nofill
*****************  *****************  *****************
*1A TRAILING    *  *1A TRAILING    *  *1This comes    *
* command hasn't*  * command is now*  * after the TEST*
* been issued.  *  * active.       *  * PAGE command. *
*****************  *               *  *****************
                   *               *
                   *****************
.fill
.fill
.left margin 0
.page.initial page.skip left page.initial page
.RIGHT TOP TITLE'FORMAT Development History',,'>'
.center
Appendix A
.skip 3
.center
FORMAT Program Development History
.center
------ ------- ----------- -------
.skip
.left margin 4
.indent -4
May 1980
.break
Original release of the FORMAT program through DECUS library.
.skip
.indent -4
August 1980
.break
(correction) Empty lines were being discarded when multiple spacing
in nofill mode.  A line represented by merely a semicolon to right
of a command was being discarded when in nofill mode.
.skip.test page 3.indent -4.fill
August 1983
.break
The following commands were added to support paging on video terminals.
The general function of each group of new commands is listed at the
top.
.nofill.skip.test page 12
screen top  screen bottom  1st statement new statement
_.TOP        _.BOTTOM        _.GROUP        _.DEFINE PREFACE
_.DEFINE TOP _.DEFINE BOTTOM _.DEFINE GROUP _.RESUME PREFACE
_.NO TOP     _.NO BOTTOM     _.NO GROUP
_.RESUME TOP _.RESUME BOTTOM _.RESUME GROUP

select paging    page characteristics  other
_.PAGING          _.PAGE LENGTH          _.END DEFINITION
_.NO PAGING       _.PAGE CARRIAGE        _.PAGE POSITION
_.PAGE            _.NO PAGE CARRIAGE
_.TEST PAGE
_.TEST SPACING
.fill.skip.test page 3
(change) The _.LENGTH command has been renamed _.OUTPUT LENGTH, the
_.BEGIN command has been renamed _.TEXT, and the _.FORMAT command has
been renamed _.CONTINUE, but the previous names are still recognized.
.skip.test page 3
(change) A preface line is no longer cancelled by a _.TEXT command.
.skip.test page 3
(extension) The _.COMMENT command has been added to allow commenting
of the source file.
.skip.test page 3
(extension) The _.BLANK and _.SKIP commands now accept negative
arguments to allow skipping to within the indicated number of lines
at the bottom of the page on a video terminal.
.skip.test page 3
(extension) The _.PARAGRAPH command now accepts a third argument which
is the number of additional lines for which there must be room on the
page.  A new page is generated if there is not enough space.
.skip.test page 3
(extension) The dollar signs appearing within the range of a _.PROGRAM
command, as well as in the text defined by the _.TOP, _.BOTTOM, _.GROUP
and _.PREFACE commands, can now be followed by an equal sign to change
the number of the next statement or by a plus or minus sign to
temporarily modify the value which is copied into the output.
.fill
.left margin 0
.page.initial page.skip left page.initial page
.RIGHT TOP TITLE'List of Files Included in this Package',,'>'
.center
Appendix B
.skip 3
.center
List of Files Included in this Package
.center
---- -- ----- -------- -- ---- -------
.left margin 12
.skip.test page 3.indent-12
ABSTRA.RNO##Abstract containing a short description of the FORMAT
program.
.skip.test page 3.indent-12
FMTD10.FOR##A version of the FMTASK and FMTEND routines for the
DECsystem10 and DECsystem20 computers.  The FMTASK routine asks for
the user to specify the input file and opens it, then asks for the
user to specify the output file and opens it.  The FMTEND routine closes
the files when they are done.  These routines are simple and can be
modified easily for use on other computers.
.skip.test page 3.indent-12
FORMAT.DOC##The instruction manual.  This was produced by using the
FROFF word processor to process the rough form of the manual in the
FORMAT.RNO file.
.skip.test page 3.indent-12
FORMAT.FOR##The system independent portion of the FORMAT program.  This
must be loaded with a version of the FMTASK and FMTEND routines
customized for the computer on which the FORMAT program will be used.
.skip.test page 3.indent-12
FORMAT.GET##File containing the results which are expected when the
test cases in the FORMAT.TRY file are processed by the FORMAT program.
.skip.test page 3.indent-12
FORMAT.KEY##Data file which when processed by the KEYWRD program
produces the BLOCK DATA routine which defines the vocabulary of commands
recognized by the FORMAT program.
.skip.test page 3.indent-12
FORMAT.RNO##The rough form of the instruction manual.  This is meant
to be processed by the FROFF word processor.
.skip.test page 3.indent-12
FORMAT.TRY##A group of test cases which when processed by the FORMAT
program should produce a file identical to the FORMAT.GET file.
