.sp 1;.nonum;.lm 8;.ps 50,72
.ts 1,8,16,24,32,40,48,56,64
.pg;.nm ch 1
.ch SIMULA FOR DEC SYSTEM 10#############TD, SIMDDT
.nm 1
.st 741101####780302######6###########################Ingrid Wennerstrom
.lm 8;.pg;.i -8;IV######THE DEBUG SYSTEM
.br;----------------
.P -8,2,1;IV.1####SYSTEM DESCRIPTION
.s;The SIMULA Language Handbook Part II, Chapter 9, contains a description
of the SIMDDT system from the user's point of view.
.s;The main tasks of SIMDDT are:
.i -3;*##to produce a message stating the reason for SIMDDT invocation.
.i -3;*##to produce a diagnostic message when a run time error
has been found. The message contains a reference to the source line
where the error occurred.
.p -3,0,4;*##to respond to valid user commands and give a message
for invalid commands.
.p -3,0,4;*##to set, remove or display breakpoints in the user program.
.p -3,0,3;*##to perform breakpoint actions on reaching a breakpoint.
.p -3,0,6;*##to display values of variables, the entire storage pool,
the operating chain and all scheduled processes (OUTPUT, VARIABLES,
CHAIN, SCHEDULED and ALL commands).
.p -3,0;*##to change the value of a variable (INPUT command).
.p -3,0;*##to direct the output from SIMDDT to another file or terminal
than the user TTY (USE command).
.p -3,0;*##to take command input from a file or another terminal
(@ command).
.p -3,0;*##to display source program lines (DISPLAY command).
.p -3,0;*##to change the viewpoint of the program (INSPECT).
.p -3,0;*##to close files on demand (CLOSE).
.p 0,1,4;The SIMDDT program is self-relocating and is read from disk
by the SIMRTS routine OCLD on demand. It exists as a binary file SIMDDn.ABS
(n = version number, e.g_. 4). The file is normally read into the
dynamic part of the low segment area and may be moved by the garbage
collector routine (SAGC). If SIMDDT is invoked before the SIMULA program
starts execution, however, by a LOAD-REENTER sequence or a DEBUG command,
it will be placed before the SIMULA data area and will not be moved,
neither will it disappear if the program exits and is restarted by
a START command.
The SIMDDn.ABS file is generated by execution of the special utility
program SUTABS loaded together with the REL file produced by assembling
the SIMDDT source modules.
.p 0,1,6;The commands to SIMDDT are normally taken from the user terminal
but may be taken from a file (or terminal) specified by the @ command.
Communication with the RTS is via information in the low segment STATIC
area and via accumulators at entry to SIMDDT and to RTS routines from
SIMDDT.
.p 0,1,6;Output from SIMDDT is written on the user's TTY
(which may be a controlling PTY if SIMDDT is run in a subjob to e.g_.
BATCON). Output can also be directed to a disk file or another TTY.
.br;New feature starting with version 4(302):
If another TTY is used both as input (@TTYn:) and as output (USE TTYn:),
no output will appear on the controlling user TTY. This is useful
if the ordinary TTY should be undisturbed by debug info.
.p 0,1,5;The LINE NUMBER TABLE generated by the compiler is used by
SIMDDT to find the core address that corresponds to a source program
line or vice versa.
.br;One type of entry found in the line number table shows the block
structure of the program. From these entries, the corresponding SYMBOL
TABLES can be found (via the prototypes) and this enables SIMDDT to
find the proper match to an identifier given in a command by
following the block structure outwards.
SIMDDT only accepts identifiers visible from the current block.
For an OUTPUT or INPUT command, the current block is the block in
which program execution was interrupted, and for a breakpoint command
(AT ...) it is the block containing the statement referenced via the
line number.
.br;The INSPECT command can be used to change the current block, however,
to any block reachable via the operating chain or via reference variables.
.p 0,1,5;The SYMBOL TABLES generated by the compiler contain for each
identifier its name, characteristics and the offset within its block
instance. Every object with a prototype also has a symbol table.
.p 0,1,5;The BREAKPOINT RECORD TABLE contains the information from
the user breakpoint commands and the instructions that were replaced
by breakpoint UUO's in the generated code. The breakpoint record contains
pointers to the line number table, the symbol tables and the effective
block level (copied from the prototype). To implement the IFCHANGED
form of the breakpoint command the REF and TEXT variable addresses
and values must be kept between breakpoints. The SIMDDT work area
does not contain space for the actual text values saved. To solve
the space and relocation problems for these variables, one REF array
and one TEXT array are allocated via the RTS. Old REF and TEXT pointers
are kept in those arrays, which are properly relocated by the garbage
collector, thus the referenced values will be retained for later comparison.
.p 0,1,6;The KEYWORD TABLE contains one entry for each special identifier
or operator that must be recognized by SIMDDT when scanning a user
command. The entry consists of name (SIXBIT), control bits and a dispatch
routine address for command starting kewwords.
.p 0,1,7;All messages form SIMDDT are created in SIMDDT and this applies
also to most of the messages from the generated program and from SIMRTS.
Some terminating error messages and the I/O file specification
dialogue messages are not handled by SIMDDT.
The method for handling diagnostic messages is almost the same as
the method used in the compiler, see II.5.
.pg;.nm ch 2;.lm 8
.ch SIMULA FOR DEC SYSTEM 10#############TD, SIMDDT
.nm 1
.st 741101####780302######6###########################Ingrid Wennerstrom
.pg;.lm 8;.i -8;IV.2####SIMDDT DECOMPOSITION
.S 2;SIMDDT consists of the following components:
.lm 24;.p -16,1;Source module	Function
.p -16,1;SIMDS1		entry points
.p -16,1;SIMDS2		I/O, messages, initialization, search of the
line number table and interface to SIMRTS routines.
.p -16,1;SIMDS3		breakpoint table processing, output text creation,
search of symbol tables and scanning of input.
.p -16,1;SIMDS8		error message table start address.
.p -16,1;SIMEDS		error message tables created by SUTEDS utility.
.p -16,1;SIMDS9		breakpoint and command processing.
.p -16,1;SIMDS7		data area.
.pg;.lm 1;.lt 30
IV.2.1  Main flow
        ---------

  -----------      -----------       -----------        -----------
 ( from OCEI )    ( from OCUU )     ( from OCRE )      ( from OCUU )
  -----------      -----------       -----------        -----------
       !                !                 !                  !
       !                !                 !                  !
+-------------+  +-------------+   +--------------+   +--------------+
! DSINI       !  ! DSINB, DSBP !   ! DSINR        !   ! DSINE        !
! initialise  !  ! breakpoint  !   ! ^C-interrupt !   ! Error in the !
! SIMDDT      !  ! actions     !   ! - REENTER    !   ! program      !
+-------------+  +-------------+   +--------------+   +--------------+
       !                !                 !                  !
       !             +-----+           +-----+            +-----+
       !     Y    +   break-  +      + SIMDDT  +       +  termin- +
       !<--------<    point    >   <   active    >-+  <   ating     >-+
       !          +   STOP?   +      + already?+   ! Y +  error?  +   ! Y
       !             +-----+           +-----+    (1)     +-----+    (1)
       !                ! N               ! N                ! N
       !               (2)                !                  !
       !                           +--------------+   +--------------+
       !                           !Output message!   ! Output error !
       !<--------------------------!with interrupt!   ! message      !
       !                           !address       !   !              !
       !                           +--------------+   +--------------+
       !                                                     !
       !<----------------------------------------------------+
       !
      (3)
.el
.pg;.lt 38
                                     ----------       -----------
                 (3)               ( from START )   ( from OCSPDR )
                  !                  ----------       -----------
                  !                      !                 !
                  !                +------------+   +-------------+
                  !                ! DSINM      !   ! DSINS       !
                  !                !SIMDDT loa- !   ! Remove all  !
                  !                !ded with prg!   ! breakpoints !
                  !                +------------+   +-------------+
            +------------+               !                 !
            ! DSCM       !           ----------            !
+---------->! accept user!         ( to .MAIN+2 )         (1)
!           ! command    !           ----------
!           +------------+
!                 !
!           +--------------------------------------------------+
!           !                  !               !               !
!     +------------+     +------------+  +------------+  +------------+
!     ! DSAT       !     ! DSVA       !  ! DSPR       !  ! DSEX       !
!     ! breakpoint ! ... ! VARIABLES  !  ! PROCEED    !  ! EXIT       !
!     ! settings   !     ! command    !  ! command    !  ! command    !
!     +------------+     +------------+  +------------+  +------------+
!           !                  !               !               !
+------------------------------+            +-----+            !
                                  Y      +   ENTER   +         !
                               +-------< via breakpoint>       !
                               !         +     ?     +         !
                               V            +-----+            !
                         +------------+        ! N          +-----+
                         ! Perform    !        !     N   +   DEBUG   +
                         ! breakpoint !        !<------<     mode      >
                         ! actions    !        !         +     ?     +
                         +------------+        !            +-----+
                               !         (1)-->!               !
                               !               !
                          -------------   -------------   ------------
                         (EXIT to progr) (RETURN to RTS) (EXIT to OCEP)
                          -------------   -------------   ------------
.el
.pg;.lm 8;.i -8;IV.2.2##Module contents
.br;---------------
.s;The following list should serve as an index to the source listing.
Detailed descriptions are given there.
.nf;.s;SIMDS1
------
.f;.lm 16;.p -8,0,4;DSINI###Starts SIMDDT processing in debug mode.
Called from the RTS routine OCEI before starting execution of user
program code.
.p -8,0,3;DSINE###Starting point in SIMDDT for error processing. Called
from RTS (OCUU). Outputs the error message.
.p -8,0,3;DSINEM#Entry from INSPECT/START to repeat error message.
.p -8,0,3;DSINB###Start of breakpoint instruction processing. Called
by OCUU. Locates breakpoint and continues at DSBP.
.p -8,0,3;DSINR###Entry point after _^C-REENTER or CONTINUE following
program exit. Called from OCRE. Indicates interruption point (source
line) by a message.
.p -8,0,3;DSINRM#Entry from INSPECT/START to repeat message.
.p -8,0,3;DSINC###This routine is entered from a code sequence in
the static low segment area on return from certain RTS routines which
may have caused garbage collection or detected an error (see DSCRT).
Relocates the SIMDDT stack and I/O text variables if a garbage collection
was performed since SIMDDT called the RTS routine.
Writes any error message replacing the message prefix ZYQ by ZYD.
.p -8,0,6;DSINM###The whole program starts in this entry point if
SIMDDT.REL was loaded with the user main program and the last entry
point definition seen by LINK was DSINM.
This feature is mainly used for SIMDDT debugging purposes. Exits directly
to the generated program (at .MAIN+2) with the base address of SIMDDT
(DSSTAR) in ac X1.
.p -8,0,4;DSINS###Removes all breakpoints. Called from the RTS routine
OCSPDR before restarting a SIMULA program that has executed since
being loaded to core. Since the low segment will be cleared, it is
not possible to keep the breakpoints.
.p -8,1,10;SIMDS2
.i -8;------
.i -8;DSFK####Finds a keyword in the keyword table.
.p -8,0,2;DSTC####Converts a valid ASCII character to SIXBIT.
.p -8,0,2;DSIT####Inputs a command line from the TTY or a file.
.p -8,0,3;DSO#####Several routines to create a message in the output
buffer, write the buffer on the tty or a file.
.p -8,0,3;DSVO####Outputs message on file and tty.
.p -8,0,3;DSSCI###Loads next input character in an accumulator.
.p -8,0,3;DSSKB###Loads next non-blank, non-tab character in an accumulator.
.p -8,0,3;DSGI####Gets the next identifier or relational operator from the input
buffer.
.p -8,0,3;DSIFK###Finds keyword identifier in input buffer.
.p -8,0,3;DSPM####Creates a message and puts it in the output buffer using the
message tables generated by SUTEDS.
.p -8,0,3;DSIS####Initialises SIMDDT.
.p -8,0,3;DSISRB##Removes all breakpoints from user code.
.p -8,0,3;DSOC####Puts a character in the output text.
.p -8,0,3;DSONL###Initialises the output text pointers.
.p -8,0,3;DSINL###Initialises the input text pointers.
.p -8,0,3;DSPL####Locates an address in the line number table and puts the string
<MODULE>:<NNNNN>, <MODULE>:#O<oooooo> or O<oooooo> in the output buffer.
.p -8,0,3;DSLL####Locates a line number in a given line number table.
.p -8,0,3;DSLO####Locates an octal address in any of the line number tables.
.p -8,0,3;DSEZLN##Searches the line number table for the main program to find
the line number tables for external classes and procedures.
.p -8,0,3;DSPO####Puts an octal number in the output buffer.
.p -8,0,3;DSTX####Several routines handling the interface to the RTS text routines
TXPI, TXPR, TXGI and TXGR.
.p -8,0,3;DSCRT
.p -8,0,3;DSCTX###Save status and call an RTS routine via a code sequence in the
low segment area. Any call from SIMDDT to a RTS routine which may
cause garbage collection or find an error must be routed via DSCRT
or DSCTX. DSCTX calls the TXGI or the TXGR routine.
.p -8,0,3;DSCLO###Collection of routines that close a (specific)
file using the RTS routine IOCL.
.p -8,0,3;DSBUTX##Initialises the input and output text pointers and the SIMDDT
stack.
.p -8,0,3;DSEXPR##Closes an open display file and resets variables.
.p -8,0,3;DSFSP###Creates a file specification.
.p -8,0,3;DSCF####Creates a file object and opens the file.
.p -8,0,3;DSCFAB##Allocate buffers when normal method cannot be used (no GC
allowed).
.p -8,0,3;DSCFLB##Link buffers set up by DSCFAB.
.p -8,0,3;DSRUC###Finds static or dynamic link.
.p -8,0,3;DSRU####Calls DSRUC.
.p -8,0,3;DSLPR###Finds prototype or class identifier in any of the existing
line number tables.
.p -8,0,3;DSCHGC##Checks if a command is allowed (garbage collection may be
prohibited).
.p -8,0,3;DSVAK###Checks for /-ARRAY, /-TEXT, /-GC or /START:oooooo in command.
.p -8,0,3;DSIOCT##Compute value of integer given in octal radix.
.p -8,1,10;SIMDS3
.i -8;------
.p -8,0,3;DSRB####Releases all linked breakpoint entries (ZBE records).
.p -8,0,3;DSNB####Finds the next breakpoint entry or word within the breakpoint
entry (ZBE).
.p -8,0,3;DSNBC###Finds the next breakpoint entry (ZBE) which contains information
from a new command.
.p -8,0,3;DSFB####Reserve and link one more breakpoint entry (ZBE) or reserve
the next word within the breakpoint entry.
.p -8,0,3;DSPS####Puts identifier from the keyword table or the symbol table
or puts MAIN or BLOCK in the output buffer.
.p -8,0,3;DSPI####Puts <IDENTIFICATION2> in the output buffer. The information
is fetched from the breakpoint entries given in the call.
.p -8,0,3;DSNI####Gets a new <IDENTIFICATION> or <IDENTIFICATION2> from the
input buffer and places the information in the breakpoint entries
(ZBE).
.p -8,0,3;DSSS####Finds all blocks accessible via the current program block
or via a specified class and its prefix classes.
The symbol tables accessible for each block are passed as parameters
(one at a time) to a subroutine whose address is given in the call
to DSSS as a parameter. DSSS searches the line number table and finds
the symbol tables via the prototype pointers.
.p -8,0,3;DSCT####Checks if a symbol table entry (ZSD) can be handled by SIMDDT.
.p -8,0,3;DSLV####Locates the address of a variable with the help of the XCB
ac and the breakpoint entries (ZBE).
.p -8,0,3;DSSPV###Gets system procedure value address.
.p -8,0,3;DSCSQU##Calls RTS routine CSQU to check a qualification.
.p -8,0,3;DSNILV##CAlls DSNI and DSLV to find the address of an <IDENTIFICATION2>.
.p -8,0,3;DSPV####Edits the value of a variable into the output text.
.p -8,0,3;DSPVS###Outputs array elements or a complete block (*).
.p -8,0,3;DSFA####Puts the class, procedure or block identification in the output
buffer. The identification consists of name, octal address, reactivation
point or invocation address.
.p -8,0,3;DSVIV###Checks if a variable has its standard initial value.
.p -8,0,3;DSVAR###Fetches the subscript, dope vector and base address for an
array element.
.p -8,0,3;DSGS####Loads the next text constant character from the input buffer.
.p -8,0,3;DSGL####Gets the statement identification <LINE> from the input buffer
and returns the address of the correponding line number table entry.
.p -8,0,3;DSGV####Gets a <VALUE> from the input command and saves the information
in the breakpoint entry (ZBE).
.p -8,0,3;DSRLB###Resets all information from one breakpoint command.
.p -8,0,3;DSRLBA##Resets all information from one breakpoint command if an error
occurred while scanning the command.
.p -8,0,3;DSRLBI##Removes a breakpoint instruction from the compiled code.
.p -8,0,3;DSRL####Removes the information from all breakpoint commands relating
to the same breakpoint location.
.p -8,0,3;DSPB####Reconstructs a breakpoint command and puts it in the output
buffer.
.p -8,0,3;DSLB####Scans the breakpoint records (ZBR) for a match to an input
statement identification <LINE>.
.p -8,0,3;DSRAF###Reserves any free element in the REF array YDSREF.
.p -8,0,3;DSRAT###Reserves any free element in the TEXT array YDSTXT.
.p -8,0,3;DSFAR###Releases an element in the REF array YDSREF.
.p -8,0,3;DSFAT###Releases an element in the TEXT array YDSTXT.
.p -8,0,3;DSFCV###Loads address of a constant to an ac.
.p -8,2,10;SIMDS9
.i -8;------
.p -8,0;DSBP####Performs the actions specified for a breakpoint.
.p -8,0,3;DSCM####Outputs the prompting asterisk (*) on the terminal where commands
are input, scans the first word of the command and dispatches control
to the proper routine via the keyword table.
.p -8,0,3;DSST####Sets a flag when STOP was found as the first word of the command.
.p -8,0,3;DSHE####Outputs helpful text on the terminal (HELP command).
.p -8,0,3;DSAT####Scans the AT command, saves the information in a breakpoint
record and a set of linked breakpoint entries (ZBR and ZBE) and substitutes
a special instruction (BREAK UUO) for the user code instruction.
.p -8,0,3;DSDP####Outputs the requested source program lines (DISPLAY command).
.p -8,0,3;DSOP####Handles the OUTPUT command.
.p -8,0,3;DSIP####Handles the INPUT command.
.p -8,0,3;DSRE####Handles the REMOVE command; removes information for one or
all breakpoints.
.p -8,0,3;DSBR####Handles BREAKS command, listing all breakpoint commands currently
defined and removes a command if requested by the uesr.
.p -8,0,3;DSCL####Closes all open files except SYSIN, SYSOUT or lists all open
files, letting the user decide on closing each file separately.
.p -8,0,3;DSPR####Handles PROCEED command. Exits from SIMDDT via the RTS stack
if SIMDDT was entered via DSINI, DSINE or DSINR. Interprets the user
instruction and branches to the following instruction if SIMDDT was
entered at DSINB (breakpoint entry).
.p -8,0,3;DSUS####Handles USE command. Calls the RTS routines IOLN, CPNE, CSEN
and IOOP to establish a USE file object and to initialise the file.
.p -8,0,3;DSCH####Handles CHAIN command. Outputs operating chain starting from
the current block.
.p -8,0,3;DSVA####Handles VARIABLES command. The garbage collector routine in
the RTS is called unless prohibited by a /-GC switch, by entering
through DSINR or by the SWNOGC flag being on. All variables in the
storage pool are listed, normally from the bottom of the pool, unless
modified by a /START switch.
.p -8,0,3;DSPAE###Outputs an array identifier, its bounds and any array element
which have values different from the default initial value.
.p -8,0,3;DSVA01##Outputs all variables in a block.
.p -8,0,3;DSSC####Handles SCHEDULED command. Uses the SUNE procedure of the
RTS to find the next scheduled process.
.p -8,0,3;DSPC####Handles INSPECT command. Changes current block pointer.
.p -8,0,3;DSAL####Handles ALL command. Invokes DSCH, DSVA, DSSC.
.p -8,0,3;DSEX####Handles EXIT command. In error mode, exit is via the SIMRTS
stack, in debug mode exit is to OCEP for program termination.
.p -8,0,3;DSNOPR##Handles NOPROCEED command. Inhibits use of the PROCEED command.
This allows more SIMDDT actions at the expense of not being able to
continue.
.p -8,0,3;DSGET###Handles @ command. Opens a file for input (using the RTS routines
for file handling) and sets the YDSITTY switch off to indicate command
input from a file (which may represent a disk file or another TTY).
.p -8,0,3;DSNOTI##Handles unimplemented commands.
.p -8,0,3;DSTERM
.p -8,0;DSIE####Entered after a termination error detected within SIMDDT. Outputs
message and branches to OCEP to terminate the program.
.pg;.nm ch 3;.lm 8
.ch SIMULA FOR DEC SYSTEM 10#############TD, SIMDDT
.nm 1
.st 741101####780302######6###########################Ingrid Wennerstrom
.pg;.lm 8;.i -8;IV.3####LOW SEGMENT ORGANISATION
.S;.LT 40
ACCUMULATORS  +---------------+   GENERATED PROGRAM
------------  !---------------!   -----------------
              ! ZLN, ZSM, ZSD !   Constant records generated by the
              ! ZPR, ZMP      !   compiler, referenced by SIMDDT,
              : - - - - - - - :   see I.5
XLOW -------> !---------------!
              ! Global variab-!   STATIC LOW SEGMENT AREA
              ! les (STATIC)  !   -----------------------
XPDP -------> !...............!   Used by RTS and SIMDDT,
              ! RTS stack     !   relocated by garbage collector
              : - - - - - - - :
XDBAS ------> :---------------:   DYNAMIC LOW SEGMENT AREA
              :---------------:   ------------------------
              ! ZDN           !   SIMDDn.ABS (approx. 6.5K)
XDZBR ------> !---------------!
              ! ZBR           !   SIMDDT data area:
              !---------------!   Breakpoint record and
              ! ZBE           !   entries
              :---------------:
XDSTK ------> :---------------:
              ! SIMDDT stack  !
              !---------------!
              ! ZTE (ZDSZTE)  !   TEXT record for I/O
              !---------------!
              !input text buf !
              !---------------!
              !output text buf!
              !---------------!
              !input text str.!
              !---------------!
              ! ZAR (ZDSTXT)  !  TEXT array used by SIMDDT
              !---------------!
              ! ZAR (ZDSREF)  !  REF  array used by SIMDDT
              :---------------:
              :               :
XCB --------> :---------------:
              ! ZBI           !  Current block instance
              :---------------:
              :               :
              +---------------+
.el
.pg;.lm 8;.i -8;IV.3.1##Static low segment area
.br;-----------------------
.s;This is the communication area for the RTS. It is also used for interface
between SIMDDT and the RTS. When SIMDDT is active, the XLOW ac always points
to the STATIC area.
.p -8,1;IV.3.2##SIMDDn.ABS
.br;----------
.s;The SIMDDT code is read from the disk file SIMDDn.ABS. n = SIMULA system
version number, e.g_. the version 4 SIMDDT file is called SIMDD4.ABS. Earlier
versions were called SIMDDT.ABS regardless of version.
The data in the file has the form of two dynamic records, one ZYS record and
a ZTE (TEXT) record, referenced as ZDSZTE.
.pg;.lm 8;.i -8;IV.3.2.1#Keyword Table (ZKW)
.br;#-------------------
.lt 22

+---------------------------------------+
!ZKW!ZKW!ZKW!ZKWTYP!ZKWCOD!    ZKWADR   !
!LNE!DBG!ERR!      !      !             !
!---------------------------------------!
!        ZKWNM1                         !
!---------------------------------------!
!        ZKWNM2                         !
!---------------------------------------!
!        !             !                !
!---------------------------------------!
!                                       !
!- - - - - - - - - - - - - - - - - - - -!
:                                       :
:                                       :
!---------------------------------------!
!        !             !                !
!---------------------------------------!
!                                       !
!---------------------------------------!
:                                       :
:- - - - - - - - - - - - - - - - - - - -:
.el
.lm 24;.p -16,2,5;class ZKW;#comment
.p -16,0;-----######-------
.br;This class describes the format of the keyword table. Each keyword
entry occupies two or three words in the table. Every keyword used
in a SIMDDT command has an entry in this table.
Entries also exist for the comparison (relational) operators >, >=,
_..., _\=, == and =/=. All entries starting with the same character
form a group. Within this group the entries are sorted on the length
of the name;
.p -16,1,4;boolean ZKWLNE;#comment
.p -16,0;-------#########-------
.p -16,0;<0:0>###########This flag is set when the second
word, ZKWNM2, of the name is present;
.p -16,1,4;boolean ZKWDBG;#comment
.p -16,0;-------#########-------
.p -16,0;<1:1>###########This flag is set when the keyword
is allowed in a debug mode command;
.p -16,1,4;boolean ZKWERR;#comment
.p -16,0;-------#########-------
.p -16,0;<2:2>###########This flag is set when the keyword
is allowed in an error mode command;
.p -16,1,8;integer ZKWTYP;#comment
.p -16,0,1;-------#########-------
.p -16,0;<3:5>###########This field gives the type of keyword.
.nf;The different types are:
start of command
inside command
used in relations
after / in INSPECT;
.f;.p -16,1,8;integer ZKWCOD;#comment
.p -16,0,1;-------#########-------
.p -16,0;<6:17>##########The accumulator XDBAS is placed
in this field if ZKWTYP is start of command.
.br;This field gives the type of a relational operator or the type
of a constant;
.p -16,1,8;integer ZKWADR;#comment
.p -16,0,1;-------#########-------
.p -16,0;<18:35>#########This field gives the relative address
of a command routine if ZKWTYP is start of command. For a relational
operator it gives the instruction to be used and for a constant (FALSE,
NONE, NOTEXT or TRUE) it gives the value;
.p -16,1,4;integer ZKWNM1;#comment
.p -16,0,1;-------#########-------
.p -16,0;<0:35>##########This field gives the six initial
characters of the keyword (sixbit code);
.p -16,1,4;integer ZKWNM2;#comment
.p -16,0,1;-------#########-------
.p -16,0;<0:35>##########This field gives the last six
characters of a keyword longer than 6 characters. Only present if
ZKWLNE is set;
.lm 8;.f;.p -8,2,6;IV.3.2.2#Error tables YE3DL, YE3D, YE3M and YE3MI
.s;These tables are described in section II.C.3. The combined size
is roughly 0.8 K words.
.pg;.lm 8;.i -8;IV.3.2.3#Breakpoint record ZBR
.lt 44

          +-------------------------------------------------+
          ! ZDN                                             !
          !-------------------------------------------------!
     +----! ZBRZBE [0]            !          0              !
     !    +-------------------------------------------------+
     !    ! ZBRZBE [1]            !     ZBRZLN [1]          !
     !    +-------------------------------------------------+
     !    ! ZBRINS [1]                                      !
     !    +-------------------------------------------------+
     !    ! ZBRZBE [2]            !     ZBRZLN [2]          !----+
     !    !-------------------------------------------------!    !
     !    ! ZBRINS [2]                                      !    !
     !    +-------------------------------------------------+    !
     !    :                                                 :    !
     !    :                                                 :    !
     !    +-------------------------------------------------+    !
     ! +--! ZBRZBE [QBRN]         !     ZBRZLN [QBRN]       !    !
     ! !  +-------------------------------------------------+    !
     ! !  ! ZBRINS [QBRN]                                   !    !
     ! !  !-------------------------------------------------!    !
     ! +->! First ZBE for first breakpoint line             !--+ !
     !    !-------------------------------------------------!  ! !
     ! +--! Second ZBE for first breakpoint line            !<-+ !
     ! !  !-------------------------------------------------!    !
     ! +->! Last ZBE for first breakpoint line              !    !
     !    !-------------------------------------------------!    !
     !    ! First ZBE for second breakpoint line            !<---+
     !    +-------------------------------------------------+
     !    :                                                 :
     !    :                                                 :
     !    +-------------------------------------------------+
     +--->! First free ZBE                                  !--+
          !-------------------------------------------------!  !
       +--:                                                 :<-+
       !  +-------------------------------------------------+
       +->! Last free ZBE                                   !
          +-------------------------------------------------+
          !                                                 !
          !-------------------------------------------------!
          !                                                 !
          ! Work area for SIMDDT                            !
          !                                                 !
          +-------------------------------------------------+
.el
.pg;.f;.lm 24;.p -16,0;ZDN class ZBR;##comment
.p -16,0;####-----#######-------
.br;This class describes the format of the breakpoint record. It is used 
for storage of information from breakpoint commands. The last part
of the ZBR record is used as a work area. Since the record is placed
inside the dynamic record for the first part of SIMDDn.ABS, the garbage
collector is not aware of it. The accumulator XDZBR addresses this
record and it would be possible to move all other parts of SIMDDn.ABS
to the high segment keeping the data area (ZBR record) in the low
segment;
.p -16,1,8;ref (ZBE) array ZBRZBE[0:QBRN];#comment
.p -16,0;  ---#######-----#################-------
.p -16,0;<0:17>##########The first entry in this array points to the
first free breakpoint entry ZBE. All free ZBE's are then linked together.
The maximum number of different line numbers for all active breakpoints
is QBRN. The ZBRZBE field points to the first ZBE used for a set of
breakpoints with the same line number.
The line number is specified via the ZBRZLN field. The pointer is
zero for unused entries. The address ZBRZBE is relative to the start
of the ZBR record;
.p -16,1,8;ref (ZLN) array ZBRZLN[0:QBRN];#comment
.p -16,0;  ---#######-----#################-------
.p -16,0;<18:35>#########The array elements point to line number table
entries defining the corresponding breakpoint line numbers. An unused
entry has a zero value;
.p -16,1,8;integer###array ZBRINS[0:QBRN];#comment
.p -16,0;  -------###-----#################-------
.p -16,0;<0:35>##########The array elements contain the instructions
from generated code replaced by breakpoint instructions. These entries
are valid only when the corresponding ZBRZBE element is non-zero;
.pg;.lm 8;.i -8;IV.3.2.4#Breakpoint entry ZBE
.lt 33

     AT line
     +----------------------------------------------------+
     !     ZBEZBE            !STO!STB!ZBETYP!             !
     !----------------------------------------------------!
     !                    ZBESTR                          !
     +----------------------------------------------------!
     !     ZBENIN            !         ZBENVA             !
     +----------------------------------------------------!
     !                    not used                        !
     +----------------------------------------------------!

     AT line list
     +----------------------------------------------------+
     !     ZBEZBE            !STO!STB!ZBETYP!             !
     !----------------------------------------------------!
     !    !IDL!IDD!EBL!SUN!  ! ZBEZSD                     !
     !- - - - - - - - - - - - - - - - - - - - - - - - - - !
     !    !IDL!IDD!EBL!SUN!  ! ZBEZSD                     !
     +----------------------------------------------------!
     !                         ZBEVSU                     !
     +----------------------------------------------------!

     AT line IFCHANGED list
     +----------------------------------------------------+
     !     ZBEZBE            !STO!STB!ZBETYP!             !
     !----------------------------------------------------!
     !    !IDL!IDD!EBL!SUN!  ! ZBEZSD                     !
     +----------------------------------------------------!
     !                     ZBEVAL                         !
     +----------------------------------------------------!
     !                     ZBEVAL                         !
     +----------------------------------------------------+
.el
.pg;.lt 21
     AT line IF relation
     +----------------------------------------------------+
     !     ZBEZBE            !STO!STB!ZBETYP!             !
     !----------------------------------------------------!
     !    !IDL!IDD!EBL!SUN!  ! ZBEZSD                     !
     +----------------------------------------------------!
     !     ZBEROP            ! ZBETCI                     !
     +----------------------------------------------------!
     !                     ZBEVAL                         !
     +----------------------------------------------------!

     Continuation entry
     +----------------------------------------------------+
     !     ZBEZBE            !STO!STB!ZBETYP!             !
     !----------------------------------------------------!
     !    !IDL!IDD!EBL!SUN!  ! ZBEZSD                     !
     +----------------------------------------------------!
     !    !IDL!IDD!EBL!SUN!  ! ZBEZSD                     !
     +----------------------------------------------------!
     !                     ZBEVAL                         !
     +----------------------------------------------------!
.el
.lm 24;.f;.p -16,2,5;class ZBE;######comment
.i -16;-----###########-------
.br;This class describes the format of the breakpoint
entry that is placed in the breakpoint record. The length is QZBEL
(4 at present) words. Each new breakpoint command causes a number
of ZBE records to be reserved. These contain information describing
the breakpoint command and the breakpoint action. ZBE entries are
also used when processing INPUT and OUTPUT commands but in this case
they are released at exit from the command routine;
.p -16,1,6;ref(ZBE)ZBEZBE;#comment
.p -16,0,0;---#############-------
.p -16;<0:17>##########This field points to the next
ZBE entry for the same line, or contains zero to mark the end of the
chain. The address is relative to the start of the breakpoint record;
.p -16,1,3;boolean ZBESTO;#comment
.p -16,0,0;-------#########-------
.p -16,0;<18:18>#########This flag is set when STOP was
specified in the command;
.p -16,1,3;boolean ZBESTB;#comment
.p -16,0,0;-------#########-------
.i -16;<19:19>#########This flag is set when a text
string was present in the command;
.p -16,1,11;integer ZBETYP;#comment
.p -16,0;-------#########-------
.i -16;<20:23>#########This field gives the type of the
ZBE entry and it can assume one of the following meanings and codes:
.nf;AT		  QBEAT
AT list		  QBEATL
AT IFCHANGED list QBEATC
AT IF relation	  QBEATR
continuation	  QBECON
;
.f;.p -16,1,6;integer ZBESTR;#comment
.p -16,0,0;-------#########-------
.i -16;<0:35>##########This field is only present if the
ZBESTB flag is set. It contains the first 5 characters of the string.
This entry may exist for all but continuation type ZBE entries;
.p -16,1,6;integer ZBENIN;#comment
.p -16,0,0;-------#########-------
.i -16;<0:17>##########This field is only present if type
is QBEAT. It gives the initial value of the counter n (default = 1);
.p -16,1,6;integer ZBENVA;#comment
.p -16,0,0;-------#########-------
.i -16;<18:35>#########This field gives the current value
of the counter n. The breakpoint action is carried out when n is zero;
.p -16,1,6;ref(ZSD)ZBEZSD;#comment
.p -16,0,0;---#############-------
.i -16;<18:35>#########One word in ZBE is reserved for
each identifier present in the breakpoint commands. This field points
to the ZSD entry that represents the identifier;
.p -16,1,3;boolean ZBEIDL;#comment
.p -16,0,0;-------#########-------
.i -16;<0:0>###########This flag is set when there are
more identifications left in a list;
.p -16,1,3;boolean ZBEIDD;#comment
.p -16,0,0;-------#########-------
.i -16;<2:2>###########This flag is set when a dot was
placed after the identifier. Note that subscripts may also be present;
.p -16,1,6;integer ZBEEBL;#comment
.p -16,0,0;-------#########-------
.i -16;<3:9>###########This integer gives the effective
block level, copied from the prototype record for the symbol table
containing the identifier;
.p -16,1,6;integer ZBESUN;#comment
.p -16,0,0;-------#########-------
.i -16;<10:13>#########This integer gives the number of
subscripts that were placed after the identifier;
.p -16,1,6;integer ZBEVSU;#comment
.p -16,0,0;-------#########-------
.i -16;<0:35>##########This integer gives the value of
a subscript;
.p -16,1,6;integer ZBEVAL;#comment
.p -16,0,0;-------#########-------
.i -16;<0:35>##########This field gives the value of
a constant or a variable. If the type is LONG REAL or TEXT, two words
are used. The value of a variable or constant is saved for arithmetic,
boolean or character types. For TEXT the value NOTEXT may be saved,
also the subscript to an element of the ZDSTXT array. For REF, NONE
may be saved, also the array subscript in ZDSREF and a prototype address
for a variable in an object relation.
The ZBEVAL field is used in a QBEATC type entry to save the last value
of the variable and it is used in a QBEATR entry to hold the value
of any constant given in the command. ZBEVAL is also used in an INPUT
command;
.p -16,1,5;ref(ZKW)ZBEROP;#comment
.p -16,0,0;---#############-------
.i -16;<0:17>##########This field is present only if the type is QBEATR.
It points to the relation operator entry in the keyword table;
.p -16,1,5;boolean ZBETCI;#comment
.p -16,0,0;-------#########-------
.i -16;<18:18>#########This flag is set if a constant follows the
relational operator, implying that the next field is ZBEVAL. Otherwise
an identification follows;
.p -16,1,5;boolean ZBETHI;#comment
.p -16,0,0;-------#########-------
.i -16;<1:1>###########This flag is set when THIS is used instead
of an identifier. The ZBEZSD entry points at the class prototype;
.p -16,1,5;boolean ZBEQUA;#comment
.p -16,0,0;-------#########-------
.i -16;<14:14>#########This flag is set when QUA is used after the
reference variable. The class prototype is placed in the entry following
the normal identification entries;
.p -16,1,5;boolean ZBESTA;#comment
.p -16,0,0;-------#########-------
.i -16;<15:15>#########This flag is set when a * is used instead of
an identifier;
.pg;.lm 8;.i -8;IV.3.2.5#SIMDDT stack
.s;This is a conventional stack used to hold return addresses from
subroutines and as save area for accumulators for accummulators and
other quantities. It is addressed via the XDSTK ac, which is set up
for overflow detection by an interrupt. Underflow is caught by a few
addresses to an error routine at the stack bottom.
.p -8,2,8;IV.3.2.6#SIMDDT work area
.s;This contains the internal SIMDDT variables and also some instructions
used by the PROCEED command routine DSPR. These instructions are relocated
by SIMDDT and cannot be write-protected.
.p -8,2,10;IV.3.2.7#ZDSZTE, text record
.s;This record is used as a buffer area for the I/O texts. The first
3 elements in the YDSTXT text array contain text variables which point
to three subtexts of ZDSZTE, each QDSION (135) characters long. The
buffers have the subtext form to facilitate communication with the
RTS text routines.
.p -8,2,8;IV.3.3##ZAR records: ZDSTXT and ZDSREF
.br;-------------------------------
.s;During initialisation, SIMDDT requests two arrays from the run
time system, one text array and one ref array. Any variable saved in those
arrays is relocated by the garbage collector if
the referenced data has been moved.
.pg;.nm ch 4;.lm 8
.ch SIMULA FOR DEC SYSTEM 10#############TD, SIMDDT
.nm 1
.st 741101####780302######6###########################Ingrid Wennerstrom
.pg;.lm 8;.i -8;IV.4####FILE DESCRIPTIONS
.P -8,2;IV.4.1##SIMDDT input file
.br;-----------------
.p -8,1;IV.4.1.1#TTY input
.s;The user TTY (which may be simulated by a PTY via a controlling
program) is normally used for all input to SIMDDT. The INCHWL monitor
call is used to read user commands into the ZDSZTE record. The YDSIPO
variable contains a byte pointer to the buffer and the first element
in the ZDSTXT array holds a text variable which points to the proper
subtext of the ZDSZTE record.
.p -8,2,10;IV.4.1.2#Input file specified in @ command
.s;The command routine DSGET handles the @ command. The i/o routines
in the RTS are used for all processing of files other than the user
TTY. The DSIT routine calls the IOIG routine to read an input line.
The file is closed in the DSEX routine and if end of file is found.
From version 4(302), it is possible to direct all SIMDDT i/o to another
terminal, including the * prompter, if the USE and @ commands specify
a tty device other than the controlling TTY.
.p -8,2,10;IV.4.2##SIMDDT output files
.br;-------------------
.p -8,1;IV.4.2.1#TTY output
.s;The user TTY (simulated by a PTY when the job is controlled by
another job, e.g_. in batch) is normally used for all SIMDDT output.
The output text is edited in the ZDSZTE text record. The variable
YDSOPO contains a byte pointer into the buffer and the second element
of the ZDSTXT array holds a subtext pointer to the buffer. The OUTSTR
monitor call is used to output a string to the TTY.
.p -8,2,10;IV.4.2.2#SYSOUT file
.s;The SYSOUT file is used for SIMDDT error mode output if SYSOUT
is not directed to the user TTY. The DSINE routine outputs the last
image created on the SYSOUT file before the error occurred. DSINE
also replaces the current image pointer for SYSOUT with a pointer
to the output buffer in ZDSZTE. Subsequently SYSOUT is treated like
a file specified in a USE command.
.p -8,2,10;IV.4.2.3#Output file specified in a USE command
.s;The DSUS command routine handles the USE command. The RTS i/o routines
are used for all processing of a file which is not the user TTY. Only
one USE file can exist. Any existing USE file is closed when a new
USE command is given. The DSEX routine also closes the USE file.
The DSO set of routines call the IOOG (IOBO) RTS routine to output
a line from the ZDSZTE record to the file. Some output to the USE
file is copied to the controlling TTY, unless (from version 4(302))
the USE file is another terminal.
.p -8,2,10;IV.4.3##DISPLAY file
.br;------------
.s;The (source) file implied by the DISPLAY command is read and output.
The RTS I/O routines are used. The display file is closed on exit
from SIMDDT.
.br;The name of the main source program is taken from a GETTAB entry
and the name of an external source module is assumed to be the class
or procedure name. The extension is assumed to be _.SIM.
.p -8,2,7;IV.4.4##Help file
.br;---------
.s;The help file HLP:SIMDDT.HLP is read and output. The RTS i/o routines
are used.
.pg;.nm ch 5;.lm 8
.ch SIMULA FOR DEC SYSTEM 10#############TD, SIMDDT
.nm 1
.st 741101####780302######6###########################Ingrid Wennerstrom
.pg;.lm 8;.i -8;IV.5####DIAGNOSTIC HANDLING
.P -8,2;IV.5.1##Introduction
.br;------------
.s;SIMDDT outputs diagnostic messages for all errors detected inside
SIMDDT and for most of the errors detected by the RTS. The possible
error messages are listed in the SIMULA Language Handbook part II,
appendix D.
A utility program, SUTEDS (see V.5), is used to create message tables
from the RUNOFF input file for the handbook.
The SIMDDT routine DSPM reconstructs the message and puts it in the
output text buffer.
.p -8,2,10;IV.5.2##SIMDDT invoked from the RTS routine OCUU
.br;----------------------------------------
.s;When the RTS detects an error, the error number and the user code address
corresponding to the error are stored in the static low segment area
and SIMDDT is started at its entry point DSINE.
A flag is stored with the error number determining if further processing
is possible and which input is needed if any. The diagnostic handling
in the RTS is described in III.5. If the error was found in an RTS
routine called from SIMDDT, further processing is normally possible.
.pg;.lt 40
IV.5.3  Main flow of the DSINE routine
        ------------------------------

 ---------------------
(Enter DSINE from OCUU)
 ---------------------
       !
    ------             ------       TTY/SYSOUT---+
  + SIMDDT +   Yes   + SIMDDT +  No ! ? ERROR    !    ------------
<   active   >----><initialised >-->! WHILE INI- !-->(Exit to OCEP)
  +    ?   +         +    ?   +     ! TIATING .. !    ------------
    ------             ------       +------------+
    No !<------+          ! Yes
+------------+ !       ------       TTY/SYSOUT---+
! Set SIMDDT ! !     +  RTS   + Yes !ZYDnnn      !    ------------
! error mode ! !   <called from >-->!message     !-->(Return via  )
!            ! !     + SIMDDT?+     !ZYQ->ZYD    !   (SIMDDT stack)
+------------+ !       ------       +------------+    ------------
       !       !          ! No
+------------+ !       ------       TTY/SYSOUT---+
! Find       ! !     + SIMDDT + Yes !? ERROR     !    ------------
! <LINE> of  ! !   <  in error  >-->!WHILE PROCES!-->(Exit to OCEP)
! error      ! !     + mode ? +     !SING ERROR  !    ------------
+------------+ !       ------       +------------+
       !       !          ! No
TTY/SYSOUT---+ !   +------------+
! ? ERROR IN ! !   ! Indicate   !
! JOB AT     ! +---! replacement!
! <LINE>     !     ! ZYQ->ZYD   !
+------------+     +------------+
       !
TTY/SYSOUT---+
! ZYQnnn     !
! message    !
!            !
+------------+
       !
 ------------
(Exit to DSCM)
 ------------
.el
.pg;.lm 8;.i -8;IV.5.4##SIMDDT internal errors
.br;----------------------
.s;The SIMDDT routine DSOEM is called when an error is detected while
scanning an input command or while processing a breakpoint action.
DSOEM outputs the input command up to the last scanned character (if
relevant) and the ZYDnnn message.
The rest of the command is ignored and the command action is usually
not performed. E.g. the command "INPUT i:=1 xxx" will give the messages:
.br;INPUT i:= 1 x
.br;ZYD603 END OF INPUT EXPECTED
.BR;The command "STOP AT 3,ab" gives:
.br;STOP AT 3,a
.br;ZYD605 INVALID LOOP COUNTER
.br;After the first command, the value of i is 1, but no breakpoint is
set at line 3 after the second command.
.s;The DSTERM routine is called when an unexpected error is detected
in SIMDDT. The ZYD675 message is output and program execution aborted
via the RTS routine OCEP.
.p -8,2,10;IV.5.5##Addition of a new message to SIMDDT or SIMRTS
.br;---------------------------------------------
.p -2,1;-#Insert the new message in the RUNOFF input file containing
appendix D (SLH2C.RNO or SIMLH2.RNM). The assembly time constants
QZYQLN, QZYDFN, QZYDLN and QMSUPN must be changed if the message cannot
be placed in a free slot in the existing intervals. The SUTEDS program
must be accordingly modified.
.p -2,1,6;-#Execute the SUTEDS program to create a new SIMEDS.MAC
file. Note that the input file (see above) is assumed to be
DSK:SIMLH2.RNO. The RUNOFF input file must thus be temporarily renamed
or copied to a file with the expected name.
.p -2,1,7;-#Insert the code for the error message in the RTS or the
SIMDDT routine or insert code generation statements in pass 2 of the
compiler if the error message will be detected by compiled code.
.p -2,1;-#Reassemble SIMDDT to create the SIMDDT.REL file.
.p -2,1;-#Reassemble and link any changed RTS or compiled module.
.p -2,1;-#EXECUTE SIMDDT.REL,SUTABS.MAC to create the SIMDDn.ABS file.
.pg;.nm ch 6;.lm 8
.ch SIMULA FOR DEC SYSTEM 10#############TD, SIMDDT
.nm 1
.st 741101####780302######6###########################Ingrid Wennerstrom
.pg;.lm 8;.i -8;IV.6####SIMDDT INTERFACE
.p -8,2;IV.6.1##Monitor interface
.br;-----------------
.s;The monitor commands INCHWL and OUTSTR are used to communicate
with the user TTY. All other i/o is performed via the i/o routines
in the RTS. The RTS also handles traps and UUO processing.
.br;The job data locations _.JBSA, _.JBFF, _.JBUUO  and _.JBOPS are
read by SIMDDT but not changed.
.p -8,2,6;IV.6.2##Interface with generated code
.br;-----------------------------
.s;The address of the line number table for the main program is placed
in the static low segment area by the OCIN routine. The ZLN table
contains addresses to generated instructions which may be replaced
by a breakpoint instruction. The ZSM, ZSD, ZPR and ZMP records are
referenced by SIMDDT.
.s;If SIMDDT.REL was linked with the main program, the start address
_.MAIN of the main program is used by SIMDDT, see DSINM.
.p -8,2,10;IV.6.3##SIMRTS interface
.br;----------------
.p -8,2;IV.6.3.1#Entries to SIMDDT from SIMRTS
.s;The entry points DSINI, DSINB, DSINR, DSINE and DSINS of SIMDDT
are used by SIMRTS, see IV.2.1. These entries are placed at fixed
offsets from the start of SIMDDT. If necessary, the SIMDDn.ABS file
will be read into the dynamic low segment area from disk. SIMDDT.REL
may also be linked with the main program, usually for SIMDDT debugging purposes.
.p -8,2,6;IV.6.3.2#SIMRTS routines used from SIMDDT
.br;#--------------------------------
.s;SIMDDT calls a SIMRTS routine according to the standard interface
for that routine. No special code is placed in SIMRTS routines to
check for a call from SIMDDT. If a routine may cause garbage collection
or find an error, the call is placed in the static low segment area
YDSINC. The return address must not point into SIMDDT since it may
be moved by the garbage collector before the routine returns.
The eventual return to SIMDDT enters at DSINC. This routine relocates
the return address kept in the SIMDDT stack. The following RTS routines
are called from SIMDDT:
.nf;.s
Name	Explanation
----	-----------
.s;####-+
IOLN !
IOOP !
IOOG !	I/O related routines called
IOIG !	via DSCRTU and YDSINC(XLOW)
IOOB !
IOCL !
CPNE !
CSEN !
####-+
.lm 16;.f;.p -8,1,3;CSQU####Qualification check called directly
from DSCSQU.
.p -8,1,3;CSNA####Allocates array, called directly
from DSIS.
.p -8,1,7;SUNE####Finds next event, called directly from DSSC. The
variable YSUNE(XLOW) contains the address of the YSUNE routine if
Simulation is active.
.p -8,1,6;SAGC####Performs a garbage collection. The call is initiated
from the DSVA routine if the flag SWNOGC is off. The SIMDDT routine
DSCRTS and the YDSINC(XLOW) area are used to invoke SAGC.
.nf;.lm 8;.p 0,1,8
			      --+
TXVA	Text value assignment	!
TXRE	Text relation		! Called directly from
TXST	Strip text		! the SIMDDT routine
TXPI	Put integer in text	!
TXPR	Put real number in text	!
			      --+
.p 0,1,7
			      --+
TXGI	Get integer from text	! Called from
TXGR	Get real from text	! DSCTX
			      --+
.p 0,1,7
			      --+
TXBL	Create blank text	! Called via DSCRTS
TXCY	Create text copy	! and YDSINC(XLOW)
			      --+
.f;.lm 8;.p -8,2,10;IV.6.4##Global variables
.br;----------------
.s;A part of the static low segment area is used for SIMDDT variables
that do not need relocation after garbage collection. The variables
YSDBCOM, YDSBSAV, YDSINC, YDSZLN are used internally in SIMDDT.
The variables YDSEAD, YDSENR, YDSZLA, YDSNOG and YDSCAD are used by
SIMRTS to pass information to SIMDDT. The RTS routines check the variable
YDSWIT to find out if SIMDDT is active. The size of SIMDDT is defined
by QDSLG.
.p 0,1,5;YDSIGS is the start of a save area for the byte pointer to
the break character found by INIMAGE (IOIG).
IOIG saves the value for SIMDDT use.
.p 0,1,4;The flag word YDSCLOSE is tested and set by the OCEP RTS
routine and by SIMDDT. It is used to control file closing at end of
execution.
.p 0,1,7;Another part of the static low segment area contains global
SIMDDT variables that must be relocated by the garbage collector.
The existence of pointers in this area also prevents the corresponding
records from being removed as garbage.
The variables in this area are:
YDSIAC, YDSBAS, YDSTXT, YDSREF, YDSUFO, YDSSIOT, YDSCFO, YDSDFO,
YDSSXCB, YDSRXCB and YDSIFO.
.P 0,1,3;SIMDDT references the garbage collector variables YSABOT,
YSATOP and YSAGCN.
.P 0,1;SIMDDT references the simulation variables YSULEV and YSUNE.
.p 0,1,4;SIMDDT also references the SYSOUT pointer YSYSOUT, the
FORTRAN interface variable YFOXCB and the SIMRTS accumulator save
area YUUOAC.
.pg;.nm ch 7;.lm 8
.ch SIMULA FOR DEC SYSTEM 10#############TD, SIMDDT
.nm 1
.st 741101####780302######6###########################Ingrid Wennerstrom
.pg;.lm 8;.i -8;IV.7####COMMON MACRO PARAMETER FILES
.S;The SIMDDT modules refer to the universal files (.UNV) SIMMAC,
SIMMCR, SIMRPA.
.s;The $$RELO macro and the assembly variable $$BAS used in certain
SIMMAC macro definitions are redefined in SIMDS1.MAC. Thus the instructions
generated from conditional macros and field definitions will not contain
any relocatable addresses.
SIMDDT code is accessed via fixed offsets, indexed by XDBAS, which
will always contain the base address of SIMDDT while executing within
SIMDDT.
.s;The SIMRPA macro file contains definitions for the SIMDDT variables
which are placed in the static low segment area. The variable names
all start with "YDS".
.pg;.nm ch 8;.lm 8
.ch SIMULA FOR DEC SYSTEM 10#############TD, SIMDDT
.nm 1
.st 741101####780302######6###########################Ingrid Wennerstrom
.pg;.lm 8;.i -8;IV.8####TESTING
.p -8,2;IV.8.1##Compiler switches
.br;-----------------
.s;When compiling a SIMULA program used to test SIMDDT, the compiler
switches D, I, L and Y should be set.
.p -8,2;IV.8.2##Testing with DDT
.br;----------------
.s;The DDT program has been heavily used to test SIMDDT. Appendix
H.9 of the SIMULA Handbook part II describes how to use DDT together
with SIMDDT.
.s;To keep the SIMDDT symbol tables used by DDT in core, SIMDDT must
be loaded as a REL file with the SIMULA program REL file(s).
The following command can be used:
.s;DEBUG/DDT usermainprogram.SIM,SIMDDT.REL[path]/REL
.s;The name of the loaded program will be SIMDDT - may be changed
with a SAVE command specifying another name.
.s;It is often convenient to set a DDT breakpoint in DSCM, the routine
which reads a SIMDDT command.
.s;The line number table of the main program starts at the location
_.MAINL.
.p 0,1,10;The contents of some special ac's during SIMDDT execution
are:
.nf;.s
Accumulator	Explanation
-----------	-----------
.s;XPDP		SIMRTS stack pointer.
.f;.lm 24;.p -16,0,2;XLOW		Pointer to static low segment
area for global variables.
.p -16,0,1;XCB		Current block, never changed by SIMDDT.
.p -16,0,1;XDBAS		Base register for SIMDDT code.
.p -16,0,1;XDSTK		SIMDDT stack pointer.
.p -16,0,1;XDZBR		Pointer to SIMDDT data area.
.p -16,0,2;XDINT		Pointer to input text variable.
Output text variable is at 2(XDINT).
.p -16,0,1;XDSWIT		SIMDDT status switches.
.p -16,0,2;XDZBE		Pointer to last referenced ZBE entry.
Useful after a set breakpoint command.
.f;.lm 8;.p 0,1,3;The global variable YDSBCOM(XLOW) holds the address
of the instruction following the instruction replaced by a BREAK UUO.
.p 0,1,4;The local variable YDSCZBR has the current breakpoint number.
The address of the ZBR entry for the current breakpoint is found from
the expression 3+(XDZBR)+(YDSCZBR), where () implies "contents".
.pg;.nm ch 9;.lm 8
.ch SIMULA FOR DEC SYSTEM 10#############TD, SIMDDT
.nm 1
.st 741101####780302######6###########################Ingrid Wennerstrom
.pg;.lm 8;.i -8;IV.9####SAMPLE PROGRAM
.S;The program DEMDDT.SIM listed in appendix H.9 of the SIMULA Language
Handbook part II can be used together with DDT to find out how SIMDDT
works.
.s;The following figure shows the contents of the ZBR and ZBE records
after the set breakpoint command:
.s;*AT 39 IFCHANGED refpc.lrpc
.s;See SIMDDT EXAMPLE, TRACING in the handbook.
.pg;.lt 46
ZBR     :                                        :
        :                                        :
        !----------------------------------------!
        !          0        !         0          !
        !----------------------------------------!
        !                             0          !
        !----------------------------------------!
    +---!         63        !      4510          ! AT 39 IFCHANGED
    !   !----------------------------------------! refpc.lrpc
    !   !         MOVEI 1,         4532          ! Instruction saved
    !   !----------------------------------------!
    !+--!         57        !                    ! AT 28 IF ipc = 4
    !!  !----------------------------------------!
    !!  !                                        !
    !!  !----------------------------------------!
    !!+-!         53        !                    ! AT 8 fip1
    !!! !----------------------------------------!
    !!! !                                        !
    !!! !----------------------------------------!
ZBE !!+>!          0        !                    !
    !!  !----------------------------------------!
    !!  !                                        !
    !!  !                                        !
    !!  !----------------------------------------!
    !+->!          0        !                    !
    !   !----------------------------------------!
    !   !                                        !
    !   !                                        !
    !   !----------------------------------------!
    +-->!         67        !  0  2  0  0  0  0  !
     +--!----------------------------------------!
     !  !  1  0  1  4  0  0 !      4563          !
     !  !----------------------------------------!
     !  !  0  0  0  2  0  0 !      4544          !
     !  !----------------------------------------!
     !  !                             0          ! Saved value of lrpc
     !  !========================================! (word 1)
     +->!          0        !         0          !
        !----------------------------------------!
XDZBE-->!                             0          ! Saved value of lrpc
        !----------------------------------------! (word 2)
        !                not used                !
        !----------------------------------------!
        !                not used                !
        !----------------------------------------!
        :                                        :
.el
.pg;.lt 28
        ZSD entry for refpc
        !----------------------------------------!
4563    !  0  0  0  7  0  1 !         6          !
        !----------------------------------------!
        !  R  !  E  !  F    !  P  !  C  !        !
        !----------------------------------------!
        !                   !      4367          ! CLASS pc prototype
        !----------------------------------------!
        :   ZSD entry for lrpc                   :
        :                                        :
        !----------------------------------------!
4544    !  0  0  0  3  0  1 !         5          !
        !----------------------------------------!
        :                                        :
        :                                        :
        :  ZLN entry for line 39                 :
        !----------------------------------------!
4510    !         47        !      4246          !
        !----------------------------------------!
        :                                        :

         Breakpoint instruction which replaces
         the MOVEI 1,4532 instruction in code
        +----------------------------------------+
4246    !  0  1  7  0  0  0 !        42          ! 42 is offset into
        +----------------------------------------+ the ZBR record

        Figure IV.9  Snapshot of core after set breakpoint instruction.
.el
   