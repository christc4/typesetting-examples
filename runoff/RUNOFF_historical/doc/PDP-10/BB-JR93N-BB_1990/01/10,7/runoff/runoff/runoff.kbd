<	RUNOFF  --  RUNOFF macros for ITPS-10 system
	Robert D. Houk  --  30-Jul-77

These macros are intended for two purposes - one is to provide an
interface into ITPS for RUNOFF users to ease their conversion over
to ITPS; the second reason is to provide a prototype macro system
for general use, specifically that same area addressed by RUNOFF.

In general, these macros parallel RUNOFF in name and function -
wherever there is an applicable RUNOFF command there is an ITPS
macro of the same name (usually RUNOFF's abbreviated name) with
the same or similar functionality.

To use the RUNOFF macro system simply include in your text file:

	[*setup macro]
	[*RUNOFF][preliminary user commands][*BEGIN]
	body of user text
	[*END]

This command sequence must be followed in order to assure proper
functioning of the macro subsystem. The "preliminary user  commands"
are any commands which merely set parameters - such as [*FT] or [*PS],
etc. The [*BEGIN] macro call must precede all user typeset text (in-
cluding all leading, tabbing, etc.)!!! The user should include the
[*END] macro call (to do any device-specific end of take functions)
as the very last piece of his text file.

Important system conventions:

    1)  All type faces are assumed to be setup (i.e., numbers are
	assigned to faces) with the major face (as specifiec by the
	[Fnnn] command) a multiple of 10 (decimal); the correspond-
	ing italics face as "nnn" + 1; the corresponding bold face
	as "nnn" + 2; the corresponding small caps face as "nnn" +3.
	Consider the standard line-printer/ASCII setup: face 210 is
	the standard face; face 211 is the italics face; face 212 is
	the bold face; and face 213 is the small caps face.

    2)	The setup macro initializes the D-registers (see below) and
	defines the incore macro END to be called at the end of the
	take to do any device-dependent functions

    3)	If D1 is zero then +& character is form feed (octal 014); if
	positive then D1 contains amount of leading to perform between
	"pages".

    4)	Whenever a value "n" is specified as being "p.p's" then
the numeric value of picas must be followed by a "." character
to delimit the picas and another numeric value to represent the
points:
	"50" is fifty points;
	".50" is fifty points;
	"4.2" is four picas two points (fifty points);
	"42.0" is forty-two picas (five hundred and four points);
	"42." is illegal (no points "fraction" specified).

	Whenever a value is specified as being points then the numeric
value may be either just points or picas.points.
------------------------------------------------------------------------



			***   WARNING   ***



Following are general warnings concerning restrictions or bugs about
which the user should be aware:

    1)	In versions of JUSTIF before %301(373) the use of one-shot
	face commands is not allowed (e.g., the [WB] command) since
	JUSTIF does not properly reset the $F register at the end of
	the one-shot.

    2)	The face modify facility ([FM] command) is not supported.

    3)	JUSTIF should be assembled to handle at least 128 incore mac-
	ros with a minimum size of 48 words each.

In general tracking down errors can be very painful, as JUSTIF is very
sensitive (trusting) of user input. The best way to track down errors is
probably to get the .JH file and simply trace down what happened - char-
acter by character until the "obvious" error appears. Once an error has
occurred JUSTIF has a tendency to propagate the error - hundreds of errors
may happen just because the column width got set wrong for example. If an
error after the first error is not obvious (like illegal command) then try
the file again after having fixed the "obvious" leading errors. JUSTIF is
very trusting of user input and tends to just believe anything you tell it,
especially in macros, and gets correspondlingly confused when you tell it
something wrong.

Probably 99.9% of all errors are in the end attributed to user error, but
errors in the basic system software do happen, especially after a new re-
lease of some sort. If a problem defies solution, try to reduce the number
of variables involved to a minimum - try simple test cases to make sure you
understand the basic functionality being exercised, ask other people for help
(it is truly amazing how consistently one can misread a (e.g.) mis-spelled
word), even trace the .JH file character by character. If all else fails,
give up and try a different approach.
------------------------------------------------------------------------



		***   PROGRAMMING ARCANA   ***


A very important (and incredibly obscure) macro programming procedure
which can lead to "impossible" (to comprehend) bugs concerns the way
JUSTIF handles "page" breaks (really a vertical column break). JUSTIF
always processes text until a word break before trying to justify a
line of text (it has to go to the end of the word so it can properly
hyphenate the word). This means that any text which exceeds the line,
as finally "set" by the justification routines, must be "reprocessed"
a second time. JUSTIF does this by "re-executing" the input stream
from the point that the line break occured. The obscurity is that
the input stream can contain embedded commands which are also executed
a second time. This leads to some very bizarre (yea, even psychopathic)
cases. Consider a line which contains the following text stream:

	. . . re[FB]stric[FR]tions/Z . . .

The usage of the face commands "[FB]" and "[FR]" illustrates why JUSTIF
must process until an unambiguous end of line is encountered - the com-
mands can affect the way the word itself is set. Now, if the line is
finally broken at "restric-" then the "tions" will appear on the next
line. But to JUSTIF, the next line will start "[FR]tions/Z". It is the
"/Z" which causes the grief - it was seen once whilst looking for an
end of word condition, and then again when the end of word was finally
set. The net effect is that the "tions" is overlaid across the begining
of the line which hyphenated "restric-". This trivial (yet still pain-
fully obscure) example can be sidestepped by putting a space between
the "tions" and the "/Z" as so:

	. . . re[FB]stric[FR]tions /Z . . .

Since JUSTIF will not set the line until the column which has been
EXCEEDED the "/Z" will only be executed if the "tions" can be guaranteed
to fit the line, and the "/Z" will also be guaranteed to affect only
the final typeset line which contains the "tions" text. (The case cited
above has actually been fixed in JUSTIF, but still serves to illustrate
my point).

The real complications arise when the line break coincides with the page
(or column) break - for in this case the "excess" text must be saved
across any page-break information (which is to say the [VH macro). The
penultimate headache arises when it is a macro itself (such as the [*ELS]
macro herein defined) which finally trips the page break mechanism at
some intermediate point within the macro itself. Since the macro is just
a string of commands (and//or text) itself, these commands are subject
to the same treatment as the "/Z" in the example above. This can lead to
non-obvious (to say the least) behaviour for commands which modify data
such as one of the user registers (e.g., a [ZS command) since the command
can be executed twice! Therefore macros must written in such a manner
that any line break caused by the macro will not doubly-execute any
such commands.

As a real-life example (which took an hour DDT'ing my way through JUSTIF
to initially comprehend), consider the [*ELS] macro below. It starts out
with a call to the [*TBOL] macro - to ensure that any previous text is
set and a new line is started (since [*ELS] by definition terminates
any [*LE] currently being processed). This [*TBOL] macro also has the
effect of guaranteeing that any impending page break that might occur
will occur at the [*TBOL] execution - ensuring that following commands
up to the "[ZET1,TLE0]" command are safe. Now the [*TLE0] macro, if
called (i.e., register T1 contains 0) can cause a page break since it
calls the [*TTP] macro, which in turn . . . If the [*ELS] macro did
not start out with a [*TBOL] call (which it didn't for a long time)
and if the [*ELS] macro was called at the end of a line of text which
EXACTLY fit the page, then the initial commands in the [*ELS] macro
would get executed twice (in particular, the "[ZSI5,1]" command, which
caused I5 to go negative, which lead in turn to calculating negative
indents since the indents are calculated as the product of the [*LS]
nesting level, which . . .)!

Another example is the set of [*HLn] macros below. In the HLn macros
I must save the HLn text body away (in a TTHLn "scratch" macro) before
a possible page break occurs. This is required for running headers
which want to include in the running head the HL level and/or text
for that page. The problem lies with HLn macros which are the very first
text on a page - the HLn macro must be seen and executed before the
page break in order to provide the header information. This requires
that the TTHLn macro be defined and the Hn register be incremented
before the [*TBOL] call (which is what may well force a page break
if there is no more room in the current page). Unfortunately (as de-
scribed above) if the [*TBOL] causes the page break all preceding
commands will be re-executed - leaving the Hn register incremented
twice (it's ok for the TTHLn macro to be redefined since it is re-
defined to be the same thing). Therefore I use register H0 as a sort
of "reeentrancy" counter to indicate how many times the [ZIHn] com-
mand was executed, and to adjust the Hn register accordingly. (As a
corollary, this mean that a running head macro must subtract H0 from
Hn iff H0 .GT. 0 in order to find the correct header level, and fur-
ther, that running feet can't reliably access the current header level
counters.)

So if you encounter problems which seem to arise at page, or even line
boundries (easy to check - add leading text to shift everything down
a word/line or two) look for this case arising - the [VH macro being
called.

Good Luck.
------------------------------------------------------------------------



		        Register Usage Conventions

		     (Unless otherwise specified, all
		     applicable values are in points)


A group			Not Used.

B group			Not used

C group			Multi-column work
	C		Scratch column counter for [*THVCL]
	C0		Column (as opposed to page) width
	C1		Column gutter (space between columns)
	C2		Number of columns
	C3		Total leading ($U) at top of text column(s)
	C4		Not used
	C5		Not used
	C6		Not used
	C7		Not used
	C8		Not used
	C9		Not used

D group			Device (setup) specific information
	D		Not used
	D0		Base face
	D1		If .EQ. 0 device does form feed'ss (+& char)
			If .GT. 0 do [VA!D1] to split pages
	D2		If .EQ. 0 no super/subscript (instead do (nn))
			If .GT. 0 D2 is percent stored leading for [EJ]
	D3		Width of average character (in percent) re em space
	D4		Not used
	D5		Not used
	D6		Not used
	D7		Not used
	D8		Not used
	D9		Not used

E group			Not used

F group			Reserved for footnoting

G group			Running head/foot control
	G		Not used
	G0		.GT. 0 if have seen [*CH] or [*AX]
	G1		[*FT] setting for running head
	G2		If .LT. 0 then no running head at all
			If .EQ. 0 then blank running head
			If .GT. 0 then normal running heads
	G3		[*FT] setting for running foot
	G4		If .LT. 0 then no running foot at all
			If .EQ. 0 then blank running foot
			If .GT. 0 then normal running foot
	G5		Not used
	G6		Not used
	G7		.NE. 0 then print page number on page header
	G8		.NE. 0 then print subtitle on page header
	G9		.NE. 0 then print title on page header

H group			Header level information
	H		Not used
	H0		Interlock on Hn level increments
	H1		Header level 1
	H2		Header level 2
	H3		Header level 3
	H4		Header level 4
	H5		Header level 5
	H6		Not used
	H7		Not used
	H8		Not used
	H9		Not used

I group			Indent information
	I		Not used
	I0		Right margin (effectively the column width)
	I1		Left margin (indent from 0)
	I2		Indent (both margins) for each [*NOTE]
	I3		Nesting level for [*NOTE]
	I4		Indent (left margin) for each [*LE]
	I5		Nesting level for [*LIST]
	I6		Not used
	I7		Not used
	I8		Not used
	I9		Not used

J group			Tables information [*TABLE?]
	J		$U for bottom of longest table sub-column
	J0		Total indent from table sub-columns
	J1		Width of sub-column 1 (points)
	J2		Width of sub-column 2
	J3		Width of sub-column 3
	J4		Width of sub-column 4
	J5		Width of sub-column 5
	J6		Space (gutter) between table sub-columns
	J7		Space (leading) 'tween table entries
	J8		Test page value for start of new table entry
	J9		Table indent

K group			Not used

L group			Listing control and lists
	L		.GE. 0 then list all ([MJ] command)
			.LT. 0 then suppress macro & commands ([MJ%])
	L0		.EQ. 0 then L8 leading else L9 leading
	L1		List level 1 number
	L2		List level 2 number
	L3		List level 3 number
	L4		List level 4 number
	L5		List level 5 number
	L6		Extra leading (points) between [*LS]'s
	L7		T.P. (lines) after L6 for [*LS]
	L8		Extra leading (points) between [*LE]'s
	L9		T.P. (lines) after L8 for [*LE]

M group			Not used

N group			Not used

O group			Not used

P group			Page formating information
	P		Page number of current page
	P0		Page width
	P1		Page depth
	P2		Pointsize (regular text)
	P3		Leading   (regular text)
	P4		Pointsize (running head)
	P5		Leading   (running head)
	P6		Pointsize (chapter header)
	P7		Leading   (chapter header)
	P8		Pointsize (running foot)
	P9		Leading   (running foot)

Q group			Paragraphing and other random info
	Q		Total leading ($U register) at top of page text
	Q0		Paragraph indent
	Q1		Paragraph leading (extra between paragraphs)
	Q2		Paragraph test page
	Q3		Not used
	Q4		Not used
	Q5		Not used
	Q6		Not used
	Q7		Not used
	Q8		Not used
	Q9		Not used

R group			Scratch and Temporary work registers

S group			Scratch and Temporary work registers

T group			Scratch and Temporary work registers

U group			Not used

V group			Not used

W group			Not used

X group			Not used

Y group			Not used

Z group			Not used
------------------------------------------------------------------------



			Vertical Mark Point usage



0			Not used

1			Not used

2			Not used

3			Not used

4			Not used

5			Not used

6			Not used

7			Temp used by [*THV] and friends

8			Top of current table entry ([*TEn]) column

9			Bottom of longest (so far) table entry column
------------------------------------------------------------------------



			Command Macros Listing



	(tbs)



------------------------------------------------------------------------



			Internal macros Listing



	(tbs)
------------------------------------------------------------------------



			Command Macros



	AX	n,title		Set appendix number "n", title "title"



>[*COR:AX=[*TBOL]<		Make sure previous line is ended
>[ZXG0,1]<			Flag in chapter/appendix
>[*COR:TCNUM=@=]<		Set text of chapter/appendix number
>[*TITLE]<			Define new title
>[*COR:TSUBTT==]<		Clear subtitle
>[*THL0]<			Clear all header-level information
>[ZGG2,TZXG2]<			Get [*FT] setting for running head
>[ZZP][*PGI]<			Advance to new page
><				  This may unfortunately cause a blank page
><				  if the [*TBOL] above terminated the pre-
><				  ceding page, but it must be done this way
>[ZGG4,TZXG4]<			Get [*FT] setting for running foot
>[ZZG1][ZZG3]<			Reset [*FT]
>[*TSAVE][PR!P6,!P7][C.!P0]<	Set up for Chapter heading text
>[FB]Appendix [*TCNUM][FR]/C<	Print "Appendix n"
>[FB][*TTITLE][FR]/C<		And the title beneath it
>[*TRSTR][VA36]/L<		Reset for normal text
>=]/Z<



------------------------------------------------------------------------



	BEGIN			Start typeset output



>[*COR:BEGIN=[ZSG4,1]<		Set running foot back
>[ZUD1][ZXD1,-1]<		Suppress initial page feed
>[*THV]<			First title, etc.
>[ZVD1]<			Restore page feed value
>=]/Z<



------------------------------------------------------------------------



	BL	n		Skip "n" * 12 points



>[*COR:BL=[*TBOL]<		Make sure at start of line
>[ZXT1,@]<			Read "number" of lines
>[ZMT1,12][VA!T1]<		Advance that far
>=]/Z<



------------------------------------------------------------------------



	CH	n,title		Set chapter number "n" with title "title"



>[*COR:CH=[*TBOL]<		Make sure line is ended
>[ZXG0,1]<			Flag in chapter/appendix
>[*COR:TCNUM=@=]<		Set text of chapter/appendix number
>[*TITLE]<			Define new title
>[*COR:TSUBTT==]<		Clear subtitle
>[*THL0]<			Clear all header-level information
>[ZGG2,TZXG2]<			Get [*FT] setting for running head
>[ZZP][*PGI]<			Advance to new page
><				  This may unfortunately cause a blank page
><				  if the [*TBOL] above terminated the pre-
><				  ceding page, but it must be done this way
>[ZGG4,TZXG4]<			Get [*FT] setting for running foot
>[ZZG1][ZZG3]<			Reset [*FT]
>[*TSAVE][PR!P6,!P7][C.!P0]<	Set up for Chapter heading text
>[FB]Chapter [*TCNUM][FR]/C<	Print "Chapter n"
>[FB][*TTITLE][FR]/C<		Print title beneath that
>[*TRSTR][VA36]/L<		Reset for normal text
>=]/Z<



------------------------------------------------------------------------



	COL	n,g		Set multiple columns (note this command
				resets both the	left and right margins)
					n = Number of columns
					g = Gutter (p.p's) between columns



>[*COR:COL=[ZXC2,@]<		Pickup number of columns
>[ZXC1,@]<			Pickup column gutter
>[*TCOLST][*TCOLSX]<		Setup for text columns
>[ZXI0,C0][ZZI1]<		Reset left and right margins ([*TCALIR] etc.)
>=]/Z<



------------------------------------------------------------------------



	ELS			End list



>[*COR:ELS=[*TBOL]<		Insure at begining of a line
>[ZZL0]<			Flag between lists leading
>[ZSI5,1][ZXT1,I5]<		Decrement lists nesting level
>[ZET1,TLE0]<			Set [*LE] for level 0 (illegal)
>[ZST1,1][ZET1,TLE1]<		Set [*LE] for level 1
>[ZST1,1][ZET1,TLE2]<		Set [*LE] for level 2
>[ZST1,1][ZET1,TLE3]<		Set [*LE] for level 3
>[ZST1,1][ZET1,TLE4]<		Set [*LE] for level 4
>[*TCALIL][IL.!T1]<		Set new left indent as appropriate
>[*TCALIR][IR.!T1]<		Set new right indent as appropriate
>=]/Z<



------------------------------------------------------------------------



	END			End of typeset text, clean up



>[*COR:END=[*TBOL]<		Ensure at begining of line
>[VC%][C.!P0][I%]<		Clear world
>[ZGG4,TFOOTD]<			Do a running foot if enabled
>[*TDEND]<			Do any device-specific end of take clean up
>=]/Z<



------------------------------------------------------------------------



	ERROR			Increment error counter, print "?"



>[*COR:ERROR=[*TBOL]<		Make sure at start of line
>[ZXS9,$E][ZIS9][ME!S9]<	Increment JUSTIF error counter
>/L? <				Prefix error text
>=]/Z<



------------------------------------------------------------------------



	FT			Put running head on first page



>[*COR:FT=[ZXG1,1]<		Notify [*CH] & [*AX]
>[ZXG2,1]<			Notify [*THV]
>=]/z<



------------------------------------------------------------------------



	HL1	Header		Header level 1 text with header "Header"



>[*COR:HL1=[ZIH0]<		Count times reentered
>[*THL1]<			Stuff too big to fit in definition here
>[*TBOL]<			Now, make sure on a new line
>[ZSH1,H0]<			Allow for reentrancy
>[ZXT1,5][ZMT1,P3]<		TP of 5 lines with a
>[ZXT2,2][ZMT2,P3]<		Skip of 2 lines
>[*TTP]<			Make sure have room on page
>[FB][ZNG0,TCNUM][ZNG0,TDOT]<	Chapter number if in chapter/appendix
>[ZAH1].0<			Header level one numbering
> [*TTHL1][FR]/L/L<		Now print the header (in bold face)
>[ZXH0,-1]=]/Z<			HL command now processed



------------------------------------------------------------------------



	HL2	Header		Header level 2 text



>[*COR:HL2=[ZIH0]<		Count times reentered
>[*COR:TTHL2=@=]<		Save the HL2 text
>[ZIH2]<			Increment header level
>[ZZH3][*COR:TTHL3==]<		Clear header level 3
>[ZZH4][*COR:TTHL4==]<		Clear header level 4
>[ZZH5][*COR:TTHL5==]<		Clear header level 5
>[*TBOL]<			Now, make sure at begining of line
>[ZSH2,H0]<			Allow for reentrancy
>[ZXT1,4][ZMT1,P3]<		TP of 4 lines with a
>[ZXT2,1][ZMT2,P3]<		Skip of 1 line
>[*TTP]<			Make sure have room on pages
>[ZNG0,TCNUM][ZNG0,TDOT]<	Chapter number if in chapter/appendix
>[ZAH1].[ZAH2]<			Header level 2 numbering
> [*TTHL2]/L/L<			List the text body
>[ZXH0,-1]=]/Z<			HL2 command finished




------------------------------------------------------------------------



	HL3	Header		Header level 3 text



>[*COR:HL3=[ZIH0]<		Count times reentered
>[*COR:TTHL3=@=]<		Save the HL3 text
>[ZIH3]<			Increment header level
>[ZZH4][*COR:TTHL4==]<		Clear header level 4
>[ZZH5][*COR:TTHL5==]<		Clear header level 5
>[*TBOL]<			Now, make sure at begining of line
>[ZSH3,H0]<			Allow for reentrancy
>[ZXT1,3][ZMT1,P3]<		TP of 3 lines with a
>[ZXT2,P3]<			Skip of only 1 line
>[*TTP]<			Make sure room on page
>[ZNG0,TCNUM][ZNG0,TDOT]<	Chapter number if in chapter/appendix
>[ZAH1].[ZAH2].[ZAH3]<		Header level 3 numbering
> [*TTHL3]/L<			Issue the text body
>[ZXH0,-1]=]/Z<			HL3 command finished




------------------------------------------------------------------------



	HL4	Header		Header level 4 text



>[*COR:HL4=[ZIH0]<		Count times reentered
>[*COR:TTHL4=@=]<		Save the HL4 text
>[ZIH4]<			Increment header level
>[ZZH5][*COR:TTHL5==]<		Clear header level 5
>[*TBOL]<			Now, make sure at begining of line
>[ZSH4,H0]<			Allow for reentrancy
>[ZXT1,2][ZMT1,P3]<		TP of 2 lines with a
>[ZXT2,P3]<			Skip of 1 line
>[*TTP]<			Make sure room on page
>[ZNG0,TCNUM][ZNG0,TDOT]<	Chapter number if in chapter/appendix
>[ZAH1].[ZAH2].[ZAH3].[ZAH4]<	Header level 4 numbering
> [*TTHL4] - <			Issue text body
>[ZXH0,-1]=]/Z<			HL4 command finished



------------------------------------------------------------------------



	HL5	Header		Header level 5 text



>[*COR:HL5=[ZIH0]<		Count times reentered
>[*COR:TTHL5=@=]<		Save the HL5 text
>[ZIH5]<			Increment header level
>[*TBOL]<			Now, make sure at begining of line
>[ZSH5,H0]<			Adjust header level around reentrancy
>[ZXT1,2][ZMT1,P3]<		TP of 2 lines with a
>[ZXT2,P3]<			Skip of 1 line
>[*TTP]<			Make sure room on page
>[ZNG0,TCNUM][ZNG0,TDOT]<	Chapter number if in chapter/appendix
>[ZAH1].[ZAH2].[ZAH3].[ZAH4].<	Higher level numbering
>[ZAH5]<			Header level 5 numbering
> [*TTHL5] - <			Issue text body
>[ZXH0,-1]=]/Z<			HL5 command finished



------------------------------------------------------------------------



	I	n		Indent "n" p.p's from left (one-shot)



>[*COR:I=[*TBOL][ZXT1,@]<	Read indent amount
>[HL.!T1,0,1]<			Indent one line
>=]/Z<



------------------------------------------------------------------------



	IVLS	i,j,k,l,m	Set list parameters
					i p.p's indent for each [*LS]
					j inter-list extra leading
					k inter-list t.p. (lines after "j")
					l intra-list extra leading
					m intra-list t.p. (lines after "l")



>[*COR:IVLS=[ZXI4,@]<		Indent value in p.p's for each [*LS] nesting
>[ZXL6,@]<			Inter-list (between lists) extra leading
>[ZXL7,@]<			Inter-list test page (in addition to L6)
>[ZXL8,@]<			Intra-list (between list items) extra leading
>[ZXL9,@]<			Intra-list test page (in addition to L8)
>=]/Z<



------------------------------------------------------------------------



	IVTB	i, t, v, g	Set table sub-column parameters
					i indent p.p's
					t test page p.p's
					v leading between entries
					g gutter between sub-columns



>[*COR:IVTB=[ZXJ9,@]<		Pickup table indent
>[ZXJ8,@]<			Pickup test page value
>[ZXJ7,@]<			Pickup (extra) leading between entries
>[ZXJ6,@]<			Pickup sub-column gutter
>=]/Z<



------------------------------------------------------------------------



	LALL			List macro and command expansions



>[*COR:LALL=[ZPL,2]<		Bump nesting count of [*LALL]'s
>[ZGL,TMJON]<			If .GE. 0 then turn on listing ([MJ])
>[ZSL,1]<			Make register "L" contain true value
>=]/Z<



------------------------------------------------------------------------



	LE			List entry item follows



>[*COR:LE=<			Not legal till see [*LS]
>[*ERROR]Not in a "List"/L/L<	Issue error message
>=]/Z<



------------------------------------------------------------------------



	LM	n		Set left margin to "n" p.p's from 0



>[*COR:LM=[ZXI1,@]<		Remember new left margin
>[*TCALIL][IL.!T1]<		Set new left indent
>=]/Z<



------------------------------------------------------------------------



	LS			Start a new list (recurses)



>[*COR:LS=[*TBOL]<		Ensure at begining of a line
>[ZZL0]<			Flag between lists leading
>[ZII5][ZXT1,I5]<		Increment list level
>[ZST1,1][ZET1,TLE1]<		Set for list level 1
>[ZST1,1][ZET1,TLE2]<		Set for list level 2
>[ZST1,1][ZET1,TLE3]<		Set for list level 3
>[ZST1,1][ZET1,TLE4]<		Set for list level 4
>[ZST1,1][ZET1,TLE5]<		Set for list level 5
>[*TCALIL][IL.!T1]<		Set new left indent as appropriate
>[*TCALIR][IR.!T1]<		Set new right indent as appropriate
>=]/Z<



------------------------------------------------------------------------



	NHD			No running head (but keep paging)



>[*COR:NHD=[ZXG2,-9999999999]<	No running head (but keep paging)
>=]/Z<



------------------------------------------------------------------------



	NLV	n,m,o,p,q	Set header level to "n.m.o.p.q"



>[*COR:NLV=[ZXH1,@]<		Load header level 1
>[ZXH2,@]<			Load header level 2
>[ZXH3,@]<			Load header level 3
>[ZXH4,@]<			Load header level 4
>[ZXH5,@]<			Load header level 5
>=]/Z<



------------------------------------------------------------------------



	NM	n		Set page number to "n", enable paging



>[*COR:NM=[ZXP,@]<		Set new page number
>[*PAGING]<			Enable paging
>=]/Z<



------------------------------------------------------------------------



	NNM			Turn off page numbering



>[*COR:NNM=[ZZG7]<		No page numbers on running head
>=]/Z<



------------------------------------------------------------------------



	NOTE	note,text	Print "note" bold centered, text



>[*COR:NOTE=[*TBOL]<		Make sure at nice place
>[ZII3]<			Increment [*NOTE] nesting level
>[*TCALIL][IL.!T1]<		New left indent
>[*TCALIR][IR.!T1]<		New right indent
>[ZXT1,P3][ZMT1,5]<		Test page of 5 lines
>[ZXT2,P3][*TTP]<		With one blank line before "note"
>[FB]@[FR]/C/L<		Print "NOTE" or whatever in centered  bold
>@<				The note text itself
>[*TBOL]<			Make sure last line terminated
>[ZSI3,1]<			Decrement nesting level
>[*TCALIL][IL.!T1]<		Reset left indent
>[*TCALIR][IR.!T1]<		Reset right indent
>[ZXT1,P3][ZMT1,3]<		Test page to make sure not too close
>[ZXT2,P3][*TTP]<		To bottom of page
>=]/Z<



------------------------------------------------------------------------



	NPA			Turn off paging completely
				Note that [*AX] and [*CH] reset this



>[*COR:NPA=[VC9999999999]<	Set [FB]HUGE[FR] page
>=]/Z<



------------------------------------------------------------------------



	NRFOOT			Turn off running feet



>[*COR:NRFOOT=[ZXG4,-999999999]<Turn off running feet
>=]/Z<



------------------------------------------------------------------------



	NRHEAD			Turn off running head(s)



>[*COR:NRHEAD=[ZXG2,-999999999]<Turn off running head(s)
>=]/z<



------------------------------------------------------------------------



	NST			Turn off subtitles in running head(s)



>[*COR:NST=[ZZG8]<		No subtitles on running head(s)
>=]/Z<



------------------------------------------------------------------------



	NTI			Turn off titles, subtitles in running head(s)



>[*COR:NTI=[ZZG8][ZZG9]<	No titles, subtitles on running head(s)
>=]/Z<



------------------------------------------------------------------------



	PARA	i, s, t		Set paragraphing parameters:
					Indent "i" p.p's;
					Skip "s" points;
					Test Page "t" points.



>[*COR:PARA=[ZXQ0,@]<		Read in paragraph indent
>[ZXQ1,@]<			Read in skip value
>[ZXQ2,@]<			Get test page values
>[IP.!Q0,.!Q1]<			Tell JUSTIF (TP not yet implemented)
>=]/Z<



------------------------------------------------------------------------



	PG			Force a new page



>[*COR:PG=[ZXC,1][VB]<		Force premature page break at next line
>=]/Z<



------------------------------------------------------------------------



	PGI			Force a new page immediately
				 (this defeats allowing following [*HLn]
				  to provide running header information)



>[*COR:PGI=[ZXC,1][VB]/L<	Force premature page break immediately
>=]/Z<



------------------------------------------------------------------------



	PGCOL			Force a new column



>[*COR:PGCOL=[VB]<		Force premature column break
>=]/Z<



------------------------------------------------------------------------



	PLCHAP	points,leading	Pointsize & leading for chap/app
				(Must be issued from regular text)



>[*COR:PLCHAP=[ZXP6,@]<	Read in pointsize for chapter titles
>[ZXP7,@]<			And read in leading
>=]/Z<



------------------------------------------------------------------------



	PLFOOT	points,leading	Pointsize & leading for running feet
				(Must be issued from regular text)



>[*COR:PLFOOT=[ZXP8,@]<	Read in pointsize for running feet
>[ZXP9,@]<			And read in leading
>=]/Z<



------------------------------------------------------------------------



	PLHEAD	points,leading	Pointsize & leading for running head(s)
				(Must be issued from regular text)


>[*COR:PLHEAD=[ZXP4,@]<	Read in pointsize for running head(s)
>[ZXP5,@]<			And read in leading
>=]/Z<



------------------------------------------------------------------------



	PLTEXT	points,leading	Pointsize & leading for regular text
				(Must be issued from regular text)



>[*COR:PLTEXT=[ZXP2,@]<	Read in pointsize for regular text
>[ZXP3,@]<			And read in leading
>[PR!P2,!P3]<			Set regular text parameters
>=]/Z<



------------------------------------------------------------------------



	PS	h, w		Set page size "w" p.p's by "h" p.p's
				(Does not include space for any running feet,
				resets both left and right margins)



>[*COR:PS=[*TBOL]<		Insure at begining of fresh line
>[ZXS1,P1]<			Old height of page
>[ZXP1,@]<			New height of page
>[ZXS2,$M][ZDS2,$Y]<		Remainder of old page
>[ZXT1,P1][ZPT1,S2][ZST1,S1]<	Current difference of old and new page
>[ZXP0,@][CM.!P0]<		Set new width of page
>[ZGT1,TVC]<			If .GT. 0 then still room left on page
>[ZET1,PG]<			If .EQ. 0 then time for a new page
>[ZLT1,PG]<			If .LT. 0 then time for a new page
>[ZGT1,TCOLST]<			If not new page, set columns
>[ZXI0,C0][ZZI1]<		Reset left and right margin
><				  (Necessary for multi-columning)
>=]/Z<



------------------------------------------------------------------------



	RFOOT			Turn on running feet



>[*COR:RFOOT=[ZXG4,1]<		Turn on running feet
>=]/Z<



------------------------------------------------------------------------



	RHEAD			Turn on running head(s)



>[*COR:RHEAD=[ZXG2,1]<		Turn on running head(s)
>=]/Z<



------------------------------------------------------------------------



	RM	n		Set right margin to "n" p.p's from 0



>[*COR:RM=[ZXI0,@]<		Read in indent amount
>[*TCALIR][IR.!T1]<		Set new right indent
>=]/Z<



------------------------------------------------------------------------



	SK	n		Skip "n" lines



>[*COR:SK=[*TBOL]<		Start fresh line
>[AR@][*TEOL]<		Skip "n" lines
>=]/Z<



------------------------------------------------------------------------



	SP	v		Set vertical leading to "v" points



>[*COR:SP=[ZXP3,@][V!P3]<	Set and remember new stored leading
>=]/Z<



------------------------------------------------------------------------



	SUB	n		Print "n" as subscript



>[*COR:SUB=[ZXT5,$P][ZXT6,$V]<	Get current pointsize and leading
>[ZU$P]<			Save pointsize for moment
>[ZMT5,60][ZDT5,10000]<		T5:=60% of current pointsize
>[ZMT6,D2][ZDT6,10000]<		T6:=(D2)% of current leading
>[PR!T5][EJ-!T6]<		Smaller print, lower baseline
>[ZET6,TLPRN]<			If no baseline then type "(" instead
>@<				The subscript itself
>[ZET6,TRPRN]<			If no baseline then type ")" instead
>[EJ%][ZVT5][ZDT5,100][PR!T5]<	Restore world
>=]/Z<



------------------------------------------------------------------------



	SUBTTL	text		Set page header subtitle to "text"



>[*COR:SUBTTL=<
>[*COR:TSUBTT=@=]<		Define new subtitle text
>=]/Z<



------------------------------------------------------------------------



	SUP	n		Print "n" as superscript



>[*COR:SUP=[ZXT5,$P][ZXT6,$V]<	Get current pointsize and leading
>[ZU$P]<			Save pointsize for moment
>[ZMT5,60][ZDT5,10000]<		T5:=60% of current pointsize
>[ZMT6,D2][ZDT6,10000]<		T6:=(D2)% of current leading
>[PR!T5][EJ!T6]<		Smaller print, lower baseline
>[ZET6,TLPRN]<			If no baseline then type "(" instead
>@<				The superscript itself
>[ZET6,TRPRN]<			If no baseline then type ")" instead
>[EJ%][ZVT5][ZDT5,100][PR!T5]<	Restore world
>=]/Z<



------------------------------------------------------------------------



	TABLE2	w1, w2		Set for two column table
					w1 width of sub-column 1
					w2 width of sub-column 2


>[*COR:TABLE2=[ZXJ1,@]<	Pickup width of sub-column 1
>[ZXJ2,@]<			Pickup width of sub-column 2
>[ZZJ3][ZZJ4][ZZJ5]<		Clear others
>=]/Z<



------------------------------------------------------------------------



	TABLE3	w1, w2, w3	Set for three column table
					w1 width of sub-column 1
					w2 width of sub-column 2
					w3 width of sub-column 3



>[*COR:TABLE3=[ZXJ1,@]<	Pickup width of sub-column 1
>[ZXJ2,@][ZXJ3,@]<		Pickup widths of subcolumns 2 and 3
>[ZZJ4][ZZJ5]<			Clear the rest
>=]/Z<



------------------------------------------------------------------------



	TABLE4	w1, w2, w3, w4	Set for four column table
					w1 width of sub-column 1
					w2 width of sub-column 2
					w3 width of sub-column 3
					w4 width of sub-column 4



>[*COR:TABLE4=[ZXJ1,@]<	Pickup width of sub-column 1
>[ZXJ2,@][ZXJ3,@][ZXJ4,@]<Pickup widths of subcolumns 2, 3, and 4
>[ZZJ5]<			Clear the rest
>=]/Z<



------------------------------------------------------------------------



	TABLE5	w1, w2, w3, w4, w5	Set for four column table
					w1 width of sub-column 1
					w2 width of sub-column 2
					w3 width of sub-column 3
					w4 width of sub-column 4



>[*COR:TABLE5=[ZXJ1,@]<	Pickup width of subcolumn 1
>[ZXJ2,@][ZXJ3,@][ZXJ4,@]<Pickup widths of subcolumns 2, 3, and 4
>[ZXJ5,@]<			Pickup width of subcolumn 5
>=]/Z<



------------------------------------------------------------------------



	TABS8			Set Tab stops every 8 "spaces"



>[*COR:TABS8=[T%]<		First clear old tab stops
>[TS4.10,9.7,14.5,19.2,24.0,28.10,33.7,38.5,43.2,48.0,52.10,57.7,62.5,67.2,72.0,76.10]<
>=]/Z<



------------------------------------------------------------------------



	TE2	t1, t2		Text entry for 2-sub-column table
					t1 text for sub-column 1
					t2 text for sub-column 2



>[*COR:TE2=[*TTEI]<		Setup for table entry
>@<				Text body of sub-column 1
>[ZXS1,J1][ZXS2,J2][*TTBLTE]<	Set for table sub-column 2
>@<				Text body of sub-column 2
>[*TTEND]<			End of table entry, position past longest
>=]/Z<



------------------------------------------------------------------------



	TE3	t1, t2, t3	Text entry for 3-sub-column table
					t1 text for sub-column 1
					t2 text for sub-column 2
					t3 text for sub-column 3


>[*COR:TE3=[*TTEI]<		Setup for table entry
>@<				Text body of sub-column 1
>[ZXS1,J1][ZXS2,J2][*TTBLTE]<	Set for table sub-column 2
>@<				Text body of sub-column 2
>[ZXS1,J2][ZXS2,J3][*TTBLTE]<	Set for table sub-column 3
>@<				Text body of sub-column 3
>[*TTEND]<			End of table entry, position past longest
>=]/Z<



------------------------------------------------------------------------



	TE4	t1, t2, t3, t4	Text entry for 4-sub-column table
					t1 text for sub-column 1
					t2 text for sub-column 2
					t3 text for sub-column 3
					t4 text for sub-column 4



>[*COR:TE4=[*TTEI]<		Setup for table entry
>@<				Text body of sub-column 1
>[ZXS1,J1][ZXS2,J2][*TTBLTE]<	Set for table sub-column 2
>@<				Text body of sub-column 2
>[ZXS1,J2][ZXS2,J3][*TTBLTE]<	Set for table sub-column 3
>@<				Text body of sub-column 3
>[ZXS1,J3][ZXS2,J4][*TTBLTE]<	Set for table sub-column 4
>@<				Text body of sub-column 4
>[*TTEND]<			End of table entry, position past longest
>=]/Z<



------------------------------------------------------------------------



	TE5	t1, t2, t3, t4, t5	Text entry for 5-sub-column table
					t1 text for sub-column 1
					t2 text for sub-column 2
					t3 text for sub-column 3
					t4 text for sub-column 4



>[*COR:TE5=[*TTEI]<		Setup for table entry
>@<				Text body of sub-column 1
>[ZXS1,J1][ZXS2,J2][*TTBLTE]<	Set for table sub-column 2
>@<				Text body of sub-column 2
>[ZXS1,J2][ZXS2,J3][*TTBLTE]<	Set for table sub-column 3
>@<				Text body of sub-column 3
>[ZXS1,J3][ZXS2,J4][*TTBLTE]<	Set for table sub-column 4
>@<				Text body of sub-column 4
>[ZXS1,J4][ZXS2,J5][*TTBLTE]<	Set for table sub-column 5
>@<				Text body of sub-column 5
>[*TTEND]<			End of table entry, position past longest
>=]/Z<



------------------------------------------------------------------------



	TITLE	text		Set page header title to "text"



>[*COR:TITLE=<
>[*COR:TTITLE=@=]<		Define new title text
>=]/Z<



------------------------------------------------------------------------



	TP	n, s		Test column for at least "n" lines left
					if no new column skip "s" lines



>[*COR:TP=[*TBOL]<		Make sure at begining of line
>[ZXT1,@][ZMT1,P3]<		T1:=t.p. value in points
>[ZXT2,@][ZMT2,P3]<		T2:=skip value in points
>[*TTP]<			Do the actual test page (column) work
>=]/Z<



------------------------------------------------------------------------



	TPV	v, s		Test column for at least "v" points left
					if no new column skip "s" points



>[*COR:TPV=[*TBOL]<		Make sure at begining of line
>[ZXT1,@]<			T1:=t.p. value in points
>[ZXT2,@]<			T2:=skip value in points
>[*TTP]<			Do the actual test page (column) work
>=]/Z<



------------------------------------------------------------------------



	XALL			Turn off macro and command listing



>[*COR:XALL=[ZSL,1]<		Bump nesting count of [*SALL]'s
>[ZLL,TMJOFF]<			If .LT. 0 then turn off listing ([MJ%])

>=]/Z<



------------------------------------------------------------------------



	Internal usage macros






	TBOL			Make sure at begining of line



>[*COR:TBOL=/?<			Make sure at begining of line
>=]/Z<



------------------------------------------------------------------------



	TCALIL			Calculate total left indent into T1



>[*COR:TCALIL=[ZXT1,I1]<	Get left margin
>[ZXT2,I2][ZMT2,I3][ZPT1,T2]<	Left indent for [*NOTE]
>[ZXT2,I4][ZMT2,I5][ZPT1,T2]<	Left indent for [*LE]
>[ZPT1,J0]<			Indent for table sub-column(s)
>=]/Z<



------------------------------------------------------------------------



	TCALIR			Calculate total right indent into T1



>[*COR:TCALIR=[ZXT1,C0]<	Get column width
>[ZST1,I0]<			Get indent to right margin
>[ZXT2,I2][ZMT2,I3][ZPT1,T2]<	Right indent for [*NOTE]
>=]/Z<



------------------------------------------------------------------------



	TCOLST			Setup parameters for multi-columns



>[*COR:TCOLST=[ZXT1,C1]<	Column gutter
>[ZMT1,C2][ZST1,C1]<		T1 := total space devoted to gutter
>[ZXT2,P0][ZST2,T1]<		T2 := total space available to text
>[ZDT2,C2][ZXC0,T2]<		C0 := width of each column
>[C.!C0][VG.!C1]<		Set column width and gutter
>=]/Z<



------------------------------------------------------------------------



	TCOLSX			Set column parameters



>[*COR:TCOLSX=<
>[ZXC,C2][C.!C0]<		Set column width for text column(s)
><				 (Must set column width before [VC] com-
><				  mand; [VC] remembers widest column set,
><				  which otherwise would be [C.!P0] above)
>[ZXT1,$M][ZDT1,$Y]<		Calculate column length for text column(s)
>[VM7][VC%][VP7][VC!T1]<	Set column length for text column(s)
><				 (Must reset [VC%] so [VC] returns here;
><				  [VC] remembers longest column set, which
><				  otherwise would be from [VC!P1] above)
>[ZXC3,$U]<			Remember total leading at start of column
>=]/Z<



------------------------------------------------------------------------



	TCNUM			Text for chapter/appendix level



>[*COR:TCNUM=<			Initially blank
>=]/Z<



------------------------------------------------------------------------



	TDASH			Print "-"



>[*COR:TDASH=-<			"-"
>=]/Z<



------------------------------------------------------------------------



	TDOT			Print "."



>[*COR:TDOT=.<			"."
>=]/Z<



------------------------------------------------------------------------



	TEOL			Give forced end of line



>[*COR:TEOL=/L<			Quad left will do for now
>=]/Z<



------------------------------------------------------------------------



	TFACE			Set to proper face in T1


>[*COR:TFACE=[ZCT1,10000]<	Reduce to font number (ignore [FM])
>[ZXT2,T1][ZCT2,10]<		T2:=subface index (1=italics, etc.)
>[ZST1,T2][F!T1]<		T1:=master face font number
>[ZST2,1][ZET2,TFI]<		If subface 1 then italics face
>[ZST2,1][ZET2,TFB]<		If subface 2 then bold face
>[ZST2,1][ZET2,TFS]<		If subface 3 then small caps face
>=]/Z<



------------------------------------------------------------------------



	TFB			Set bold face



>[*COR:TFB=[FB]<		Bold face command
>=]/Z<



------------------------------------------------------------------------



	TFFEED			Do a logical page feed (seperation)



>[*COR:TFFEED=[ZED1,TLPFF]<	Do form feed if available
>[ZXT2,D1][ZGT2,TVAT2]<		Else do immediate lead 'tween pages
>[ZXQ,$U]/Z<			Leading at start of page (text)
>=]/Z<



------------------------------------------------------------------------



	TFI			Set italics face



>[*COR:TFI=[FI]<		Italics face command
>=]/Z<



------------------------------------------------------------------------



	TFM			Set face modify(ed)



>[*COR:TFM=[FM]<		Face modify command
>=]/Z<



------------------------------------------------------------------------



	TFOOTD			Do a running foot



>[*COR:TFOOTD=<
>[F!D0][PR!P8,!P9]<		Set for running foot text
>[ZXT1,$U][ZST1,Q][ZDT1,$Y]<	T1:=total points so far this page
>[ZXT2,P1][ZST2,T1][VA!T2]<	Position for running foot
>[*TFOOTR]<			Print the running foot
>=]/Z<



------------------------------------------------------------------------



	TFS			Set small caps face



>[*COR:TFS=[FS]<		Small caps face command
>=]/Z<



------------------------------------------------------------------------



	TFU			Set face underline(d)



>[*COR:TFU=[FU]<		Face underline command
>=]/Z<



------------------------------------------------------------------------



	THEADB			Force immediate blank running head



>[*COR:THEADB=<
>[ZUG7][ZUG8][ZUG9]<		Save current header setting
>[ZZG7][ZZG8][ZZG9]<		Turn off all parts of head
>[*THEADD]<			Do the running head
>[ZVG9][ZVG8][ZVG7]<		Now restore header settings
>=]/Z<



------------------------------------------------------------------------



	THEADD			Do a running head



>[*COR:THEADD=<
>[F!D0][PR!P4,!P5]<		Set for page header text
>[*THEADR]<			Print the running head
>=]/Z<



------------------------------------------------------------------------



	THEADR			Print the running head text



>[*COR:THEADR=[ZNG9,TTITLE]/Q<	Print title if titling
>[ZNG7,TPAGE][ZNG7,TPAGNO]/R<	Print page number if numbering
>[ZNG8,TSUBTT]/L/L/L<		Print subtitle if subtitling
>=]/Z<



------------------------------------------------------------------------



	THL0			Reset all header level information



>[*COR:THL0=[ZXH0,-1]<		Just to make sure . . .
>[ZZH1][*COR:TTHL1==]<		Clear header level 1
>[ZZH2][*COR:TTHL2==]<		Clear header level 2
>[ZZH3][*COR:TTHL3==]<		Clear header level 3
>[ZZH4][*COR:TTHL4==]<		Clear header level 4
>[ZZH5][*COR:TTHL5==]<		Clear header level 5
>=]/Z<



------------------------------------------------------------------------



	THL1			Helper for HL1



>[*COR:THL1=[*COR:TTHL1=@=]<	Save the HL1 text
>[*COR:TSUBTT=[*TTHL1]=]<	And give a free [*SUBTTL] a la RUNOFF
>[ZIH1]<			Increment header level
>[ZZH2][*COR:TTHL2==]<		Clear header level 2
>[ZZH3][*COR:TTHL3==]<		Clear header level 3
>[ZZH4][*COR:TTHL4==]<		Clear header level 4
>[ZZH5][*COR:TTHL5==]<		Clear header level 5
><				  The levels are advanced before the [*TBOL]
><				  in case the last command was a [*PG]
>=]/Z<



------------------------------------------------------------------------



	THV			Paging macro (set by [VH command)



>[*COR:THV=[*TSAVE]<		Save the state of the world
>[VM7][VC%][VP7][I%][C.!P0]<	Turn off all columning or paging
>[ZGG4,TFOOTD]<			Do running foot if set
>[*TFFEED]<			Advance to "top of next page"
>[VC!P1]<			Set size (length) of this page
>[ZIP]<				Increment the page number
>[ZEG2,THEADB]<			Do blank header if (e.g.) [*CH]
>[ZGG2,THEADD]<			Otherwise do a normal running header
>[ZZG1][ZZG3]<			Reset [*FT] anti-blanker
>[ZIG2][ZIG4]<			Bump [*CH] blanker
>[*TRSTR]<			Restore the state of the world
>=]/Z<



------------------------------------------------------------------------



	THVCL			End of column macro (calls THV)



>[*COR:THVCL=[ZSC,1][ZEC,THV]<	Call THV macro if end of page
>=]/Z<



------------------------------------------------------------------------



	TLE0			Define [*LE] for list level 0 (illegal)



>[*COR:TLE0=[*COR:LE=<		Define the [*LE] macro
>[*ERROR]Not in a "List"/L/L<	Issue error message
>=]<				End of [*LE] macro definition
>[ZZL1]<			Reset list level 1 counter
>[ZXT1,P3][ZMT1,L7][ZPT1,L6]<	Test page value
>[ZXT2,L6][*TTP]<		And skip value
>[ZZT1]<			Clear T1 for [*LS]/[*ELS]
>=]/Z<



------------------------------------------------------------------------



	TLE1			Define [*LE] macro for list level 1



>[*COR:TLE1=[*COR:LE=<		Define [*LE] macro
>[*TBOL]<			Insure at start of a new line
>[ZXT1,P3][ZMT1,L7][ZPT1,L6]<	Inter-list test page value
>[ZXT2,L6][ZEL0,TTP]<		Do inter-list leading if first item
>[ZXT1,P3][ZMT1,L9][ZPT1,L8]<	Intra-list test page value
>[ZXT2,L8][ZGL0,TTP]<		Do intra-list leading if otherwise
>[*TBOL]<			Cause page break if one is pending
>[ZIL0]<			Note we are now "otherwise" until [*LS]/[*ELS]
>[HL-3,0,1]<			Put list item number out 3 picas
>[ZIL1][ZAL1]./Z<		Number this list item
>=]<				End of [*LE] macro definition
>[ZZL2]<			Reset next lower level's counter
>[ZZT1]<			Clear T1 for [*LS]/[*ELS]
>=]/Z<



------------------------------------------------------------------------



	TLE2			Define [*LE] macro for list level 2



>[*COR:TLE2=[*COR:LE=<		Define [*LE] macro
>[*TBOL]<			Insure at start of a new line
>[ZXT1,P3][ZMT1,L7][ZPT1,L6]<	Inter-list test page value
>[ZXT2,L6][ZEL0,TTP]<		Do inter-list leading if first item
>[ZXT1,P3][ZMT1,L9][ZPT1,L8]<	Intra-list test page value
>[ZXT2,L8][ZGL0,TTP]<		Do intra-list leading if otherwise
>[ZIL0]<			Note we are now "otherwise" until [*LS]/[*ELS]
>[HL-3,0,1]<			Put list item number out 3 picas
>[ZIL2][ZAL2]./Z<		Number this list item
>=]<				End of [*LE] macro definition
>[ZZL3]<			Reset next lower level's counter
>[ZZT1]<			Clear T1 for [*LS]/[*ELS]
>=]/Z<



------------------------------------------------------------------------



	TLE3			Define [*LE] macro for list level 3



>[*COR:TLE3=[*COR:LE=<		Define [*LE] macro
>[*TBOL]<			Insure at start of a new line
>[ZXT1,P3][ZMT1,L7][ZPT1,L6]<	Inter-list test page value
>[ZXT2,L6][ZEL0,TTP]<		Do inter-list leading if first item
>[ZXT1,P3][ZMT1,L9][ZPT1,L8]<	Intra-list test page value
>[ZXT2,L8][ZGL0,TTP]<		Do intra-list leading if otherwise
>[ZIL0]<			Note we are now "otherwise" until [*LS]/[*ELS]
>[HL-3,0,1]<			Put list item number out 3 picas
>[ZIL3][ZAL3]./Z<		Number this list item
>=]<				End of [*LE] macro definition
>[ZZL4]<			Reset next lower level's counter
>[ZZT1]<			Clear T1 for [*LS]/[*ELS]
>=]/Z<



------------------------------------------------------------------------



	TLE4			Define [*LE] macro for list level 4



>[*COR:TLE4=[*COR:LE=<		Define [*LE] macro
>[*TBOL]<			Insure at start of a new line
>[ZXT1,P3][ZMT1,L7][ZPT1,L6]<	Inter-list test page value
>[ZXT2,L6][ZEL0,TTP]<		Do inter-list leading if first item
>[ZXT1,P3][ZMT1,L9][ZPT1,L8]<	Intra-list test page value
>[ZXT2,L8][ZGL0,TTP]<		Do intra-list leading if otherwise
>[ZIL0]<			Note we are now "otherwise" until [*LS]/[*ELS]
>[HL-3,0,1]<			Put list item number out 3 picas
>[ZIL4][ZAL4]./Z<		Number this list item
>=]<				End of [*LE] macro definition
>[ZZL5]<			Reset next lower level's counter
>[ZZT1]<			Clear T1 for [*LS]/[*ELS]
>=]/Z<



------------------------------------------------------------------------



	TLE5			Define [*LE] macro for list level 5



>[*COR:TLE5=[*COR:LE=<		Define [*LE] macro
>[*TBOL]<			Insure at start of a new line
>[ZXT1,P3][ZMT1,L7][ZPT1,L6]<	Inter-list test page value
>[ZXT2,L6][ZEL0,TTP]<		Do inter-list leading if first item
>[ZXT1,P3][ZMT1,L9][ZPT1,L8]<	Intra-list test page value
>[ZXT2,L8][ZGL0,TTP]<		Do intra-list leading if otherwise
>[ZIL0]<			Note we are now "otherwise" until [*LS]/[*ELS]
>[HL-3,0,1]<			Put list item number out 3 picas
>[ZIL5][ZAL5]./Z<		Number this list item
>=]<				End of [*LE] macro definition
>[ZZT1]<			Clear T1 for [*LS]/[*ELS]
>=]/Z<



------------------------------------------------------------------------



	TLPFF			Do a line-printer (ASCII) form feed



>[*COR:TLPFF=+&<		Print form feed character
>=]/Z<



------------------------------------------------------------------------



	TLPRN			Print "("



>[*COR:TLPRN=(<			"(" CHARACTER
>=]/Z<



------------------------------------------------------------------------



	TMJOFF			Do [MJ%]



>[*COR:TMJOFF=[MJ%]<		Turn off command and macro listing
>=]/Z<



------------------------------------------------------------------------



	TMJON			Do [MJ]



>[*COR:TMJON=[MJ]<		Turn on command and macro listing
>=]/Z<



------------------------------------------------------------------------



	TNPGVA			Do a skip ([VA!T2]) if not at top of page



>[*COR:TNPGVA=[ZXT1,C3]<	Leading at start of this text column(s)
>[ZST1,$U]<			Less leading at current position
>[ZLT1,TVAT2]<			If .LT. 0 then not at top of column(s)
>[ZXT1,-1]<			Insure T1 negative (e.g., [*TTP])
>=]/Z<



------------------------------------------------------------------------



	TPAGE			Print "Page"



>[*COR:TPAGE=Page <		"Page"
>=]/Z<



------------------------------------------------------------------------



	TPAGNO			Print page number



>[*COR:TPAGNO=[ZGG0,TCNUM]<	If chapter/appendix then chapter number
>[ZGG0,TDASH][ZAP]<		Print current page number
>=]/Z<



------------------------------------------------------------------------



	TPOSB			Position to bottom of page (running foot)



>[*COR:TPOSB=[ZXT1,P1]<		Total page depth
>[ZPT1,Q]<			Total leading at end of page
>[ZST1,$U]<			T1 := amount of leading left this page
>[VA!T1]/Z<			Position to bottom of [*PS] page
>=]/Z<



------------------------------------------------------------------------



	TRPRN			Print ")"



>[*COR:TRPRN=)<			")"
>=]/Z<



------------------------------------------------------------------------



	TRSTR			Restore state of world to normal
				(Called only after [*TSAVE])



>[*COR:TRSTR=[ZVT1][*TFACE]<	Restore face to user-specified
>[PR!P2,!P3]<			Re-set pointsize and leading
>[*TCOLSX]<			Re-set column parameters
>[*TCALIL][IL.!T1]<		Re-set left indent
>[*TCALIR][IR.!T1]<		Re-set right indent
>=]/Z<



------------------------------------------------------------------------



	TSAVE			Save state of world



>[*COR:TSAVE=[ZU$F]<		Save current face
>=]/Z<



------------------------------------------------------------------------



	TSUBTT			Text body of subtitle



>[*COR:TSUBTT=<			Initially null (no subtitle seen yet)
>=]/Z<



------------------------------------------------------------------------



	TTBLTE			Advance to next table sub-column



>[*COR:TTBLTE=[*TBOL]<		Ensure at start of new line
>[*TTBLTV]<			Check for longest sub-column
>[ZPJ0,S1][ZPJ0,J6]<		Advance sub-column indent measure
>[*TCALIL][IL.!T1]<		Set new sub-column indent
>[ZPT1,S2][C.!T1]<		Set width for table sub-column
>[VP8]<				Position for next table sub-column
>=]/Z<



------------------------------------------------------------------------



	TTBLTV			Test for longest table sub-column



>[*COR:TTBLTV=[ZXT1,$U]<	Total leading so far
>[ZST1,J][ZGT1,TTBLVM]<		Mark longest table sub-column
>=]/Z<



------------------------------------------------------------------------



	TTBLVM			Mark longest table sub-column



>[*COR:TTBLVM=[ZXJ,$U]<		Remember leading at longest point
>[VM9]<				And markpoint so we can [VP] later
>=]/Z<



------------------------------------------------------------------------



	TTEI			Internal [*TE?] initializer



>[*COR:TTEI=[*TBOL]<		Ensure at start of line
>[ZXT1,J8][ZZT2][ZGT1,TTP]<	Do test page
>[*TBOL]<			Trip the [VH macro if column break pending
>[VM8]<				Mark vertical start of sub-column
>[ZXJ,$U]<			Longest sub-column so far
>[ZXJ0,J9][*TCALIL][IL.!T1]<	Set initial table indent
>[ZPT1,J1][C.!T1]<		Set sub-column 1 column width
>=]/Z<



------------------------------------------------------------------------



	TTEND			End of TE? commands



>[*COR:TTEND=<			Common commands to end TE? commands
>[*TBOL][*TTBLTV][VP9]<		Check and position to longest sub-column
>[ZXT1,J8][ZXT2,J7][ZGT1,TTP]<	Do any between-entry leading
>[ZZJ0][*TCALIL][IL.!T1]<	Reset left margin for normal text
>[C.!C0]<			Reset text column width
>=]/Z<



------------------------------------------------------------------------



	TTHL1			Text body of HL1



>[*COR:TTHL1=<			Initially null
>=]/Z<



------------------------------------------------------------------------



	TTHL2			Text body of HL2



>[*COR:TTHL2=<			Initially null
>=]/Z<



------------------------------------------------------------------------



	TTHL3			Text body of HL3



>[*COR:TTHL3=<			Initially null
>=]/Z<



------------------------------------------------------------------------



	TTHL4			Text body of HL4



>[*COR:TTHL4=<			Initially null
>=]/Z<



------------------------------------------------------------------------



	TTHL5			Text body of HL5



>[*COR:TTHL5=<			Initially null
>=]/Z<



------------------------------------------------------------------------



	TTSDS			Print " - "



>[*COR:TTSDS= - <		The advertised " - "
>=]/Z<



------------------------------------------------------------------------



	TTITLE			Text body of title



>[*COR:TTITLE=<			Initially null (no title seen yet)
>=]/Z<



------------------------------------------------------------------------



	TTP			Internal test page (column) worker
					T1:=t.p. value in points
					T2:=skip value in points



>[*COR:TTP=[ZMT1,$Y][ZST1,$M]<	T1:=negative of room left
>[ZLT1,TNPGVA][ZET1,TNPGVA]<	If .LE. 0 then room on column, do SKIP
>[ZGT1,PGCOL]<			If .GT. 0 then new column, no SKIP
>=]/Z<



------------------------------------------------------------------------



	TVAT2			Do [VA!T2]



>[*COR:TVAT2=[VA!T2]<		Do [VA!T2] command
>=]/Z<



------------------------------------------------------------------------



	TVC			Do [VC!T1]



>[*COR:TVC=[VC!T1]<		Set new rest of page
>=]/Z<



------------------------------------------------------------------------



	TZXG2			Do [ZXG2,G1]



>[*COR:TZXG2=[ZXG2,G1]<		Do the [ZXG2,G1] command
>=]/Z<



------------------------------------------------------------------------



	TZXG4			Do [ZXG4,G3]



>[*COR:TZXG4=[ZXG4,G3]<		Do the [ZXG4,G3] command
>=]/Z<



------------------------------------------------------------------------



			Initialization



>[ZXG2,0]<			Default is no first title
>[*THL0]<			Initialize header-level counters
>[ZXG0,0]<			No chapter or appendices yet
>[ZXG7,1][ZXG8,1][ZXG9,1]<	Print page number, title, subtitles
>[ZXI0,42.0]<			Right margin of 42 picas (7 inches)
>[ZXI1,0]<			Left margin of 0 picas
>[ZXI2,3.0][ZXI3,0]<		[*NOTE] indent of 3 picas, none yet seen
>[ZXI4,3.0][ZXI5,0]<		[*LE] indent of 3 picas, none yet seen
>[ZXL6,1.0][ZXL7,2]<		Default inter-list leading and t.p.
>[ZXL8,0.0][ZXL9,1]<		Default intra-list leading and t.p.
>[ZXP,0]<			Initial page number
>[ZXP0,42.0]<			Page size of 42 picas wide
>[ZXP1,60.0]<			By 60 picas (10 inches, 60 lines) long
>[ZXP2,10][ZXP3,12]<		Regular text at 10 on 12
>[ZXP4,10][ZXP5,12]<		Page headers at 10 on 12
>[ZXP6,16][ZXP7,18]<		Chapter/appendix titles at 16 on 18
>[ZXP8,10][ZXP9,12]<		Footnotes at 10 on 12
>[ZXC0,P0][ZXC1,3.0][ZXC2,1]<	Initially one column as wide as page size
>[ZXQ0,3.0]<			Paragraph indent of 3 picas
>[ZXQ1,12]<			With one blank line between paragraphs
>[ZXQ2,36]<			And a test page of at least 36 points
>[ZXJ6,3.0]<			Table "gutter" of 3 picas
>[ZXJ7,0]<			No extra spacing between table entries
>[ZXJ8,3.0]<			Table entry test page of 3 picas
>[ZXJ9,0]<			No special table indent


>[*TABS8]<			Setup "normal" tab stops
>[*RHEAD][*NRFOOT]<		Default is running head, no running foot
>[PR!P2,!P3]<			Set pointsize and leading
>[CM.!P0][*TCOLST]<		Set column width information
>[VC!P1]<			Set column depth
>[*TCALIL][IL.!T1]<		Set any left indent
>[*TCALIR][IR.!T1]<		Set any right indent
>[VHTHVCL]<			Start of column macro
>